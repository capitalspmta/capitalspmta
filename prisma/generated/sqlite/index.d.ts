
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Product
 * 
 */
export type Product = $Result.DefaultSelection<Prisma.$ProductPayload>
/**
 * Model Coupon
 * 
 */
export type Coupon = $Result.DefaultSelection<Prisma.$CouponPayload>
/**
 * Model PurchaseItem
 * 
 */
export type PurchaseItem = $Result.DefaultSelection<Prisma.$PurchaseItemPayload>
/**
 * Model Entitlement
 * 
 */
export type Entitlement = $Result.DefaultSelection<Prisma.$EntitlementPayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model StaffShift
 * 
 */
export type StaffShift = $Result.DefaultSelection<Prisma.$StaffShiftPayload>
/**
 * Model StaffWeeklyReward
 * 
 */
export type StaffWeeklyReward = $Result.DefaultSelection<Prisma.$StaffWeeklyRewardPayload>
/**
 * Model AdminCase
 * 
 */
export type AdminCase = $Result.DefaultSelection<Prisma.$AdminCasePayload>
/**
 * Model UserReputation
 * 
 */
export type UserReputation = $Result.DefaultSelection<Prisma.$UserReputationPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model ForumCategory
 * 
 */
export type ForumCategory = $Result.DefaultSelection<Prisma.$ForumCategoryPayload>
/**
 * Model ForumBoard
 * 
 */
export type ForumBoard = $Result.DefaultSelection<Prisma.$ForumBoardPayload>
/**
 * Model Topic
 * 
 */
export type Topic = $Result.DefaultSelection<Prisma.$TopicPayload>
/**
 * Model Post
 * 
 */
export type Post = $Result.DefaultSelection<Prisma.$PostPayload>
/**
 * Model PostAttachment
 * 
 */
export type PostAttachment = $Result.DefaultSelection<Prisma.$PostAttachmentPayload>
/**
 * Model TicketCategory
 * 
 */
export type TicketCategory = $Result.DefaultSelection<Prisma.$TicketCategoryPayload>
/**
 * Model Ticket
 * 
 */
export type Ticket = $Result.DefaultSelection<Prisma.$TicketPayload>
/**
 * Model TicketMessage
 * 
 */
export type TicketMessage = $Result.DefaultSelection<Prisma.$TicketMessagePayload>
/**
 * Model Purchase
 * 
 */
export type Purchase = $Result.DefaultSelection<Prisma.$PurchasePayload>
/**
 * Model AuditLog
 * 
 */
export type AuditLog = $Result.DefaultSelection<Prisma.$AuditLogPayload>
/**
 * Model MpWebhookEvent
 * 
 */
export type MpWebhookEvent = $Result.DefaultSelection<Prisma.$MpWebhookEventPayload>
/**
 * Model Role
 * 
 */
export type Role = $Result.DefaultSelection<Prisma.$RolePayload>
/**
 * Model Permission
 * 
 */
export type Permission = $Result.DefaultSelection<Prisma.$PermissionPayload>
/**
 * Model RolePermission
 * 
 */
export type RolePermission = $Result.DefaultSelection<Prisma.$RolePermissionPayload>
/**
 * Model UserRole
 * 
 */
export type UserRole = $Result.DefaultSelection<Prisma.$UserRolePayload>
/**
 * Model WhitelistConfig
 * 
 */
export type WhitelistConfig = $Result.DefaultSelection<Prisma.$WhitelistConfigPayload>
/**
 * Model WhitelistQuestion
 * 
 */
export type WhitelistQuestion = $Result.DefaultSelection<Prisma.$WhitelistQuestionPayload>
/**
 * Model WhitelistApplication
 * 
 */
export type WhitelistApplication = $Result.DefaultSelection<Prisma.$WhitelistApplicationPayload>
/**
 * Model WhitelistAnswer
 * 
 */
export type WhitelistAnswer = $Result.DefaultSelection<Prisma.$WhitelistAnswerPayload>
/**
 * Model Badge
 * 
 */
export type Badge = $Result.DefaultSelection<Prisma.$BadgePayload>
/**
 * Model UserBadge
 * 
 */
export type UserBadge = $Result.DefaultSelection<Prisma.$UserBadgePayload>
/**
 * Model Conversation
 * 
 */
export type Conversation = $Result.DefaultSelection<Prisma.$ConversationPayload>
/**
 * Model ConversationParticipant
 * 
 */
export type ConversationParticipant = $Result.DefaultSelection<Prisma.$ConversationParticipantPayload>
/**
 * Model DirectMessage
 * 
 */
export type DirectMessage = $Result.DefaultSelection<Prisma.$DirectMessagePayload>
/**
 * Model BankInfo
 * 
 */
export type BankInfo = $Result.DefaultSelection<Prisma.$BankInfoPayload>
/**
 * Model SiteSetting
 * 
 */
export type SiteSetting = $Result.DefaultSelection<Prisma.$SiteSettingPayload>
/**
 * Model GameAccount
 * 
 */
export type GameAccount = $Result.DefaultSelection<Prisma.$GameAccountPayload>
/**
 * Model TicketParticipant
 * 
 */
export type TicketParticipant = $Result.DefaultSelection<Prisma.$TicketParticipantPayload>
/**
 * Model TicketRating
 * 
 */
export type TicketRating = $Result.DefaultSelection<Prisma.$TicketRatingPayload>
/**
 * Model MtaAccessLog
 * 
 */
export type MtaAccessLog = $Result.DefaultSelection<Prisma.$MtaAccessLogPayload>
/**
 * Model TicketRatingRequirement
 * 
 */
export type TicketRatingRequirement = $Result.DefaultSelection<Prisma.$TicketRatingRequirementPayload>
/**
 * Model PasswordResetToken
 * 
 */
export type PasswordResetToken = $Result.DefaultSelection<Prisma.$PasswordResetTokenPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Products
 * const products = await prisma.product.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Products
   * const products = await prisma.product.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.product`: Exposes CRUD operations for the **Product** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Products
    * const products = await prisma.product.findMany()
    * ```
    */
  get product(): Prisma.ProductDelegate<ExtArgs>;

  /**
   * `prisma.coupon`: Exposes CRUD operations for the **Coupon** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Coupons
    * const coupons = await prisma.coupon.findMany()
    * ```
    */
  get coupon(): Prisma.CouponDelegate<ExtArgs>;

  /**
   * `prisma.purchaseItem`: Exposes CRUD operations for the **PurchaseItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PurchaseItems
    * const purchaseItems = await prisma.purchaseItem.findMany()
    * ```
    */
  get purchaseItem(): Prisma.PurchaseItemDelegate<ExtArgs>;

  /**
   * `prisma.entitlement`: Exposes CRUD operations for the **Entitlement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Entitlements
    * const entitlements = await prisma.entitlement.findMany()
    * ```
    */
  get entitlement(): Prisma.EntitlementDelegate<ExtArgs>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs>;

  /**
   * `prisma.staffShift`: Exposes CRUD operations for the **StaffShift** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StaffShifts
    * const staffShifts = await prisma.staffShift.findMany()
    * ```
    */
  get staffShift(): Prisma.StaffShiftDelegate<ExtArgs>;

  /**
   * `prisma.staffWeeklyReward`: Exposes CRUD operations for the **StaffWeeklyReward** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StaffWeeklyRewards
    * const staffWeeklyRewards = await prisma.staffWeeklyReward.findMany()
    * ```
    */
  get staffWeeklyReward(): Prisma.StaffWeeklyRewardDelegate<ExtArgs>;

  /**
   * `prisma.adminCase`: Exposes CRUD operations for the **AdminCase** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AdminCases
    * const adminCases = await prisma.adminCase.findMany()
    * ```
    */
  get adminCase(): Prisma.AdminCaseDelegate<ExtArgs>;

  /**
   * `prisma.userReputation`: Exposes CRUD operations for the **UserReputation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserReputations
    * const userReputations = await prisma.userReputation.findMany()
    * ```
    */
  get userReputation(): Prisma.UserReputationDelegate<ExtArgs>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.forumCategory`: Exposes CRUD operations for the **ForumCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ForumCategories
    * const forumCategories = await prisma.forumCategory.findMany()
    * ```
    */
  get forumCategory(): Prisma.ForumCategoryDelegate<ExtArgs>;

  /**
   * `prisma.forumBoard`: Exposes CRUD operations for the **ForumBoard** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ForumBoards
    * const forumBoards = await prisma.forumBoard.findMany()
    * ```
    */
  get forumBoard(): Prisma.ForumBoardDelegate<ExtArgs>;

  /**
   * `prisma.topic`: Exposes CRUD operations for the **Topic** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Topics
    * const topics = await prisma.topic.findMany()
    * ```
    */
  get topic(): Prisma.TopicDelegate<ExtArgs>;

  /**
   * `prisma.post`: Exposes CRUD operations for the **Post** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Posts
    * const posts = await prisma.post.findMany()
    * ```
    */
  get post(): Prisma.PostDelegate<ExtArgs>;

  /**
   * `prisma.postAttachment`: Exposes CRUD operations for the **PostAttachment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PostAttachments
    * const postAttachments = await prisma.postAttachment.findMany()
    * ```
    */
  get postAttachment(): Prisma.PostAttachmentDelegate<ExtArgs>;

  /**
   * `prisma.ticketCategory`: Exposes CRUD operations for the **TicketCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TicketCategories
    * const ticketCategories = await prisma.ticketCategory.findMany()
    * ```
    */
  get ticketCategory(): Prisma.TicketCategoryDelegate<ExtArgs>;

  /**
   * `prisma.ticket`: Exposes CRUD operations for the **Ticket** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tickets
    * const tickets = await prisma.ticket.findMany()
    * ```
    */
  get ticket(): Prisma.TicketDelegate<ExtArgs>;

  /**
   * `prisma.ticketMessage`: Exposes CRUD operations for the **TicketMessage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TicketMessages
    * const ticketMessages = await prisma.ticketMessage.findMany()
    * ```
    */
  get ticketMessage(): Prisma.TicketMessageDelegate<ExtArgs>;

  /**
   * `prisma.purchase`: Exposes CRUD operations for the **Purchase** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Purchases
    * const purchases = await prisma.purchase.findMany()
    * ```
    */
  get purchase(): Prisma.PurchaseDelegate<ExtArgs>;

  /**
   * `prisma.auditLog`: Exposes CRUD operations for the **AuditLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditLogs
    * const auditLogs = await prisma.auditLog.findMany()
    * ```
    */
  get auditLog(): Prisma.AuditLogDelegate<ExtArgs>;

  /**
   * `prisma.mpWebhookEvent`: Exposes CRUD operations for the **MpWebhookEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MpWebhookEvents
    * const mpWebhookEvents = await prisma.mpWebhookEvent.findMany()
    * ```
    */
  get mpWebhookEvent(): Prisma.MpWebhookEventDelegate<ExtArgs>;

  /**
   * `prisma.role`: Exposes CRUD operations for the **Role** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Roles
    * const roles = await prisma.role.findMany()
    * ```
    */
  get role(): Prisma.RoleDelegate<ExtArgs>;

  /**
   * `prisma.permission`: Exposes CRUD operations for the **Permission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Permissions
    * const permissions = await prisma.permission.findMany()
    * ```
    */
  get permission(): Prisma.PermissionDelegate<ExtArgs>;

  /**
   * `prisma.rolePermission`: Exposes CRUD operations for the **RolePermission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RolePermissions
    * const rolePermissions = await prisma.rolePermission.findMany()
    * ```
    */
  get rolePermission(): Prisma.RolePermissionDelegate<ExtArgs>;

  /**
   * `prisma.userRole`: Exposes CRUD operations for the **UserRole** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserRoles
    * const userRoles = await prisma.userRole.findMany()
    * ```
    */
  get userRole(): Prisma.UserRoleDelegate<ExtArgs>;

  /**
   * `prisma.whitelistConfig`: Exposes CRUD operations for the **WhitelistConfig** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WhitelistConfigs
    * const whitelistConfigs = await prisma.whitelistConfig.findMany()
    * ```
    */
  get whitelistConfig(): Prisma.WhitelistConfigDelegate<ExtArgs>;

  /**
   * `prisma.whitelistQuestion`: Exposes CRUD operations for the **WhitelistQuestion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WhitelistQuestions
    * const whitelistQuestions = await prisma.whitelistQuestion.findMany()
    * ```
    */
  get whitelistQuestion(): Prisma.WhitelistQuestionDelegate<ExtArgs>;

  /**
   * `prisma.whitelistApplication`: Exposes CRUD operations for the **WhitelistApplication** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WhitelistApplications
    * const whitelistApplications = await prisma.whitelistApplication.findMany()
    * ```
    */
  get whitelistApplication(): Prisma.WhitelistApplicationDelegate<ExtArgs>;

  /**
   * `prisma.whitelistAnswer`: Exposes CRUD operations for the **WhitelistAnswer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WhitelistAnswers
    * const whitelistAnswers = await prisma.whitelistAnswer.findMany()
    * ```
    */
  get whitelistAnswer(): Prisma.WhitelistAnswerDelegate<ExtArgs>;

  /**
   * `prisma.badge`: Exposes CRUD operations for the **Badge** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Badges
    * const badges = await prisma.badge.findMany()
    * ```
    */
  get badge(): Prisma.BadgeDelegate<ExtArgs>;

  /**
   * `prisma.userBadge`: Exposes CRUD operations for the **UserBadge** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserBadges
    * const userBadges = await prisma.userBadge.findMany()
    * ```
    */
  get userBadge(): Prisma.UserBadgeDelegate<ExtArgs>;

  /**
   * `prisma.conversation`: Exposes CRUD operations for the **Conversation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Conversations
    * const conversations = await prisma.conversation.findMany()
    * ```
    */
  get conversation(): Prisma.ConversationDelegate<ExtArgs>;

  /**
   * `prisma.conversationParticipant`: Exposes CRUD operations for the **ConversationParticipant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ConversationParticipants
    * const conversationParticipants = await prisma.conversationParticipant.findMany()
    * ```
    */
  get conversationParticipant(): Prisma.ConversationParticipantDelegate<ExtArgs>;

  /**
   * `prisma.directMessage`: Exposes CRUD operations for the **DirectMessage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DirectMessages
    * const directMessages = await prisma.directMessage.findMany()
    * ```
    */
  get directMessage(): Prisma.DirectMessageDelegate<ExtArgs>;

  /**
   * `prisma.bankInfo`: Exposes CRUD operations for the **BankInfo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BankInfos
    * const bankInfos = await prisma.bankInfo.findMany()
    * ```
    */
  get bankInfo(): Prisma.BankInfoDelegate<ExtArgs>;

  /**
   * `prisma.siteSetting`: Exposes CRUD operations for the **SiteSetting** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SiteSettings
    * const siteSettings = await prisma.siteSetting.findMany()
    * ```
    */
  get siteSetting(): Prisma.SiteSettingDelegate<ExtArgs>;

  /**
   * `prisma.gameAccount`: Exposes CRUD operations for the **GameAccount** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GameAccounts
    * const gameAccounts = await prisma.gameAccount.findMany()
    * ```
    */
  get gameAccount(): Prisma.GameAccountDelegate<ExtArgs>;

  /**
   * `prisma.ticketParticipant`: Exposes CRUD operations for the **TicketParticipant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TicketParticipants
    * const ticketParticipants = await prisma.ticketParticipant.findMany()
    * ```
    */
  get ticketParticipant(): Prisma.TicketParticipantDelegate<ExtArgs>;

  /**
   * `prisma.ticketRating`: Exposes CRUD operations for the **TicketRating** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TicketRatings
    * const ticketRatings = await prisma.ticketRating.findMany()
    * ```
    */
  get ticketRating(): Prisma.TicketRatingDelegate<ExtArgs>;

  /**
   * `prisma.mtaAccessLog`: Exposes CRUD operations for the **MtaAccessLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MtaAccessLogs
    * const mtaAccessLogs = await prisma.mtaAccessLog.findMany()
    * ```
    */
  get mtaAccessLog(): Prisma.MtaAccessLogDelegate<ExtArgs>;

  /**
   * `prisma.ticketRatingRequirement`: Exposes CRUD operations for the **TicketRatingRequirement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TicketRatingRequirements
    * const ticketRatingRequirements = await prisma.ticketRatingRequirement.findMany()
    * ```
    */
  get ticketRatingRequirement(): Prisma.TicketRatingRequirementDelegate<ExtArgs>;

  /**
   * `prisma.passwordResetToken`: Exposes CRUD operations for the **PasswordResetToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PasswordResetTokens
    * const passwordResetTokens = await prisma.passwordResetToken.findMany()
    * ```
    */
  get passwordResetToken(): Prisma.PasswordResetTokenDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Product: 'Product',
    Coupon: 'Coupon',
    PurchaseItem: 'PurchaseItem',
    Entitlement: 'Entitlement',
    Notification: 'Notification',
    StaffShift: 'StaffShift',
    StaffWeeklyReward: 'StaffWeeklyReward',
    AdminCase: 'AdminCase',
    UserReputation: 'UserReputation',
    User: 'User',
    ForumCategory: 'ForumCategory',
    ForumBoard: 'ForumBoard',
    Topic: 'Topic',
    Post: 'Post',
    PostAttachment: 'PostAttachment',
    TicketCategory: 'TicketCategory',
    Ticket: 'Ticket',
    TicketMessage: 'TicketMessage',
    Purchase: 'Purchase',
    AuditLog: 'AuditLog',
    MpWebhookEvent: 'MpWebhookEvent',
    Role: 'Role',
    Permission: 'Permission',
    RolePermission: 'RolePermission',
    UserRole: 'UserRole',
    WhitelistConfig: 'WhitelistConfig',
    WhitelistQuestion: 'WhitelistQuestion',
    WhitelistApplication: 'WhitelistApplication',
    WhitelistAnswer: 'WhitelistAnswer',
    Badge: 'Badge',
    UserBadge: 'UserBadge',
    Conversation: 'Conversation',
    ConversationParticipant: 'ConversationParticipant',
    DirectMessage: 'DirectMessage',
    BankInfo: 'BankInfo',
    SiteSetting: 'SiteSetting',
    GameAccount: 'GameAccount',
    TicketParticipant: 'TicketParticipant',
    TicketRating: 'TicketRating',
    MtaAccessLog: 'MtaAccessLog',
    TicketRatingRequirement: 'TicketRatingRequirement',
    PasswordResetToken: 'PasswordResetToken'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "product" | "coupon" | "purchaseItem" | "entitlement" | "notification" | "staffShift" | "staffWeeklyReward" | "adminCase" | "userReputation" | "user" | "forumCategory" | "forumBoard" | "topic" | "post" | "postAttachment" | "ticketCategory" | "ticket" | "ticketMessage" | "purchase" | "auditLog" | "mpWebhookEvent" | "role" | "permission" | "rolePermission" | "userRole" | "whitelistConfig" | "whitelistQuestion" | "whitelistApplication" | "whitelistAnswer" | "badge" | "userBadge" | "conversation" | "conversationParticipant" | "directMessage" | "bankInfo" | "siteSetting" | "gameAccount" | "ticketParticipant" | "ticketRating" | "mtaAccessLog" | "ticketRatingRequirement" | "passwordResetToken"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Product: {
        payload: Prisma.$ProductPayload<ExtArgs>
        fields: Prisma.ProductFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findFirst: {
            args: Prisma.ProductFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findMany: {
            args: Prisma.ProductFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          create: {
            args: Prisma.ProductCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          createMany: {
            args: Prisma.ProductCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          delete: {
            args: Prisma.ProductDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          update: {
            args: Prisma.ProductUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          deleteMany: {
            args: Prisma.ProductDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProductUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          aggregate: {
            args: Prisma.ProductAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProduct>
          }
          groupBy: {
            args: Prisma.ProductGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductCountArgs<ExtArgs>
            result: $Utils.Optional<ProductCountAggregateOutputType> | number
          }
        }
      }
      Coupon: {
        payload: Prisma.$CouponPayload<ExtArgs>
        fields: Prisma.CouponFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CouponFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouponPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CouponFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouponPayload>
          }
          findFirst: {
            args: Prisma.CouponFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouponPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CouponFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouponPayload>
          }
          findMany: {
            args: Prisma.CouponFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouponPayload>[]
          }
          create: {
            args: Prisma.CouponCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouponPayload>
          }
          createMany: {
            args: Prisma.CouponCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CouponCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouponPayload>[]
          }
          delete: {
            args: Prisma.CouponDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouponPayload>
          }
          update: {
            args: Prisma.CouponUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouponPayload>
          }
          deleteMany: {
            args: Prisma.CouponDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CouponUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CouponUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouponPayload>
          }
          aggregate: {
            args: Prisma.CouponAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCoupon>
          }
          groupBy: {
            args: Prisma.CouponGroupByArgs<ExtArgs>
            result: $Utils.Optional<CouponGroupByOutputType>[]
          }
          count: {
            args: Prisma.CouponCountArgs<ExtArgs>
            result: $Utils.Optional<CouponCountAggregateOutputType> | number
          }
        }
      }
      PurchaseItem: {
        payload: Prisma.$PurchaseItemPayload<ExtArgs>
        fields: Prisma.PurchaseItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PurchaseItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PurchaseItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseItemPayload>
          }
          findFirst: {
            args: Prisma.PurchaseItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PurchaseItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseItemPayload>
          }
          findMany: {
            args: Prisma.PurchaseItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseItemPayload>[]
          }
          create: {
            args: Prisma.PurchaseItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseItemPayload>
          }
          createMany: {
            args: Prisma.PurchaseItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PurchaseItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseItemPayload>[]
          }
          delete: {
            args: Prisma.PurchaseItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseItemPayload>
          }
          update: {
            args: Prisma.PurchaseItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseItemPayload>
          }
          deleteMany: {
            args: Prisma.PurchaseItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PurchaseItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PurchaseItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseItemPayload>
          }
          aggregate: {
            args: Prisma.PurchaseItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePurchaseItem>
          }
          groupBy: {
            args: Prisma.PurchaseItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<PurchaseItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.PurchaseItemCountArgs<ExtArgs>
            result: $Utils.Optional<PurchaseItemCountAggregateOutputType> | number
          }
        }
      }
      Entitlement: {
        payload: Prisma.$EntitlementPayload<ExtArgs>
        fields: Prisma.EntitlementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EntitlementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EntitlementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EntitlementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EntitlementPayload>
          }
          findFirst: {
            args: Prisma.EntitlementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EntitlementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EntitlementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EntitlementPayload>
          }
          findMany: {
            args: Prisma.EntitlementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EntitlementPayload>[]
          }
          create: {
            args: Prisma.EntitlementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EntitlementPayload>
          }
          createMany: {
            args: Prisma.EntitlementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EntitlementCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EntitlementPayload>[]
          }
          delete: {
            args: Prisma.EntitlementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EntitlementPayload>
          }
          update: {
            args: Prisma.EntitlementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EntitlementPayload>
          }
          deleteMany: {
            args: Prisma.EntitlementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EntitlementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EntitlementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EntitlementPayload>
          }
          aggregate: {
            args: Prisma.EntitlementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEntitlement>
          }
          groupBy: {
            args: Prisma.EntitlementGroupByArgs<ExtArgs>
            result: $Utils.Optional<EntitlementGroupByOutputType>[]
          }
          count: {
            args: Prisma.EntitlementCountArgs<ExtArgs>
            result: $Utils.Optional<EntitlementCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      StaffShift: {
        payload: Prisma.$StaffShiftPayload<ExtArgs>
        fields: Prisma.StaffShiftFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StaffShiftFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffShiftPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StaffShiftFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffShiftPayload>
          }
          findFirst: {
            args: Prisma.StaffShiftFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffShiftPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StaffShiftFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffShiftPayload>
          }
          findMany: {
            args: Prisma.StaffShiftFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffShiftPayload>[]
          }
          create: {
            args: Prisma.StaffShiftCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffShiftPayload>
          }
          createMany: {
            args: Prisma.StaffShiftCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StaffShiftCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffShiftPayload>[]
          }
          delete: {
            args: Prisma.StaffShiftDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffShiftPayload>
          }
          update: {
            args: Prisma.StaffShiftUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffShiftPayload>
          }
          deleteMany: {
            args: Prisma.StaffShiftDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StaffShiftUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StaffShiftUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffShiftPayload>
          }
          aggregate: {
            args: Prisma.StaffShiftAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStaffShift>
          }
          groupBy: {
            args: Prisma.StaffShiftGroupByArgs<ExtArgs>
            result: $Utils.Optional<StaffShiftGroupByOutputType>[]
          }
          count: {
            args: Prisma.StaffShiftCountArgs<ExtArgs>
            result: $Utils.Optional<StaffShiftCountAggregateOutputType> | number
          }
        }
      }
      StaffWeeklyReward: {
        payload: Prisma.$StaffWeeklyRewardPayload<ExtArgs>
        fields: Prisma.StaffWeeklyRewardFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StaffWeeklyRewardFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffWeeklyRewardPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StaffWeeklyRewardFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffWeeklyRewardPayload>
          }
          findFirst: {
            args: Prisma.StaffWeeklyRewardFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffWeeklyRewardPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StaffWeeklyRewardFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffWeeklyRewardPayload>
          }
          findMany: {
            args: Prisma.StaffWeeklyRewardFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffWeeklyRewardPayload>[]
          }
          create: {
            args: Prisma.StaffWeeklyRewardCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffWeeklyRewardPayload>
          }
          createMany: {
            args: Prisma.StaffWeeklyRewardCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StaffWeeklyRewardCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffWeeklyRewardPayload>[]
          }
          delete: {
            args: Prisma.StaffWeeklyRewardDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffWeeklyRewardPayload>
          }
          update: {
            args: Prisma.StaffWeeklyRewardUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffWeeklyRewardPayload>
          }
          deleteMany: {
            args: Prisma.StaffWeeklyRewardDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StaffWeeklyRewardUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StaffWeeklyRewardUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffWeeklyRewardPayload>
          }
          aggregate: {
            args: Prisma.StaffWeeklyRewardAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStaffWeeklyReward>
          }
          groupBy: {
            args: Prisma.StaffWeeklyRewardGroupByArgs<ExtArgs>
            result: $Utils.Optional<StaffWeeklyRewardGroupByOutputType>[]
          }
          count: {
            args: Prisma.StaffWeeklyRewardCountArgs<ExtArgs>
            result: $Utils.Optional<StaffWeeklyRewardCountAggregateOutputType> | number
          }
        }
      }
      AdminCase: {
        payload: Prisma.$AdminCasePayload<ExtArgs>
        fields: Prisma.AdminCaseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdminCaseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminCasePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdminCaseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminCasePayload>
          }
          findFirst: {
            args: Prisma.AdminCaseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminCasePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdminCaseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminCasePayload>
          }
          findMany: {
            args: Prisma.AdminCaseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminCasePayload>[]
          }
          create: {
            args: Prisma.AdminCaseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminCasePayload>
          }
          createMany: {
            args: Prisma.AdminCaseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AdminCaseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminCasePayload>[]
          }
          delete: {
            args: Prisma.AdminCaseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminCasePayload>
          }
          update: {
            args: Prisma.AdminCaseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminCasePayload>
          }
          deleteMany: {
            args: Prisma.AdminCaseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdminCaseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AdminCaseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminCasePayload>
          }
          aggregate: {
            args: Prisma.AdminCaseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdminCase>
          }
          groupBy: {
            args: Prisma.AdminCaseGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdminCaseGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdminCaseCountArgs<ExtArgs>
            result: $Utils.Optional<AdminCaseCountAggregateOutputType> | number
          }
        }
      }
      UserReputation: {
        payload: Prisma.$UserReputationPayload<ExtArgs>
        fields: Prisma.UserReputationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserReputationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserReputationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserReputationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserReputationPayload>
          }
          findFirst: {
            args: Prisma.UserReputationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserReputationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserReputationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserReputationPayload>
          }
          findMany: {
            args: Prisma.UserReputationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserReputationPayload>[]
          }
          create: {
            args: Prisma.UserReputationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserReputationPayload>
          }
          createMany: {
            args: Prisma.UserReputationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserReputationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserReputationPayload>[]
          }
          delete: {
            args: Prisma.UserReputationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserReputationPayload>
          }
          update: {
            args: Prisma.UserReputationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserReputationPayload>
          }
          deleteMany: {
            args: Prisma.UserReputationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserReputationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserReputationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserReputationPayload>
          }
          aggregate: {
            args: Prisma.UserReputationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserReputation>
          }
          groupBy: {
            args: Prisma.UserReputationGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserReputationGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserReputationCountArgs<ExtArgs>
            result: $Utils.Optional<UserReputationCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      ForumCategory: {
        payload: Prisma.$ForumCategoryPayload<ExtArgs>
        fields: Prisma.ForumCategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ForumCategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumCategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ForumCategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumCategoryPayload>
          }
          findFirst: {
            args: Prisma.ForumCategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumCategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ForumCategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumCategoryPayload>
          }
          findMany: {
            args: Prisma.ForumCategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumCategoryPayload>[]
          }
          create: {
            args: Prisma.ForumCategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumCategoryPayload>
          }
          createMany: {
            args: Prisma.ForumCategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ForumCategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumCategoryPayload>[]
          }
          delete: {
            args: Prisma.ForumCategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumCategoryPayload>
          }
          update: {
            args: Prisma.ForumCategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumCategoryPayload>
          }
          deleteMany: {
            args: Prisma.ForumCategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ForumCategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ForumCategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumCategoryPayload>
          }
          aggregate: {
            args: Prisma.ForumCategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateForumCategory>
          }
          groupBy: {
            args: Prisma.ForumCategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<ForumCategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.ForumCategoryCountArgs<ExtArgs>
            result: $Utils.Optional<ForumCategoryCountAggregateOutputType> | number
          }
        }
      }
      ForumBoard: {
        payload: Prisma.$ForumBoardPayload<ExtArgs>
        fields: Prisma.ForumBoardFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ForumBoardFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumBoardPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ForumBoardFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumBoardPayload>
          }
          findFirst: {
            args: Prisma.ForumBoardFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumBoardPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ForumBoardFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumBoardPayload>
          }
          findMany: {
            args: Prisma.ForumBoardFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumBoardPayload>[]
          }
          create: {
            args: Prisma.ForumBoardCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumBoardPayload>
          }
          createMany: {
            args: Prisma.ForumBoardCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ForumBoardCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumBoardPayload>[]
          }
          delete: {
            args: Prisma.ForumBoardDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumBoardPayload>
          }
          update: {
            args: Prisma.ForumBoardUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumBoardPayload>
          }
          deleteMany: {
            args: Prisma.ForumBoardDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ForumBoardUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ForumBoardUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumBoardPayload>
          }
          aggregate: {
            args: Prisma.ForumBoardAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateForumBoard>
          }
          groupBy: {
            args: Prisma.ForumBoardGroupByArgs<ExtArgs>
            result: $Utils.Optional<ForumBoardGroupByOutputType>[]
          }
          count: {
            args: Prisma.ForumBoardCountArgs<ExtArgs>
            result: $Utils.Optional<ForumBoardCountAggregateOutputType> | number
          }
        }
      }
      Topic: {
        payload: Prisma.$TopicPayload<ExtArgs>
        fields: Prisma.TopicFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TopicFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TopicFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicPayload>
          }
          findFirst: {
            args: Prisma.TopicFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TopicFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicPayload>
          }
          findMany: {
            args: Prisma.TopicFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicPayload>[]
          }
          create: {
            args: Prisma.TopicCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicPayload>
          }
          createMany: {
            args: Prisma.TopicCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TopicCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicPayload>[]
          }
          delete: {
            args: Prisma.TopicDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicPayload>
          }
          update: {
            args: Prisma.TopicUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicPayload>
          }
          deleteMany: {
            args: Prisma.TopicDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TopicUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TopicUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicPayload>
          }
          aggregate: {
            args: Prisma.TopicAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTopic>
          }
          groupBy: {
            args: Prisma.TopicGroupByArgs<ExtArgs>
            result: $Utils.Optional<TopicGroupByOutputType>[]
          }
          count: {
            args: Prisma.TopicCountArgs<ExtArgs>
            result: $Utils.Optional<TopicCountAggregateOutputType> | number
          }
        }
      }
      Post: {
        payload: Prisma.$PostPayload<ExtArgs>
        fields: Prisma.PostFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PostFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PostFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          findFirst: {
            args: Prisma.PostFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PostFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          findMany: {
            args: Prisma.PostFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>[]
          }
          create: {
            args: Prisma.PostCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          createMany: {
            args: Prisma.PostCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PostCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>[]
          }
          delete: {
            args: Prisma.PostDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          update: {
            args: Prisma.PostUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          deleteMany: {
            args: Prisma.PostDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PostUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PostUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          aggregate: {
            args: Prisma.PostAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePost>
          }
          groupBy: {
            args: Prisma.PostGroupByArgs<ExtArgs>
            result: $Utils.Optional<PostGroupByOutputType>[]
          }
          count: {
            args: Prisma.PostCountArgs<ExtArgs>
            result: $Utils.Optional<PostCountAggregateOutputType> | number
          }
        }
      }
      PostAttachment: {
        payload: Prisma.$PostAttachmentPayload<ExtArgs>
        fields: Prisma.PostAttachmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PostAttachmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostAttachmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PostAttachmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostAttachmentPayload>
          }
          findFirst: {
            args: Prisma.PostAttachmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostAttachmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PostAttachmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostAttachmentPayload>
          }
          findMany: {
            args: Prisma.PostAttachmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostAttachmentPayload>[]
          }
          create: {
            args: Prisma.PostAttachmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostAttachmentPayload>
          }
          createMany: {
            args: Prisma.PostAttachmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PostAttachmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostAttachmentPayload>[]
          }
          delete: {
            args: Prisma.PostAttachmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostAttachmentPayload>
          }
          update: {
            args: Prisma.PostAttachmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostAttachmentPayload>
          }
          deleteMany: {
            args: Prisma.PostAttachmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PostAttachmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PostAttachmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostAttachmentPayload>
          }
          aggregate: {
            args: Prisma.PostAttachmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePostAttachment>
          }
          groupBy: {
            args: Prisma.PostAttachmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<PostAttachmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.PostAttachmentCountArgs<ExtArgs>
            result: $Utils.Optional<PostAttachmentCountAggregateOutputType> | number
          }
        }
      }
      TicketCategory: {
        payload: Prisma.$TicketCategoryPayload<ExtArgs>
        fields: Prisma.TicketCategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TicketCategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketCategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TicketCategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketCategoryPayload>
          }
          findFirst: {
            args: Prisma.TicketCategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketCategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TicketCategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketCategoryPayload>
          }
          findMany: {
            args: Prisma.TicketCategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketCategoryPayload>[]
          }
          create: {
            args: Prisma.TicketCategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketCategoryPayload>
          }
          createMany: {
            args: Prisma.TicketCategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TicketCategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketCategoryPayload>[]
          }
          delete: {
            args: Prisma.TicketCategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketCategoryPayload>
          }
          update: {
            args: Prisma.TicketCategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketCategoryPayload>
          }
          deleteMany: {
            args: Prisma.TicketCategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TicketCategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TicketCategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketCategoryPayload>
          }
          aggregate: {
            args: Prisma.TicketCategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTicketCategory>
          }
          groupBy: {
            args: Prisma.TicketCategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<TicketCategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.TicketCategoryCountArgs<ExtArgs>
            result: $Utils.Optional<TicketCategoryCountAggregateOutputType> | number
          }
        }
      }
      Ticket: {
        payload: Prisma.$TicketPayload<ExtArgs>
        fields: Prisma.TicketFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TicketFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TicketFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>
          }
          findFirst: {
            args: Prisma.TicketFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TicketFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>
          }
          findMany: {
            args: Prisma.TicketFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>[]
          }
          create: {
            args: Prisma.TicketCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>
          }
          createMany: {
            args: Prisma.TicketCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TicketCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>[]
          }
          delete: {
            args: Prisma.TicketDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>
          }
          update: {
            args: Prisma.TicketUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>
          }
          deleteMany: {
            args: Prisma.TicketDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TicketUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TicketUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>
          }
          aggregate: {
            args: Prisma.TicketAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTicket>
          }
          groupBy: {
            args: Prisma.TicketGroupByArgs<ExtArgs>
            result: $Utils.Optional<TicketGroupByOutputType>[]
          }
          count: {
            args: Prisma.TicketCountArgs<ExtArgs>
            result: $Utils.Optional<TicketCountAggregateOutputType> | number
          }
        }
      }
      TicketMessage: {
        payload: Prisma.$TicketMessagePayload<ExtArgs>
        fields: Prisma.TicketMessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TicketMessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketMessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TicketMessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketMessagePayload>
          }
          findFirst: {
            args: Prisma.TicketMessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketMessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TicketMessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketMessagePayload>
          }
          findMany: {
            args: Prisma.TicketMessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketMessagePayload>[]
          }
          create: {
            args: Prisma.TicketMessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketMessagePayload>
          }
          createMany: {
            args: Prisma.TicketMessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TicketMessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketMessagePayload>[]
          }
          delete: {
            args: Prisma.TicketMessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketMessagePayload>
          }
          update: {
            args: Prisma.TicketMessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketMessagePayload>
          }
          deleteMany: {
            args: Prisma.TicketMessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TicketMessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TicketMessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketMessagePayload>
          }
          aggregate: {
            args: Prisma.TicketMessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTicketMessage>
          }
          groupBy: {
            args: Prisma.TicketMessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<TicketMessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.TicketMessageCountArgs<ExtArgs>
            result: $Utils.Optional<TicketMessageCountAggregateOutputType> | number
          }
        }
      }
      Purchase: {
        payload: Prisma.$PurchasePayload<ExtArgs>
        fields: Prisma.PurchaseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PurchaseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PurchaseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload>
          }
          findFirst: {
            args: Prisma.PurchaseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PurchaseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload>
          }
          findMany: {
            args: Prisma.PurchaseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload>[]
          }
          create: {
            args: Prisma.PurchaseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload>
          }
          createMany: {
            args: Prisma.PurchaseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PurchaseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload>[]
          }
          delete: {
            args: Prisma.PurchaseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload>
          }
          update: {
            args: Prisma.PurchaseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload>
          }
          deleteMany: {
            args: Prisma.PurchaseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PurchaseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PurchaseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload>
          }
          aggregate: {
            args: Prisma.PurchaseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePurchase>
          }
          groupBy: {
            args: Prisma.PurchaseGroupByArgs<ExtArgs>
            result: $Utils.Optional<PurchaseGroupByOutputType>[]
          }
          count: {
            args: Prisma.PurchaseCountArgs<ExtArgs>
            result: $Utils.Optional<PurchaseCountAggregateOutputType> | number
          }
        }
      }
      AuditLog: {
        payload: Prisma.$AuditLogPayload<ExtArgs>
        fields: Prisma.AuditLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findFirst: {
            args: Prisma.AuditLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findMany: {
            args: Prisma.AuditLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          create: {
            args: Prisma.AuditLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          createMany: {
            args: Prisma.AuditLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuditLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          delete: {
            args: Prisma.AuditLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          update: {
            args: Prisma.AuditLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          deleteMany: {
            args: Prisma.AuditLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AuditLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          aggregate: {
            args: Prisma.AuditLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditLog>
          }
          groupBy: {
            args: Prisma.AuditLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditLogCountArgs<ExtArgs>
            result: $Utils.Optional<AuditLogCountAggregateOutputType> | number
          }
        }
      }
      MpWebhookEvent: {
        payload: Prisma.$MpWebhookEventPayload<ExtArgs>
        fields: Prisma.MpWebhookEventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MpWebhookEventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MpWebhookEventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MpWebhookEventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MpWebhookEventPayload>
          }
          findFirst: {
            args: Prisma.MpWebhookEventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MpWebhookEventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MpWebhookEventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MpWebhookEventPayload>
          }
          findMany: {
            args: Prisma.MpWebhookEventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MpWebhookEventPayload>[]
          }
          create: {
            args: Prisma.MpWebhookEventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MpWebhookEventPayload>
          }
          createMany: {
            args: Prisma.MpWebhookEventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MpWebhookEventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MpWebhookEventPayload>[]
          }
          delete: {
            args: Prisma.MpWebhookEventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MpWebhookEventPayload>
          }
          update: {
            args: Prisma.MpWebhookEventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MpWebhookEventPayload>
          }
          deleteMany: {
            args: Prisma.MpWebhookEventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MpWebhookEventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MpWebhookEventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MpWebhookEventPayload>
          }
          aggregate: {
            args: Prisma.MpWebhookEventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMpWebhookEvent>
          }
          groupBy: {
            args: Prisma.MpWebhookEventGroupByArgs<ExtArgs>
            result: $Utils.Optional<MpWebhookEventGroupByOutputType>[]
          }
          count: {
            args: Prisma.MpWebhookEventCountArgs<ExtArgs>
            result: $Utils.Optional<MpWebhookEventCountAggregateOutputType> | number
          }
        }
      }
      Role: {
        payload: Prisma.$RolePayload<ExtArgs>
        fields: Prisma.RoleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          findFirst: {
            args: Prisma.RoleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          findMany: {
            args: Prisma.RoleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          create: {
            args: Prisma.RoleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          createMany: {
            args: Prisma.RoleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RoleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          delete: {
            args: Prisma.RoleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          update: {
            args: Prisma.RoleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          deleteMany: {
            args: Prisma.RoleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RoleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RoleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          aggregate: {
            args: Prisma.RoleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRole>
          }
          groupBy: {
            args: Prisma.RoleGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoleGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoleCountArgs<ExtArgs>
            result: $Utils.Optional<RoleCountAggregateOutputType> | number
          }
        }
      }
      Permission: {
        payload: Prisma.$PermissionPayload<ExtArgs>
        fields: Prisma.PermissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PermissionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PermissionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          findFirst: {
            args: Prisma.PermissionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PermissionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          findMany: {
            args: Prisma.PermissionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>[]
          }
          create: {
            args: Prisma.PermissionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          createMany: {
            args: Prisma.PermissionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PermissionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>[]
          }
          delete: {
            args: Prisma.PermissionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          update: {
            args: Prisma.PermissionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          deleteMany: {
            args: Prisma.PermissionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PermissionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PermissionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          aggregate: {
            args: Prisma.PermissionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePermission>
          }
          groupBy: {
            args: Prisma.PermissionGroupByArgs<ExtArgs>
            result: $Utils.Optional<PermissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.PermissionCountArgs<ExtArgs>
            result: $Utils.Optional<PermissionCountAggregateOutputType> | number
          }
        }
      }
      RolePermission: {
        payload: Prisma.$RolePermissionPayload<ExtArgs>
        fields: Prisma.RolePermissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RolePermissionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RolePermissionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>
          }
          findFirst: {
            args: Prisma.RolePermissionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RolePermissionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>
          }
          findMany: {
            args: Prisma.RolePermissionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>[]
          }
          create: {
            args: Prisma.RolePermissionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>
          }
          createMany: {
            args: Prisma.RolePermissionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RolePermissionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>[]
          }
          delete: {
            args: Prisma.RolePermissionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>
          }
          update: {
            args: Prisma.RolePermissionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>
          }
          deleteMany: {
            args: Prisma.RolePermissionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RolePermissionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RolePermissionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>
          }
          aggregate: {
            args: Prisma.RolePermissionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRolePermission>
          }
          groupBy: {
            args: Prisma.RolePermissionGroupByArgs<ExtArgs>
            result: $Utils.Optional<RolePermissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.RolePermissionCountArgs<ExtArgs>
            result: $Utils.Optional<RolePermissionCountAggregateOutputType> | number
          }
        }
      }
      UserRole: {
        payload: Prisma.$UserRolePayload<ExtArgs>
        fields: Prisma.UserRoleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserRoleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserRoleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          findFirst: {
            args: Prisma.UserRoleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserRoleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          findMany: {
            args: Prisma.UserRoleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>[]
          }
          create: {
            args: Prisma.UserRoleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          createMany: {
            args: Prisma.UserRoleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserRoleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>[]
          }
          delete: {
            args: Prisma.UserRoleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          update: {
            args: Prisma.UserRoleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          deleteMany: {
            args: Prisma.UserRoleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserRoleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserRoleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          aggregate: {
            args: Prisma.UserRoleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserRole>
          }
          groupBy: {
            args: Prisma.UserRoleGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserRoleGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserRoleCountArgs<ExtArgs>
            result: $Utils.Optional<UserRoleCountAggregateOutputType> | number
          }
        }
      }
      WhitelistConfig: {
        payload: Prisma.$WhitelistConfigPayload<ExtArgs>
        fields: Prisma.WhitelistConfigFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WhitelistConfigFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhitelistConfigPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WhitelistConfigFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhitelistConfigPayload>
          }
          findFirst: {
            args: Prisma.WhitelistConfigFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhitelistConfigPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WhitelistConfigFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhitelistConfigPayload>
          }
          findMany: {
            args: Prisma.WhitelistConfigFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhitelistConfigPayload>[]
          }
          create: {
            args: Prisma.WhitelistConfigCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhitelistConfigPayload>
          }
          createMany: {
            args: Prisma.WhitelistConfigCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WhitelistConfigCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhitelistConfigPayload>[]
          }
          delete: {
            args: Prisma.WhitelistConfigDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhitelistConfigPayload>
          }
          update: {
            args: Prisma.WhitelistConfigUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhitelistConfigPayload>
          }
          deleteMany: {
            args: Prisma.WhitelistConfigDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WhitelistConfigUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WhitelistConfigUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhitelistConfigPayload>
          }
          aggregate: {
            args: Prisma.WhitelistConfigAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWhitelistConfig>
          }
          groupBy: {
            args: Prisma.WhitelistConfigGroupByArgs<ExtArgs>
            result: $Utils.Optional<WhitelistConfigGroupByOutputType>[]
          }
          count: {
            args: Prisma.WhitelistConfigCountArgs<ExtArgs>
            result: $Utils.Optional<WhitelistConfigCountAggregateOutputType> | number
          }
        }
      }
      WhitelistQuestion: {
        payload: Prisma.$WhitelistQuestionPayload<ExtArgs>
        fields: Prisma.WhitelistQuestionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WhitelistQuestionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhitelistQuestionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WhitelistQuestionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhitelistQuestionPayload>
          }
          findFirst: {
            args: Prisma.WhitelistQuestionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhitelistQuestionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WhitelistQuestionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhitelistQuestionPayload>
          }
          findMany: {
            args: Prisma.WhitelistQuestionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhitelistQuestionPayload>[]
          }
          create: {
            args: Prisma.WhitelistQuestionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhitelistQuestionPayload>
          }
          createMany: {
            args: Prisma.WhitelistQuestionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WhitelistQuestionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhitelistQuestionPayload>[]
          }
          delete: {
            args: Prisma.WhitelistQuestionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhitelistQuestionPayload>
          }
          update: {
            args: Prisma.WhitelistQuestionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhitelistQuestionPayload>
          }
          deleteMany: {
            args: Prisma.WhitelistQuestionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WhitelistQuestionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WhitelistQuestionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhitelistQuestionPayload>
          }
          aggregate: {
            args: Prisma.WhitelistQuestionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWhitelistQuestion>
          }
          groupBy: {
            args: Prisma.WhitelistQuestionGroupByArgs<ExtArgs>
            result: $Utils.Optional<WhitelistQuestionGroupByOutputType>[]
          }
          count: {
            args: Prisma.WhitelistQuestionCountArgs<ExtArgs>
            result: $Utils.Optional<WhitelistQuestionCountAggregateOutputType> | number
          }
        }
      }
      WhitelistApplication: {
        payload: Prisma.$WhitelistApplicationPayload<ExtArgs>
        fields: Prisma.WhitelistApplicationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WhitelistApplicationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhitelistApplicationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WhitelistApplicationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhitelistApplicationPayload>
          }
          findFirst: {
            args: Prisma.WhitelistApplicationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhitelistApplicationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WhitelistApplicationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhitelistApplicationPayload>
          }
          findMany: {
            args: Prisma.WhitelistApplicationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhitelistApplicationPayload>[]
          }
          create: {
            args: Prisma.WhitelistApplicationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhitelistApplicationPayload>
          }
          createMany: {
            args: Prisma.WhitelistApplicationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WhitelistApplicationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhitelistApplicationPayload>[]
          }
          delete: {
            args: Prisma.WhitelistApplicationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhitelistApplicationPayload>
          }
          update: {
            args: Prisma.WhitelistApplicationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhitelistApplicationPayload>
          }
          deleteMany: {
            args: Prisma.WhitelistApplicationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WhitelistApplicationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WhitelistApplicationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhitelistApplicationPayload>
          }
          aggregate: {
            args: Prisma.WhitelistApplicationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWhitelistApplication>
          }
          groupBy: {
            args: Prisma.WhitelistApplicationGroupByArgs<ExtArgs>
            result: $Utils.Optional<WhitelistApplicationGroupByOutputType>[]
          }
          count: {
            args: Prisma.WhitelistApplicationCountArgs<ExtArgs>
            result: $Utils.Optional<WhitelistApplicationCountAggregateOutputType> | number
          }
        }
      }
      WhitelistAnswer: {
        payload: Prisma.$WhitelistAnswerPayload<ExtArgs>
        fields: Prisma.WhitelistAnswerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WhitelistAnswerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhitelistAnswerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WhitelistAnswerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhitelistAnswerPayload>
          }
          findFirst: {
            args: Prisma.WhitelistAnswerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhitelistAnswerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WhitelistAnswerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhitelistAnswerPayload>
          }
          findMany: {
            args: Prisma.WhitelistAnswerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhitelistAnswerPayload>[]
          }
          create: {
            args: Prisma.WhitelistAnswerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhitelistAnswerPayload>
          }
          createMany: {
            args: Prisma.WhitelistAnswerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WhitelistAnswerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhitelistAnswerPayload>[]
          }
          delete: {
            args: Prisma.WhitelistAnswerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhitelistAnswerPayload>
          }
          update: {
            args: Prisma.WhitelistAnswerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhitelistAnswerPayload>
          }
          deleteMany: {
            args: Prisma.WhitelistAnswerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WhitelistAnswerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WhitelistAnswerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhitelistAnswerPayload>
          }
          aggregate: {
            args: Prisma.WhitelistAnswerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWhitelistAnswer>
          }
          groupBy: {
            args: Prisma.WhitelistAnswerGroupByArgs<ExtArgs>
            result: $Utils.Optional<WhitelistAnswerGroupByOutputType>[]
          }
          count: {
            args: Prisma.WhitelistAnswerCountArgs<ExtArgs>
            result: $Utils.Optional<WhitelistAnswerCountAggregateOutputType> | number
          }
        }
      }
      Badge: {
        payload: Prisma.$BadgePayload<ExtArgs>
        fields: Prisma.BadgeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BadgeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BadgeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload>
          }
          findFirst: {
            args: Prisma.BadgeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BadgeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload>
          }
          findMany: {
            args: Prisma.BadgeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload>[]
          }
          create: {
            args: Prisma.BadgeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload>
          }
          createMany: {
            args: Prisma.BadgeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BadgeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload>[]
          }
          delete: {
            args: Prisma.BadgeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload>
          }
          update: {
            args: Prisma.BadgeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload>
          }
          deleteMany: {
            args: Prisma.BadgeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BadgeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BadgeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload>
          }
          aggregate: {
            args: Prisma.BadgeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBadge>
          }
          groupBy: {
            args: Prisma.BadgeGroupByArgs<ExtArgs>
            result: $Utils.Optional<BadgeGroupByOutputType>[]
          }
          count: {
            args: Prisma.BadgeCountArgs<ExtArgs>
            result: $Utils.Optional<BadgeCountAggregateOutputType> | number
          }
        }
      }
      UserBadge: {
        payload: Prisma.$UserBadgePayload<ExtArgs>
        fields: Prisma.UserBadgeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserBadgeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBadgePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserBadgeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBadgePayload>
          }
          findFirst: {
            args: Prisma.UserBadgeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBadgePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserBadgeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBadgePayload>
          }
          findMany: {
            args: Prisma.UserBadgeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBadgePayload>[]
          }
          create: {
            args: Prisma.UserBadgeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBadgePayload>
          }
          createMany: {
            args: Prisma.UserBadgeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserBadgeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBadgePayload>[]
          }
          delete: {
            args: Prisma.UserBadgeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBadgePayload>
          }
          update: {
            args: Prisma.UserBadgeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBadgePayload>
          }
          deleteMany: {
            args: Prisma.UserBadgeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserBadgeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserBadgeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBadgePayload>
          }
          aggregate: {
            args: Prisma.UserBadgeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserBadge>
          }
          groupBy: {
            args: Prisma.UserBadgeGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserBadgeGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserBadgeCountArgs<ExtArgs>
            result: $Utils.Optional<UserBadgeCountAggregateOutputType> | number
          }
        }
      }
      Conversation: {
        payload: Prisma.$ConversationPayload<ExtArgs>
        fields: Prisma.ConversationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConversationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConversationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          findFirst: {
            args: Prisma.ConversationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConversationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          findMany: {
            args: Prisma.ConversationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>[]
          }
          create: {
            args: Prisma.ConversationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          createMany: {
            args: Prisma.ConversationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ConversationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>[]
          }
          delete: {
            args: Prisma.ConversationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          update: {
            args: Prisma.ConversationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          deleteMany: {
            args: Prisma.ConversationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ConversationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ConversationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          aggregate: {
            args: Prisma.ConversationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConversation>
          }
          groupBy: {
            args: Prisma.ConversationGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConversationGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConversationCountArgs<ExtArgs>
            result: $Utils.Optional<ConversationCountAggregateOutputType> | number
          }
        }
      }
      ConversationParticipant: {
        payload: Prisma.$ConversationParticipantPayload<ExtArgs>
        fields: Prisma.ConversationParticipantFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConversationParticipantFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationParticipantPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConversationParticipantFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationParticipantPayload>
          }
          findFirst: {
            args: Prisma.ConversationParticipantFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationParticipantPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConversationParticipantFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationParticipantPayload>
          }
          findMany: {
            args: Prisma.ConversationParticipantFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationParticipantPayload>[]
          }
          create: {
            args: Prisma.ConversationParticipantCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationParticipantPayload>
          }
          createMany: {
            args: Prisma.ConversationParticipantCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ConversationParticipantCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationParticipantPayload>[]
          }
          delete: {
            args: Prisma.ConversationParticipantDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationParticipantPayload>
          }
          update: {
            args: Prisma.ConversationParticipantUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationParticipantPayload>
          }
          deleteMany: {
            args: Prisma.ConversationParticipantDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ConversationParticipantUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ConversationParticipantUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationParticipantPayload>
          }
          aggregate: {
            args: Prisma.ConversationParticipantAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConversationParticipant>
          }
          groupBy: {
            args: Prisma.ConversationParticipantGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConversationParticipantGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConversationParticipantCountArgs<ExtArgs>
            result: $Utils.Optional<ConversationParticipantCountAggregateOutputType> | number
          }
        }
      }
      DirectMessage: {
        payload: Prisma.$DirectMessagePayload<ExtArgs>
        fields: Prisma.DirectMessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DirectMessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DirectMessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DirectMessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DirectMessagePayload>
          }
          findFirst: {
            args: Prisma.DirectMessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DirectMessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DirectMessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DirectMessagePayload>
          }
          findMany: {
            args: Prisma.DirectMessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DirectMessagePayload>[]
          }
          create: {
            args: Prisma.DirectMessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DirectMessagePayload>
          }
          createMany: {
            args: Prisma.DirectMessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DirectMessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DirectMessagePayload>[]
          }
          delete: {
            args: Prisma.DirectMessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DirectMessagePayload>
          }
          update: {
            args: Prisma.DirectMessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DirectMessagePayload>
          }
          deleteMany: {
            args: Prisma.DirectMessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DirectMessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DirectMessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DirectMessagePayload>
          }
          aggregate: {
            args: Prisma.DirectMessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDirectMessage>
          }
          groupBy: {
            args: Prisma.DirectMessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<DirectMessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.DirectMessageCountArgs<ExtArgs>
            result: $Utils.Optional<DirectMessageCountAggregateOutputType> | number
          }
        }
      }
      BankInfo: {
        payload: Prisma.$BankInfoPayload<ExtArgs>
        fields: Prisma.BankInfoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BankInfoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankInfoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BankInfoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankInfoPayload>
          }
          findFirst: {
            args: Prisma.BankInfoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankInfoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BankInfoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankInfoPayload>
          }
          findMany: {
            args: Prisma.BankInfoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankInfoPayload>[]
          }
          create: {
            args: Prisma.BankInfoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankInfoPayload>
          }
          createMany: {
            args: Prisma.BankInfoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BankInfoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankInfoPayload>[]
          }
          delete: {
            args: Prisma.BankInfoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankInfoPayload>
          }
          update: {
            args: Prisma.BankInfoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankInfoPayload>
          }
          deleteMany: {
            args: Prisma.BankInfoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BankInfoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BankInfoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankInfoPayload>
          }
          aggregate: {
            args: Prisma.BankInfoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBankInfo>
          }
          groupBy: {
            args: Prisma.BankInfoGroupByArgs<ExtArgs>
            result: $Utils.Optional<BankInfoGroupByOutputType>[]
          }
          count: {
            args: Prisma.BankInfoCountArgs<ExtArgs>
            result: $Utils.Optional<BankInfoCountAggregateOutputType> | number
          }
        }
      }
      SiteSetting: {
        payload: Prisma.$SiteSettingPayload<ExtArgs>
        fields: Prisma.SiteSettingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SiteSettingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteSettingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SiteSettingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteSettingPayload>
          }
          findFirst: {
            args: Prisma.SiteSettingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteSettingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SiteSettingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteSettingPayload>
          }
          findMany: {
            args: Prisma.SiteSettingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteSettingPayload>[]
          }
          create: {
            args: Prisma.SiteSettingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteSettingPayload>
          }
          createMany: {
            args: Prisma.SiteSettingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SiteSettingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteSettingPayload>[]
          }
          delete: {
            args: Prisma.SiteSettingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteSettingPayload>
          }
          update: {
            args: Prisma.SiteSettingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteSettingPayload>
          }
          deleteMany: {
            args: Prisma.SiteSettingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SiteSettingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SiteSettingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteSettingPayload>
          }
          aggregate: {
            args: Prisma.SiteSettingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSiteSetting>
          }
          groupBy: {
            args: Prisma.SiteSettingGroupByArgs<ExtArgs>
            result: $Utils.Optional<SiteSettingGroupByOutputType>[]
          }
          count: {
            args: Prisma.SiteSettingCountArgs<ExtArgs>
            result: $Utils.Optional<SiteSettingCountAggregateOutputType> | number
          }
        }
      }
      GameAccount: {
        payload: Prisma.$GameAccountPayload<ExtArgs>
        fields: Prisma.GameAccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GameAccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameAccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GameAccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameAccountPayload>
          }
          findFirst: {
            args: Prisma.GameAccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameAccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GameAccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameAccountPayload>
          }
          findMany: {
            args: Prisma.GameAccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameAccountPayload>[]
          }
          create: {
            args: Prisma.GameAccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameAccountPayload>
          }
          createMany: {
            args: Prisma.GameAccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GameAccountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameAccountPayload>[]
          }
          delete: {
            args: Prisma.GameAccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameAccountPayload>
          }
          update: {
            args: Prisma.GameAccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameAccountPayload>
          }
          deleteMany: {
            args: Prisma.GameAccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GameAccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.GameAccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameAccountPayload>
          }
          aggregate: {
            args: Prisma.GameAccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGameAccount>
          }
          groupBy: {
            args: Prisma.GameAccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<GameAccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.GameAccountCountArgs<ExtArgs>
            result: $Utils.Optional<GameAccountCountAggregateOutputType> | number
          }
        }
      }
      TicketParticipant: {
        payload: Prisma.$TicketParticipantPayload<ExtArgs>
        fields: Prisma.TicketParticipantFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TicketParticipantFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketParticipantPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TicketParticipantFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketParticipantPayload>
          }
          findFirst: {
            args: Prisma.TicketParticipantFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketParticipantPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TicketParticipantFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketParticipantPayload>
          }
          findMany: {
            args: Prisma.TicketParticipantFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketParticipantPayload>[]
          }
          create: {
            args: Prisma.TicketParticipantCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketParticipantPayload>
          }
          createMany: {
            args: Prisma.TicketParticipantCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TicketParticipantCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketParticipantPayload>[]
          }
          delete: {
            args: Prisma.TicketParticipantDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketParticipantPayload>
          }
          update: {
            args: Prisma.TicketParticipantUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketParticipantPayload>
          }
          deleteMany: {
            args: Prisma.TicketParticipantDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TicketParticipantUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TicketParticipantUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketParticipantPayload>
          }
          aggregate: {
            args: Prisma.TicketParticipantAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTicketParticipant>
          }
          groupBy: {
            args: Prisma.TicketParticipantGroupByArgs<ExtArgs>
            result: $Utils.Optional<TicketParticipantGroupByOutputType>[]
          }
          count: {
            args: Prisma.TicketParticipantCountArgs<ExtArgs>
            result: $Utils.Optional<TicketParticipantCountAggregateOutputType> | number
          }
        }
      }
      TicketRating: {
        payload: Prisma.$TicketRatingPayload<ExtArgs>
        fields: Prisma.TicketRatingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TicketRatingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketRatingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TicketRatingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketRatingPayload>
          }
          findFirst: {
            args: Prisma.TicketRatingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketRatingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TicketRatingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketRatingPayload>
          }
          findMany: {
            args: Prisma.TicketRatingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketRatingPayload>[]
          }
          create: {
            args: Prisma.TicketRatingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketRatingPayload>
          }
          createMany: {
            args: Prisma.TicketRatingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TicketRatingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketRatingPayload>[]
          }
          delete: {
            args: Prisma.TicketRatingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketRatingPayload>
          }
          update: {
            args: Prisma.TicketRatingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketRatingPayload>
          }
          deleteMany: {
            args: Prisma.TicketRatingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TicketRatingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TicketRatingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketRatingPayload>
          }
          aggregate: {
            args: Prisma.TicketRatingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTicketRating>
          }
          groupBy: {
            args: Prisma.TicketRatingGroupByArgs<ExtArgs>
            result: $Utils.Optional<TicketRatingGroupByOutputType>[]
          }
          count: {
            args: Prisma.TicketRatingCountArgs<ExtArgs>
            result: $Utils.Optional<TicketRatingCountAggregateOutputType> | number
          }
        }
      }
      MtaAccessLog: {
        payload: Prisma.$MtaAccessLogPayload<ExtArgs>
        fields: Prisma.MtaAccessLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MtaAccessLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MtaAccessLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MtaAccessLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MtaAccessLogPayload>
          }
          findFirst: {
            args: Prisma.MtaAccessLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MtaAccessLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MtaAccessLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MtaAccessLogPayload>
          }
          findMany: {
            args: Prisma.MtaAccessLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MtaAccessLogPayload>[]
          }
          create: {
            args: Prisma.MtaAccessLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MtaAccessLogPayload>
          }
          createMany: {
            args: Prisma.MtaAccessLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MtaAccessLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MtaAccessLogPayload>[]
          }
          delete: {
            args: Prisma.MtaAccessLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MtaAccessLogPayload>
          }
          update: {
            args: Prisma.MtaAccessLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MtaAccessLogPayload>
          }
          deleteMany: {
            args: Prisma.MtaAccessLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MtaAccessLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MtaAccessLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MtaAccessLogPayload>
          }
          aggregate: {
            args: Prisma.MtaAccessLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMtaAccessLog>
          }
          groupBy: {
            args: Prisma.MtaAccessLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<MtaAccessLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.MtaAccessLogCountArgs<ExtArgs>
            result: $Utils.Optional<MtaAccessLogCountAggregateOutputType> | number
          }
        }
      }
      TicketRatingRequirement: {
        payload: Prisma.$TicketRatingRequirementPayload<ExtArgs>
        fields: Prisma.TicketRatingRequirementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TicketRatingRequirementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketRatingRequirementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TicketRatingRequirementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketRatingRequirementPayload>
          }
          findFirst: {
            args: Prisma.TicketRatingRequirementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketRatingRequirementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TicketRatingRequirementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketRatingRequirementPayload>
          }
          findMany: {
            args: Prisma.TicketRatingRequirementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketRatingRequirementPayload>[]
          }
          create: {
            args: Prisma.TicketRatingRequirementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketRatingRequirementPayload>
          }
          createMany: {
            args: Prisma.TicketRatingRequirementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TicketRatingRequirementCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketRatingRequirementPayload>[]
          }
          delete: {
            args: Prisma.TicketRatingRequirementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketRatingRequirementPayload>
          }
          update: {
            args: Prisma.TicketRatingRequirementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketRatingRequirementPayload>
          }
          deleteMany: {
            args: Prisma.TicketRatingRequirementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TicketRatingRequirementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TicketRatingRequirementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketRatingRequirementPayload>
          }
          aggregate: {
            args: Prisma.TicketRatingRequirementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTicketRatingRequirement>
          }
          groupBy: {
            args: Prisma.TicketRatingRequirementGroupByArgs<ExtArgs>
            result: $Utils.Optional<TicketRatingRequirementGroupByOutputType>[]
          }
          count: {
            args: Prisma.TicketRatingRequirementCountArgs<ExtArgs>
            result: $Utils.Optional<TicketRatingRequirementCountAggregateOutputType> | number
          }
        }
      }
      PasswordResetToken: {
        payload: Prisma.$PasswordResetTokenPayload<ExtArgs>
        fields: Prisma.PasswordResetTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PasswordResetTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PasswordResetTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          findFirst: {
            args: Prisma.PasswordResetTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PasswordResetTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          findMany: {
            args: Prisma.PasswordResetTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>[]
          }
          create: {
            args: Prisma.PasswordResetTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          createMany: {
            args: Prisma.PasswordResetTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PasswordResetTokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>[]
          }
          delete: {
            args: Prisma.PasswordResetTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          update: {
            args: Prisma.PasswordResetTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          deleteMany: {
            args: Prisma.PasswordResetTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PasswordResetTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PasswordResetTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          aggregate: {
            args: Prisma.PasswordResetTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePasswordResetToken>
          }
          groupBy: {
            args: Prisma.PasswordResetTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<PasswordResetTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.PasswordResetTokenCountArgs<ExtArgs>
            result: $Utils.Optional<PasswordResetTokenCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type ProductCountOutputType
   */

  export type ProductCountOutputType = {
    purchaseItems: number
  }

  export type ProductCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    purchaseItems?: boolean | ProductCountOutputTypeCountPurchaseItemsArgs
  }

  // Custom InputTypes
  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCountOutputType
     */
    select?: ProductCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountPurchaseItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseItemWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    topics: number
    posts: number
    tickets: number
    assignedTickets: number
    ticketMsgs: number
    ticketParticipants: number
    ticketParticipantsAdded: number
    ticketRatingsGiven: number
    ticketRatingsReceived: number
    closedTickets: number
    purchases: number
    auditLogs: number
    userRoles: number
    whitelistApps: number
    reviewedWhitelists: number
    convoParts: number
    sentMessages: number
    receivedMessages: number
    userBadges: number
    gameAccounts: number
    mtaAccessLogs: number
    ticketRatingReqGiven: number
    ticketRatingReqReceived: number
    passwordResetTokens: number
    entitlements: number
    notifications: number
    staffShifts: number
    staffWeeklyRewards: number
    adminCasesTarget: number
    adminCasesStaff: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    topics?: boolean | UserCountOutputTypeCountTopicsArgs
    posts?: boolean | UserCountOutputTypeCountPostsArgs
    tickets?: boolean | UserCountOutputTypeCountTicketsArgs
    assignedTickets?: boolean | UserCountOutputTypeCountAssignedTicketsArgs
    ticketMsgs?: boolean | UserCountOutputTypeCountTicketMsgsArgs
    ticketParticipants?: boolean | UserCountOutputTypeCountTicketParticipantsArgs
    ticketParticipantsAdded?: boolean | UserCountOutputTypeCountTicketParticipantsAddedArgs
    ticketRatingsGiven?: boolean | UserCountOutputTypeCountTicketRatingsGivenArgs
    ticketRatingsReceived?: boolean | UserCountOutputTypeCountTicketRatingsReceivedArgs
    closedTickets?: boolean | UserCountOutputTypeCountClosedTicketsArgs
    purchases?: boolean | UserCountOutputTypeCountPurchasesArgs
    auditLogs?: boolean | UserCountOutputTypeCountAuditLogsArgs
    userRoles?: boolean | UserCountOutputTypeCountUserRolesArgs
    whitelistApps?: boolean | UserCountOutputTypeCountWhitelistAppsArgs
    reviewedWhitelists?: boolean | UserCountOutputTypeCountReviewedWhitelistsArgs
    convoParts?: boolean | UserCountOutputTypeCountConvoPartsArgs
    sentMessages?: boolean | UserCountOutputTypeCountSentMessagesArgs
    receivedMessages?: boolean | UserCountOutputTypeCountReceivedMessagesArgs
    userBadges?: boolean | UserCountOutputTypeCountUserBadgesArgs
    gameAccounts?: boolean | UserCountOutputTypeCountGameAccountsArgs
    mtaAccessLogs?: boolean | UserCountOutputTypeCountMtaAccessLogsArgs
    ticketRatingReqGiven?: boolean | UserCountOutputTypeCountTicketRatingReqGivenArgs
    ticketRatingReqReceived?: boolean | UserCountOutputTypeCountTicketRatingReqReceivedArgs
    passwordResetTokens?: boolean | UserCountOutputTypeCountPasswordResetTokensArgs
    entitlements?: boolean | UserCountOutputTypeCountEntitlementsArgs
    notifications?: boolean | UserCountOutputTypeCountNotificationsArgs
    staffShifts?: boolean | UserCountOutputTypeCountStaffShiftsArgs
    staffWeeklyRewards?: boolean | UserCountOutputTypeCountStaffWeeklyRewardsArgs
    adminCasesTarget?: boolean | UserCountOutputTypeCountAdminCasesTargetArgs
    adminCasesStaff?: boolean | UserCountOutputTypeCountAdminCasesStaffArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTopicsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TopicWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTicketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAssignedTicketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTicketMsgsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketMessageWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTicketParticipantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketParticipantWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTicketParticipantsAddedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketParticipantWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTicketRatingsGivenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketRatingWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTicketRatingsReceivedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketRatingWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountClosedTicketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPurchasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAuditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUserRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserRoleWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountWhitelistAppsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WhitelistApplicationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReviewedWhitelistsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WhitelistApplicationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountConvoPartsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConversationParticipantWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSentMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DirectMessageWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReceivedMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DirectMessageWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUserBadgesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserBadgeWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountGameAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GameAccountWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMtaAccessLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MtaAccessLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTicketRatingReqGivenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketRatingRequirementWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTicketRatingReqReceivedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketRatingRequirementWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPasswordResetTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PasswordResetTokenWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountEntitlementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EntitlementWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountStaffShiftsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StaffShiftWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountStaffWeeklyRewardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StaffWeeklyRewardWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAdminCasesTargetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminCaseWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAdminCasesStaffArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminCaseWhereInput
  }


  /**
   * Count Type ForumCategoryCountOutputType
   */

  export type ForumCategoryCountOutputType = {
    boards: number
  }

  export type ForumCategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    boards?: boolean | ForumCategoryCountOutputTypeCountBoardsArgs
  }

  // Custom InputTypes
  /**
   * ForumCategoryCountOutputType without action
   */
  export type ForumCategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumCategoryCountOutputType
     */
    select?: ForumCategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ForumCategoryCountOutputType without action
   */
  export type ForumCategoryCountOutputTypeCountBoardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ForumBoardWhereInput
  }


  /**
   * Count Type ForumBoardCountOutputType
   */

  export type ForumBoardCountOutputType = {
    topics: number
  }

  export type ForumBoardCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    topics?: boolean | ForumBoardCountOutputTypeCountTopicsArgs
  }

  // Custom InputTypes
  /**
   * ForumBoardCountOutputType without action
   */
  export type ForumBoardCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumBoardCountOutputType
     */
    select?: ForumBoardCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ForumBoardCountOutputType without action
   */
  export type ForumBoardCountOutputTypeCountTopicsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TopicWhereInput
  }


  /**
   * Count Type TopicCountOutputType
   */

  export type TopicCountOutputType = {
    posts: number
  }

  export type TopicCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    posts?: boolean | TopicCountOutputTypeCountPostsArgs
  }

  // Custom InputTypes
  /**
   * TopicCountOutputType without action
   */
  export type TopicCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TopicCountOutputType
     */
    select?: TopicCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TopicCountOutputType without action
   */
  export type TopicCountOutputTypeCountPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostWhereInput
  }


  /**
   * Count Type PostCountOutputType
   */

  export type PostCountOutputType = {
    attachments: number
  }

  export type PostCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attachments?: boolean | PostCountOutputTypeCountAttachmentsArgs
  }

  // Custom InputTypes
  /**
   * PostCountOutputType without action
   */
  export type PostCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostCountOutputType
     */
    select?: PostCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PostCountOutputType without action
   */
  export type PostCountOutputTypeCountAttachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostAttachmentWhereInput
  }


  /**
   * Count Type TicketCategoryCountOutputType
   */

  export type TicketCategoryCountOutputType = {
    tickets: number
  }

  export type TicketCategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tickets?: boolean | TicketCategoryCountOutputTypeCountTicketsArgs
  }

  // Custom InputTypes
  /**
   * TicketCategoryCountOutputType without action
   */
  export type TicketCategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketCategoryCountOutputType
     */
    select?: TicketCategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TicketCategoryCountOutputType without action
   */
  export type TicketCategoryCountOutputTypeCountTicketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketWhereInput
  }


  /**
   * Count Type TicketCountOutputType
   */

  export type TicketCountOutputType = {
    messages: number
    participants: number
    ratings: number
    ratingRequirements: number
  }

  export type TicketCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    messages?: boolean | TicketCountOutputTypeCountMessagesArgs
    participants?: boolean | TicketCountOutputTypeCountParticipantsArgs
    ratings?: boolean | TicketCountOutputTypeCountRatingsArgs
    ratingRequirements?: boolean | TicketCountOutputTypeCountRatingRequirementsArgs
  }

  // Custom InputTypes
  /**
   * TicketCountOutputType without action
   */
  export type TicketCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketCountOutputType
     */
    select?: TicketCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TicketCountOutputType without action
   */
  export type TicketCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketMessageWhereInput
  }

  /**
   * TicketCountOutputType without action
   */
  export type TicketCountOutputTypeCountParticipantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketParticipantWhereInput
  }

  /**
   * TicketCountOutputType without action
   */
  export type TicketCountOutputTypeCountRatingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketRatingWhereInput
  }

  /**
   * TicketCountOutputType without action
   */
  export type TicketCountOutputTypeCountRatingRequirementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketRatingRequirementWhereInput
  }


  /**
   * Count Type PurchaseCountOutputType
   */

  export type PurchaseCountOutputType = {
    items: number
  }

  export type PurchaseCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | PurchaseCountOutputTypeCountItemsArgs
  }

  // Custom InputTypes
  /**
   * PurchaseCountOutputType without action
   */
  export type PurchaseCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseCountOutputType
     */
    select?: PurchaseCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PurchaseCountOutputType without action
   */
  export type PurchaseCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseItemWhereInput
  }


  /**
   * Count Type RoleCountOutputType
   */

  export type RoleCountOutputType = {
    permissions: number
    users: number
  }

  export type RoleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    permissions?: boolean | RoleCountOutputTypeCountPermissionsArgs
    users?: boolean | RoleCountOutputTypeCountUsersArgs
  }

  // Custom InputTypes
  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleCountOutputType
     */
    select?: RoleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeCountPermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RolePermissionWhereInput
  }

  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserRoleWhereInput
  }


  /**
   * Count Type PermissionCountOutputType
   */

  export type PermissionCountOutputType = {
    roles: number
  }

  export type PermissionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    roles?: boolean | PermissionCountOutputTypeCountRolesArgs
  }

  // Custom InputTypes
  /**
   * PermissionCountOutputType without action
   */
  export type PermissionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PermissionCountOutputType
     */
    select?: PermissionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PermissionCountOutputType without action
   */
  export type PermissionCountOutputTypeCountRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RolePermissionWhereInput
  }


  /**
   * Count Type WhitelistQuestionCountOutputType
   */

  export type WhitelistQuestionCountOutputType = {
    answers: number
  }

  export type WhitelistQuestionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    answers?: boolean | WhitelistQuestionCountOutputTypeCountAnswersArgs
  }

  // Custom InputTypes
  /**
   * WhitelistQuestionCountOutputType without action
   */
  export type WhitelistQuestionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhitelistQuestionCountOutputType
     */
    select?: WhitelistQuestionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WhitelistQuestionCountOutputType without action
   */
  export type WhitelistQuestionCountOutputTypeCountAnswersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WhitelistAnswerWhereInput
  }


  /**
   * Count Type WhitelistApplicationCountOutputType
   */

  export type WhitelistApplicationCountOutputType = {
    answers: number
  }

  export type WhitelistApplicationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    answers?: boolean | WhitelistApplicationCountOutputTypeCountAnswersArgs
  }

  // Custom InputTypes
  /**
   * WhitelistApplicationCountOutputType without action
   */
  export type WhitelistApplicationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhitelistApplicationCountOutputType
     */
    select?: WhitelistApplicationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WhitelistApplicationCountOutputType without action
   */
  export type WhitelistApplicationCountOutputTypeCountAnswersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WhitelistAnswerWhereInput
  }


  /**
   * Count Type BadgeCountOutputType
   */

  export type BadgeCountOutputType = {
    users: number
  }

  export type BadgeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | BadgeCountOutputTypeCountUsersArgs
  }

  // Custom InputTypes
  /**
   * BadgeCountOutputType without action
   */
  export type BadgeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BadgeCountOutputType
     */
    select?: BadgeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BadgeCountOutputType without action
   */
  export type BadgeCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserBadgeWhereInput
  }


  /**
   * Count Type ConversationCountOutputType
   */

  export type ConversationCountOutputType = {
    participants: number
    messages: number
  }

  export type ConversationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    participants?: boolean | ConversationCountOutputTypeCountParticipantsArgs
    messages?: boolean | ConversationCountOutputTypeCountMessagesArgs
  }

  // Custom InputTypes
  /**
   * ConversationCountOutputType without action
   */
  export type ConversationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationCountOutputType
     */
    select?: ConversationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ConversationCountOutputType without action
   */
  export type ConversationCountOutputTypeCountParticipantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConversationParticipantWhereInput
  }

  /**
   * ConversationCountOutputType without action
   */
  export type ConversationCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DirectMessageWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Product
   */

  export type AggregateProduct = {
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  export type ProductAvgAggregateOutputType = {
    priceCents: number | null
    durationDays: number | null
    grantPoints: number | null
  }

  export type ProductSumAggregateOutputType = {
    priceCents: number | null
    durationDays: number | null
    grantPoints: number | null
  }

  export type ProductMinAggregateOutputType = {
    id: string | null
    sku: string | null
    name: string | null
    description: string | null
    priceCents: number | null
    currency: string | null
    durationDays: number | null
    grantPoints: number | null
    grantVipRole: string | null
    mtaActions: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductMaxAggregateOutputType = {
    id: string | null
    sku: string | null
    name: string | null
    description: string | null
    priceCents: number | null
    currency: string | null
    durationDays: number | null
    grantPoints: number | null
    grantVipRole: string | null
    mtaActions: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductCountAggregateOutputType = {
    id: number
    sku: number
    name: number
    description: number
    priceCents: number
    currency: number
    durationDays: number
    grantPoints: number
    grantVipRole: number
    mtaActions: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProductAvgAggregateInputType = {
    priceCents?: true
    durationDays?: true
    grantPoints?: true
  }

  export type ProductSumAggregateInputType = {
    priceCents?: true
    durationDays?: true
    grantPoints?: true
  }

  export type ProductMinAggregateInputType = {
    id?: true
    sku?: true
    name?: true
    description?: true
    priceCents?: true
    currency?: true
    durationDays?: true
    grantPoints?: true
    grantVipRole?: true
    mtaActions?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductMaxAggregateInputType = {
    id?: true
    sku?: true
    name?: true
    description?: true
    priceCents?: true
    currency?: true
    durationDays?: true
    grantPoints?: true
    grantVipRole?: true
    mtaActions?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductCountAggregateInputType = {
    id?: true
    sku?: true
    name?: true
    description?: true
    priceCents?: true
    currency?: true
    durationDays?: true
    grantPoints?: true
    grantVipRole?: true
    mtaActions?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProductAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Product to aggregate.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Products
    **/
    _count?: true | ProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductMaxAggregateInputType
  }

  export type GetProductAggregateType<T extends ProductAggregateArgs> = {
        [P in keyof T & keyof AggregateProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProduct[P]>
      : GetScalarType<T[P], AggregateProduct[P]>
  }




  export type ProductGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithAggregationInput | ProductOrderByWithAggregationInput[]
    by: ProductScalarFieldEnum[] | ProductScalarFieldEnum
    having?: ProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductCountAggregateInputType | true
    _avg?: ProductAvgAggregateInputType
    _sum?: ProductSumAggregateInputType
    _min?: ProductMinAggregateInputType
    _max?: ProductMaxAggregateInputType
  }

  export type ProductGroupByOutputType = {
    id: string
    sku: string
    name: string
    description: string | null
    priceCents: number
    currency: string
    durationDays: number | null
    grantPoints: number
    grantVipRole: string | null
    mtaActions: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  type GetProductGroupByPayload<T extends ProductGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductGroupByOutputType[P]>
            : GetScalarType<T[P], ProductGroupByOutputType[P]>
        }
      >
    >


  export type ProductSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sku?: boolean
    name?: boolean
    description?: boolean
    priceCents?: boolean
    currency?: boolean
    durationDays?: boolean
    grantPoints?: boolean
    grantVipRole?: boolean
    mtaActions?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    purchaseItems?: boolean | Product$purchaseItemsArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sku?: boolean
    name?: boolean
    description?: boolean
    priceCents?: boolean
    currency?: boolean
    durationDays?: boolean
    grantPoints?: boolean
    grantVipRole?: boolean
    mtaActions?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["product"]>

  export type ProductSelectScalar = {
    id?: boolean
    sku?: boolean
    name?: boolean
    description?: boolean
    priceCents?: boolean
    currency?: boolean
    durationDays?: boolean
    grantPoints?: boolean
    grantVipRole?: boolean
    mtaActions?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProductInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    purchaseItems?: boolean | Product$purchaseItemsArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProductIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ProductPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Product"
    objects: {
      purchaseItems: Prisma.$PurchaseItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sku: string
      name: string
      description: string | null
      priceCents: number
      currency: string
      durationDays: number | null
      grantPoints: number
      grantVipRole: string | null
      mtaActions: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["product"]>
    composites: {}
  }

  type ProductGetPayload<S extends boolean | null | undefined | ProductDefaultArgs> = $Result.GetResult<Prisma.$ProductPayload, S>

  type ProductCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProductFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProductCountAggregateInputType | true
    }

  export interface ProductDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Product'], meta: { name: 'Product' } }
    /**
     * Find zero or one Product that matches the filter.
     * @param {ProductFindUniqueArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductFindUniqueArgs>(args: SelectSubset<T, ProductFindUniqueArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Product that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProductFindUniqueOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Product that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductFindFirstArgs>(args?: SelectSubset<T, ProductFindFirstArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Product that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Products
     * const products = await prisma.product.findMany()
     * 
     * // Get first 10 Products
     * const products = await prisma.product.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productWithIdOnly = await prisma.product.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductFindManyArgs>(args?: SelectSubset<T, ProductFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Product.
     * @param {ProductCreateArgs} args - Arguments to create a Product.
     * @example
     * // Create one Product
     * const Product = await prisma.product.create({
     *   data: {
     *     // ... data to create a Product
     *   }
     * })
     * 
     */
    create<T extends ProductCreateArgs>(args: SelectSubset<T, ProductCreateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Products.
     * @param {ProductCreateManyArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductCreateManyArgs>(args?: SelectSubset<T, ProductCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Products and returns the data saved in the database.
     * @param {ProductCreateManyAndReturnArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Products and only return the `id`
     * const productWithIdOnly = await prisma.product.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Product.
     * @param {ProductDeleteArgs} args - Arguments to delete one Product.
     * @example
     * // Delete one Product
     * const Product = await prisma.product.delete({
     *   where: {
     *     // ... filter to delete one Product
     *   }
     * })
     * 
     */
    delete<T extends ProductDeleteArgs>(args: SelectSubset<T, ProductDeleteArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Product.
     * @param {ProductUpdateArgs} args - Arguments to update one Product.
     * @example
     * // Update one Product
     * const product = await prisma.product.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductUpdateArgs>(args: SelectSubset<T, ProductUpdateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Products.
     * @param {ProductDeleteManyArgs} args - Arguments to filter Products to delete.
     * @example
     * // Delete a few Products
     * const { count } = await prisma.product.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductDeleteManyArgs>(args?: SelectSubset<T, ProductDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductUpdateManyArgs>(args: SelectSubset<T, ProductUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Product.
     * @param {ProductUpsertArgs} args - Arguments to update or create a Product.
     * @example
     * // Update or create a Product
     * const product = await prisma.product.upsert({
     *   create: {
     *     // ... data to create a Product
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Product we want to update
     *   }
     * })
     */
    upsert<T extends ProductUpsertArgs>(args: SelectSubset<T, ProductUpsertArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCountArgs} args - Arguments to filter Products to count.
     * @example
     * // Count the number of Products
     * const count = await prisma.product.count({
     *   where: {
     *     // ... the filter for the Products we want to count
     *   }
     * })
    **/
    count<T extends ProductCountArgs>(
      args?: Subset<T, ProductCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductAggregateArgs>(args: Subset<T, ProductAggregateArgs>): Prisma.PrismaPromise<GetProductAggregateType<T>>

    /**
     * Group by Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductGroupByArgs['orderBy'] }
        : { orderBy?: ProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Product model
   */
  readonly fields: ProductFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Product.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    purchaseItems<T extends Product$purchaseItemsArgs<ExtArgs> = {}>(args?: Subset<T, Product$purchaseItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseItemPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Product model
   */ 
  interface ProductFieldRefs {
    readonly id: FieldRef<"Product", 'String'>
    readonly sku: FieldRef<"Product", 'String'>
    readonly name: FieldRef<"Product", 'String'>
    readonly description: FieldRef<"Product", 'String'>
    readonly priceCents: FieldRef<"Product", 'Int'>
    readonly currency: FieldRef<"Product", 'String'>
    readonly durationDays: FieldRef<"Product", 'Int'>
    readonly grantPoints: FieldRef<"Product", 'Int'>
    readonly grantVipRole: FieldRef<"Product", 'String'>
    readonly mtaActions: FieldRef<"Product", 'String'>
    readonly isActive: FieldRef<"Product", 'Boolean'>
    readonly createdAt: FieldRef<"Product", 'DateTime'>
    readonly updatedAt: FieldRef<"Product", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Product findUnique
   */
  export type ProductFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findUniqueOrThrow
   */
  export type ProductFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findFirst
   */
  export type ProductFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findFirstOrThrow
   */
  export type ProductFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findMany
   */
  export type ProductFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Products to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product create
   */
  export type ProductCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to create a Product.
     */
    data: XOR<ProductCreateInput, ProductUncheckedCreateInput>
  }

  /**
   * Product createMany
   */
  export type ProductCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
  }

  /**
   * Product createManyAndReturn
   */
  export type ProductCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
  }

  /**
   * Product update
   */
  export type ProductUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to update a Product.
     */
    data: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
    /**
     * Choose, which Product to update.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product updateMany
   */
  export type ProductUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Products.
     */
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductWhereInput
  }

  /**
   * Product upsert
   */
  export type ProductUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The filter to search for the Product to update in case it exists.
     */
    where: ProductWhereUniqueInput
    /**
     * In case the Product found by the `where` argument doesn't exist, create a new Product with this data.
     */
    create: XOR<ProductCreateInput, ProductUncheckedCreateInput>
    /**
     * In case the Product was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
  }

  /**
   * Product delete
   */
  export type ProductDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter which Product to delete.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product deleteMany
   */
  export type ProductDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Products to delete
     */
    where?: ProductWhereInput
  }

  /**
   * Product.purchaseItems
   */
  export type Product$purchaseItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseItem
     */
    select?: PurchaseItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseItemInclude<ExtArgs> | null
    where?: PurchaseItemWhereInput
    orderBy?: PurchaseItemOrderByWithRelationInput | PurchaseItemOrderByWithRelationInput[]
    cursor?: PurchaseItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseItemScalarFieldEnum | PurchaseItemScalarFieldEnum[]
  }

  /**
   * Product without action
   */
  export type ProductDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
  }


  /**
   * Model Coupon
   */

  export type AggregateCoupon = {
    _count: CouponCountAggregateOutputType | null
    _avg: CouponAvgAggregateOutputType | null
    _sum: CouponSumAggregateOutputType | null
    _min: CouponMinAggregateOutputType | null
    _max: CouponMaxAggregateOutputType | null
  }

  export type CouponAvgAggregateOutputType = {
    percentOff: number | null
    amountOffCents: number | null
    maxUses: number | null
    uses: number | null
  }

  export type CouponSumAggregateOutputType = {
    percentOff: number | null
    amountOffCents: number | null
    maxUses: number | null
    uses: number | null
  }

  export type CouponMinAggregateOutputType = {
    id: string | null
    code: string | null
    percentOff: number | null
    amountOffCents: number | null
    maxUses: number | null
    uses: number | null
    expiresAt: Date | null
    isActive: boolean | null
    createdAt: Date | null
  }

  export type CouponMaxAggregateOutputType = {
    id: string | null
    code: string | null
    percentOff: number | null
    amountOffCents: number | null
    maxUses: number | null
    uses: number | null
    expiresAt: Date | null
    isActive: boolean | null
    createdAt: Date | null
  }

  export type CouponCountAggregateOutputType = {
    id: number
    code: number
    percentOff: number
    amountOffCents: number
    maxUses: number
    uses: number
    expiresAt: number
    isActive: number
    createdAt: number
    _all: number
  }


  export type CouponAvgAggregateInputType = {
    percentOff?: true
    amountOffCents?: true
    maxUses?: true
    uses?: true
  }

  export type CouponSumAggregateInputType = {
    percentOff?: true
    amountOffCents?: true
    maxUses?: true
    uses?: true
  }

  export type CouponMinAggregateInputType = {
    id?: true
    code?: true
    percentOff?: true
    amountOffCents?: true
    maxUses?: true
    uses?: true
    expiresAt?: true
    isActive?: true
    createdAt?: true
  }

  export type CouponMaxAggregateInputType = {
    id?: true
    code?: true
    percentOff?: true
    amountOffCents?: true
    maxUses?: true
    uses?: true
    expiresAt?: true
    isActive?: true
    createdAt?: true
  }

  export type CouponCountAggregateInputType = {
    id?: true
    code?: true
    percentOff?: true
    amountOffCents?: true
    maxUses?: true
    uses?: true
    expiresAt?: true
    isActive?: true
    createdAt?: true
    _all?: true
  }

  export type CouponAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Coupon to aggregate.
     */
    where?: CouponWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Coupons to fetch.
     */
    orderBy?: CouponOrderByWithRelationInput | CouponOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CouponWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Coupons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Coupons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Coupons
    **/
    _count?: true | CouponCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CouponAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CouponSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CouponMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CouponMaxAggregateInputType
  }

  export type GetCouponAggregateType<T extends CouponAggregateArgs> = {
        [P in keyof T & keyof AggregateCoupon]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCoupon[P]>
      : GetScalarType<T[P], AggregateCoupon[P]>
  }




  export type CouponGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CouponWhereInput
    orderBy?: CouponOrderByWithAggregationInput | CouponOrderByWithAggregationInput[]
    by: CouponScalarFieldEnum[] | CouponScalarFieldEnum
    having?: CouponScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CouponCountAggregateInputType | true
    _avg?: CouponAvgAggregateInputType
    _sum?: CouponSumAggregateInputType
    _min?: CouponMinAggregateInputType
    _max?: CouponMaxAggregateInputType
  }

  export type CouponGroupByOutputType = {
    id: string
    code: string
    percentOff: number | null
    amountOffCents: number | null
    maxUses: number | null
    uses: number
    expiresAt: Date | null
    isActive: boolean
    createdAt: Date
    _count: CouponCountAggregateOutputType | null
    _avg: CouponAvgAggregateOutputType | null
    _sum: CouponSumAggregateOutputType | null
    _min: CouponMinAggregateOutputType | null
    _max: CouponMaxAggregateOutputType | null
  }

  type GetCouponGroupByPayload<T extends CouponGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CouponGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CouponGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CouponGroupByOutputType[P]>
            : GetScalarType<T[P], CouponGroupByOutputType[P]>
        }
      >
    >


  export type CouponSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    percentOff?: boolean
    amountOffCents?: boolean
    maxUses?: boolean
    uses?: boolean
    expiresAt?: boolean
    isActive?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["coupon"]>

  export type CouponSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    percentOff?: boolean
    amountOffCents?: boolean
    maxUses?: boolean
    uses?: boolean
    expiresAt?: boolean
    isActive?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["coupon"]>

  export type CouponSelectScalar = {
    id?: boolean
    code?: boolean
    percentOff?: boolean
    amountOffCents?: boolean
    maxUses?: boolean
    uses?: boolean
    expiresAt?: boolean
    isActive?: boolean
    createdAt?: boolean
  }


  export type $CouponPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Coupon"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      percentOff: number | null
      amountOffCents: number | null
      maxUses: number | null
      uses: number
      expiresAt: Date | null
      isActive: boolean
      createdAt: Date
    }, ExtArgs["result"]["coupon"]>
    composites: {}
  }

  type CouponGetPayload<S extends boolean | null | undefined | CouponDefaultArgs> = $Result.GetResult<Prisma.$CouponPayload, S>

  type CouponCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CouponFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CouponCountAggregateInputType | true
    }

  export interface CouponDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Coupon'], meta: { name: 'Coupon' } }
    /**
     * Find zero or one Coupon that matches the filter.
     * @param {CouponFindUniqueArgs} args - Arguments to find a Coupon
     * @example
     * // Get one Coupon
     * const coupon = await prisma.coupon.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CouponFindUniqueArgs>(args: SelectSubset<T, CouponFindUniqueArgs<ExtArgs>>): Prisma__CouponClient<$Result.GetResult<Prisma.$CouponPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Coupon that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CouponFindUniqueOrThrowArgs} args - Arguments to find a Coupon
     * @example
     * // Get one Coupon
     * const coupon = await prisma.coupon.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CouponFindUniqueOrThrowArgs>(args: SelectSubset<T, CouponFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CouponClient<$Result.GetResult<Prisma.$CouponPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Coupon that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouponFindFirstArgs} args - Arguments to find a Coupon
     * @example
     * // Get one Coupon
     * const coupon = await prisma.coupon.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CouponFindFirstArgs>(args?: SelectSubset<T, CouponFindFirstArgs<ExtArgs>>): Prisma__CouponClient<$Result.GetResult<Prisma.$CouponPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Coupon that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouponFindFirstOrThrowArgs} args - Arguments to find a Coupon
     * @example
     * // Get one Coupon
     * const coupon = await prisma.coupon.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CouponFindFirstOrThrowArgs>(args?: SelectSubset<T, CouponFindFirstOrThrowArgs<ExtArgs>>): Prisma__CouponClient<$Result.GetResult<Prisma.$CouponPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Coupons that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouponFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Coupons
     * const coupons = await prisma.coupon.findMany()
     * 
     * // Get first 10 Coupons
     * const coupons = await prisma.coupon.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const couponWithIdOnly = await prisma.coupon.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CouponFindManyArgs>(args?: SelectSubset<T, CouponFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CouponPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Coupon.
     * @param {CouponCreateArgs} args - Arguments to create a Coupon.
     * @example
     * // Create one Coupon
     * const Coupon = await prisma.coupon.create({
     *   data: {
     *     // ... data to create a Coupon
     *   }
     * })
     * 
     */
    create<T extends CouponCreateArgs>(args: SelectSubset<T, CouponCreateArgs<ExtArgs>>): Prisma__CouponClient<$Result.GetResult<Prisma.$CouponPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Coupons.
     * @param {CouponCreateManyArgs} args - Arguments to create many Coupons.
     * @example
     * // Create many Coupons
     * const coupon = await prisma.coupon.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CouponCreateManyArgs>(args?: SelectSubset<T, CouponCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Coupons and returns the data saved in the database.
     * @param {CouponCreateManyAndReturnArgs} args - Arguments to create many Coupons.
     * @example
     * // Create many Coupons
     * const coupon = await prisma.coupon.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Coupons and only return the `id`
     * const couponWithIdOnly = await prisma.coupon.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CouponCreateManyAndReturnArgs>(args?: SelectSubset<T, CouponCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CouponPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Coupon.
     * @param {CouponDeleteArgs} args - Arguments to delete one Coupon.
     * @example
     * // Delete one Coupon
     * const Coupon = await prisma.coupon.delete({
     *   where: {
     *     // ... filter to delete one Coupon
     *   }
     * })
     * 
     */
    delete<T extends CouponDeleteArgs>(args: SelectSubset<T, CouponDeleteArgs<ExtArgs>>): Prisma__CouponClient<$Result.GetResult<Prisma.$CouponPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Coupon.
     * @param {CouponUpdateArgs} args - Arguments to update one Coupon.
     * @example
     * // Update one Coupon
     * const coupon = await prisma.coupon.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CouponUpdateArgs>(args: SelectSubset<T, CouponUpdateArgs<ExtArgs>>): Prisma__CouponClient<$Result.GetResult<Prisma.$CouponPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Coupons.
     * @param {CouponDeleteManyArgs} args - Arguments to filter Coupons to delete.
     * @example
     * // Delete a few Coupons
     * const { count } = await prisma.coupon.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CouponDeleteManyArgs>(args?: SelectSubset<T, CouponDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Coupons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouponUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Coupons
     * const coupon = await prisma.coupon.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CouponUpdateManyArgs>(args: SelectSubset<T, CouponUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Coupon.
     * @param {CouponUpsertArgs} args - Arguments to update or create a Coupon.
     * @example
     * // Update or create a Coupon
     * const coupon = await prisma.coupon.upsert({
     *   create: {
     *     // ... data to create a Coupon
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Coupon we want to update
     *   }
     * })
     */
    upsert<T extends CouponUpsertArgs>(args: SelectSubset<T, CouponUpsertArgs<ExtArgs>>): Prisma__CouponClient<$Result.GetResult<Prisma.$CouponPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Coupons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouponCountArgs} args - Arguments to filter Coupons to count.
     * @example
     * // Count the number of Coupons
     * const count = await prisma.coupon.count({
     *   where: {
     *     // ... the filter for the Coupons we want to count
     *   }
     * })
    **/
    count<T extends CouponCountArgs>(
      args?: Subset<T, CouponCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CouponCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Coupon.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouponAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CouponAggregateArgs>(args: Subset<T, CouponAggregateArgs>): Prisma.PrismaPromise<GetCouponAggregateType<T>>

    /**
     * Group by Coupon.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouponGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CouponGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CouponGroupByArgs['orderBy'] }
        : { orderBy?: CouponGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CouponGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCouponGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Coupon model
   */
  readonly fields: CouponFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Coupon.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CouponClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Coupon model
   */ 
  interface CouponFieldRefs {
    readonly id: FieldRef<"Coupon", 'String'>
    readonly code: FieldRef<"Coupon", 'String'>
    readonly percentOff: FieldRef<"Coupon", 'Int'>
    readonly amountOffCents: FieldRef<"Coupon", 'Int'>
    readonly maxUses: FieldRef<"Coupon", 'Int'>
    readonly uses: FieldRef<"Coupon", 'Int'>
    readonly expiresAt: FieldRef<"Coupon", 'DateTime'>
    readonly isActive: FieldRef<"Coupon", 'Boolean'>
    readonly createdAt: FieldRef<"Coupon", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Coupon findUnique
   */
  export type CouponFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelect<ExtArgs> | null
    /**
     * Filter, which Coupon to fetch.
     */
    where: CouponWhereUniqueInput
  }

  /**
   * Coupon findUniqueOrThrow
   */
  export type CouponFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelect<ExtArgs> | null
    /**
     * Filter, which Coupon to fetch.
     */
    where: CouponWhereUniqueInput
  }

  /**
   * Coupon findFirst
   */
  export type CouponFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelect<ExtArgs> | null
    /**
     * Filter, which Coupon to fetch.
     */
    where?: CouponWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Coupons to fetch.
     */
    orderBy?: CouponOrderByWithRelationInput | CouponOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Coupons.
     */
    cursor?: CouponWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Coupons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Coupons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Coupons.
     */
    distinct?: CouponScalarFieldEnum | CouponScalarFieldEnum[]
  }

  /**
   * Coupon findFirstOrThrow
   */
  export type CouponFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelect<ExtArgs> | null
    /**
     * Filter, which Coupon to fetch.
     */
    where?: CouponWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Coupons to fetch.
     */
    orderBy?: CouponOrderByWithRelationInput | CouponOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Coupons.
     */
    cursor?: CouponWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Coupons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Coupons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Coupons.
     */
    distinct?: CouponScalarFieldEnum | CouponScalarFieldEnum[]
  }

  /**
   * Coupon findMany
   */
  export type CouponFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelect<ExtArgs> | null
    /**
     * Filter, which Coupons to fetch.
     */
    where?: CouponWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Coupons to fetch.
     */
    orderBy?: CouponOrderByWithRelationInput | CouponOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Coupons.
     */
    cursor?: CouponWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Coupons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Coupons.
     */
    skip?: number
    distinct?: CouponScalarFieldEnum | CouponScalarFieldEnum[]
  }

  /**
   * Coupon create
   */
  export type CouponCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelect<ExtArgs> | null
    /**
     * The data needed to create a Coupon.
     */
    data: XOR<CouponCreateInput, CouponUncheckedCreateInput>
  }

  /**
   * Coupon createMany
   */
  export type CouponCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Coupons.
     */
    data: CouponCreateManyInput | CouponCreateManyInput[]
  }

  /**
   * Coupon createManyAndReturn
   */
  export type CouponCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Coupons.
     */
    data: CouponCreateManyInput | CouponCreateManyInput[]
  }

  /**
   * Coupon update
   */
  export type CouponUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelect<ExtArgs> | null
    /**
     * The data needed to update a Coupon.
     */
    data: XOR<CouponUpdateInput, CouponUncheckedUpdateInput>
    /**
     * Choose, which Coupon to update.
     */
    where: CouponWhereUniqueInput
  }

  /**
   * Coupon updateMany
   */
  export type CouponUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Coupons.
     */
    data: XOR<CouponUpdateManyMutationInput, CouponUncheckedUpdateManyInput>
    /**
     * Filter which Coupons to update
     */
    where?: CouponWhereInput
  }

  /**
   * Coupon upsert
   */
  export type CouponUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelect<ExtArgs> | null
    /**
     * The filter to search for the Coupon to update in case it exists.
     */
    where: CouponWhereUniqueInput
    /**
     * In case the Coupon found by the `where` argument doesn't exist, create a new Coupon with this data.
     */
    create: XOR<CouponCreateInput, CouponUncheckedCreateInput>
    /**
     * In case the Coupon was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CouponUpdateInput, CouponUncheckedUpdateInput>
  }

  /**
   * Coupon delete
   */
  export type CouponDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelect<ExtArgs> | null
    /**
     * Filter which Coupon to delete.
     */
    where: CouponWhereUniqueInput
  }

  /**
   * Coupon deleteMany
   */
  export type CouponDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Coupons to delete
     */
    where?: CouponWhereInput
  }

  /**
   * Coupon without action
   */
  export type CouponDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelect<ExtArgs> | null
  }


  /**
   * Model PurchaseItem
   */

  export type AggregatePurchaseItem = {
    _count: PurchaseItemCountAggregateOutputType | null
    _avg: PurchaseItemAvgAggregateOutputType | null
    _sum: PurchaseItemSumAggregateOutputType | null
    _min: PurchaseItemMinAggregateOutputType | null
    _max: PurchaseItemMaxAggregateOutputType | null
  }

  export type PurchaseItemAvgAggregateOutputType = {
    priceCents: number | null
    durationDays: number | null
    grantPoints: number | null
  }

  export type PurchaseItemSumAggregateOutputType = {
    priceCents: number | null
    durationDays: number | null
    grantPoints: number | null
  }

  export type PurchaseItemMinAggregateOutputType = {
    id: string | null
    purchaseId: string | null
    productId: string | null
    sku: string | null
    name: string | null
    priceCents: number | null
    durationDays: number | null
    grantPoints: number | null
    grantVipRole: string | null
    mtaActions: string | null
  }

  export type PurchaseItemMaxAggregateOutputType = {
    id: string | null
    purchaseId: string | null
    productId: string | null
    sku: string | null
    name: string | null
    priceCents: number | null
    durationDays: number | null
    grantPoints: number | null
    grantVipRole: string | null
    mtaActions: string | null
  }

  export type PurchaseItemCountAggregateOutputType = {
    id: number
    purchaseId: number
    productId: number
    sku: number
    name: number
    priceCents: number
    durationDays: number
    grantPoints: number
    grantVipRole: number
    mtaActions: number
    _all: number
  }


  export type PurchaseItemAvgAggregateInputType = {
    priceCents?: true
    durationDays?: true
    grantPoints?: true
  }

  export type PurchaseItemSumAggregateInputType = {
    priceCents?: true
    durationDays?: true
    grantPoints?: true
  }

  export type PurchaseItemMinAggregateInputType = {
    id?: true
    purchaseId?: true
    productId?: true
    sku?: true
    name?: true
    priceCents?: true
    durationDays?: true
    grantPoints?: true
    grantVipRole?: true
    mtaActions?: true
  }

  export type PurchaseItemMaxAggregateInputType = {
    id?: true
    purchaseId?: true
    productId?: true
    sku?: true
    name?: true
    priceCents?: true
    durationDays?: true
    grantPoints?: true
    grantVipRole?: true
    mtaActions?: true
  }

  export type PurchaseItemCountAggregateInputType = {
    id?: true
    purchaseId?: true
    productId?: true
    sku?: true
    name?: true
    priceCents?: true
    durationDays?: true
    grantPoints?: true
    grantVipRole?: true
    mtaActions?: true
    _all?: true
  }

  export type PurchaseItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PurchaseItem to aggregate.
     */
    where?: PurchaseItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseItems to fetch.
     */
    orderBy?: PurchaseItemOrderByWithRelationInput | PurchaseItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PurchaseItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PurchaseItems
    **/
    _count?: true | PurchaseItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PurchaseItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PurchaseItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PurchaseItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PurchaseItemMaxAggregateInputType
  }

  export type GetPurchaseItemAggregateType<T extends PurchaseItemAggregateArgs> = {
        [P in keyof T & keyof AggregatePurchaseItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePurchaseItem[P]>
      : GetScalarType<T[P], AggregatePurchaseItem[P]>
  }




  export type PurchaseItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseItemWhereInput
    orderBy?: PurchaseItemOrderByWithAggregationInput | PurchaseItemOrderByWithAggregationInput[]
    by: PurchaseItemScalarFieldEnum[] | PurchaseItemScalarFieldEnum
    having?: PurchaseItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PurchaseItemCountAggregateInputType | true
    _avg?: PurchaseItemAvgAggregateInputType
    _sum?: PurchaseItemSumAggregateInputType
    _min?: PurchaseItemMinAggregateInputType
    _max?: PurchaseItemMaxAggregateInputType
  }

  export type PurchaseItemGroupByOutputType = {
    id: string
    purchaseId: string
    productId: string
    sku: string
    name: string
    priceCents: number
    durationDays: number | null
    grantPoints: number
    grantVipRole: string | null
    mtaActions: string | null
    _count: PurchaseItemCountAggregateOutputType | null
    _avg: PurchaseItemAvgAggregateOutputType | null
    _sum: PurchaseItemSumAggregateOutputType | null
    _min: PurchaseItemMinAggregateOutputType | null
    _max: PurchaseItemMaxAggregateOutputType | null
  }

  type GetPurchaseItemGroupByPayload<T extends PurchaseItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PurchaseItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PurchaseItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PurchaseItemGroupByOutputType[P]>
            : GetScalarType<T[P], PurchaseItemGroupByOutputType[P]>
        }
      >
    >


  export type PurchaseItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    purchaseId?: boolean
    productId?: boolean
    sku?: boolean
    name?: boolean
    priceCents?: boolean
    durationDays?: boolean
    grantPoints?: boolean
    grantVipRole?: boolean
    mtaActions?: boolean
    purchase?: boolean | PurchaseDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseItem"]>

  export type PurchaseItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    purchaseId?: boolean
    productId?: boolean
    sku?: boolean
    name?: boolean
    priceCents?: boolean
    durationDays?: boolean
    grantPoints?: boolean
    grantVipRole?: boolean
    mtaActions?: boolean
    purchase?: boolean | PurchaseDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseItem"]>

  export type PurchaseItemSelectScalar = {
    id?: boolean
    purchaseId?: boolean
    productId?: boolean
    sku?: boolean
    name?: boolean
    priceCents?: boolean
    durationDays?: boolean
    grantPoints?: boolean
    grantVipRole?: boolean
    mtaActions?: boolean
  }

  export type PurchaseItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    purchase?: boolean | PurchaseDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type PurchaseItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    purchase?: boolean | PurchaseDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }

  export type $PurchaseItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PurchaseItem"
    objects: {
      purchase: Prisma.$PurchasePayload<ExtArgs>
      product: Prisma.$ProductPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      purchaseId: string
      productId: string
      sku: string
      name: string
      priceCents: number
      durationDays: number | null
      grantPoints: number
      grantVipRole: string | null
      mtaActions: string | null
    }, ExtArgs["result"]["purchaseItem"]>
    composites: {}
  }

  type PurchaseItemGetPayload<S extends boolean | null | undefined | PurchaseItemDefaultArgs> = $Result.GetResult<Prisma.$PurchaseItemPayload, S>

  type PurchaseItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PurchaseItemFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PurchaseItemCountAggregateInputType | true
    }

  export interface PurchaseItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PurchaseItem'], meta: { name: 'PurchaseItem' } }
    /**
     * Find zero or one PurchaseItem that matches the filter.
     * @param {PurchaseItemFindUniqueArgs} args - Arguments to find a PurchaseItem
     * @example
     * // Get one PurchaseItem
     * const purchaseItem = await prisma.purchaseItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PurchaseItemFindUniqueArgs>(args: SelectSubset<T, PurchaseItemFindUniqueArgs<ExtArgs>>): Prisma__PurchaseItemClient<$Result.GetResult<Prisma.$PurchaseItemPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PurchaseItem that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PurchaseItemFindUniqueOrThrowArgs} args - Arguments to find a PurchaseItem
     * @example
     * // Get one PurchaseItem
     * const purchaseItem = await prisma.purchaseItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PurchaseItemFindUniqueOrThrowArgs>(args: SelectSubset<T, PurchaseItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PurchaseItemClient<$Result.GetResult<Prisma.$PurchaseItemPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PurchaseItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseItemFindFirstArgs} args - Arguments to find a PurchaseItem
     * @example
     * // Get one PurchaseItem
     * const purchaseItem = await prisma.purchaseItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PurchaseItemFindFirstArgs>(args?: SelectSubset<T, PurchaseItemFindFirstArgs<ExtArgs>>): Prisma__PurchaseItemClient<$Result.GetResult<Prisma.$PurchaseItemPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PurchaseItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseItemFindFirstOrThrowArgs} args - Arguments to find a PurchaseItem
     * @example
     * // Get one PurchaseItem
     * const purchaseItem = await prisma.purchaseItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PurchaseItemFindFirstOrThrowArgs>(args?: SelectSubset<T, PurchaseItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__PurchaseItemClient<$Result.GetResult<Prisma.$PurchaseItemPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PurchaseItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PurchaseItems
     * const purchaseItems = await prisma.purchaseItem.findMany()
     * 
     * // Get first 10 PurchaseItems
     * const purchaseItems = await prisma.purchaseItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const purchaseItemWithIdOnly = await prisma.purchaseItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PurchaseItemFindManyArgs>(args?: SelectSubset<T, PurchaseItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseItemPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PurchaseItem.
     * @param {PurchaseItemCreateArgs} args - Arguments to create a PurchaseItem.
     * @example
     * // Create one PurchaseItem
     * const PurchaseItem = await prisma.purchaseItem.create({
     *   data: {
     *     // ... data to create a PurchaseItem
     *   }
     * })
     * 
     */
    create<T extends PurchaseItemCreateArgs>(args: SelectSubset<T, PurchaseItemCreateArgs<ExtArgs>>): Prisma__PurchaseItemClient<$Result.GetResult<Prisma.$PurchaseItemPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PurchaseItems.
     * @param {PurchaseItemCreateManyArgs} args - Arguments to create many PurchaseItems.
     * @example
     * // Create many PurchaseItems
     * const purchaseItem = await prisma.purchaseItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PurchaseItemCreateManyArgs>(args?: SelectSubset<T, PurchaseItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PurchaseItems and returns the data saved in the database.
     * @param {PurchaseItemCreateManyAndReturnArgs} args - Arguments to create many PurchaseItems.
     * @example
     * // Create many PurchaseItems
     * const purchaseItem = await prisma.purchaseItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PurchaseItems and only return the `id`
     * const purchaseItemWithIdOnly = await prisma.purchaseItem.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PurchaseItemCreateManyAndReturnArgs>(args?: SelectSubset<T, PurchaseItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseItemPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PurchaseItem.
     * @param {PurchaseItemDeleteArgs} args - Arguments to delete one PurchaseItem.
     * @example
     * // Delete one PurchaseItem
     * const PurchaseItem = await prisma.purchaseItem.delete({
     *   where: {
     *     // ... filter to delete one PurchaseItem
     *   }
     * })
     * 
     */
    delete<T extends PurchaseItemDeleteArgs>(args: SelectSubset<T, PurchaseItemDeleteArgs<ExtArgs>>): Prisma__PurchaseItemClient<$Result.GetResult<Prisma.$PurchaseItemPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PurchaseItem.
     * @param {PurchaseItemUpdateArgs} args - Arguments to update one PurchaseItem.
     * @example
     * // Update one PurchaseItem
     * const purchaseItem = await prisma.purchaseItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PurchaseItemUpdateArgs>(args: SelectSubset<T, PurchaseItemUpdateArgs<ExtArgs>>): Prisma__PurchaseItemClient<$Result.GetResult<Prisma.$PurchaseItemPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PurchaseItems.
     * @param {PurchaseItemDeleteManyArgs} args - Arguments to filter PurchaseItems to delete.
     * @example
     * // Delete a few PurchaseItems
     * const { count } = await prisma.purchaseItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PurchaseItemDeleteManyArgs>(args?: SelectSubset<T, PurchaseItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PurchaseItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PurchaseItems
     * const purchaseItem = await prisma.purchaseItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PurchaseItemUpdateManyArgs>(args: SelectSubset<T, PurchaseItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PurchaseItem.
     * @param {PurchaseItemUpsertArgs} args - Arguments to update or create a PurchaseItem.
     * @example
     * // Update or create a PurchaseItem
     * const purchaseItem = await prisma.purchaseItem.upsert({
     *   create: {
     *     // ... data to create a PurchaseItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PurchaseItem we want to update
     *   }
     * })
     */
    upsert<T extends PurchaseItemUpsertArgs>(args: SelectSubset<T, PurchaseItemUpsertArgs<ExtArgs>>): Prisma__PurchaseItemClient<$Result.GetResult<Prisma.$PurchaseItemPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PurchaseItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseItemCountArgs} args - Arguments to filter PurchaseItems to count.
     * @example
     * // Count the number of PurchaseItems
     * const count = await prisma.purchaseItem.count({
     *   where: {
     *     // ... the filter for the PurchaseItems we want to count
     *   }
     * })
    **/
    count<T extends PurchaseItemCountArgs>(
      args?: Subset<T, PurchaseItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PurchaseItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PurchaseItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PurchaseItemAggregateArgs>(args: Subset<T, PurchaseItemAggregateArgs>): Prisma.PrismaPromise<GetPurchaseItemAggregateType<T>>

    /**
     * Group by PurchaseItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PurchaseItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PurchaseItemGroupByArgs['orderBy'] }
        : { orderBy?: PurchaseItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PurchaseItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPurchaseItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PurchaseItem model
   */
  readonly fields: PurchaseItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PurchaseItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PurchaseItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    purchase<T extends PurchaseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PurchaseDefaultArgs<ExtArgs>>): Prisma__PurchaseClient<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PurchaseItem model
   */ 
  interface PurchaseItemFieldRefs {
    readonly id: FieldRef<"PurchaseItem", 'String'>
    readonly purchaseId: FieldRef<"PurchaseItem", 'String'>
    readonly productId: FieldRef<"PurchaseItem", 'String'>
    readonly sku: FieldRef<"PurchaseItem", 'String'>
    readonly name: FieldRef<"PurchaseItem", 'String'>
    readonly priceCents: FieldRef<"PurchaseItem", 'Int'>
    readonly durationDays: FieldRef<"PurchaseItem", 'Int'>
    readonly grantPoints: FieldRef<"PurchaseItem", 'Int'>
    readonly grantVipRole: FieldRef<"PurchaseItem", 'String'>
    readonly mtaActions: FieldRef<"PurchaseItem", 'String'>
  }
    

  // Custom InputTypes
  /**
   * PurchaseItem findUnique
   */
  export type PurchaseItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseItem
     */
    select?: PurchaseItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseItemInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseItem to fetch.
     */
    where: PurchaseItemWhereUniqueInput
  }

  /**
   * PurchaseItem findUniqueOrThrow
   */
  export type PurchaseItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseItem
     */
    select?: PurchaseItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseItemInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseItem to fetch.
     */
    where: PurchaseItemWhereUniqueInput
  }

  /**
   * PurchaseItem findFirst
   */
  export type PurchaseItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseItem
     */
    select?: PurchaseItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseItemInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseItem to fetch.
     */
    where?: PurchaseItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseItems to fetch.
     */
    orderBy?: PurchaseItemOrderByWithRelationInput | PurchaseItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PurchaseItems.
     */
    cursor?: PurchaseItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PurchaseItems.
     */
    distinct?: PurchaseItemScalarFieldEnum | PurchaseItemScalarFieldEnum[]
  }

  /**
   * PurchaseItem findFirstOrThrow
   */
  export type PurchaseItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseItem
     */
    select?: PurchaseItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseItemInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseItem to fetch.
     */
    where?: PurchaseItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseItems to fetch.
     */
    orderBy?: PurchaseItemOrderByWithRelationInput | PurchaseItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PurchaseItems.
     */
    cursor?: PurchaseItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PurchaseItems.
     */
    distinct?: PurchaseItemScalarFieldEnum | PurchaseItemScalarFieldEnum[]
  }

  /**
   * PurchaseItem findMany
   */
  export type PurchaseItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseItem
     */
    select?: PurchaseItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseItemInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseItems to fetch.
     */
    where?: PurchaseItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseItems to fetch.
     */
    orderBy?: PurchaseItemOrderByWithRelationInput | PurchaseItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PurchaseItems.
     */
    cursor?: PurchaseItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseItems.
     */
    skip?: number
    distinct?: PurchaseItemScalarFieldEnum | PurchaseItemScalarFieldEnum[]
  }

  /**
   * PurchaseItem create
   */
  export type PurchaseItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseItem
     */
    select?: PurchaseItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseItemInclude<ExtArgs> | null
    /**
     * The data needed to create a PurchaseItem.
     */
    data: XOR<PurchaseItemCreateInput, PurchaseItemUncheckedCreateInput>
  }

  /**
   * PurchaseItem createMany
   */
  export type PurchaseItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PurchaseItems.
     */
    data: PurchaseItemCreateManyInput | PurchaseItemCreateManyInput[]
  }

  /**
   * PurchaseItem createManyAndReturn
   */
  export type PurchaseItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseItem
     */
    select?: PurchaseItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PurchaseItems.
     */
    data: PurchaseItemCreateManyInput | PurchaseItemCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PurchaseItem update
   */
  export type PurchaseItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseItem
     */
    select?: PurchaseItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseItemInclude<ExtArgs> | null
    /**
     * The data needed to update a PurchaseItem.
     */
    data: XOR<PurchaseItemUpdateInput, PurchaseItemUncheckedUpdateInput>
    /**
     * Choose, which PurchaseItem to update.
     */
    where: PurchaseItemWhereUniqueInput
  }

  /**
   * PurchaseItem updateMany
   */
  export type PurchaseItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PurchaseItems.
     */
    data: XOR<PurchaseItemUpdateManyMutationInput, PurchaseItemUncheckedUpdateManyInput>
    /**
     * Filter which PurchaseItems to update
     */
    where?: PurchaseItemWhereInput
  }

  /**
   * PurchaseItem upsert
   */
  export type PurchaseItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseItem
     */
    select?: PurchaseItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseItemInclude<ExtArgs> | null
    /**
     * The filter to search for the PurchaseItem to update in case it exists.
     */
    where: PurchaseItemWhereUniqueInput
    /**
     * In case the PurchaseItem found by the `where` argument doesn't exist, create a new PurchaseItem with this data.
     */
    create: XOR<PurchaseItemCreateInput, PurchaseItemUncheckedCreateInput>
    /**
     * In case the PurchaseItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PurchaseItemUpdateInput, PurchaseItemUncheckedUpdateInput>
  }

  /**
   * PurchaseItem delete
   */
  export type PurchaseItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseItem
     */
    select?: PurchaseItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseItemInclude<ExtArgs> | null
    /**
     * Filter which PurchaseItem to delete.
     */
    where: PurchaseItemWhereUniqueInput
  }

  /**
   * PurchaseItem deleteMany
   */
  export type PurchaseItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PurchaseItems to delete
     */
    where?: PurchaseItemWhereInput
  }

  /**
   * PurchaseItem without action
   */
  export type PurchaseItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseItem
     */
    select?: PurchaseItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseItemInclude<ExtArgs> | null
  }


  /**
   * Model Entitlement
   */

  export type AggregateEntitlement = {
    _count: EntitlementCountAggregateOutputType | null
    _min: EntitlementMinAggregateOutputType | null
    _max: EntitlementMaxAggregateOutputType | null
  }

  export type EntitlementMinAggregateOutputType = {
    id: string | null
    userId: string | null
    roleName: string | null
    expiresAt: Date | null
    source: string | null
    createdAt: Date | null
  }

  export type EntitlementMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    roleName: string | null
    expiresAt: Date | null
    source: string | null
    createdAt: Date | null
  }

  export type EntitlementCountAggregateOutputType = {
    id: number
    userId: number
    roleName: number
    expiresAt: number
    source: number
    createdAt: number
    _all: number
  }


  export type EntitlementMinAggregateInputType = {
    id?: true
    userId?: true
    roleName?: true
    expiresAt?: true
    source?: true
    createdAt?: true
  }

  export type EntitlementMaxAggregateInputType = {
    id?: true
    userId?: true
    roleName?: true
    expiresAt?: true
    source?: true
    createdAt?: true
  }

  export type EntitlementCountAggregateInputType = {
    id?: true
    userId?: true
    roleName?: true
    expiresAt?: true
    source?: true
    createdAt?: true
    _all?: true
  }

  export type EntitlementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Entitlement to aggregate.
     */
    where?: EntitlementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Entitlements to fetch.
     */
    orderBy?: EntitlementOrderByWithRelationInput | EntitlementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EntitlementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Entitlements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Entitlements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Entitlements
    **/
    _count?: true | EntitlementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EntitlementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EntitlementMaxAggregateInputType
  }

  export type GetEntitlementAggregateType<T extends EntitlementAggregateArgs> = {
        [P in keyof T & keyof AggregateEntitlement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEntitlement[P]>
      : GetScalarType<T[P], AggregateEntitlement[P]>
  }




  export type EntitlementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EntitlementWhereInput
    orderBy?: EntitlementOrderByWithAggregationInput | EntitlementOrderByWithAggregationInput[]
    by: EntitlementScalarFieldEnum[] | EntitlementScalarFieldEnum
    having?: EntitlementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EntitlementCountAggregateInputType | true
    _min?: EntitlementMinAggregateInputType
    _max?: EntitlementMaxAggregateInputType
  }

  export type EntitlementGroupByOutputType = {
    id: string
    userId: string
    roleName: string
    expiresAt: Date
    source: string | null
    createdAt: Date
    _count: EntitlementCountAggregateOutputType | null
    _min: EntitlementMinAggregateOutputType | null
    _max: EntitlementMaxAggregateOutputType | null
  }

  type GetEntitlementGroupByPayload<T extends EntitlementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EntitlementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EntitlementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EntitlementGroupByOutputType[P]>
            : GetScalarType<T[P], EntitlementGroupByOutputType[P]>
        }
      >
    >


  export type EntitlementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    roleName?: boolean
    expiresAt?: boolean
    source?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["entitlement"]>

  export type EntitlementSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    roleName?: boolean
    expiresAt?: boolean
    source?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["entitlement"]>

  export type EntitlementSelectScalar = {
    id?: boolean
    userId?: boolean
    roleName?: boolean
    expiresAt?: boolean
    source?: boolean
    createdAt?: boolean
  }

  export type EntitlementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type EntitlementIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $EntitlementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Entitlement"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      roleName: string
      expiresAt: Date
      source: string | null
      createdAt: Date
    }, ExtArgs["result"]["entitlement"]>
    composites: {}
  }

  type EntitlementGetPayload<S extends boolean | null | undefined | EntitlementDefaultArgs> = $Result.GetResult<Prisma.$EntitlementPayload, S>

  type EntitlementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EntitlementFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EntitlementCountAggregateInputType | true
    }

  export interface EntitlementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Entitlement'], meta: { name: 'Entitlement' } }
    /**
     * Find zero or one Entitlement that matches the filter.
     * @param {EntitlementFindUniqueArgs} args - Arguments to find a Entitlement
     * @example
     * // Get one Entitlement
     * const entitlement = await prisma.entitlement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EntitlementFindUniqueArgs>(args: SelectSubset<T, EntitlementFindUniqueArgs<ExtArgs>>): Prisma__EntitlementClient<$Result.GetResult<Prisma.$EntitlementPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Entitlement that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EntitlementFindUniqueOrThrowArgs} args - Arguments to find a Entitlement
     * @example
     * // Get one Entitlement
     * const entitlement = await prisma.entitlement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EntitlementFindUniqueOrThrowArgs>(args: SelectSubset<T, EntitlementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EntitlementClient<$Result.GetResult<Prisma.$EntitlementPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Entitlement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntitlementFindFirstArgs} args - Arguments to find a Entitlement
     * @example
     * // Get one Entitlement
     * const entitlement = await prisma.entitlement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EntitlementFindFirstArgs>(args?: SelectSubset<T, EntitlementFindFirstArgs<ExtArgs>>): Prisma__EntitlementClient<$Result.GetResult<Prisma.$EntitlementPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Entitlement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntitlementFindFirstOrThrowArgs} args - Arguments to find a Entitlement
     * @example
     * // Get one Entitlement
     * const entitlement = await prisma.entitlement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EntitlementFindFirstOrThrowArgs>(args?: SelectSubset<T, EntitlementFindFirstOrThrowArgs<ExtArgs>>): Prisma__EntitlementClient<$Result.GetResult<Prisma.$EntitlementPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Entitlements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntitlementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Entitlements
     * const entitlements = await prisma.entitlement.findMany()
     * 
     * // Get first 10 Entitlements
     * const entitlements = await prisma.entitlement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const entitlementWithIdOnly = await prisma.entitlement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EntitlementFindManyArgs>(args?: SelectSubset<T, EntitlementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EntitlementPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Entitlement.
     * @param {EntitlementCreateArgs} args - Arguments to create a Entitlement.
     * @example
     * // Create one Entitlement
     * const Entitlement = await prisma.entitlement.create({
     *   data: {
     *     // ... data to create a Entitlement
     *   }
     * })
     * 
     */
    create<T extends EntitlementCreateArgs>(args: SelectSubset<T, EntitlementCreateArgs<ExtArgs>>): Prisma__EntitlementClient<$Result.GetResult<Prisma.$EntitlementPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Entitlements.
     * @param {EntitlementCreateManyArgs} args - Arguments to create many Entitlements.
     * @example
     * // Create many Entitlements
     * const entitlement = await prisma.entitlement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EntitlementCreateManyArgs>(args?: SelectSubset<T, EntitlementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Entitlements and returns the data saved in the database.
     * @param {EntitlementCreateManyAndReturnArgs} args - Arguments to create many Entitlements.
     * @example
     * // Create many Entitlements
     * const entitlement = await prisma.entitlement.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Entitlements and only return the `id`
     * const entitlementWithIdOnly = await prisma.entitlement.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EntitlementCreateManyAndReturnArgs>(args?: SelectSubset<T, EntitlementCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EntitlementPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Entitlement.
     * @param {EntitlementDeleteArgs} args - Arguments to delete one Entitlement.
     * @example
     * // Delete one Entitlement
     * const Entitlement = await prisma.entitlement.delete({
     *   where: {
     *     // ... filter to delete one Entitlement
     *   }
     * })
     * 
     */
    delete<T extends EntitlementDeleteArgs>(args: SelectSubset<T, EntitlementDeleteArgs<ExtArgs>>): Prisma__EntitlementClient<$Result.GetResult<Prisma.$EntitlementPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Entitlement.
     * @param {EntitlementUpdateArgs} args - Arguments to update one Entitlement.
     * @example
     * // Update one Entitlement
     * const entitlement = await prisma.entitlement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EntitlementUpdateArgs>(args: SelectSubset<T, EntitlementUpdateArgs<ExtArgs>>): Prisma__EntitlementClient<$Result.GetResult<Prisma.$EntitlementPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Entitlements.
     * @param {EntitlementDeleteManyArgs} args - Arguments to filter Entitlements to delete.
     * @example
     * // Delete a few Entitlements
     * const { count } = await prisma.entitlement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EntitlementDeleteManyArgs>(args?: SelectSubset<T, EntitlementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Entitlements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntitlementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Entitlements
     * const entitlement = await prisma.entitlement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EntitlementUpdateManyArgs>(args: SelectSubset<T, EntitlementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Entitlement.
     * @param {EntitlementUpsertArgs} args - Arguments to update or create a Entitlement.
     * @example
     * // Update or create a Entitlement
     * const entitlement = await prisma.entitlement.upsert({
     *   create: {
     *     // ... data to create a Entitlement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Entitlement we want to update
     *   }
     * })
     */
    upsert<T extends EntitlementUpsertArgs>(args: SelectSubset<T, EntitlementUpsertArgs<ExtArgs>>): Prisma__EntitlementClient<$Result.GetResult<Prisma.$EntitlementPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Entitlements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntitlementCountArgs} args - Arguments to filter Entitlements to count.
     * @example
     * // Count the number of Entitlements
     * const count = await prisma.entitlement.count({
     *   where: {
     *     // ... the filter for the Entitlements we want to count
     *   }
     * })
    **/
    count<T extends EntitlementCountArgs>(
      args?: Subset<T, EntitlementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EntitlementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Entitlement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntitlementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EntitlementAggregateArgs>(args: Subset<T, EntitlementAggregateArgs>): Prisma.PrismaPromise<GetEntitlementAggregateType<T>>

    /**
     * Group by Entitlement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntitlementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EntitlementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EntitlementGroupByArgs['orderBy'] }
        : { orderBy?: EntitlementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EntitlementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEntitlementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Entitlement model
   */
  readonly fields: EntitlementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Entitlement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EntitlementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Entitlement model
   */ 
  interface EntitlementFieldRefs {
    readonly id: FieldRef<"Entitlement", 'String'>
    readonly userId: FieldRef<"Entitlement", 'String'>
    readonly roleName: FieldRef<"Entitlement", 'String'>
    readonly expiresAt: FieldRef<"Entitlement", 'DateTime'>
    readonly source: FieldRef<"Entitlement", 'String'>
    readonly createdAt: FieldRef<"Entitlement", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Entitlement findUnique
   */
  export type EntitlementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Entitlement
     */
    select?: EntitlementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntitlementInclude<ExtArgs> | null
    /**
     * Filter, which Entitlement to fetch.
     */
    where: EntitlementWhereUniqueInput
  }

  /**
   * Entitlement findUniqueOrThrow
   */
  export type EntitlementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Entitlement
     */
    select?: EntitlementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntitlementInclude<ExtArgs> | null
    /**
     * Filter, which Entitlement to fetch.
     */
    where: EntitlementWhereUniqueInput
  }

  /**
   * Entitlement findFirst
   */
  export type EntitlementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Entitlement
     */
    select?: EntitlementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntitlementInclude<ExtArgs> | null
    /**
     * Filter, which Entitlement to fetch.
     */
    where?: EntitlementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Entitlements to fetch.
     */
    orderBy?: EntitlementOrderByWithRelationInput | EntitlementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Entitlements.
     */
    cursor?: EntitlementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Entitlements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Entitlements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Entitlements.
     */
    distinct?: EntitlementScalarFieldEnum | EntitlementScalarFieldEnum[]
  }

  /**
   * Entitlement findFirstOrThrow
   */
  export type EntitlementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Entitlement
     */
    select?: EntitlementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntitlementInclude<ExtArgs> | null
    /**
     * Filter, which Entitlement to fetch.
     */
    where?: EntitlementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Entitlements to fetch.
     */
    orderBy?: EntitlementOrderByWithRelationInput | EntitlementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Entitlements.
     */
    cursor?: EntitlementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Entitlements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Entitlements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Entitlements.
     */
    distinct?: EntitlementScalarFieldEnum | EntitlementScalarFieldEnum[]
  }

  /**
   * Entitlement findMany
   */
  export type EntitlementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Entitlement
     */
    select?: EntitlementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntitlementInclude<ExtArgs> | null
    /**
     * Filter, which Entitlements to fetch.
     */
    where?: EntitlementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Entitlements to fetch.
     */
    orderBy?: EntitlementOrderByWithRelationInput | EntitlementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Entitlements.
     */
    cursor?: EntitlementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Entitlements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Entitlements.
     */
    skip?: number
    distinct?: EntitlementScalarFieldEnum | EntitlementScalarFieldEnum[]
  }

  /**
   * Entitlement create
   */
  export type EntitlementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Entitlement
     */
    select?: EntitlementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntitlementInclude<ExtArgs> | null
    /**
     * The data needed to create a Entitlement.
     */
    data: XOR<EntitlementCreateInput, EntitlementUncheckedCreateInput>
  }

  /**
   * Entitlement createMany
   */
  export type EntitlementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Entitlements.
     */
    data: EntitlementCreateManyInput | EntitlementCreateManyInput[]
  }

  /**
   * Entitlement createManyAndReturn
   */
  export type EntitlementCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Entitlement
     */
    select?: EntitlementSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Entitlements.
     */
    data: EntitlementCreateManyInput | EntitlementCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntitlementIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Entitlement update
   */
  export type EntitlementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Entitlement
     */
    select?: EntitlementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntitlementInclude<ExtArgs> | null
    /**
     * The data needed to update a Entitlement.
     */
    data: XOR<EntitlementUpdateInput, EntitlementUncheckedUpdateInput>
    /**
     * Choose, which Entitlement to update.
     */
    where: EntitlementWhereUniqueInput
  }

  /**
   * Entitlement updateMany
   */
  export type EntitlementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Entitlements.
     */
    data: XOR<EntitlementUpdateManyMutationInput, EntitlementUncheckedUpdateManyInput>
    /**
     * Filter which Entitlements to update
     */
    where?: EntitlementWhereInput
  }

  /**
   * Entitlement upsert
   */
  export type EntitlementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Entitlement
     */
    select?: EntitlementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntitlementInclude<ExtArgs> | null
    /**
     * The filter to search for the Entitlement to update in case it exists.
     */
    where: EntitlementWhereUniqueInput
    /**
     * In case the Entitlement found by the `where` argument doesn't exist, create a new Entitlement with this data.
     */
    create: XOR<EntitlementCreateInput, EntitlementUncheckedCreateInput>
    /**
     * In case the Entitlement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EntitlementUpdateInput, EntitlementUncheckedUpdateInput>
  }

  /**
   * Entitlement delete
   */
  export type EntitlementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Entitlement
     */
    select?: EntitlementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntitlementInclude<ExtArgs> | null
    /**
     * Filter which Entitlement to delete.
     */
    where: EntitlementWhereUniqueInput
  }

  /**
   * Entitlement deleteMany
   */
  export type EntitlementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Entitlements to delete
     */
    where?: EntitlementWhereInput
  }

  /**
   * Entitlement without action
   */
  export type EntitlementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Entitlement
     */
    select?: EntitlementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntitlementInclude<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    userId: string | null
    message: string | null
    href: string | null
    read: boolean | null
    createdAt: Date | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    message: string | null
    href: string | null
    read: boolean | null
    createdAt: Date | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    userId: number
    message: number
    href: number
    read: number
    createdAt: number
    _all: number
  }


  export type NotificationMinAggregateInputType = {
    id?: true
    userId?: true
    message?: true
    href?: true
    read?: true
    createdAt?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    userId?: true
    message?: true
    href?: true
    read?: true
    createdAt?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    userId?: true
    message?: true
    href?: true
    read?: true
    createdAt?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: string
    userId: string
    message: string
    href: string | null
    read: boolean
    createdAt: Date
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    message?: boolean
    href?: boolean
    read?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    message?: boolean
    href?: boolean
    read?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    userId?: boolean
    message?: boolean
    href?: boolean
    read?: boolean
    createdAt?: boolean
  }

  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      message: string
      href: string | null
      read: boolean
      createdAt: Date
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */ 
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'String'>
    readonly userId: FieldRef<"Notification", 'String'>
    readonly message: FieldRef<"Notification", 'String'>
    readonly href: FieldRef<"Notification", 'String'>
    readonly read: FieldRef<"Notification", 'Boolean'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
  }

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Model StaffShift
   */

  export type AggregateStaffShift = {
    _count: StaffShiftCountAggregateOutputType | null
    _avg: StaffShiftAvgAggregateOutputType | null
    _sum: StaffShiftSumAggregateOutputType | null
    _min: StaffShiftMinAggregateOutputType | null
    _max: StaffShiftMaxAggregateOutputType | null
  }

  export type StaffShiftAvgAggregateOutputType = {
    seconds: number | null
  }

  export type StaffShiftSumAggregateOutputType = {
    seconds: number | null
  }

  export type StaffShiftMinAggregateOutputType = {
    id: string | null
    userId: string | null
    openedAt: Date | null
    closedAt: Date | null
    seconds: number | null
    createdAt: Date | null
  }

  export type StaffShiftMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    openedAt: Date | null
    closedAt: Date | null
    seconds: number | null
    createdAt: Date | null
  }

  export type StaffShiftCountAggregateOutputType = {
    id: number
    userId: number
    openedAt: number
    closedAt: number
    seconds: number
    createdAt: number
    _all: number
  }


  export type StaffShiftAvgAggregateInputType = {
    seconds?: true
  }

  export type StaffShiftSumAggregateInputType = {
    seconds?: true
  }

  export type StaffShiftMinAggregateInputType = {
    id?: true
    userId?: true
    openedAt?: true
    closedAt?: true
    seconds?: true
    createdAt?: true
  }

  export type StaffShiftMaxAggregateInputType = {
    id?: true
    userId?: true
    openedAt?: true
    closedAt?: true
    seconds?: true
    createdAt?: true
  }

  export type StaffShiftCountAggregateInputType = {
    id?: true
    userId?: true
    openedAt?: true
    closedAt?: true
    seconds?: true
    createdAt?: true
    _all?: true
  }

  export type StaffShiftAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StaffShift to aggregate.
     */
    where?: StaffShiftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StaffShifts to fetch.
     */
    orderBy?: StaffShiftOrderByWithRelationInput | StaffShiftOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StaffShiftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StaffShifts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StaffShifts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StaffShifts
    **/
    _count?: true | StaffShiftCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StaffShiftAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StaffShiftSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StaffShiftMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StaffShiftMaxAggregateInputType
  }

  export type GetStaffShiftAggregateType<T extends StaffShiftAggregateArgs> = {
        [P in keyof T & keyof AggregateStaffShift]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStaffShift[P]>
      : GetScalarType<T[P], AggregateStaffShift[P]>
  }




  export type StaffShiftGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StaffShiftWhereInput
    orderBy?: StaffShiftOrderByWithAggregationInput | StaffShiftOrderByWithAggregationInput[]
    by: StaffShiftScalarFieldEnum[] | StaffShiftScalarFieldEnum
    having?: StaffShiftScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StaffShiftCountAggregateInputType | true
    _avg?: StaffShiftAvgAggregateInputType
    _sum?: StaffShiftSumAggregateInputType
    _min?: StaffShiftMinAggregateInputType
    _max?: StaffShiftMaxAggregateInputType
  }

  export type StaffShiftGroupByOutputType = {
    id: string
    userId: string
    openedAt: Date
    closedAt: Date | null
    seconds: number
    createdAt: Date
    _count: StaffShiftCountAggregateOutputType | null
    _avg: StaffShiftAvgAggregateOutputType | null
    _sum: StaffShiftSumAggregateOutputType | null
    _min: StaffShiftMinAggregateOutputType | null
    _max: StaffShiftMaxAggregateOutputType | null
  }

  type GetStaffShiftGroupByPayload<T extends StaffShiftGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StaffShiftGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StaffShiftGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StaffShiftGroupByOutputType[P]>
            : GetScalarType<T[P], StaffShiftGroupByOutputType[P]>
        }
      >
    >


  export type StaffShiftSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    openedAt?: boolean
    closedAt?: boolean
    seconds?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["staffShift"]>

  export type StaffShiftSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    openedAt?: boolean
    closedAt?: boolean
    seconds?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["staffShift"]>

  export type StaffShiftSelectScalar = {
    id?: boolean
    userId?: boolean
    openedAt?: boolean
    closedAt?: boolean
    seconds?: boolean
    createdAt?: boolean
  }

  export type StaffShiftInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type StaffShiftIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $StaffShiftPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StaffShift"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      openedAt: Date
      closedAt: Date | null
      seconds: number
      createdAt: Date
    }, ExtArgs["result"]["staffShift"]>
    composites: {}
  }

  type StaffShiftGetPayload<S extends boolean | null | undefined | StaffShiftDefaultArgs> = $Result.GetResult<Prisma.$StaffShiftPayload, S>

  type StaffShiftCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<StaffShiftFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: StaffShiftCountAggregateInputType | true
    }

  export interface StaffShiftDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StaffShift'], meta: { name: 'StaffShift' } }
    /**
     * Find zero or one StaffShift that matches the filter.
     * @param {StaffShiftFindUniqueArgs} args - Arguments to find a StaffShift
     * @example
     * // Get one StaffShift
     * const staffShift = await prisma.staffShift.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StaffShiftFindUniqueArgs>(args: SelectSubset<T, StaffShiftFindUniqueArgs<ExtArgs>>): Prisma__StaffShiftClient<$Result.GetResult<Prisma.$StaffShiftPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one StaffShift that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {StaffShiftFindUniqueOrThrowArgs} args - Arguments to find a StaffShift
     * @example
     * // Get one StaffShift
     * const staffShift = await prisma.staffShift.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StaffShiftFindUniqueOrThrowArgs>(args: SelectSubset<T, StaffShiftFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StaffShiftClient<$Result.GetResult<Prisma.$StaffShiftPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first StaffShift that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffShiftFindFirstArgs} args - Arguments to find a StaffShift
     * @example
     * // Get one StaffShift
     * const staffShift = await prisma.staffShift.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StaffShiftFindFirstArgs>(args?: SelectSubset<T, StaffShiftFindFirstArgs<ExtArgs>>): Prisma__StaffShiftClient<$Result.GetResult<Prisma.$StaffShiftPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first StaffShift that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffShiftFindFirstOrThrowArgs} args - Arguments to find a StaffShift
     * @example
     * // Get one StaffShift
     * const staffShift = await prisma.staffShift.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StaffShiftFindFirstOrThrowArgs>(args?: SelectSubset<T, StaffShiftFindFirstOrThrowArgs<ExtArgs>>): Prisma__StaffShiftClient<$Result.GetResult<Prisma.$StaffShiftPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more StaffShifts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffShiftFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StaffShifts
     * const staffShifts = await prisma.staffShift.findMany()
     * 
     * // Get first 10 StaffShifts
     * const staffShifts = await prisma.staffShift.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const staffShiftWithIdOnly = await prisma.staffShift.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StaffShiftFindManyArgs>(args?: SelectSubset<T, StaffShiftFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StaffShiftPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a StaffShift.
     * @param {StaffShiftCreateArgs} args - Arguments to create a StaffShift.
     * @example
     * // Create one StaffShift
     * const StaffShift = await prisma.staffShift.create({
     *   data: {
     *     // ... data to create a StaffShift
     *   }
     * })
     * 
     */
    create<T extends StaffShiftCreateArgs>(args: SelectSubset<T, StaffShiftCreateArgs<ExtArgs>>): Prisma__StaffShiftClient<$Result.GetResult<Prisma.$StaffShiftPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many StaffShifts.
     * @param {StaffShiftCreateManyArgs} args - Arguments to create many StaffShifts.
     * @example
     * // Create many StaffShifts
     * const staffShift = await prisma.staffShift.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StaffShiftCreateManyArgs>(args?: SelectSubset<T, StaffShiftCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StaffShifts and returns the data saved in the database.
     * @param {StaffShiftCreateManyAndReturnArgs} args - Arguments to create many StaffShifts.
     * @example
     * // Create many StaffShifts
     * const staffShift = await prisma.staffShift.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StaffShifts and only return the `id`
     * const staffShiftWithIdOnly = await prisma.staffShift.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StaffShiftCreateManyAndReturnArgs>(args?: SelectSubset<T, StaffShiftCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StaffShiftPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a StaffShift.
     * @param {StaffShiftDeleteArgs} args - Arguments to delete one StaffShift.
     * @example
     * // Delete one StaffShift
     * const StaffShift = await prisma.staffShift.delete({
     *   where: {
     *     // ... filter to delete one StaffShift
     *   }
     * })
     * 
     */
    delete<T extends StaffShiftDeleteArgs>(args: SelectSubset<T, StaffShiftDeleteArgs<ExtArgs>>): Prisma__StaffShiftClient<$Result.GetResult<Prisma.$StaffShiftPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one StaffShift.
     * @param {StaffShiftUpdateArgs} args - Arguments to update one StaffShift.
     * @example
     * // Update one StaffShift
     * const staffShift = await prisma.staffShift.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StaffShiftUpdateArgs>(args: SelectSubset<T, StaffShiftUpdateArgs<ExtArgs>>): Prisma__StaffShiftClient<$Result.GetResult<Prisma.$StaffShiftPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more StaffShifts.
     * @param {StaffShiftDeleteManyArgs} args - Arguments to filter StaffShifts to delete.
     * @example
     * // Delete a few StaffShifts
     * const { count } = await prisma.staffShift.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StaffShiftDeleteManyArgs>(args?: SelectSubset<T, StaffShiftDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StaffShifts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffShiftUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StaffShifts
     * const staffShift = await prisma.staffShift.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StaffShiftUpdateManyArgs>(args: SelectSubset<T, StaffShiftUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StaffShift.
     * @param {StaffShiftUpsertArgs} args - Arguments to update or create a StaffShift.
     * @example
     * // Update or create a StaffShift
     * const staffShift = await prisma.staffShift.upsert({
     *   create: {
     *     // ... data to create a StaffShift
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StaffShift we want to update
     *   }
     * })
     */
    upsert<T extends StaffShiftUpsertArgs>(args: SelectSubset<T, StaffShiftUpsertArgs<ExtArgs>>): Prisma__StaffShiftClient<$Result.GetResult<Prisma.$StaffShiftPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of StaffShifts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffShiftCountArgs} args - Arguments to filter StaffShifts to count.
     * @example
     * // Count the number of StaffShifts
     * const count = await prisma.staffShift.count({
     *   where: {
     *     // ... the filter for the StaffShifts we want to count
     *   }
     * })
    **/
    count<T extends StaffShiftCountArgs>(
      args?: Subset<T, StaffShiftCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StaffShiftCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StaffShift.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffShiftAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StaffShiftAggregateArgs>(args: Subset<T, StaffShiftAggregateArgs>): Prisma.PrismaPromise<GetStaffShiftAggregateType<T>>

    /**
     * Group by StaffShift.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffShiftGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StaffShiftGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StaffShiftGroupByArgs['orderBy'] }
        : { orderBy?: StaffShiftGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StaffShiftGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStaffShiftGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StaffShift model
   */
  readonly fields: StaffShiftFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StaffShift.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StaffShiftClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StaffShift model
   */ 
  interface StaffShiftFieldRefs {
    readonly id: FieldRef<"StaffShift", 'String'>
    readonly userId: FieldRef<"StaffShift", 'String'>
    readonly openedAt: FieldRef<"StaffShift", 'DateTime'>
    readonly closedAt: FieldRef<"StaffShift", 'DateTime'>
    readonly seconds: FieldRef<"StaffShift", 'Int'>
    readonly createdAt: FieldRef<"StaffShift", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StaffShift findUnique
   */
  export type StaffShiftFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffShift
     */
    select?: StaffShiftSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffShiftInclude<ExtArgs> | null
    /**
     * Filter, which StaffShift to fetch.
     */
    where: StaffShiftWhereUniqueInput
  }

  /**
   * StaffShift findUniqueOrThrow
   */
  export type StaffShiftFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffShift
     */
    select?: StaffShiftSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffShiftInclude<ExtArgs> | null
    /**
     * Filter, which StaffShift to fetch.
     */
    where: StaffShiftWhereUniqueInput
  }

  /**
   * StaffShift findFirst
   */
  export type StaffShiftFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffShift
     */
    select?: StaffShiftSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffShiftInclude<ExtArgs> | null
    /**
     * Filter, which StaffShift to fetch.
     */
    where?: StaffShiftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StaffShifts to fetch.
     */
    orderBy?: StaffShiftOrderByWithRelationInput | StaffShiftOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StaffShifts.
     */
    cursor?: StaffShiftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StaffShifts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StaffShifts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StaffShifts.
     */
    distinct?: StaffShiftScalarFieldEnum | StaffShiftScalarFieldEnum[]
  }

  /**
   * StaffShift findFirstOrThrow
   */
  export type StaffShiftFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffShift
     */
    select?: StaffShiftSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffShiftInclude<ExtArgs> | null
    /**
     * Filter, which StaffShift to fetch.
     */
    where?: StaffShiftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StaffShifts to fetch.
     */
    orderBy?: StaffShiftOrderByWithRelationInput | StaffShiftOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StaffShifts.
     */
    cursor?: StaffShiftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StaffShifts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StaffShifts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StaffShifts.
     */
    distinct?: StaffShiftScalarFieldEnum | StaffShiftScalarFieldEnum[]
  }

  /**
   * StaffShift findMany
   */
  export type StaffShiftFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffShift
     */
    select?: StaffShiftSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffShiftInclude<ExtArgs> | null
    /**
     * Filter, which StaffShifts to fetch.
     */
    where?: StaffShiftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StaffShifts to fetch.
     */
    orderBy?: StaffShiftOrderByWithRelationInput | StaffShiftOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StaffShifts.
     */
    cursor?: StaffShiftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StaffShifts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StaffShifts.
     */
    skip?: number
    distinct?: StaffShiftScalarFieldEnum | StaffShiftScalarFieldEnum[]
  }

  /**
   * StaffShift create
   */
  export type StaffShiftCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffShift
     */
    select?: StaffShiftSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffShiftInclude<ExtArgs> | null
    /**
     * The data needed to create a StaffShift.
     */
    data: XOR<StaffShiftCreateInput, StaffShiftUncheckedCreateInput>
  }

  /**
   * StaffShift createMany
   */
  export type StaffShiftCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StaffShifts.
     */
    data: StaffShiftCreateManyInput | StaffShiftCreateManyInput[]
  }

  /**
   * StaffShift createManyAndReturn
   */
  export type StaffShiftCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffShift
     */
    select?: StaffShiftSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many StaffShifts.
     */
    data: StaffShiftCreateManyInput | StaffShiftCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffShiftIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StaffShift update
   */
  export type StaffShiftUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffShift
     */
    select?: StaffShiftSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffShiftInclude<ExtArgs> | null
    /**
     * The data needed to update a StaffShift.
     */
    data: XOR<StaffShiftUpdateInput, StaffShiftUncheckedUpdateInput>
    /**
     * Choose, which StaffShift to update.
     */
    where: StaffShiftWhereUniqueInput
  }

  /**
   * StaffShift updateMany
   */
  export type StaffShiftUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StaffShifts.
     */
    data: XOR<StaffShiftUpdateManyMutationInput, StaffShiftUncheckedUpdateManyInput>
    /**
     * Filter which StaffShifts to update
     */
    where?: StaffShiftWhereInput
  }

  /**
   * StaffShift upsert
   */
  export type StaffShiftUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffShift
     */
    select?: StaffShiftSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffShiftInclude<ExtArgs> | null
    /**
     * The filter to search for the StaffShift to update in case it exists.
     */
    where: StaffShiftWhereUniqueInput
    /**
     * In case the StaffShift found by the `where` argument doesn't exist, create a new StaffShift with this data.
     */
    create: XOR<StaffShiftCreateInput, StaffShiftUncheckedCreateInput>
    /**
     * In case the StaffShift was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StaffShiftUpdateInput, StaffShiftUncheckedUpdateInput>
  }

  /**
   * StaffShift delete
   */
  export type StaffShiftDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffShift
     */
    select?: StaffShiftSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffShiftInclude<ExtArgs> | null
    /**
     * Filter which StaffShift to delete.
     */
    where: StaffShiftWhereUniqueInput
  }

  /**
   * StaffShift deleteMany
   */
  export type StaffShiftDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StaffShifts to delete
     */
    where?: StaffShiftWhereInput
  }

  /**
   * StaffShift without action
   */
  export type StaffShiftDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffShift
     */
    select?: StaffShiftSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffShiftInclude<ExtArgs> | null
  }


  /**
   * Model StaffWeeklyReward
   */

  export type AggregateStaffWeeklyReward = {
    _count: StaffWeeklyRewardCountAggregateOutputType | null
    _avg: StaffWeeklyRewardAvgAggregateOutputType | null
    _sum: StaffWeeklyRewardSumAggregateOutputType | null
    _min: StaffWeeklyRewardMinAggregateOutputType | null
    _max: StaffWeeklyRewardMaxAggregateOutputType | null
  }

  export type StaffWeeklyRewardAvgAggregateOutputType = {
    position: number | null
  }

  export type StaffWeeklyRewardSumAggregateOutputType = {
    position: number | null
  }

  export type StaffWeeklyRewardMinAggregateOutputType = {
    id: string | null
    userId: string | null
    position: number | null
    weekKey: string | null
    createdAt: Date | null
  }

  export type StaffWeeklyRewardMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    position: number | null
    weekKey: string | null
    createdAt: Date | null
  }

  export type StaffWeeklyRewardCountAggregateOutputType = {
    id: number
    userId: number
    position: number
    weekKey: number
    createdAt: number
    _all: number
  }


  export type StaffWeeklyRewardAvgAggregateInputType = {
    position?: true
  }

  export type StaffWeeklyRewardSumAggregateInputType = {
    position?: true
  }

  export type StaffWeeklyRewardMinAggregateInputType = {
    id?: true
    userId?: true
    position?: true
    weekKey?: true
    createdAt?: true
  }

  export type StaffWeeklyRewardMaxAggregateInputType = {
    id?: true
    userId?: true
    position?: true
    weekKey?: true
    createdAt?: true
  }

  export type StaffWeeklyRewardCountAggregateInputType = {
    id?: true
    userId?: true
    position?: true
    weekKey?: true
    createdAt?: true
    _all?: true
  }

  export type StaffWeeklyRewardAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StaffWeeklyReward to aggregate.
     */
    where?: StaffWeeklyRewardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StaffWeeklyRewards to fetch.
     */
    orderBy?: StaffWeeklyRewardOrderByWithRelationInput | StaffWeeklyRewardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StaffWeeklyRewardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StaffWeeklyRewards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StaffWeeklyRewards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StaffWeeklyRewards
    **/
    _count?: true | StaffWeeklyRewardCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StaffWeeklyRewardAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StaffWeeklyRewardSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StaffWeeklyRewardMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StaffWeeklyRewardMaxAggregateInputType
  }

  export type GetStaffWeeklyRewardAggregateType<T extends StaffWeeklyRewardAggregateArgs> = {
        [P in keyof T & keyof AggregateStaffWeeklyReward]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStaffWeeklyReward[P]>
      : GetScalarType<T[P], AggregateStaffWeeklyReward[P]>
  }




  export type StaffWeeklyRewardGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StaffWeeklyRewardWhereInput
    orderBy?: StaffWeeklyRewardOrderByWithAggregationInput | StaffWeeklyRewardOrderByWithAggregationInput[]
    by: StaffWeeklyRewardScalarFieldEnum[] | StaffWeeklyRewardScalarFieldEnum
    having?: StaffWeeklyRewardScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StaffWeeklyRewardCountAggregateInputType | true
    _avg?: StaffWeeklyRewardAvgAggregateInputType
    _sum?: StaffWeeklyRewardSumAggregateInputType
    _min?: StaffWeeklyRewardMinAggregateInputType
    _max?: StaffWeeklyRewardMaxAggregateInputType
  }

  export type StaffWeeklyRewardGroupByOutputType = {
    id: string
    userId: string
    position: number
    weekKey: string
    createdAt: Date
    _count: StaffWeeklyRewardCountAggregateOutputType | null
    _avg: StaffWeeklyRewardAvgAggregateOutputType | null
    _sum: StaffWeeklyRewardSumAggregateOutputType | null
    _min: StaffWeeklyRewardMinAggregateOutputType | null
    _max: StaffWeeklyRewardMaxAggregateOutputType | null
  }

  type GetStaffWeeklyRewardGroupByPayload<T extends StaffWeeklyRewardGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StaffWeeklyRewardGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StaffWeeklyRewardGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StaffWeeklyRewardGroupByOutputType[P]>
            : GetScalarType<T[P], StaffWeeklyRewardGroupByOutputType[P]>
        }
      >
    >


  export type StaffWeeklyRewardSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    position?: boolean
    weekKey?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["staffWeeklyReward"]>

  export type StaffWeeklyRewardSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    position?: boolean
    weekKey?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["staffWeeklyReward"]>

  export type StaffWeeklyRewardSelectScalar = {
    id?: boolean
    userId?: boolean
    position?: boolean
    weekKey?: boolean
    createdAt?: boolean
  }

  export type StaffWeeklyRewardInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type StaffWeeklyRewardIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $StaffWeeklyRewardPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StaffWeeklyReward"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      position: number
      weekKey: string
      createdAt: Date
    }, ExtArgs["result"]["staffWeeklyReward"]>
    composites: {}
  }

  type StaffWeeklyRewardGetPayload<S extends boolean | null | undefined | StaffWeeklyRewardDefaultArgs> = $Result.GetResult<Prisma.$StaffWeeklyRewardPayload, S>

  type StaffWeeklyRewardCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<StaffWeeklyRewardFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: StaffWeeklyRewardCountAggregateInputType | true
    }

  export interface StaffWeeklyRewardDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StaffWeeklyReward'], meta: { name: 'StaffWeeklyReward' } }
    /**
     * Find zero or one StaffWeeklyReward that matches the filter.
     * @param {StaffWeeklyRewardFindUniqueArgs} args - Arguments to find a StaffWeeklyReward
     * @example
     * // Get one StaffWeeklyReward
     * const staffWeeklyReward = await prisma.staffWeeklyReward.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StaffWeeklyRewardFindUniqueArgs>(args: SelectSubset<T, StaffWeeklyRewardFindUniqueArgs<ExtArgs>>): Prisma__StaffWeeklyRewardClient<$Result.GetResult<Prisma.$StaffWeeklyRewardPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one StaffWeeklyReward that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {StaffWeeklyRewardFindUniqueOrThrowArgs} args - Arguments to find a StaffWeeklyReward
     * @example
     * // Get one StaffWeeklyReward
     * const staffWeeklyReward = await prisma.staffWeeklyReward.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StaffWeeklyRewardFindUniqueOrThrowArgs>(args: SelectSubset<T, StaffWeeklyRewardFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StaffWeeklyRewardClient<$Result.GetResult<Prisma.$StaffWeeklyRewardPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first StaffWeeklyReward that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffWeeklyRewardFindFirstArgs} args - Arguments to find a StaffWeeklyReward
     * @example
     * // Get one StaffWeeklyReward
     * const staffWeeklyReward = await prisma.staffWeeklyReward.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StaffWeeklyRewardFindFirstArgs>(args?: SelectSubset<T, StaffWeeklyRewardFindFirstArgs<ExtArgs>>): Prisma__StaffWeeklyRewardClient<$Result.GetResult<Prisma.$StaffWeeklyRewardPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first StaffWeeklyReward that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffWeeklyRewardFindFirstOrThrowArgs} args - Arguments to find a StaffWeeklyReward
     * @example
     * // Get one StaffWeeklyReward
     * const staffWeeklyReward = await prisma.staffWeeklyReward.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StaffWeeklyRewardFindFirstOrThrowArgs>(args?: SelectSubset<T, StaffWeeklyRewardFindFirstOrThrowArgs<ExtArgs>>): Prisma__StaffWeeklyRewardClient<$Result.GetResult<Prisma.$StaffWeeklyRewardPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more StaffWeeklyRewards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffWeeklyRewardFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StaffWeeklyRewards
     * const staffWeeklyRewards = await prisma.staffWeeklyReward.findMany()
     * 
     * // Get first 10 StaffWeeklyRewards
     * const staffWeeklyRewards = await prisma.staffWeeklyReward.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const staffWeeklyRewardWithIdOnly = await prisma.staffWeeklyReward.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StaffWeeklyRewardFindManyArgs>(args?: SelectSubset<T, StaffWeeklyRewardFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StaffWeeklyRewardPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a StaffWeeklyReward.
     * @param {StaffWeeklyRewardCreateArgs} args - Arguments to create a StaffWeeklyReward.
     * @example
     * // Create one StaffWeeklyReward
     * const StaffWeeklyReward = await prisma.staffWeeklyReward.create({
     *   data: {
     *     // ... data to create a StaffWeeklyReward
     *   }
     * })
     * 
     */
    create<T extends StaffWeeklyRewardCreateArgs>(args: SelectSubset<T, StaffWeeklyRewardCreateArgs<ExtArgs>>): Prisma__StaffWeeklyRewardClient<$Result.GetResult<Prisma.$StaffWeeklyRewardPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many StaffWeeklyRewards.
     * @param {StaffWeeklyRewardCreateManyArgs} args - Arguments to create many StaffWeeklyRewards.
     * @example
     * // Create many StaffWeeklyRewards
     * const staffWeeklyReward = await prisma.staffWeeklyReward.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StaffWeeklyRewardCreateManyArgs>(args?: SelectSubset<T, StaffWeeklyRewardCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StaffWeeklyRewards and returns the data saved in the database.
     * @param {StaffWeeklyRewardCreateManyAndReturnArgs} args - Arguments to create many StaffWeeklyRewards.
     * @example
     * // Create many StaffWeeklyRewards
     * const staffWeeklyReward = await prisma.staffWeeklyReward.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StaffWeeklyRewards and only return the `id`
     * const staffWeeklyRewardWithIdOnly = await prisma.staffWeeklyReward.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StaffWeeklyRewardCreateManyAndReturnArgs>(args?: SelectSubset<T, StaffWeeklyRewardCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StaffWeeklyRewardPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a StaffWeeklyReward.
     * @param {StaffWeeklyRewardDeleteArgs} args - Arguments to delete one StaffWeeklyReward.
     * @example
     * // Delete one StaffWeeklyReward
     * const StaffWeeklyReward = await prisma.staffWeeklyReward.delete({
     *   where: {
     *     // ... filter to delete one StaffWeeklyReward
     *   }
     * })
     * 
     */
    delete<T extends StaffWeeklyRewardDeleteArgs>(args: SelectSubset<T, StaffWeeklyRewardDeleteArgs<ExtArgs>>): Prisma__StaffWeeklyRewardClient<$Result.GetResult<Prisma.$StaffWeeklyRewardPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one StaffWeeklyReward.
     * @param {StaffWeeklyRewardUpdateArgs} args - Arguments to update one StaffWeeklyReward.
     * @example
     * // Update one StaffWeeklyReward
     * const staffWeeklyReward = await prisma.staffWeeklyReward.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StaffWeeklyRewardUpdateArgs>(args: SelectSubset<T, StaffWeeklyRewardUpdateArgs<ExtArgs>>): Prisma__StaffWeeklyRewardClient<$Result.GetResult<Prisma.$StaffWeeklyRewardPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more StaffWeeklyRewards.
     * @param {StaffWeeklyRewardDeleteManyArgs} args - Arguments to filter StaffWeeklyRewards to delete.
     * @example
     * // Delete a few StaffWeeklyRewards
     * const { count } = await prisma.staffWeeklyReward.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StaffWeeklyRewardDeleteManyArgs>(args?: SelectSubset<T, StaffWeeklyRewardDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StaffWeeklyRewards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffWeeklyRewardUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StaffWeeklyRewards
     * const staffWeeklyReward = await prisma.staffWeeklyReward.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StaffWeeklyRewardUpdateManyArgs>(args: SelectSubset<T, StaffWeeklyRewardUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StaffWeeklyReward.
     * @param {StaffWeeklyRewardUpsertArgs} args - Arguments to update or create a StaffWeeklyReward.
     * @example
     * // Update or create a StaffWeeklyReward
     * const staffWeeklyReward = await prisma.staffWeeklyReward.upsert({
     *   create: {
     *     // ... data to create a StaffWeeklyReward
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StaffWeeklyReward we want to update
     *   }
     * })
     */
    upsert<T extends StaffWeeklyRewardUpsertArgs>(args: SelectSubset<T, StaffWeeklyRewardUpsertArgs<ExtArgs>>): Prisma__StaffWeeklyRewardClient<$Result.GetResult<Prisma.$StaffWeeklyRewardPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of StaffWeeklyRewards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffWeeklyRewardCountArgs} args - Arguments to filter StaffWeeklyRewards to count.
     * @example
     * // Count the number of StaffWeeklyRewards
     * const count = await prisma.staffWeeklyReward.count({
     *   where: {
     *     // ... the filter for the StaffWeeklyRewards we want to count
     *   }
     * })
    **/
    count<T extends StaffWeeklyRewardCountArgs>(
      args?: Subset<T, StaffWeeklyRewardCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StaffWeeklyRewardCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StaffWeeklyReward.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffWeeklyRewardAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StaffWeeklyRewardAggregateArgs>(args: Subset<T, StaffWeeklyRewardAggregateArgs>): Prisma.PrismaPromise<GetStaffWeeklyRewardAggregateType<T>>

    /**
     * Group by StaffWeeklyReward.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffWeeklyRewardGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StaffWeeklyRewardGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StaffWeeklyRewardGroupByArgs['orderBy'] }
        : { orderBy?: StaffWeeklyRewardGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StaffWeeklyRewardGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStaffWeeklyRewardGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StaffWeeklyReward model
   */
  readonly fields: StaffWeeklyRewardFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StaffWeeklyReward.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StaffWeeklyRewardClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StaffWeeklyReward model
   */ 
  interface StaffWeeklyRewardFieldRefs {
    readonly id: FieldRef<"StaffWeeklyReward", 'String'>
    readonly userId: FieldRef<"StaffWeeklyReward", 'String'>
    readonly position: FieldRef<"StaffWeeklyReward", 'Int'>
    readonly weekKey: FieldRef<"StaffWeeklyReward", 'String'>
    readonly createdAt: FieldRef<"StaffWeeklyReward", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StaffWeeklyReward findUnique
   */
  export type StaffWeeklyRewardFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffWeeklyReward
     */
    select?: StaffWeeklyRewardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffWeeklyRewardInclude<ExtArgs> | null
    /**
     * Filter, which StaffWeeklyReward to fetch.
     */
    where: StaffWeeklyRewardWhereUniqueInput
  }

  /**
   * StaffWeeklyReward findUniqueOrThrow
   */
  export type StaffWeeklyRewardFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffWeeklyReward
     */
    select?: StaffWeeklyRewardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffWeeklyRewardInclude<ExtArgs> | null
    /**
     * Filter, which StaffWeeklyReward to fetch.
     */
    where: StaffWeeklyRewardWhereUniqueInput
  }

  /**
   * StaffWeeklyReward findFirst
   */
  export type StaffWeeklyRewardFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffWeeklyReward
     */
    select?: StaffWeeklyRewardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffWeeklyRewardInclude<ExtArgs> | null
    /**
     * Filter, which StaffWeeklyReward to fetch.
     */
    where?: StaffWeeklyRewardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StaffWeeklyRewards to fetch.
     */
    orderBy?: StaffWeeklyRewardOrderByWithRelationInput | StaffWeeklyRewardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StaffWeeklyRewards.
     */
    cursor?: StaffWeeklyRewardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StaffWeeklyRewards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StaffWeeklyRewards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StaffWeeklyRewards.
     */
    distinct?: StaffWeeklyRewardScalarFieldEnum | StaffWeeklyRewardScalarFieldEnum[]
  }

  /**
   * StaffWeeklyReward findFirstOrThrow
   */
  export type StaffWeeklyRewardFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffWeeklyReward
     */
    select?: StaffWeeklyRewardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffWeeklyRewardInclude<ExtArgs> | null
    /**
     * Filter, which StaffWeeklyReward to fetch.
     */
    where?: StaffWeeklyRewardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StaffWeeklyRewards to fetch.
     */
    orderBy?: StaffWeeklyRewardOrderByWithRelationInput | StaffWeeklyRewardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StaffWeeklyRewards.
     */
    cursor?: StaffWeeklyRewardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StaffWeeklyRewards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StaffWeeklyRewards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StaffWeeklyRewards.
     */
    distinct?: StaffWeeklyRewardScalarFieldEnum | StaffWeeklyRewardScalarFieldEnum[]
  }

  /**
   * StaffWeeklyReward findMany
   */
  export type StaffWeeklyRewardFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffWeeklyReward
     */
    select?: StaffWeeklyRewardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffWeeklyRewardInclude<ExtArgs> | null
    /**
     * Filter, which StaffWeeklyRewards to fetch.
     */
    where?: StaffWeeklyRewardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StaffWeeklyRewards to fetch.
     */
    orderBy?: StaffWeeklyRewardOrderByWithRelationInput | StaffWeeklyRewardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StaffWeeklyRewards.
     */
    cursor?: StaffWeeklyRewardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StaffWeeklyRewards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StaffWeeklyRewards.
     */
    skip?: number
    distinct?: StaffWeeklyRewardScalarFieldEnum | StaffWeeklyRewardScalarFieldEnum[]
  }

  /**
   * StaffWeeklyReward create
   */
  export type StaffWeeklyRewardCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffWeeklyReward
     */
    select?: StaffWeeklyRewardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffWeeklyRewardInclude<ExtArgs> | null
    /**
     * The data needed to create a StaffWeeklyReward.
     */
    data: XOR<StaffWeeklyRewardCreateInput, StaffWeeklyRewardUncheckedCreateInput>
  }

  /**
   * StaffWeeklyReward createMany
   */
  export type StaffWeeklyRewardCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StaffWeeklyRewards.
     */
    data: StaffWeeklyRewardCreateManyInput | StaffWeeklyRewardCreateManyInput[]
  }

  /**
   * StaffWeeklyReward createManyAndReturn
   */
  export type StaffWeeklyRewardCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffWeeklyReward
     */
    select?: StaffWeeklyRewardSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many StaffWeeklyRewards.
     */
    data: StaffWeeklyRewardCreateManyInput | StaffWeeklyRewardCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffWeeklyRewardIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StaffWeeklyReward update
   */
  export type StaffWeeklyRewardUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffWeeklyReward
     */
    select?: StaffWeeklyRewardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffWeeklyRewardInclude<ExtArgs> | null
    /**
     * The data needed to update a StaffWeeklyReward.
     */
    data: XOR<StaffWeeklyRewardUpdateInput, StaffWeeklyRewardUncheckedUpdateInput>
    /**
     * Choose, which StaffWeeklyReward to update.
     */
    where: StaffWeeklyRewardWhereUniqueInput
  }

  /**
   * StaffWeeklyReward updateMany
   */
  export type StaffWeeklyRewardUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StaffWeeklyRewards.
     */
    data: XOR<StaffWeeklyRewardUpdateManyMutationInput, StaffWeeklyRewardUncheckedUpdateManyInput>
    /**
     * Filter which StaffWeeklyRewards to update
     */
    where?: StaffWeeklyRewardWhereInput
  }

  /**
   * StaffWeeklyReward upsert
   */
  export type StaffWeeklyRewardUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffWeeklyReward
     */
    select?: StaffWeeklyRewardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffWeeklyRewardInclude<ExtArgs> | null
    /**
     * The filter to search for the StaffWeeklyReward to update in case it exists.
     */
    where: StaffWeeklyRewardWhereUniqueInput
    /**
     * In case the StaffWeeklyReward found by the `where` argument doesn't exist, create a new StaffWeeklyReward with this data.
     */
    create: XOR<StaffWeeklyRewardCreateInput, StaffWeeklyRewardUncheckedCreateInput>
    /**
     * In case the StaffWeeklyReward was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StaffWeeklyRewardUpdateInput, StaffWeeklyRewardUncheckedUpdateInput>
  }

  /**
   * StaffWeeklyReward delete
   */
  export type StaffWeeklyRewardDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffWeeklyReward
     */
    select?: StaffWeeklyRewardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffWeeklyRewardInclude<ExtArgs> | null
    /**
     * Filter which StaffWeeklyReward to delete.
     */
    where: StaffWeeklyRewardWhereUniqueInput
  }

  /**
   * StaffWeeklyReward deleteMany
   */
  export type StaffWeeklyRewardDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StaffWeeklyRewards to delete
     */
    where?: StaffWeeklyRewardWhereInput
  }

  /**
   * StaffWeeklyReward without action
   */
  export type StaffWeeklyRewardDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffWeeklyReward
     */
    select?: StaffWeeklyRewardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffWeeklyRewardInclude<ExtArgs> | null
  }


  /**
   * Model AdminCase
   */

  export type AggregateAdminCase = {
    _count: AdminCaseCountAggregateOutputType | null
    _min: AdminCaseMinAggregateOutputType | null
    _max: AdminCaseMaxAggregateOutputType | null
  }

  export type AdminCaseMinAggregateOutputType = {
    id: string | null
    targetUserId: string | null
    staffUserId: string | null
    type: string | null
    reason: string | null
    expiresAt: Date | null
    active: boolean | null
    createdAt: Date | null
  }

  export type AdminCaseMaxAggregateOutputType = {
    id: string | null
    targetUserId: string | null
    staffUserId: string | null
    type: string | null
    reason: string | null
    expiresAt: Date | null
    active: boolean | null
    createdAt: Date | null
  }

  export type AdminCaseCountAggregateOutputType = {
    id: number
    targetUserId: number
    staffUserId: number
    type: number
    reason: number
    expiresAt: number
    active: number
    createdAt: number
    _all: number
  }


  export type AdminCaseMinAggregateInputType = {
    id?: true
    targetUserId?: true
    staffUserId?: true
    type?: true
    reason?: true
    expiresAt?: true
    active?: true
    createdAt?: true
  }

  export type AdminCaseMaxAggregateInputType = {
    id?: true
    targetUserId?: true
    staffUserId?: true
    type?: true
    reason?: true
    expiresAt?: true
    active?: true
    createdAt?: true
  }

  export type AdminCaseCountAggregateInputType = {
    id?: true
    targetUserId?: true
    staffUserId?: true
    type?: true
    reason?: true
    expiresAt?: true
    active?: true
    createdAt?: true
    _all?: true
  }

  export type AdminCaseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminCase to aggregate.
     */
    where?: AdminCaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminCases to fetch.
     */
    orderBy?: AdminCaseOrderByWithRelationInput | AdminCaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdminCaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminCases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminCases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AdminCases
    **/
    _count?: true | AdminCaseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdminCaseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdminCaseMaxAggregateInputType
  }

  export type GetAdminCaseAggregateType<T extends AdminCaseAggregateArgs> = {
        [P in keyof T & keyof AggregateAdminCase]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdminCase[P]>
      : GetScalarType<T[P], AggregateAdminCase[P]>
  }




  export type AdminCaseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminCaseWhereInput
    orderBy?: AdminCaseOrderByWithAggregationInput | AdminCaseOrderByWithAggregationInput[]
    by: AdminCaseScalarFieldEnum[] | AdminCaseScalarFieldEnum
    having?: AdminCaseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdminCaseCountAggregateInputType | true
    _min?: AdminCaseMinAggregateInputType
    _max?: AdminCaseMaxAggregateInputType
  }

  export type AdminCaseGroupByOutputType = {
    id: string
    targetUserId: string
    staffUserId: string
    type: string
    reason: string
    expiresAt: Date | null
    active: boolean
    createdAt: Date
    _count: AdminCaseCountAggregateOutputType | null
    _min: AdminCaseMinAggregateOutputType | null
    _max: AdminCaseMaxAggregateOutputType | null
  }

  type GetAdminCaseGroupByPayload<T extends AdminCaseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdminCaseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdminCaseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdminCaseGroupByOutputType[P]>
            : GetScalarType<T[P], AdminCaseGroupByOutputType[P]>
        }
      >
    >


  export type AdminCaseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    targetUserId?: boolean
    staffUserId?: boolean
    type?: boolean
    reason?: boolean
    expiresAt?: boolean
    active?: boolean
    createdAt?: boolean
    targetUser?: boolean | UserDefaultArgs<ExtArgs>
    staffUser?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adminCase"]>

  export type AdminCaseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    targetUserId?: boolean
    staffUserId?: boolean
    type?: boolean
    reason?: boolean
    expiresAt?: boolean
    active?: boolean
    createdAt?: boolean
    targetUser?: boolean | UserDefaultArgs<ExtArgs>
    staffUser?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adminCase"]>

  export type AdminCaseSelectScalar = {
    id?: boolean
    targetUserId?: boolean
    staffUserId?: boolean
    type?: boolean
    reason?: boolean
    expiresAt?: boolean
    active?: boolean
    createdAt?: boolean
  }

  export type AdminCaseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    targetUser?: boolean | UserDefaultArgs<ExtArgs>
    staffUser?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AdminCaseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    targetUser?: boolean | UserDefaultArgs<ExtArgs>
    staffUser?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AdminCasePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AdminCase"
    objects: {
      targetUser: Prisma.$UserPayload<ExtArgs>
      staffUser: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      targetUserId: string
      staffUserId: string
      type: string
      reason: string
      expiresAt: Date | null
      active: boolean
      createdAt: Date
    }, ExtArgs["result"]["adminCase"]>
    composites: {}
  }

  type AdminCaseGetPayload<S extends boolean | null | undefined | AdminCaseDefaultArgs> = $Result.GetResult<Prisma.$AdminCasePayload, S>

  type AdminCaseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AdminCaseFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AdminCaseCountAggregateInputType | true
    }

  export interface AdminCaseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AdminCase'], meta: { name: 'AdminCase' } }
    /**
     * Find zero or one AdminCase that matches the filter.
     * @param {AdminCaseFindUniqueArgs} args - Arguments to find a AdminCase
     * @example
     * // Get one AdminCase
     * const adminCase = await prisma.adminCase.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdminCaseFindUniqueArgs>(args: SelectSubset<T, AdminCaseFindUniqueArgs<ExtArgs>>): Prisma__AdminCaseClient<$Result.GetResult<Prisma.$AdminCasePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AdminCase that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AdminCaseFindUniqueOrThrowArgs} args - Arguments to find a AdminCase
     * @example
     * // Get one AdminCase
     * const adminCase = await prisma.adminCase.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdminCaseFindUniqueOrThrowArgs>(args: SelectSubset<T, AdminCaseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdminCaseClient<$Result.GetResult<Prisma.$AdminCasePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AdminCase that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminCaseFindFirstArgs} args - Arguments to find a AdminCase
     * @example
     * // Get one AdminCase
     * const adminCase = await prisma.adminCase.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdminCaseFindFirstArgs>(args?: SelectSubset<T, AdminCaseFindFirstArgs<ExtArgs>>): Prisma__AdminCaseClient<$Result.GetResult<Prisma.$AdminCasePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AdminCase that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminCaseFindFirstOrThrowArgs} args - Arguments to find a AdminCase
     * @example
     * // Get one AdminCase
     * const adminCase = await prisma.adminCase.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdminCaseFindFirstOrThrowArgs>(args?: SelectSubset<T, AdminCaseFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdminCaseClient<$Result.GetResult<Prisma.$AdminCasePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AdminCases that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminCaseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AdminCases
     * const adminCases = await prisma.adminCase.findMany()
     * 
     * // Get first 10 AdminCases
     * const adminCases = await prisma.adminCase.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adminCaseWithIdOnly = await prisma.adminCase.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdminCaseFindManyArgs>(args?: SelectSubset<T, AdminCaseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminCasePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AdminCase.
     * @param {AdminCaseCreateArgs} args - Arguments to create a AdminCase.
     * @example
     * // Create one AdminCase
     * const AdminCase = await prisma.adminCase.create({
     *   data: {
     *     // ... data to create a AdminCase
     *   }
     * })
     * 
     */
    create<T extends AdminCaseCreateArgs>(args: SelectSubset<T, AdminCaseCreateArgs<ExtArgs>>): Prisma__AdminCaseClient<$Result.GetResult<Prisma.$AdminCasePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AdminCases.
     * @param {AdminCaseCreateManyArgs} args - Arguments to create many AdminCases.
     * @example
     * // Create many AdminCases
     * const adminCase = await prisma.adminCase.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdminCaseCreateManyArgs>(args?: SelectSubset<T, AdminCaseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AdminCases and returns the data saved in the database.
     * @param {AdminCaseCreateManyAndReturnArgs} args - Arguments to create many AdminCases.
     * @example
     * // Create many AdminCases
     * const adminCase = await prisma.adminCase.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AdminCases and only return the `id`
     * const adminCaseWithIdOnly = await prisma.adminCase.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AdminCaseCreateManyAndReturnArgs>(args?: SelectSubset<T, AdminCaseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminCasePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AdminCase.
     * @param {AdminCaseDeleteArgs} args - Arguments to delete one AdminCase.
     * @example
     * // Delete one AdminCase
     * const AdminCase = await prisma.adminCase.delete({
     *   where: {
     *     // ... filter to delete one AdminCase
     *   }
     * })
     * 
     */
    delete<T extends AdminCaseDeleteArgs>(args: SelectSubset<T, AdminCaseDeleteArgs<ExtArgs>>): Prisma__AdminCaseClient<$Result.GetResult<Prisma.$AdminCasePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AdminCase.
     * @param {AdminCaseUpdateArgs} args - Arguments to update one AdminCase.
     * @example
     * // Update one AdminCase
     * const adminCase = await prisma.adminCase.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdminCaseUpdateArgs>(args: SelectSubset<T, AdminCaseUpdateArgs<ExtArgs>>): Prisma__AdminCaseClient<$Result.GetResult<Prisma.$AdminCasePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AdminCases.
     * @param {AdminCaseDeleteManyArgs} args - Arguments to filter AdminCases to delete.
     * @example
     * // Delete a few AdminCases
     * const { count } = await prisma.adminCase.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdminCaseDeleteManyArgs>(args?: SelectSubset<T, AdminCaseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdminCases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminCaseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AdminCases
     * const adminCase = await prisma.adminCase.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdminCaseUpdateManyArgs>(args: SelectSubset<T, AdminCaseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AdminCase.
     * @param {AdminCaseUpsertArgs} args - Arguments to update or create a AdminCase.
     * @example
     * // Update or create a AdminCase
     * const adminCase = await prisma.adminCase.upsert({
     *   create: {
     *     // ... data to create a AdminCase
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AdminCase we want to update
     *   }
     * })
     */
    upsert<T extends AdminCaseUpsertArgs>(args: SelectSubset<T, AdminCaseUpsertArgs<ExtArgs>>): Prisma__AdminCaseClient<$Result.GetResult<Prisma.$AdminCasePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AdminCases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminCaseCountArgs} args - Arguments to filter AdminCases to count.
     * @example
     * // Count the number of AdminCases
     * const count = await prisma.adminCase.count({
     *   where: {
     *     // ... the filter for the AdminCases we want to count
     *   }
     * })
    **/
    count<T extends AdminCaseCountArgs>(
      args?: Subset<T, AdminCaseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdminCaseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AdminCase.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminCaseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdminCaseAggregateArgs>(args: Subset<T, AdminCaseAggregateArgs>): Prisma.PrismaPromise<GetAdminCaseAggregateType<T>>

    /**
     * Group by AdminCase.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminCaseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdminCaseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdminCaseGroupByArgs['orderBy'] }
        : { orderBy?: AdminCaseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdminCaseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdminCaseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AdminCase model
   */
  readonly fields: AdminCaseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AdminCase.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdminCaseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    targetUser<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    staffUser<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AdminCase model
   */ 
  interface AdminCaseFieldRefs {
    readonly id: FieldRef<"AdminCase", 'String'>
    readonly targetUserId: FieldRef<"AdminCase", 'String'>
    readonly staffUserId: FieldRef<"AdminCase", 'String'>
    readonly type: FieldRef<"AdminCase", 'String'>
    readonly reason: FieldRef<"AdminCase", 'String'>
    readonly expiresAt: FieldRef<"AdminCase", 'DateTime'>
    readonly active: FieldRef<"AdminCase", 'Boolean'>
    readonly createdAt: FieldRef<"AdminCase", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AdminCase findUnique
   */
  export type AdminCaseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminCase
     */
    select?: AdminCaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminCaseInclude<ExtArgs> | null
    /**
     * Filter, which AdminCase to fetch.
     */
    where: AdminCaseWhereUniqueInput
  }

  /**
   * AdminCase findUniqueOrThrow
   */
  export type AdminCaseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminCase
     */
    select?: AdminCaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminCaseInclude<ExtArgs> | null
    /**
     * Filter, which AdminCase to fetch.
     */
    where: AdminCaseWhereUniqueInput
  }

  /**
   * AdminCase findFirst
   */
  export type AdminCaseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminCase
     */
    select?: AdminCaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminCaseInclude<ExtArgs> | null
    /**
     * Filter, which AdminCase to fetch.
     */
    where?: AdminCaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminCases to fetch.
     */
    orderBy?: AdminCaseOrderByWithRelationInput | AdminCaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminCases.
     */
    cursor?: AdminCaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminCases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminCases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminCases.
     */
    distinct?: AdminCaseScalarFieldEnum | AdminCaseScalarFieldEnum[]
  }

  /**
   * AdminCase findFirstOrThrow
   */
  export type AdminCaseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminCase
     */
    select?: AdminCaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminCaseInclude<ExtArgs> | null
    /**
     * Filter, which AdminCase to fetch.
     */
    where?: AdminCaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminCases to fetch.
     */
    orderBy?: AdminCaseOrderByWithRelationInput | AdminCaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminCases.
     */
    cursor?: AdminCaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminCases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminCases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminCases.
     */
    distinct?: AdminCaseScalarFieldEnum | AdminCaseScalarFieldEnum[]
  }

  /**
   * AdminCase findMany
   */
  export type AdminCaseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminCase
     */
    select?: AdminCaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminCaseInclude<ExtArgs> | null
    /**
     * Filter, which AdminCases to fetch.
     */
    where?: AdminCaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminCases to fetch.
     */
    orderBy?: AdminCaseOrderByWithRelationInput | AdminCaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AdminCases.
     */
    cursor?: AdminCaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminCases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminCases.
     */
    skip?: number
    distinct?: AdminCaseScalarFieldEnum | AdminCaseScalarFieldEnum[]
  }

  /**
   * AdminCase create
   */
  export type AdminCaseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminCase
     */
    select?: AdminCaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminCaseInclude<ExtArgs> | null
    /**
     * The data needed to create a AdminCase.
     */
    data: XOR<AdminCaseCreateInput, AdminCaseUncheckedCreateInput>
  }

  /**
   * AdminCase createMany
   */
  export type AdminCaseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AdminCases.
     */
    data: AdminCaseCreateManyInput | AdminCaseCreateManyInput[]
  }

  /**
   * AdminCase createManyAndReturn
   */
  export type AdminCaseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminCase
     */
    select?: AdminCaseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AdminCases.
     */
    data: AdminCaseCreateManyInput | AdminCaseCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminCaseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AdminCase update
   */
  export type AdminCaseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminCase
     */
    select?: AdminCaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminCaseInclude<ExtArgs> | null
    /**
     * The data needed to update a AdminCase.
     */
    data: XOR<AdminCaseUpdateInput, AdminCaseUncheckedUpdateInput>
    /**
     * Choose, which AdminCase to update.
     */
    where: AdminCaseWhereUniqueInput
  }

  /**
   * AdminCase updateMany
   */
  export type AdminCaseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AdminCases.
     */
    data: XOR<AdminCaseUpdateManyMutationInput, AdminCaseUncheckedUpdateManyInput>
    /**
     * Filter which AdminCases to update
     */
    where?: AdminCaseWhereInput
  }

  /**
   * AdminCase upsert
   */
  export type AdminCaseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminCase
     */
    select?: AdminCaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminCaseInclude<ExtArgs> | null
    /**
     * The filter to search for the AdminCase to update in case it exists.
     */
    where: AdminCaseWhereUniqueInput
    /**
     * In case the AdminCase found by the `where` argument doesn't exist, create a new AdminCase with this data.
     */
    create: XOR<AdminCaseCreateInput, AdminCaseUncheckedCreateInput>
    /**
     * In case the AdminCase was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdminCaseUpdateInput, AdminCaseUncheckedUpdateInput>
  }

  /**
   * AdminCase delete
   */
  export type AdminCaseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminCase
     */
    select?: AdminCaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminCaseInclude<ExtArgs> | null
    /**
     * Filter which AdminCase to delete.
     */
    where: AdminCaseWhereUniqueInput
  }

  /**
   * AdminCase deleteMany
   */
  export type AdminCaseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminCases to delete
     */
    where?: AdminCaseWhereInput
  }

  /**
   * AdminCase without action
   */
  export type AdminCaseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminCase
     */
    select?: AdminCaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminCaseInclude<ExtArgs> | null
  }


  /**
   * Model UserReputation
   */

  export type AggregateUserReputation = {
    _count: UserReputationCountAggregateOutputType | null
    _avg: UserReputationAvgAggregateOutputType | null
    _sum: UserReputationSumAggregateOutputType | null
    _min: UserReputationMinAggregateOutputType | null
    _max: UserReputationMaxAggregateOutputType | null
  }

  export type UserReputationAvgAggregateOutputType = {
    score: number | null
  }

  export type UserReputationSumAggregateOutputType = {
    score: number | null
  }

  export type UserReputationMinAggregateOutputType = {
    userId: string | null
    score: number | null
    updatedAt: Date | null
  }

  export type UserReputationMaxAggregateOutputType = {
    userId: string | null
    score: number | null
    updatedAt: Date | null
  }

  export type UserReputationCountAggregateOutputType = {
    userId: number
    score: number
    updatedAt: number
    _all: number
  }


  export type UserReputationAvgAggregateInputType = {
    score?: true
  }

  export type UserReputationSumAggregateInputType = {
    score?: true
  }

  export type UserReputationMinAggregateInputType = {
    userId?: true
    score?: true
    updatedAt?: true
  }

  export type UserReputationMaxAggregateInputType = {
    userId?: true
    score?: true
    updatedAt?: true
  }

  export type UserReputationCountAggregateInputType = {
    userId?: true
    score?: true
    updatedAt?: true
    _all?: true
  }

  export type UserReputationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserReputation to aggregate.
     */
    where?: UserReputationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserReputations to fetch.
     */
    orderBy?: UserReputationOrderByWithRelationInput | UserReputationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserReputationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserReputations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserReputations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserReputations
    **/
    _count?: true | UserReputationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserReputationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserReputationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserReputationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserReputationMaxAggregateInputType
  }

  export type GetUserReputationAggregateType<T extends UserReputationAggregateArgs> = {
        [P in keyof T & keyof AggregateUserReputation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserReputation[P]>
      : GetScalarType<T[P], AggregateUserReputation[P]>
  }




  export type UserReputationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserReputationWhereInput
    orderBy?: UserReputationOrderByWithAggregationInput | UserReputationOrderByWithAggregationInput[]
    by: UserReputationScalarFieldEnum[] | UserReputationScalarFieldEnum
    having?: UserReputationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserReputationCountAggregateInputType | true
    _avg?: UserReputationAvgAggregateInputType
    _sum?: UserReputationSumAggregateInputType
    _min?: UserReputationMinAggregateInputType
    _max?: UserReputationMaxAggregateInputType
  }

  export type UserReputationGroupByOutputType = {
    userId: string
    score: number
    updatedAt: Date
    _count: UserReputationCountAggregateOutputType | null
    _avg: UserReputationAvgAggregateOutputType | null
    _sum: UserReputationSumAggregateOutputType | null
    _min: UserReputationMinAggregateOutputType | null
    _max: UserReputationMaxAggregateOutputType | null
  }

  type GetUserReputationGroupByPayload<T extends UserReputationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserReputationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserReputationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserReputationGroupByOutputType[P]>
            : GetScalarType<T[P], UserReputationGroupByOutputType[P]>
        }
      >
    >


  export type UserReputationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    score?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userReputation"]>

  export type UserReputationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    score?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userReputation"]>

  export type UserReputationSelectScalar = {
    userId?: boolean
    score?: boolean
    updatedAt?: boolean
  }

  export type UserReputationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserReputationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserReputationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserReputation"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      userId: string
      score: number
      updatedAt: Date
    }, ExtArgs["result"]["userReputation"]>
    composites: {}
  }

  type UserReputationGetPayload<S extends boolean | null | undefined | UserReputationDefaultArgs> = $Result.GetResult<Prisma.$UserReputationPayload, S>

  type UserReputationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserReputationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserReputationCountAggregateInputType | true
    }

  export interface UserReputationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserReputation'], meta: { name: 'UserReputation' } }
    /**
     * Find zero or one UserReputation that matches the filter.
     * @param {UserReputationFindUniqueArgs} args - Arguments to find a UserReputation
     * @example
     * // Get one UserReputation
     * const userReputation = await prisma.userReputation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserReputationFindUniqueArgs>(args: SelectSubset<T, UserReputationFindUniqueArgs<ExtArgs>>): Prisma__UserReputationClient<$Result.GetResult<Prisma.$UserReputationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UserReputation that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserReputationFindUniqueOrThrowArgs} args - Arguments to find a UserReputation
     * @example
     * // Get one UserReputation
     * const userReputation = await prisma.userReputation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserReputationFindUniqueOrThrowArgs>(args: SelectSubset<T, UserReputationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserReputationClient<$Result.GetResult<Prisma.$UserReputationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UserReputation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserReputationFindFirstArgs} args - Arguments to find a UserReputation
     * @example
     * // Get one UserReputation
     * const userReputation = await prisma.userReputation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserReputationFindFirstArgs>(args?: SelectSubset<T, UserReputationFindFirstArgs<ExtArgs>>): Prisma__UserReputationClient<$Result.GetResult<Prisma.$UserReputationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UserReputation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserReputationFindFirstOrThrowArgs} args - Arguments to find a UserReputation
     * @example
     * // Get one UserReputation
     * const userReputation = await prisma.userReputation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserReputationFindFirstOrThrowArgs>(args?: SelectSubset<T, UserReputationFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserReputationClient<$Result.GetResult<Prisma.$UserReputationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UserReputations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserReputationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserReputations
     * const userReputations = await prisma.userReputation.findMany()
     * 
     * // Get first 10 UserReputations
     * const userReputations = await prisma.userReputation.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const userReputationWithUserIdOnly = await prisma.userReputation.findMany({ select: { userId: true } })
     * 
     */
    findMany<T extends UserReputationFindManyArgs>(args?: SelectSubset<T, UserReputationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserReputationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UserReputation.
     * @param {UserReputationCreateArgs} args - Arguments to create a UserReputation.
     * @example
     * // Create one UserReputation
     * const UserReputation = await prisma.userReputation.create({
     *   data: {
     *     // ... data to create a UserReputation
     *   }
     * })
     * 
     */
    create<T extends UserReputationCreateArgs>(args: SelectSubset<T, UserReputationCreateArgs<ExtArgs>>): Prisma__UserReputationClient<$Result.GetResult<Prisma.$UserReputationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UserReputations.
     * @param {UserReputationCreateManyArgs} args - Arguments to create many UserReputations.
     * @example
     * // Create many UserReputations
     * const userReputation = await prisma.userReputation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserReputationCreateManyArgs>(args?: SelectSubset<T, UserReputationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserReputations and returns the data saved in the database.
     * @param {UserReputationCreateManyAndReturnArgs} args - Arguments to create many UserReputations.
     * @example
     * // Create many UserReputations
     * const userReputation = await prisma.userReputation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserReputations and only return the `userId`
     * const userReputationWithUserIdOnly = await prisma.userReputation.createManyAndReturn({ 
     *   select: { userId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserReputationCreateManyAndReturnArgs>(args?: SelectSubset<T, UserReputationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserReputationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a UserReputation.
     * @param {UserReputationDeleteArgs} args - Arguments to delete one UserReputation.
     * @example
     * // Delete one UserReputation
     * const UserReputation = await prisma.userReputation.delete({
     *   where: {
     *     // ... filter to delete one UserReputation
     *   }
     * })
     * 
     */
    delete<T extends UserReputationDeleteArgs>(args: SelectSubset<T, UserReputationDeleteArgs<ExtArgs>>): Prisma__UserReputationClient<$Result.GetResult<Prisma.$UserReputationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UserReputation.
     * @param {UserReputationUpdateArgs} args - Arguments to update one UserReputation.
     * @example
     * // Update one UserReputation
     * const userReputation = await prisma.userReputation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserReputationUpdateArgs>(args: SelectSubset<T, UserReputationUpdateArgs<ExtArgs>>): Prisma__UserReputationClient<$Result.GetResult<Prisma.$UserReputationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UserReputations.
     * @param {UserReputationDeleteManyArgs} args - Arguments to filter UserReputations to delete.
     * @example
     * // Delete a few UserReputations
     * const { count } = await prisma.userReputation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserReputationDeleteManyArgs>(args?: SelectSubset<T, UserReputationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserReputations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserReputationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserReputations
     * const userReputation = await prisma.userReputation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserReputationUpdateManyArgs>(args: SelectSubset<T, UserReputationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserReputation.
     * @param {UserReputationUpsertArgs} args - Arguments to update or create a UserReputation.
     * @example
     * // Update or create a UserReputation
     * const userReputation = await prisma.userReputation.upsert({
     *   create: {
     *     // ... data to create a UserReputation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserReputation we want to update
     *   }
     * })
     */
    upsert<T extends UserReputationUpsertArgs>(args: SelectSubset<T, UserReputationUpsertArgs<ExtArgs>>): Prisma__UserReputationClient<$Result.GetResult<Prisma.$UserReputationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UserReputations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserReputationCountArgs} args - Arguments to filter UserReputations to count.
     * @example
     * // Count the number of UserReputations
     * const count = await prisma.userReputation.count({
     *   where: {
     *     // ... the filter for the UserReputations we want to count
     *   }
     * })
    **/
    count<T extends UserReputationCountArgs>(
      args?: Subset<T, UserReputationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserReputationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserReputation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserReputationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserReputationAggregateArgs>(args: Subset<T, UserReputationAggregateArgs>): Prisma.PrismaPromise<GetUserReputationAggregateType<T>>

    /**
     * Group by UserReputation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserReputationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserReputationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserReputationGroupByArgs['orderBy'] }
        : { orderBy?: UserReputationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserReputationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserReputationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserReputation model
   */
  readonly fields: UserReputationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserReputation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserReputationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserReputation model
   */ 
  interface UserReputationFieldRefs {
    readonly userId: FieldRef<"UserReputation", 'String'>
    readonly score: FieldRef<"UserReputation", 'Int'>
    readonly updatedAt: FieldRef<"UserReputation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserReputation findUnique
   */
  export type UserReputationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserReputation
     */
    select?: UserReputationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserReputationInclude<ExtArgs> | null
    /**
     * Filter, which UserReputation to fetch.
     */
    where: UserReputationWhereUniqueInput
  }

  /**
   * UserReputation findUniqueOrThrow
   */
  export type UserReputationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserReputation
     */
    select?: UserReputationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserReputationInclude<ExtArgs> | null
    /**
     * Filter, which UserReputation to fetch.
     */
    where: UserReputationWhereUniqueInput
  }

  /**
   * UserReputation findFirst
   */
  export type UserReputationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserReputation
     */
    select?: UserReputationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserReputationInclude<ExtArgs> | null
    /**
     * Filter, which UserReputation to fetch.
     */
    where?: UserReputationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserReputations to fetch.
     */
    orderBy?: UserReputationOrderByWithRelationInput | UserReputationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserReputations.
     */
    cursor?: UserReputationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserReputations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserReputations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserReputations.
     */
    distinct?: UserReputationScalarFieldEnum | UserReputationScalarFieldEnum[]
  }

  /**
   * UserReputation findFirstOrThrow
   */
  export type UserReputationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserReputation
     */
    select?: UserReputationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserReputationInclude<ExtArgs> | null
    /**
     * Filter, which UserReputation to fetch.
     */
    where?: UserReputationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserReputations to fetch.
     */
    orderBy?: UserReputationOrderByWithRelationInput | UserReputationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserReputations.
     */
    cursor?: UserReputationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserReputations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserReputations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserReputations.
     */
    distinct?: UserReputationScalarFieldEnum | UserReputationScalarFieldEnum[]
  }

  /**
   * UserReputation findMany
   */
  export type UserReputationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserReputation
     */
    select?: UserReputationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserReputationInclude<ExtArgs> | null
    /**
     * Filter, which UserReputations to fetch.
     */
    where?: UserReputationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserReputations to fetch.
     */
    orderBy?: UserReputationOrderByWithRelationInput | UserReputationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserReputations.
     */
    cursor?: UserReputationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserReputations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserReputations.
     */
    skip?: number
    distinct?: UserReputationScalarFieldEnum | UserReputationScalarFieldEnum[]
  }

  /**
   * UserReputation create
   */
  export type UserReputationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserReputation
     */
    select?: UserReputationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserReputationInclude<ExtArgs> | null
    /**
     * The data needed to create a UserReputation.
     */
    data: XOR<UserReputationCreateInput, UserReputationUncheckedCreateInput>
  }

  /**
   * UserReputation createMany
   */
  export type UserReputationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserReputations.
     */
    data: UserReputationCreateManyInput | UserReputationCreateManyInput[]
  }

  /**
   * UserReputation createManyAndReturn
   */
  export type UserReputationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserReputation
     */
    select?: UserReputationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many UserReputations.
     */
    data: UserReputationCreateManyInput | UserReputationCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserReputationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserReputation update
   */
  export type UserReputationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserReputation
     */
    select?: UserReputationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserReputationInclude<ExtArgs> | null
    /**
     * The data needed to update a UserReputation.
     */
    data: XOR<UserReputationUpdateInput, UserReputationUncheckedUpdateInput>
    /**
     * Choose, which UserReputation to update.
     */
    where: UserReputationWhereUniqueInput
  }

  /**
   * UserReputation updateMany
   */
  export type UserReputationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserReputations.
     */
    data: XOR<UserReputationUpdateManyMutationInput, UserReputationUncheckedUpdateManyInput>
    /**
     * Filter which UserReputations to update
     */
    where?: UserReputationWhereInput
  }

  /**
   * UserReputation upsert
   */
  export type UserReputationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserReputation
     */
    select?: UserReputationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserReputationInclude<ExtArgs> | null
    /**
     * The filter to search for the UserReputation to update in case it exists.
     */
    where: UserReputationWhereUniqueInput
    /**
     * In case the UserReputation found by the `where` argument doesn't exist, create a new UserReputation with this data.
     */
    create: XOR<UserReputationCreateInput, UserReputationUncheckedCreateInput>
    /**
     * In case the UserReputation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserReputationUpdateInput, UserReputationUncheckedUpdateInput>
  }

  /**
   * UserReputation delete
   */
  export type UserReputationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserReputation
     */
    select?: UserReputationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserReputationInclude<ExtArgs> | null
    /**
     * Filter which UserReputation to delete.
     */
    where: UserReputationWhereUniqueInput
  }

  /**
   * UserReputation deleteMany
   */
  export type UserReputationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserReputations to delete
     */
    where?: UserReputationWhereInput
  }

  /**
   * UserReputation without action
   */
  export type UserReputationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserReputation
     */
    select?: UserReputationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserReputationInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    points: number | null
  }

  export type UserSumAggregateOutputType = {
    points: number | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    username: string | null
    passwordHash: string | null
    emailVerifiedAt: Date | null
    emailVerifyToken: string | null
    emailVerifyExpiresAt: Date | null
    phone: string | null
    recoveryEmail: string | null
    googleId: string | null
    discordId: string | null
    discordUsername: string | null
    avatarKey: string | null
    role: string | null
    isDeleted: boolean | null
    bannedUntil: Date | null
    whitelistStatus: string | null
    points: number | null
    lastSeenAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    avatarUrl: string | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    username: string | null
    passwordHash: string | null
    emailVerifiedAt: Date | null
    emailVerifyToken: string | null
    emailVerifyExpiresAt: Date | null
    phone: string | null
    recoveryEmail: string | null
    googleId: string | null
    discordId: string | null
    discordUsername: string | null
    avatarKey: string | null
    role: string | null
    isDeleted: boolean | null
    bannedUntil: Date | null
    whitelistStatus: string | null
    points: number | null
    lastSeenAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    avatarUrl: string | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    username: number
    passwordHash: number
    emailVerifiedAt: number
    emailVerifyToken: number
    emailVerifyExpiresAt: number
    phone: number
    recoveryEmail: number
    googleId: number
    discordId: number
    discordUsername: number
    avatarKey: number
    role: number
    isDeleted: number
    bannedUntil: number
    whitelistStatus: number
    points: number
    lastSeenAt: number
    createdAt: number
    updatedAt: number
    avatarUrl: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    points?: true
  }

  export type UserSumAggregateInputType = {
    points?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    username?: true
    passwordHash?: true
    emailVerifiedAt?: true
    emailVerifyToken?: true
    emailVerifyExpiresAt?: true
    phone?: true
    recoveryEmail?: true
    googleId?: true
    discordId?: true
    discordUsername?: true
    avatarKey?: true
    role?: true
    isDeleted?: true
    bannedUntil?: true
    whitelistStatus?: true
    points?: true
    lastSeenAt?: true
    createdAt?: true
    updatedAt?: true
    avatarUrl?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    username?: true
    passwordHash?: true
    emailVerifiedAt?: true
    emailVerifyToken?: true
    emailVerifyExpiresAt?: true
    phone?: true
    recoveryEmail?: true
    googleId?: true
    discordId?: true
    discordUsername?: true
    avatarKey?: true
    role?: true
    isDeleted?: true
    bannedUntil?: true
    whitelistStatus?: true
    points?: true
    lastSeenAt?: true
    createdAt?: true
    updatedAt?: true
    avatarUrl?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    username?: true
    passwordHash?: true
    emailVerifiedAt?: true
    emailVerifyToken?: true
    emailVerifyExpiresAt?: true
    phone?: true
    recoveryEmail?: true
    googleId?: true
    discordId?: true
    discordUsername?: true
    avatarKey?: true
    role?: true
    isDeleted?: true
    bannedUntil?: true
    whitelistStatus?: true
    points?: true
    lastSeenAt?: true
    createdAt?: true
    updatedAt?: true
    avatarUrl?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    username: string
    passwordHash: string
    emailVerifiedAt: Date | null
    emailVerifyToken: string | null
    emailVerifyExpiresAt: Date | null
    phone: string | null
    recoveryEmail: string | null
    googleId: string | null
    discordId: string | null
    discordUsername: string | null
    avatarKey: string
    role: string
    isDeleted: boolean
    bannedUntil: Date | null
    whitelistStatus: string
    points: number
    lastSeenAt: Date
    createdAt: Date
    updatedAt: Date
    avatarUrl: string | null
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    username?: boolean
    passwordHash?: boolean
    emailVerifiedAt?: boolean
    emailVerifyToken?: boolean
    emailVerifyExpiresAt?: boolean
    phone?: boolean
    recoveryEmail?: boolean
    googleId?: boolean
    discordId?: boolean
    discordUsername?: boolean
    avatarKey?: boolean
    role?: boolean
    isDeleted?: boolean
    bannedUntil?: boolean
    whitelistStatus?: boolean
    points?: boolean
    lastSeenAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    avatarUrl?: boolean
    topics?: boolean | User$topicsArgs<ExtArgs>
    posts?: boolean | User$postsArgs<ExtArgs>
    tickets?: boolean | User$ticketsArgs<ExtArgs>
    assignedTickets?: boolean | User$assignedTicketsArgs<ExtArgs>
    ticketMsgs?: boolean | User$ticketMsgsArgs<ExtArgs>
    ticketParticipants?: boolean | User$ticketParticipantsArgs<ExtArgs>
    ticketParticipantsAdded?: boolean | User$ticketParticipantsAddedArgs<ExtArgs>
    ticketRatingsGiven?: boolean | User$ticketRatingsGivenArgs<ExtArgs>
    ticketRatingsReceived?: boolean | User$ticketRatingsReceivedArgs<ExtArgs>
    closedTickets?: boolean | User$closedTicketsArgs<ExtArgs>
    purchases?: boolean | User$purchasesArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    userRoles?: boolean | User$userRolesArgs<ExtArgs>
    whitelistApps?: boolean | User$whitelistAppsArgs<ExtArgs>
    reviewedWhitelists?: boolean | User$reviewedWhitelistsArgs<ExtArgs>
    convoParts?: boolean | User$convoPartsArgs<ExtArgs>
    sentMessages?: boolean | User$sentMessagesArgs<ExtArgs>
    receivedMessages?: boolean | User$receivedMessagesArgs<ExtArgs>
    userBadges?: boolean | User$userBadgesArgs<ExtArgs>
    gameAccounts?: boolean | User$gameAccountsArgs<ExtArgs>
    mtaAccessLogs?: boolean | User$mtaAccessLogsArgs<ExtArgs>
    ticketRatingReqGiven?: boolean | User$ticketRatingReqGivenArgs<ExtArgs>
    ticketRatingReqReceived?: boolean | User$ticketRatingReqReceivedArgs<ExtArgs>
    passwordResetTokens?: boolean | User$passwordResetTokensArgs<ExtArgs>
    entitlements?: boolean | User$entitlementsArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    staffShifts?: boolean | User$staffShiftsArgs<ExtArgs>
    staffWeeklyRewards?: boolean | User$staffWeeklyRewardsArgs<ExtArgs>
    adminCasesTarget?: boolean | User$adminCasesTargetArgs<ExtArgs>
    adminCasesStaff?: boolean | User$adminCasesStaffArgs<ExtArgs>
    reputation?: boolean | User$reputationArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    username?: boolean
    passwordHash?: boolean
    emailVerifiedAt?: boolean
    emailVerifyToken?: boolean
    emailVerifyExpiresAt?: boolean
    phone?: boolean
    recoveryEmail?: boolean
    googleId?: boolean
    discordId?: boolean
    discordUsername?: boolean
    avatarKey?: boolean
    role?: boolean
    isDeleted?: boolean
    bannedUntil?: boolean
    whitelistStatus?: boolean
    points?: boolean
    lastSeenAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    avatarUrl?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    username?: boolean
    passwordHash?: boolean
    emailVerifiedAt?: boolean
    emailVerifyToken?: boolean
    emailVerifyExpiresAt?: boolean
    phone?: boolean
    recoveryEmail?: boolean
    googleId?: boolean
    discordId?: boolean
    discordUsername?: boolean
    avatarKey?: boolean
    role?: boolean
    isDeleted?: boolean
    bannedUntil?: boolean
    whitelistStatus?: boolean
    points?: boolean
    lastSeenAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    avatarUrl?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    topics?: boolean | User$topicsArgs<ExtArgs>
    posts?: boolean | User$postsArgs<ExtArgs>
    tickets?: boolean | User$ticketsArgs<ExtArgs>
    assignedTickets?: boolean | User$assignedTicketsArgs<ExtArgs>
    ticketMsgs?: boolean | User$ticketMsgsArgs<ExtArgs>
    ticketParticipants?: boolean | User$ticketParticipantsArgs<ExtArgs>
    ticketParticipantsAdded?: boolean | User$ticketParticipantsAddedArgs<ExtArgs>
    ticketRatingsGiven?: boolean | User$ticketRatingsGivenArgs<ExtArgs>
    ticketRatingsReceived?: boolean | User$ticketRatingsReceivedArgs<ExtArgs>
    closedTickets?: boolean | User$closedTicketsArgs<ExtArgs>
    purchases?: boolean | User$purchasesArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    userRoles?: boolean | User$userRolesArgs<ExtArgs>
    whitelistApps?: boolean | User$whitelistAppsArgs<ExtArgs>
    reviewedWhitelists?: boolean | User$reviewedWhitelistsArgs<ExtArgs>
    convoParts?: boolean | User$convoPartsArgs<ExtArgs>
    sentMessages?: boolean | User$sentMessagesArgs<ExtArgs>
    receivedMessages?: boolean | User$receivedMessagesArgs<ExtArgs>
    userBadges?: boolean | User$userBadgesArgs<ExtArgs>
    gameAccounts?: boolean | User$gameAccountsArgs<ExtArgs>
    mtaAccessLogs?: boolean | User$mtaAccessLogsArgs<ExtArgs>
    ticketRatingReqGiven?: boolean | User$ticketRatingReqGivenArgs<ExtArgs>
    ticketRatingReqReceived?: boolean | User$ticketRatingReqReceivedArgs<ExtArgs>
    passwordResetTokens?: boolean | User$passwordResetTokensArgs<ExtArgs>
    entitlements?: boolean | User$entitlementsArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    staffShifts?: boolean | User$staffShiftsArgs<ExtArgs>
    staffWeeklyRewards?: boolean | User$staffWeeklyRewardsArgs<ExtArgs>
    adminCasesTarget?: boolean | User$adminCasesTargetArgs<ExtArgs>
    adminCasesStaff?: boolean | User$adminCasesStaffArgs<ExtArgs>
    reputation?: boolean | User$reputationArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      topics: Prisma.$TopicPayload<ExtArgs>[]
      posts: Prisma.$PostPayload<ExtArgs>[]
      tickets: Prisma.$TicketPayload<ExtArgs>[]
      assignedTickets: Prisma.$TicketPayload<ExtArgs>[]
      ticketMsgs: Prisma.$TicketMessagePayload<ExtArgs>[]
      ticketParticipants: Prisma.$TicketParticipantPayload<ExtArgs>[]
      ticketParticipantsAdded: Prisma.$TicketParticipantPayload<ExtArgs>[]
      ticketRatingsGiven: Prisma.$TicketRatingPayload<ExtArgs>[]
      ticketRatingsReceived: Prisma.$TicketRatingPayload<ExtArgs>[]
      closedTickets: Prisma.$TicketPayload<ExtArgs>[]
      purchases: Prisma.$PurchasePayload<ExtArgs>[]
      auditLogs: Prisma.$AuditLogPayload<ExtArgs>[]
      userRoles: Prisma.$UserRolePayload<ExtArgs>[]
      whitelistApps: Prisma.$WhitelistApplicationPayload<ExtArgs>[]
      reviewedWhitelists: Prisma.$WhitelistApplicationPayload<ExtArgs>[]
      convoParts: Prisma.$ConversationParticipantPayload<ExtArgs>[]
      sentMessages: Prisma.$DirectMessagePayload<ExtArgs>[]
      receivedMessages: Prisma.$DirectMessagePayload<ExtArgs>[]
      userBadges: Prisma.$UserBadgePayload<ExtArgs>[]
      gameAccounts: Prisma.$GameAccountPayload<ExtArgs>[]
      mtaAccessLogs: Prisma.$MtaAccessLogPayload<ExtArgs>[]
      ticketRatingReqGiven: Prisma.$TicketRatingRequirementPayload<ExtArgs>[]
      ticketRatingReqReceived: Prisma.$TicketRatingRequirementPayload<ExtArgs>[]
      passwordResetTokens: Prisma.$PasswordResetTokenPayload<ExtArgs>[]
      entitlements: Prisma.$EntitlementPayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
      staffShifts: Prisma.$StaffShiftPayload<ExtArgs>[]
      staffWeeklyRewards: Prisma.$StaffWeeklyRewardPayload<ExtArgs>[]
      adminCasesTarget: Prisma.$AdminCasePayload<ExtArgs>[]
      adminCasesStaff: Prisma.$AdminCasePayload<ExtArgs>[]
      reputation: Prisma.$UserReputationPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      username: string
      passwordHash: string
      emailVerifiedAt: Date | null
      emailVerifyToken: string | null
      emailVerifyExpiresAt: Date | null
      phone: string | null
      recoveryEmail: string | null
      googleId: string | null
      discordId: string | null
      discordUsername: string | null
      avatarKey: string
      role: string
      isDeleted: boolean
      bannedUntil: Date | null
      whitelistStatus: string
      points: number
      lastSeenAt: Date
      createdAt: Date
      updatedAt: Date
      avatarUrl: string | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    topics<T extends User$topicsArgs<ExtArgs> = {}>(args?: Subset<T, User$topicsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "findMany"> | Null>
    posts<T extends User$postsArgs<ExtArgs> = {}>(args?: Subset<T, User$postsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findMany"> | Null>
    tickets<T extends User$ticketsArgs<ExtArgs> = {}>(args?: Subset<T, User$ticketsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findMany"> | Null>
    assignedTickets<T extends User$assignedTicketsArgs<ExtArgs> = {}>(args?: Subset<T, User$assignedTicketsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findMany"> | Null>
    ticketMsgs<T extends User$ticketMsgsArgs<ExtArgs> = {}>(args?: Subset<T, User$ticketMsgsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketMessagePayload<ExtArgs>, T, "findMany"> | Null>
    ticketParticipants<T extends User$ticketParticipantsArgs<ExtArgs> = {}>(args?: Subset<T, User$ticketParticipantsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketParticipantPayload<ExtArgs>, T, "findMany"> | Null>
    ticketParticipantsAdded<T extends User$ticketParticipantsAddedArgs<ExtArgs> = {}>(args?: Subset<T, User$ticketParticipantsAddedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketParticipantPayload<ExtArgs>, T, "findMany"> | Null>
    ticketRatingsGiven<T extends User$ticketRatingsGivenArgs<ExtArgs> = {}>(args?: Subset<T, User$ticketRatingsGivenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketRatingPayload<ExtArgs>, T, "findMany"> | Null>
    ticketRatingsReceived<T extends User$ticketRatingsReceivedArgs<ExtArgs> = {}>(args?: Subset<T, User$ticketRatingsReceivedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketRatingPayload<ExtArgs>, T, "findMany"> | Null>
    closedTickets<T extends User$closedTicketsArgs<ExtArgs> = {}>(args?: Subset<T, User$closedTicketsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findMany"> | Null>
    purchases<T extends User$purchasesArgs<ExtArgs> = {}>(args?: Subset<T, User$purchasesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "findMany"> | Null>
    auditLogs<T extends User$auditLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$auditLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany"> | Null>
    userRoles<T extends User$userRolesArgs<ExtArgs> = {}>(args?: Subset<T, User$userRolesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findMany"> | Null>
    whitelistApps<T extends User$whitelistAppsArgs<ExtArgs> = {}>(args?: Subset<T, User$whitelistAppsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WhitelistApplicationPayload<ExtArgs>, T, "findMany"> | Null>
    reviewedWhitelists<T extends User$reviewedWhitelistsArgs<ExtArgs> = {}>(args?: Subset<T, User$reviewedWhitelistsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WhitelistApplicationPayload<ExtArgs>, T, "findMany"> | Null>
    convoParts<T extends User$convoPartsArgs<ExtArgs> = {}>(args?: Subset<T, User$convoPartsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationParticipantPayload<ExtArgs>, T, "findMany"> | Null>
    sentMessages<T extends User$sentMessagesArgs<ExtArgs> = {}>(args?: Subset<T, User$sentMessagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DirectMessagePayload<ExtArgs>, T, "findMany"> | Null>
    receivedMessages<T extends User$receivedMessagesArgs<ExtArgs> = {}>(args?: Subset<T, User$receivedMessagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DirectMessagePayload<ExtArgs>, T, "findMany"> | Null>
    userBadges<T extends User$userBadgesArgs<ExtArgs> = {}>(args?: Subset<T, User$userBadgesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserBadgePayload<ExtArgs>, T, "findMany"> | Null>
    gameAccounts<T extends User$gameAccountsArgs<ExtArgs> = {}>(args?: Subset<T, User$gameAccountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GameAccountPayload<ExtArgs>, T, "findMany"> | Null>
    mtaAccessLogs<T extends User$mtaAccessLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$mtaAccessLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MtaAccessLogPayload<ExtArgs>, T, "findMany"> | Null>
    ticketRatingReqGiven<T extends User$ticketRatingReqGivenArgs<ExtArgs> = {}>(args?: Subset<T, User$ticketRatingReqGivenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketRatingRequirementPayload<ExtArgs>, T, "findMany"> | Null>
    ticketRatingReqReceived<T extends User$ticketRatingReqReceivedArgs<ExtArgs> = {}>(args?: Subset<T, User$ticketRatingReqReceivedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketRatingRequirementPayload<ExtArgs>, T, "findMany"> | Null>
    passwordResetTokens<T extends User$passwordResetTokensArgs<ExtArgs> = {}>(args?: Subset<T, User$passwordResetTokensArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findMany"> | Null>
    entitlements<T extends User$entitlementsArgs<ExtArgs> = {}>(args?: Subset<T, User$entitlementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EntitlementPayload<ExtArgs>, T, "findMany"> | Null>
    notifications<T extends User$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany"> | Null>
    staffShifts<T extends User$staffShiftsArgs<ExtArgs> = {}>(args?: Subset<T, User$staffShiftsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StaffShiftPayload<ExtArgs>, T, "findMany"> | Null>
    staffWeeklyRewards<T extends User$staffWeeklyRewardsArgs<ExtArgs> = {}>(args?: Subset<T, User$staffWeeklyRewardsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StaffWeeklyRewardPayload<ExtArgs>, T, "findMany"> | Null>
    adminCasesTarget<T extends User$adminCasesTargetArgs<ExtArgs> = {}>(args?: Subset<T, User$adminCasesTargetArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminCasePayload<ExtArgs>, T, "findMany"> | Null>
    adminCasesStaff<T extends User$adminCasesStaffArgs<ExtArgs> = {}>(args?: Subset<T, User$adminCasesStaffArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminCasePayload<ExtArgs>, T, "findMany"> | Null>
    reputation<T extends User$reputationArgs<ExtArgs> = {}>(args?: Subset<T, User$reputationArgs<ExtArgs>>): Prisma__UserReputationClient<$Result.GetResult<Prisma.$UserReputationPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly username: FieldRef<"User", 'String'>
    readonly passwordHash: FieldRef<"User", 'String'>
    readonly emailVerifiedAt: FieldRef<"User", 'DateTime'>
    readonly emailVerifyToken: FieldRef<"User", 'String'>
    readonly emailVerifyExpiresAt: FieldRef<"User", 'DateTime'>
    readonly phone: FieldRef<"User", 'String'>
    readonly recoveryEmail: FieldRef<"User", 'String'>
    readonly googleId: FieldRef<"User", 'String'>
    readonly discordId: FieldRef<"User", 'String'>
    readonly discordUsername: FieldRef<"User", 'String'>
    readonly avatarKey: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'String'>
    readonly isDeleted: FieldRef<"User", 'Boolean'>
    readonly bannedUntil: FieldRef<"User", 'DateTime'>
    readonly whitelistStatus: FieldRef<"User", 'String'>
    readonly points: FieldRef<"User", 'Int'>
    readonly lastSeenAt: FieldRef<"User", 'DateTime'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly avatarUrl: FieldRef<"User", 'String'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.topics
   */
  export type User$topicsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicInclude<ExtArgs> | null
    where?: TopicWhereInput
    orderBy?: TopicOrderByWithRelationInput | TopicOrderByWithRelationInput[]
    cursor?: TopicWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TopicScalarFieldEnum | TopicScalarFieldEnum[]
  }

  /**
   * User.posts
   */
  export type User$postsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    where?: PostWhereInput
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    cursor?: PostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }

  /**
   * User.tickets
   */
  export type User$ticketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    where?: TicketWhereInput
    orderBy?: TicketOrderByWithRelationInput | TicketOrderByWithRelationInput[]
    cursor?: TicketWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TicketScalarFieldEnum | TicketScalarFieldEnum[]
  }

  /**
   * User.assignedTickets
   */
  export type User$assignedTicketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    where?: TicketWhereInput
    orderBy?: TicketOrderByWithRelationInput | TicketOrderByWithRelationInput[]
    cursor?: TicketWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TicketScalarFieldEnum | TicketScalarFieldEnum[]
  }

  /**
   * User.ticketMsgs
   */
  export type User$ticketMsgsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketMessage
     */
    select?: TicketMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketMessageInclude<ExtArgs> | null
    where?: TicketMessageWhereInput
    orderBy?: TicketMessageOrderByWithRelationInput | TicketMessageOrderByWithRelationInput[]
    cursor?: TicketMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TicketMessageScalarFieldEnum | TicketMessageScalarFieldEnum[]
  }

  /**
   * User.ticketParticipants
   */
  export type User$ticketParticipantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketParticipant
     */
    select?: TicketParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketParticipantInclude<ExtArgs> | null
    where?: TicketParticipantWhereInput
    orderBy?: TicketParticipantOrderByWithRelationInput | TicketParticipantOrderByWithRelationInput[]
    cursor?: TicketParticipantWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TicketParticipantScalarFieldEnum | TicketParticipantScalarFieldEnum[]
  }

  /**
   * User.ticketParticipantsAdded
   */
  export type User$ticketParticipantsAddedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketParticipant
     */
    select?: TicketParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketParticipantInclude<ExtArgs> | null
    where?: TicketParticipantWhereInput
    orderBy?: TicketParticipantOrderByWithRelationInput | TicketParticipantOrderByWithRelationInput[]
    cursor?: TicketParticipantWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TicketParticipantScalarFieldEnum | TicketParticipantScalarFieldEnum[]
  }

  /**
   * User.ticketRatingsGiven
   */
  export type User$ticketRatingsGivenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketRating
     */
    select?: TicketRatingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketRatingInclude<ExtArgs> | null
    where?: TicketRatingWhereInput
    orderBy?: TicketRatingOrderByWithRelationInput | TicketRatingOrderByWithRelationInput[]
    cursor?: TicketRatingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TicketRatingScalarFieldEnum | TicketRatingScalarFieldEnum[]
  }

  /**
   * User.ticketRatingsReceived
   */
  export type User$ticketRatingsReceivedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketRating
     */
    select?: TicketRatingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketRatingInclude<ExtArgs> | null
    where?: TicketRatingWhereInput
    orderBy?: TicketRatingOrderByWithRelationInput | TicketRatingOrderByWithRelationInput[]
    cursor?: TicketRatingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TicketRatingScalarFieldEnum | TicketRatingScalarFieldEnum[]
  }

  /**
   * User.closedTickets
   */
  export type User$closedTicketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    where?: TicketWhereInput
    orderBy?: TicketOrderByWithRelationInput | TicketOrderByWithRelationInput[]
    cursor?: TicketWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TicketScalarFieldEnum | TicketScalarFieldEnum[]
  }

  /**
   * User.purchases
   */
  export type User$purchasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    where?: PurchaseWhereInput
    orderBy?: PurchaseOrderByWithRelationInput | PurchaseOrderByWithRelationInput[]
    cursor?: PurchaseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseScalarFieldEnum | PurchaseScalarFieldEnum[]
  }

  /**
   * User.auditLogs
   */
  export type User$auditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    cursor?: AuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * User.userRoles
   */
  export type User$userRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    where?: UserRoleWhereInput
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    cursor?: UserRoleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[]
  }

  /**
   * User.whitelistApps
   */
  export type User$whitelistAppsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhitelistApplication
     */
    select?: WhitelistApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhitelistApplicationInclude<ExtArgs> | null
    where?: WhitelistApplicationWhereInput
    orderBy?: WhitelistApplicationOrderByWithRelationInput | WhitelistApplicationOrderByWithRelationInput[]
    cursor?: WhitelistApplicationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WhitelistApplicationScalarFieldEnum | WhitelistApplicationScalarFieldEnum[]
  }

  /**
   * User.reviewedWhitelists
   */
  export type User$reviewedWhitelistsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhitelistApplication
     */
    select?: WhitelistApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhitelistApplicationInclude<ExtArgs> | null
    where?: WhitelistApplicationWhereInput
    orderBy?: WhitelistApplicationOrderByWithRelationInput | WhitelistApplicationOrderByWithRelationInput[]
    cursor?: WhitelistApplicationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WhitelistApplicationScalarFieldEnum | WhitelistApplicationScalarFieldEnum[]
  }

  /**
   * User.convoParts
   */
  export type User$convoPartsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationParticipant
     */
    select?: ConversationParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationParticipantInclude<ExtArgs> | null
    where?: ConversationParticipantWhereInput
    orderBy?: ConversationParticipantOrderByWithRelationInput | ConversationParticipantOrderByWithRelationInput[]
    cursor?: ConversationParticipantWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConversationParticipantScalarFieldEnum | ConversationParticipantScalarFieldEnum[]
  }

  /**
   * User.sentMessages
   */
  export type User$sentMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DirectMessage
     */
    select?: DirectMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DirectMessageInclude<ExtArgs> | null
    where?: DirectMessageWhereInput
    orderBy?: DirectMessageOrderByWithRelationInput | DirectMessageOrderByWithRelationInput[]
    cursor?: DirectMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DirectMessageScalarFieldEnum | DirectMessageScalarFieldEnum[]
  }

  /**
   * User.receivedMessages
   */
  export type User$receivedMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DirectMessage
     */
    select?: DirectMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DirectMessageInclude<ExtArgs> | null
    where?: DirectMessageWhereInput
    orderBy?: DirectMessageOrderByWithRelationInput | DirectMessageOrderByWithRelationInput[]
    cursor?: DirectMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DirectMessageScalarFieldEnum | DirectMessageScalarFieldEnum[]
  }

  /**
   * User.userBadges
   */
  export type User$userBadgesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBadge
     */
    select?: UserBadgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBadgeInclude<ExtArgs> | null
    where?: UserBadgeWhereInput
    orderBy?: UserBadgeOrderByWithRelationInput | UserBadgeOrderByWithRelationInput[]
    cursor?: UserBadgeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserBadgeScalarFieldEnum | UserBadgeScalarFieldEnum[]
  }

  /**
   * User.gameAccounts
   */
  export type User$gameAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameAccount
     */
    select?: GameAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameAccountInclude<ExtArgs> | null
    where?: GameAccountWhereInput
    orderBy?: GameAccountOrderByWithRelationInput | GameAccountOrderByWithRelationInput[]
    cursor?: GameAccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GameAccountScalarFieldEnum | GameAccountScalarFieldEnum[]
  }

  /**
   * User.mtaAccessLogs
   */
  export type User$mtaAccessLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MtaAccessLog
     */
    select?: MtaAccessLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MtaAccessLogInclude<ExtArgs> | null
    where?: MtaAccessLogWhereInput
    orderBy?: MtaAccessLogOrderByWithRelationInput | MtaAccessLogOrderByWithRelationInput[]
    cursor?: MtaAccessLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MtaAccessLogScalarFieldEnum | MtaAccessLogScalarFieldEnum[]
  }

  /**
   * User.ticketRatingReqGiven
   */
  export type User$ticketRatingReqGivenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketRatingRequirement
     */
    select?: TicketRatingRequirementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketRatingRequirementInclude<ExtArgs> | null
    where?: TicketRatingRequirementWhereInput
    orderBy?: TicketRatingRequirementOrderByWithRelationInput | TicketRatingRequirementOrderByWithRelationInput[]
    cursor?: TicketRatingRequirementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TicketRatingRequirementScalarFieldEnum | TicketRatingRequirementScalarFieldEnum[]
  }

  /**
   * User.ticketRatingReqReceived
   */
  export type User$ticketRatingReqReceivedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketRatingRequirement
     */
    select?: TicketRatingRequirementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketRatingRequirementInclude<ExtArgs> | null
    where?: TicketRatingRequirementWhereInput
    orderBy?: TicketRatingRequirementOrderByWithRelationInput | TicketRatingRequirementOrderByWithRelationInput[]
    cursor?: TicketRatingRequirementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TicketRatingRequirementScalarFieldEnum | TicketRatingRequirementScalarFieldEnum[]
  }

  /**
   * User.passwordResetTokens
   */
  export type User$passwordResetTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    where?: PasswordResetTokenWhereInput
    orderBy?: PasswordResetTokenOrderByWithRelationInput | PasswordResetTokenOrderByWithRelationInput[]
    cursor?: PasswordResetTokenWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PasswordResetTokenScalarFieldEnum | PasswordResetTokenScalarFieldEnum[]
  }

  /**
   * User.entitlements
   */
  export type User$entitlementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Entitlement
     */
    select?: EntitlementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntitlementInclude<ExtArgs> | null
    where?: EntitlementWhereInput
    orderBy?: EntitlementOrderByWithRelationInput | EntitlementOrderByWithRelationInput[]
    cursor?: EntitlementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EntitlementScalarFieldEnum | EntitlementScalarFieldEnum[]
  }

  /**
   * User.notifications
   */
  export type User$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * User.staffShifts
   */
  export type User$staffShiftsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffShift
     */
    select?: StaffShiftSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffShiftInclude<ExtArgs> | null
    where?: StaffShiftWhereInput
    orderBy?: StaffShiftOrderByWithRelationInput | StaffShiftOrderByWithRelationInput[]
    cursor?: StaffShiftWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StaffShiftScalarFieldEnum | StaffShiftScalarFieldEnum[]
  }

  /**
   * User.staffWeeklyRewards
   */
  export type User$staffWeeklyRewardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffWeeklyReward
     */
    select?: StaffWeeklyRewardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffWeeklyRewardInclude<ExtArgs> | null
    where?: StaffWeeklyRewardWhereInput
    orderBy?: StaffWeeklyRewardOrderByWithRelationInput | StaffWeeklyRewardOrderByWithRelationInput[]
    cursor?: StaffWeeklyRewardWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StaffWeeklyRewardScalarFieldEnum | StaffWeeklyRewardScalarFieldEnum[]
  }

  /**
   * User.adminCasesTarget
   */
  export type User$adminCasesTargetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminCase
     */
    select?: AdminCaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminCaseInclude<ExtArgs> | null
    where?: AdminCaseWhereInput
    orderBy?: AdminCaseOrderByWithRelationInput | AdminCaseOrderByWithRelationInput[]
    cursor?: AdminCaseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdminCaseScalarFieldEnum | AdminCaseScalarFieldEnum[]
  }

  /**
   * User.adminCasesStaff
   */
  export type User$adminCasesStaffArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminCase
     */
    select?: AdminCaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminCaseInclude<ExtArgs> | null
    where?: AdminCaseWhereInput
    orderBy?: AdminCaseOrderByWithRelationInput | AdminCaseOrderByWithRelationInput[]
    cursor?: AdminCaseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdminCaseScalarFieldEnum | AdminCaseScalarFieldEnum[]
  }

  /**
   * User.reputation
   */
  export type User$reputationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserReputation
     */
    select?: UserReputationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserReputationInclude<ExtArgs> | null
    where?: UserReputationWhereInput
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model ForumCategory
   */

  export type AggregateForumCategory = {
    _count: ForumCategoryCountAggregateOutputType | null
    _avg: ForumCategoryAvgAggregateOutputType | null
    _sum: ForumCategorySumAggregateOutputType | null
    _min: ForumCategoryMinAggregateOutputType | null
    _max: ForumCategoryMaxAggregateOutputType | null
  }

  export type ForumCategoryAvgAggregateOutputType = {
    order: number | null
  }

  export type ForumCategorySumAggregateOutputType = {
    order: number | null
  }

  export type ForumCategoryMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    order: number | null
    createdAt: Date | null
  }

  export type ForumCategoryMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    order: number | null
    createdAt: Date | null
  }

  export type ForumCategoryCountAggregateOutputType = {
    id: number
    name: number
    description: number
    order: number
    createdAt: number
    _all: number
  }


  export type ForumCategoryAvgAggregateInputType = {
    order?: true
  }

  export type ForumCategorySumAggregateInputType = {
    order?: true
  }

  export type ForumCategoryMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    order?: true
    createdAt?: true
  }

  export type ForumCategoryMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    order?: true
    createdAt?: true
  }

  export type ForumCategoryCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    order?: true
    createdAt?: true
    _all?: true
  }

  export type ForumCategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ForumCategory to aggregate.
     */
    where?: ForumCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ForumCategories to fetch.
     */
    orderBy?: ForumCategoryOrderByWithRelationInput | ForumCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ForumCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ForumCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ForumCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ForumCategories
    **/
    _count?: true | ForumCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ForumCategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ForumCategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ForumCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ForumCategoryMaxAggregateInputType
  }

  export type GetForumCategoryAggregateType<T extends ForumCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateForumCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateForumCategory[P]>
      : GetScalarType<T[P], AggregateForumCategory[P]>
  }




  export type ForumCategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ForumCategoryWhereInput
    orderBy?: ForumCategoryOrderByWithAggregationInput | ForumCategoryOrderByWithAggregationInput[]
    by: ForumCategoryScalarFieldEnum[] | ForumCategoryScalarFieldEnum
    having?: ForumCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ForumCategoryCountAggregateInputType | true
    _avg?: ForumCategoryAvgAggregateInputType
    _sum?: ForumCategorySumAggregateInputType
    _min?: ForumCategoryMinAggregateInputType
    _max?: ForumCategoryMaxAggregateInputType
  }

  export type ForumCategoryGroupByOutputType = {
    id: string
    name: string
    description: string | null
    order: number
    createdAt: Date
    _count: ForumCategoryCountAggregateOutputType | null
    _avg: ForumCategoryAvgAggregateOutputType | null
    _sum: ForumCategorySumAggregateOutputType | null
    _min: ForumCategoryMinAggregateOutputType | null
    _max: ForumCategoryMaxAggregateOutputType | null
  }

  type GetForumCategoryGroupByPayload<T extends ForumCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ForumCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ForumCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ForumCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], ForumCategoryGroupByOutputType[P]>
        }
      >
    >


  export type ForumCategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    order?: boolean
    createdAt?: boolean
    boards?: boolean | ForumCategory$boardsArgs<ExtArgs>
    _count?: boolean | ForumCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["forumCategory"]>

  export type ForumCategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    order?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["forumCategory"]>

  export type ForumCategorySelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    order?: boolean
    createdAt?: boolean
  }

  export type ForumCategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    boards?: boolean | ForumCategory$boardsArgs<ExtArgs>
    _count?: boolean | ForumCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ForumCategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ForumCategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ForumCategory"
    objects: {
      boards: Prisma.$ForumBoardPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      order: number
      createdAt: Date
    }, ExtArgs["result"]["forumCategory"]>
    composites: {}
  }

  type ForumCategoryGetPayload<S extends boolean | null | undefined | ForumCategoryDefaultArgs> = $Result.GetResult<Prisma.$ForumCategoryPayload, S>

  type ForumCategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ForumCategoryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ForumCategoryCountAggregateInputType | true
    }

  export interface ForumCategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ForumCategory'], meta: { name: 'ForumCategory' } }
    /**
     * Find zero or one ForumCategory that matches the filter.
     * @param {ForumCategoryFindUniqueArgs} args - Arguments to find a ForumCategory
     * @example
     * // Get one ForumCategory
     * const forumCategory = await prisma.forumCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ForumCategoryFindUniqueArgs>(args: SelectSubset<T, ForumCategoryFindUniqueArgs<ExtArgs>>): Prisma__ForumCategoryClient<$Result.GetResult<Prisma.$ForumCategoryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ForumCategory that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ForumCategoryFindUniqueOrThrowArgs} args - Arguments to find a ForumCategory
     * @example
     * // Get one ForumCategory
     * const forumCategory = await prisma.forumCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ForumCategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, ForumCategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ForumCategoryClient<$Result.GetResult<Prisma.$ForumCategoryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ForumCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForumCategoryFindFirstArgs} args - Arguments to find a ForumCategory
     * @example
     * // Get one ForumCategory
     * const forumCategory = await prisma.forumCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ForumCategoryFindFirstArgs>(args?: SelectSubset<T, ForumCategoryFindFirstArgs<ExtArgs>>): Prisma__ForumCategoryClient<$Result.GetResult<Prisma.$ForumCategoryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ForumCategory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForumCategoryFindFirstOrThrowArgs} args - Arguments to find a ForumCategory
     * @example
     * // Get one ForumCategory
     * const forumCategory = await prisma.forumCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ForumCategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, ForumCategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__ForumCategoryClient<$Result.GetResult<Prisma.$ForumCategoryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ForumCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForumCategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ForumCategories
     * const forumCategories = await prisma.forumCategory.findMany()
     * 
     * // Get first 10 ForumCategories
     * const forumCategories = await prisma.forumCategory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const forumCategoryWithIdOnly = await prisma.forumCategory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ForumCategoryFindManyArgs>(args?: SelectSubset<T, ForumCategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ForumCategoryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ForumCategory.
     * @param {ForumCategoryCreateArgs} args - Arguments to create a ForumCategory.
     * @example
     * // Create one ForumCategory
     * const ForumCategory = await prisma.forumCategory.create({
     *   data: {
     *     // ... data to create a ForumCategory
     *   }
     * })
     * 
     */
    create<T extends ForumCategoryCreateArgs>(args: SelectSubset<T, ForumCategoryCreateArgs<ExtArgs>>): Prisma__ForumCategoryClient<$Result.GetResult<Prisma.$ForumCategoryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ForumCategories.
     * @param {ForumCategoryCreateManyArgs} args - Arguments to create many ForumCategories.
     * @example
     * // Create many ForumCategories
     * const forumCategory = await prisma.forumCategory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ForumCategoryCreateManyArgs>(args?: SelectSubset<T, ForumCategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ForumCategories and returns the data saved in the database.
     * @param {ForumCategoryCreateManyAndReturnArgs} args - Arguments to create many ForumCategories.
     * @example
     * // Create many ForumCategories
     * const forumCategory = await prisma.forumCategory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ForumCategories and only return the `id`
     * const forumCategoryWithIdOnly = await prisma.forumCategory.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ForumCategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, ForumCategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ForumCategoryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ForumCategory.
     * @param {ForumCategoryDeleteArgs} args - Arguments to delete one ForumCategory.
     * @example
     * // Delete one ForumCategory
     * const ForumCategory = await prisma.forumCategory.delete({
     *   where: {
     *     // ... filter to delete one ForumCategory
     *   }
     * })
     * 
     */
    delete<T extends ForumCategoryDeleteArgs>(args: SelectSubset<T, ForumCategoryDeleteArgs<ExtArgs>>): Prisma__ForumCategoryClient<$Result.GetResult<Prisma.$ForumCategoryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ForumCategory.
     * @param {ForumCategoryUpdateArgs} args - Arguments to update one ForumCategory.
     * @example
     * // Update one ForumCategory
     * const forumCategory = await prisma.forumCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ForumCategoryUpdateArgs>(args: SelectSubset<T, ForumCategoryUpdateArgs<ExtArgs>>): Prisma__ForumCategoryClient<$Result.GetResult<Prisma.$ForumCategoryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ForumCategories.
     * @param {ForumCategoryDeleteManyArgs} args - Arguments to filter ForumCategories to delete.
     * @example
     * // Delete a few ForumCategories
     * const { count } = await prisma.forumCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ForumCategoryDeleteManyArgs>(args?: SelectSubset<T, ForumCategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ForumCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForumCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ForumCategories
     * const forumCategory = await prisma.forumCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ForumCategoryUpdateManyArgs>(args: SelectSubset<T, ForumCategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ForumCategory.
     * @param {ForumCategoryUpsertArgs} args - Arguments to update or create a ForumCategory.
     * @example
     * // Update or create a ForumCategory
     * const forumCategory = await prisma.forumCategory.upsert({
     *   create: {
     *     // ... data to create a ForumCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ForumCategory we want to update
     *   }
     * })
     */
    upsert<T extends ForumCategoryUpsertArgs>(args: SelectSubset<T, ForumCategoryUpsertArgs<ExtArgs>>): Prisma__ForumCategoryClient<$Result.GetResult<Prisma.$ForumCategoryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ForumCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForumCategoryCountArgs} args - Arguments to filter ForumCategories to count.
     * @example
     * // Count the number of ForumCategories
     * const count = await prisma.forumCategory.count({
     *   where: {
     *     // ... the filter for the ForumCategories we want to count
     *   }
     * })
    **/
    count<T extends ForumCategoryCountArgs>(
      args?: Subset<T, ForumCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ForumCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ForumCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForumCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ForumCategoryAggregateArgs>(args: Subset<T, ForumCategoryAggregateArgs>): Prisma.PrismaPromise<GetForumCategoryAggregateType<T>>

    /**
     * Group by ForumCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForumCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ForumCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ForumCategoryGroupByArgs['orderBy'] }
        : { orderBy?: ForumCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ForumCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetForumCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ForumCategory model
   */
  readonly fields: ForumCategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ForumCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ForumCategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    boards<T extends ForumCategory$boardsArgs<ExtArgs> = {}>(args?: Subset<T, ForumCategory$boardsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ForumBoardPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ForumCategory model
   */ 
  interface ForumCategoryFieldRefs {
    readonly id: FieldRef<"ForumCategory", 'String'>
    readonly name: FieldRef<"ForumCategory", 'String'>
    readonly description: FieldRef<"ForumCategory", 'String'>
    readonly order: FieldRef<"ForumCategory", 'Int'>
    readonly createdAt: FieldRef<"ForumCategory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ForumCategory findUnique
   */
  export type ForumCategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumCategory
     */
    select?: ForumCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ForumCategory to fetch.
     */
    where: ForumCategoryWhereUniqueInput
  }

  /**
   * ForumCategory findUniqueOrThrow
   */
  export type ForumCategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumCategory
     */
    select?: ForumCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ForumCategory to fetch.
     */
    where: ForumCategoryWhereUniqueInput
  }

  /**
   * ForumCategory findFirst
   */
  export type ForumCategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumCategory
     */
    select?: ForumCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ForumCategory to fetch.
     */
    where?: ForumCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ForumCategories to fetch.
     */
    orderBy?: ForumCategoryOrderByWithRelationInput | ForumCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ForumCategories.
     */
    cursor?: ForumCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ForumCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ForumCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ForumCategories.
     */
    distinct?: ForumCategoryScalarFieldEnum | ForumCategoryScalarFieldEnum[]
  }

  /**
   * ForumCategory findFirstOrThrow
   */
  export type ForumCategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumCategory
     */
    select?: ForumCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ForumCategory to fetch.
     */
    where?: ForumCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ForumCategories to fetch.
     */
    orderBy?: ForumCategoryOrderByWithRelationInput | ForumCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ForumCategories.
     */
    cursor?: ForumCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ForumCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ForumCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ForumCategories.
     */
    distinct?: ForumCategoryScalarFieldEnum | ForumCategoryScalarFieldEnum[]
  }

  /**
   * ForumCategory findMany
   */
  export type ForumCategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumCategory
     */
    select?: ForumCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ForumCategories to fetch.
     */
    where?: ForumCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ForumCategories to fetch.
     */
    orderBy?: ForumCategoryOrderByWithRelationInput | ForumCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ForumCategories.
     */
    cursor?: ForumCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ForumCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ForumCategories.
     */
    skip?: number
    distinct?: ForumCategoryScalarFieldEnum | ForumCategoryScalarFieldEnum[]
  }

  /**
   * ForumCategory create
   */
  export type ForumCategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumCategory
     */
    select?: ForumCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumCategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a ForumCategory.
     */
    data: XOR<ForumCategoryCreateInput, ForumCategoryUncheckedCreateInput>
  }

  /**
   * ForumCategory createMany
   */
  export type ForumCategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ForumCategories.
     */
    data: ForumCategoryCreateManyInput | ForumCategoryCreateManyInput[]
  }

  /**
   * ForumCategory createManyAndReturn
   */
  export type ForumCategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumCategory
     */
    select?: ForumCategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ForumCategories.
     */
    data: ForumCategoryCreateManyInput | ForumCategoryCreateManyInput[]
  }

  /**
   * ForumCategory update
   */
  export type ForumCategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumCategory
     */
    select?: ForumCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumCategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a ForumCategory.
     */
    data: XOR<ForumCategoryUpdateInput, ForumCategoryUncheckedUpdateInput>
    /**
     * Choose, which ForumCategory to update.
     */
    where: ForumCategoryWhereUniqueInput
  }

  /**
   * ForumCategory updateMany
   */
  export type ForumCategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ForumCategories.
     */
    data: XOR<ForumCategoryUpdateManyMutationInput, ForumCategoryUncheckedUpdateManyInput>
    /**
     * Filter which ForumCategories to update
     */
    where?: ForumCategoryWhereInput
  }

  /**
   * ForumCategory upsert
   */
  export type ForumCategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumCategory
     */
    select?: ForumCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumCategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the ForumCategory to update in case it exists.
     */
    where: ForumCategoryWhereUniqueInput
    /**
     * In case the ForumCategory found by the `where` argument doesn't exist, create a new ForumCategory with this data.
     */
    create: XOR<ForumCategoryCreateInput, ForumCategoryUncheckedCreateInput>
    /**
     * In case the ForumCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ForumCategoryUpdateInput, ForumCategoryUncheckedUpdateInput>
  }

  /**
   * ForumCategory delete
   */
  export type ForumCategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumCategory
     */
    select?: ForumCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumCategoryInclude<ExtArgs> | null
    /**
     * Filter which ForumCategory to delete.
     */
    where: ForumCategoryWhereUniqueInput
  }

  /**
   * ForumCategory deleteMany
   */
  export type ForumCategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ForumCategories to delete
     */
    where?: ForumCategoryWhereInput
  }

  /**
   * ForumCategory.boards
   */
  export type ForumCategory$boardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumBoard
     */
    select?: ForumBoardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumBoardInclude<ExtArgs> | null
    where?: ForumBoardWhereInput
    orderBy?: ForumBoardOrderByWithRelationInput | ForumBoardOrderByWithRelationInput[]
    cursor?: ForumBoardWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ForumBoardScalarFieldEnum | ForumBoardScalarFieldEnum[]
  }

  /**
   * ForumCategory without action
   */
  export type ForumCategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumCategory
     */
    select?: ForumCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumCategoryInclude<ExtArgs> | null
  }


  /**
   * Model ForumBoard
   */

  export type AggregateForumBoard = {
    _count: ForumBoardCountAggregateOutputType | null
    _avg: ForumBoardAvgAggregateOutputType | null
    _sum: ForumBoardSumAggregateOutputType | null
    _min: ForumBoardMinAggregateOutputType | null
    _max: ForumBoardMaxAggregateOutputType | null
  }

  export type ForumBoardAvgAggregateOutputType = {
    order: number | null
    pointsOnTopic: number | null
    pointsOnReply: number | null
  }

  export type ForumBoardSumAggregateOutputType = {
    order: number | null
    pointsOnTopic: number | null
    pointsOnReply: number | null
  }

  export type ForumBoardMinAggregateOutputType = {
    id: string | null
    categoryId: string | null
    name: string | null
    description: string | null
    order: number | null
    requireWhitelist: boolean | null
    pointsOnTopic: number | null
    pointsOnReply: number | null
    allowReplies: boolean | null
    createdAt: Date | null
  }

  export type ForumBoardMaxAggregateOutputType = {
    id: string | null
    categoryId: string | null
    name: string | null
    description: string | null
    order: number | null
    requireWhitelist: boolean | null
    pointsOnTopic: number | null
    pointsOnReply: number | null
    allowReplies: boolean | null
    createdAt: Date | null
  }

  export type ForumBoardCountAggregateOutputType = {
    id: number
    categoryId: number
    name: number
    description: number
    order: number
    requireWhitelist: number
    pointsOnTopic: number
    pointsOnReply: number
    allowReplies: number
    createdAt: number
    _all: number
  }


  export type ForumBoardAvgAggregateInputType = {
    order?: true
    pointsOnTopic?: true
    pointsOnReply?: true
  }

  export type ForumBoardSumAggregateInputType = {
    order?: true
    pointsOnTopic?: true
    pointsOnReply?: true
  }

  export type ForumBoardMinAggregateInputType = {
    id?: true
    categoryId?: true
    name?: true
    description?: true
    order?: true
    requireWhitelist?: true
    pointsOnTopic?: true
    pointsOnReply?: true
    allowReplies?: true
    createdAt?: true
  }

  export type ForumBoardMaxAggregateInputType = {
    id?: true
    categoryId?: true
    name?: true
    description?: true
    order?: true
    requireWhitelist?: true
    pointsOnTopic?: true
    pointsOnReply?: true
    allowReplies?: true
    createdAt?: true
  }

  export type ForumBoardCountAggregateInputType = {
    id?: true
    categoryId?: true
    name?: true
    description?: true
    order?: true
    requireWhitelist?: true
    pointsOnTopic?: true
    pointsOnReply?: true
    allowReplies?: true
    createdAt?: true
    _all?: true
  }

  export type ForumBoardAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ForumBoard to aggregate.
     */
    where?: ForumBoardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ForumBoards to fetch.
     */
    orderBy?: ForumBoardOrderByWithRelationInput | ForumBoardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ForumBoardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ForumBoards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ForumBoards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ForumBoards
    **/
    _count?: true | ForumBoardCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ForumBoardAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ForumBoardSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ForumBoardMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ForumBoardMaxAggregateInputType
  }

  export type GetForumBoardAggregateType<T extends ForumBoardAggregateArgs> = {
        [P in keyof T & keyof AggregateForumBoard]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateForumBoard[P]>
      : GetScalarType<T[P], AggregateForumBoard[P]>
  }




  export type ForumBoardGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ForumBoardWhereInput
    orderBy?: ForumBoardOrderByWithAggregationInput | ForumBoardOrderByWithAggregationInput[]
    by: ForumBoardScalarFieldEnum[] | ForumBoardScalarFieldEnum
    having?: ForumBoardScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ForumBoardCountAggregateInputType | true
    _avg?: ForumBoardAvgAggregateInputType
    _sum?: ForumBoardSumAggregateInputType
    _min?: ForumBoardMinAggregateInputType
    _max?: ForumBoardMaxAggregateInputType
  }

  export type ForumBoardGroupByOutputType = {
    id: string
    categoryId: string
    name: string
    description: string | null
    order: number
    requireWhitelist: boolean
    pointsOnTopic: number
    pointsOnReply: number
    allowReplies: boolean
    createdAt: Date
    _count: ForumBoardCountAggregateOutputType | null
    _avg: ForumBoardAvgAggregateOutputType | null
    _sum: ForumBoardSumAggregateOutputType | null
    _min: ForumBoardMinAggregateOutputType | null
    _max: ForumBoardMaxAggregateOutputType | null
  }

  type GetForumBoardGroupByPayload<T extends ForumBoardGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ForumBoardGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ForumBoardGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ForumBoardGroupByOutputType[P]>
            : GetScalarType<T[P], ForumBoardGroupByOutputType[P]>
        }
      >
    >


  export type ForumBoardSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    categoryId?: boolean
    name?: boolean
    description?: boolean
    order?: boolean
    requireWhitelist?: boolean
    pointsOnTopic?: boolean
    pointsOnReply?: boolean
    allowReplies?: boolean
    createdAt?: boolean
    category?: boolean | ForumCategoryDefaultArgs<ExtArgs>
    topics?: boolean | ForumBoard$topicsArgs<ExtArgs>
    _count?: boolean | ForumBoardCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["forumBoard"]>

  export type ForumBoardSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    categoryId?: boolean
    name?: boolean
    description?: boolean
    order?: boolean
    requireWhitelist?: boolean
    pointsOnTopic?: boolean
    pointsOnReply?: boolean
    allowReplies?: boolean
    createdAt?: boolean
    category?: boolean | ForumCategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["forumBoard"]>

  export type ForumBoardSelectScalar = {
    id?: boolean
    categoryId?: boolean
    name?: boolean
    description?: boolean
    order?: boolean
    requireWhitelist?: boolean
    pointsOnTopic?: boolean
    pointsOnReply?: boolean
    allowReplies?: boolean
    createdAt?: boolean
  }

  export type ForumBoardInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | ForumCategoryDefaultArgs<ExtArgs>
    topics?: boolean | ForumBoard$topicsArgs<ExtArgs>
    _count?: boolean | ForumBoardCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ForumBoardIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | ForumCategoryDefaultArgs<ExtArgs>
  }

  export type $ForumBoardPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ForumBoard"
    objects: {
      category: Prisma.$ForumCategoryPayload<ExtArgs>
      topics: Prisma.$TopicPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      categoryId: string
      name: string
      description: string | null
      order: number
      requireWhitelist: boolean
      pointsOnTopic: number
      pointsOnReply: number
      allowReplies: boolean
      createdAt: Date
    }, ExtArgs["result"]["forumBoard"]>
    composites: {}
  }

  type ForumBoardGetPayload<S extends boolean | null | undefined | ForumBoardDefaultArgs> = $Result.GetResult<Prisma.$ForumBoardPayload, S>

  type ForumBoardCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ForumBoardFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ForumBoardCountAggregateInputType | true
    }

  export interface ForumBoardDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ForumBoard'], meta: { name: 'ForumBoard' } }
    /**
     * Find zero or one ForumBoard that matches the filter.
     * @param {ForumBoardFindUniqueArgs} args - Arguments to find a ForumBoard
     * @example
     * // Get one ForumBoard
     * const forumBoard = await prisma.forumBoard.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ForumBoardFindUniqueArgs>(args: SelectSubset<T, ForumBoardFindUniqueArgs<ExtArgs>>): Prisma__ForumBoardClient<$Result.GetResult<Prisma.$ForumBoardPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ForumBoard that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ForumBoardFindUniqueOrThrowArgs} args - Arguments to find a ForumBoard
     * @example
     * // Get one ForumBoard
     * const forumBoard = await prisma.forumBoard.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ForumBoardFindUniqueOrThrowArgs>(args: SelectSubset<T, ForumBoardFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ForumBoardClient<$Result.GetResult<Prisma.$ForumBoardPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ForumBoard that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForumBoardFindFirstArgs} args - Arguments to find a ForumBoard
     * @example
     * // Get one ForumBoard
     * const forumBoard = await prisma.forumBoard.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ForumBoardFindFirstArgs>(args?: SelectSubset<T, ForumBoardFindFirstArgs<ExtArgs>>): Prisma__ForumBoardClient<$Result.GetResult<Prisma.$ForumBoardPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ForumBoard that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForumBoardFindFirstOrThrowArgs} args - Arguments to find a ForumBoard
     * @example
     * // Get one ForumBoard
     * const forumBoard = await prisma.forumBoard.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ForumBoardFindFirstOrThrowArgs>(args?: SelectSubset<T, ForumBoardFindFirstOrThrowArgs<ExtArgs>>): Prisma__ForumBoardClient<$Result.GetResult<Prisma.$ForumBoardPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ForumBoards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForumBoardFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ForumBoards
     * const forumBoards = await prisma.forumBoard.findMany()
     * 
     * // Get first 10 ForumBoards
     * const forumBoards = await prisma.forumBoard.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const forumBoardWithIdOnly = await prisma.forumBoard.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ForumBoardFindManyArgs>(args?: SelectSubset<T, ForumBoardFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ForumBoardPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ForumBoard.
     * @param {ForumBoardCreateArgs} args - Arguments to create a ForumBoard.
     * @example
     * // Create one ForumBoard
     * const ForumBoard = await prisma.forumBoard.create({
     *   data: {
     *     // ... data to create a ForumBoard
     *   }
     * })
     * 
     */
    create<T extends ForumBoardCreateArgs>(args: SelectSubset<T, ForumBoardCreateArgs<ExtArgs>>): Prisma__ForumBoardClient<$Result.GetResult<Prisma.$ForumBoardPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ForumBoards.
     * @param {ForumBoardCreateManyArgs} args - Arguments to create many ForumBoards.
     * @example
     * // Create many ForumBoards
     * const forumBoard = await prisma.forumBoard.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ForumBoardCreateManyArgs>(args?: SelectSubset<T, ForumBoardCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ForumBoards and returns the data saved in the database.
     * @param {ForumBoardCreateManyAndReturnArgs} args - Arguments to create many ForumBoards.
     * @example
     * // Create many ForumBoards
     * const forumBoard = await prisma.forumBoard.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ForumBoards and only return the `id`
     * const forumBoardWithIdOnly = await prisma.forumBoard.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ForumBoardCreateManyAndReturnArgs>(args?: SelectSubset<T, ForumBoardCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ForumBoardPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ForumBoard.
     * @param {ForumBoardDeleteArgs} args - Arguments to delete one ForumBoard.
     * @example
     * // Delete one ForumBoard
     * const ForumBoard = await prisma.forumBoard.delete({
     *   where: {
     *     // ... filter to delete one ForumBoard
     *   }
     * })
     * 
     */
    delete<T extends ForumBoardDeleteArgs>(args: SelectSubset<T, ForumBoardDeleteArgs<ExtArgs>>): Prisma__ForumBoardClient<$Result.GetResult<Prisma.$ForumBoardPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ForumBoard.
     * @param {ForumBoardUpdateArgs} args - Arguments to update one ForumBoard.
     * @example
     * // Update one ForumBoard
     * const forumBoard = await prisma.forumBoard.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ForumBoardUpdateArgs>(args: SelectSubset<T, ForumBoardUpdateArgs<ExtArgs>>): Prisma__ForumBoardClient<$Result.GetResult<Prisma.$ForumBoardPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ForumBoards.
     * @param {ForumBoardDeleteManyArgs} args - Arguments to filter ForumBoards to delete.
     * @example
     * // Delete a few ForumBoards
     * const { count } = await prisma.forumBoard.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ForumBoardDeleteManyArgs>(args?: SelectSubset<T, ForumBoardDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ForumBoards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForumBoardUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ForumBoards
     * const forumBoard = await prisma.forumBoard.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ForumBoardUpdateManyArgs>(args: SelectSubset<T, ForumBoardUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ForumBoard.
     * @param {ForumBoardUpsertArgs} args - Arguments to update or create a ForumBoard.
     * @example
     * // Update or create a ForumBoard
     * const forumBoard = await prisma.forumBoard.upsert({
     *   create: {
     *     // ... data to create a ForumBoard
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ForumBoard we want to update
     *   }
     * })
     */
    upsert<T extends ForumBoardUpsertArgs>(args: SelectSubset<T, ForumBoardUpsertArgs<ExtArgs>>): Prisma__ForumBoardClient<$Result.GetResult<Prisma.$ForumBoardPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ForumBoards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForumBoardCountArgs} args - Arguments to filter ForumBoards to count.
     * @example
     * // Count the number of ForumBoards
     * const count = await prisma.forumBoard.count({
     *   where: {
     *     // ... the filter for the ForumBoards we want to count
     *   }
     * })
    **/
    count<T extends ForumBoardCountArgs>(
      args?: Subset<T, ForumBoardCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ForumBoardCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ForumBoard.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForumBoardAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ForumBoardAggregateArgs>(args: Subset<T, ForumBoardAggregateArgs>): Prisma.PrismaPromise<GetForumBoardAggregateType<T>>

    /**
     * Group by ForumBoard.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForumBoardGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ForumBoardGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ForumBoardGroupByArgs['orderBy'] }
        : { orderBy?: ForumBoardGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ForumBoardGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetForumBoardGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ForumBoard model
   */
  readonly fields: ForumBoardFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ForumBoard.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ForumBoardClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    category<T extends ForumCategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ForumCategoryDefaultArgs<ExtArgs>>): Prisma__ForumCategoryClient<$Result.GetResult<Prisma.$ForumCategoryPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    topics<T extends ForumBoard$topicsArgs<ExtArgs> = {}>(args?: Subset<T, ForumBoard$topicsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ForumBoard model
   */ 
  interface ForumBoardFieldRefs {
    readonly id: FieldRef<"ForumBoard", 'String'>
    readonly categoryId: FieldRef<"ForumBoard", 'String'>
    readonly name: FieldRef<"ForumBoard", 'String'>
    readonly description: FieldRef<"ForumBoard", 'String'>
    readonly order: FieldRef<"ForumBoard", 'Int'>
    readonly requireWhitelist: FieldRef<"ForumBoard", 'Boolean'>
    readonly pointsOnTopic: FieldRef<"ForumBoard", 'Int'>
    readonly pointsOnReply: FieldRef<"ForumBoard", 'Int'>
    readonly allowReplies: FieldRef<"ForumBoard", 'Boolean'>
    readonly createdAt: FieldRef<"ForumBoard", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ForumBoard findUnique
   */
  export type ForumBoardFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumBoard
     */
    select?: ForumBoardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumBoardInclude<ExtArgs> | null
    /**
     * Filter, which ForumBoard to fetch.
     */
    where: ForumBoardWhereUniqueInput
  }

  /**
   * ForumBoard findUniqueOrThrow
   */
  export type ForumBoardFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumBoard
     */
    select?: ForumBoardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumBoardInclude<ExtArgs> | null
    /**
     * Filter, which ForumBoard to fetch.
     */
    where: ForumBoardWhereUniqueInput
  }

  /**
   * ForumBoard findFirst
   */
  export type ForumBoardFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumBoard
     */
    select?: ForumBoardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumBoardInclude<ExtArgs> | null
    /**
     * Filter, which ForumBoard to fetch.
     */
    where?: ForumBoardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ForumBoards to fetch.
     */
    orderBy?: ForumBoardOrderByWithRelationInput | ForumBoardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ForumBoards.
     */
    cursor?: ForumBoardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ForumBoards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ForumBoards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ForumBoards.
     */
    distinct?: ForumBoardScalarFieldEnum | ForumBoardScalarFieldEnum[]
  }

  /**
   * ForumBoard findFirstOrThrow
   */
  export type ForumBoardFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumBoard
     */
    select?: ForumBoardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumBoardInclude<ExtArgs> | null
    /**
     * Filter, which ForumBoard to fetch.
     */
    where?: ForumBoardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ForumBoards to fetch.
     */
    orderBy?: ForumBoardOrderByWithRelationInput | ForumBoardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ForumBoards.
     */
    cursor?: ForumBoardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ForumBoards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ForumBoards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ForumBoards.
     */
    distinct?: ForumBoardScalarFieldEnum | ForumBoardScalarFieldEnum[]
  }

  /**
   * ForumBoard findMany
   */
  export type ForumBoardFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumBoard
     */
    select?: ForumBoardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumBoardInclude<ExtArgs> | null
    /**
     * Filter, which ForumBoards to fetch.
     */
    where?: ForumBoardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ForumBoards to fetch.
     */
    orderBy?: ForumBoardOrderByWithRelationInput | ForumBoardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ForumBoards.
     */
    cursor?: ForumBoardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ForumBoards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ForumBoards.
     */
    skip?: number
    distinct?: ForumBoardScalarFieldEnum | ForumBoardScalarFieldEnum[]
  }

  /**
   * ForumBoard create
   */
  export type ForumBoardCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumBoard
     */
    select?: ForumBoardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumBoardInclude<ExtArgs> | null
    /**
     * The data needed to create a ForumBoard.
     */
    data: XOR<ForumBoardCreateInput, ForumBoardUncheckedCreateInput>
  }

  /**
   * ForumBoard createMany
   */
  export type ForumBoardCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ForumBoards.
     */
    data: ForumBoardCreateManyInput | ForumBoardCreateManyInput[]
  }

  /**
   * ForumBoard createManyAndReturn
   */
  export type ForumBoardCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumBoard
     */
    select?: ForumBoardSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ForumBoards.
     */
    data: ForumBoardCreateManyInput | ForumBoardCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumBoardIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ForumBoard update
   */
  export type ForumBoardUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumBoard
     */
    select?: ForumBoardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumBoardInclude<ExtArgs> | null
    /**
     * The data needed to update a ForumBoard.
     */
    data: XOR<ForumBoardUpdateInput, ForumBoardUncheckedUpdateInput>
    /**
     * Choose, which ForumBoard to update.
     */
    where: ForumBoardWhereUniqueInput
  }

  /**
   * ForumBoard updateMany
   */
  export type ForumBoardUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ForumBoards.
     */
    data: XOR<ForumBoardUpdateManyMutationInput, ForumBoardUncheckedUpdateManyInput>
    /**
     * Filter which ForumBoards to update
     */
    where?: ForumBoardWhereInput
  }

  /**
   * ForumBoard upsert
   */
  export type ForumBoardUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumBoard
     */
    select?: ForumBoardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumBoardInclude<ExtArgs> | null
    /**
     * The filter to search for the ForumBoard to update in case it exists.
     */
    where: ForumBoardWhereUniqueInput
    /**
     * In case the ForumBoard found by the `where` argument doesn't exist, create a new ForumBoard with this data.
     */
    create: XOR<ForumBoardCreateInput, ForumBoardUncheckedCreateInput>
    /**
     * In case the ForumBoard was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ForumBoardUpdateInput, ForumBoardUncheckedUpdateInput>
  }

  /**
   * ForumBoard delete
   */
  export type ForumBoardDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumBoard
     */
    select?: ForumBoardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumBoardInclude<ExtArgs> | null
    /**
     * Filter which ForumBoard to delete.
     */
    where: ForumBoardWhereUniqueInput
  }

  /**
   * ForumBoard deleteMany
   */
  export type ForumBoardDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ForumBoards to delete
     */
    where?: ForumBoardWhereInput
  }

  /**
   * ForumBoard.topics
   */
  export type ForumBoard$topicsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicInclude<ExtArgs> | null
    where?: TopicWhereInput
    orderBy?: TopicOrderByWithRelationInput | TopicOrderByWithRelationInput[]
    cursor?: TopicWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TopicScalarFieldEnum | TopicScalarFieldEnum[]
  }

  /**
   * ForumBoard without action
   */
  export type ForumBoardDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumBoard
     */
    select?: ForumBoardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumBoardInclude<ExtArgs> | null
  }


  /**
   * Model Topic
   */

  export type AggregateTopic = {
    _count: TopicCountAggregateOutputType | null
    _min: TopicMinAggregateOutputType | null
    _max: TopicMaxAggregateOutputType | null
  }

  export type TopicMinAggregateOutputType = {
    id: string | null
    boardId: string | null
    authorId: string | null
    title: string | null
    status: string | null
    pinned: boolean | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    lastPostAt: Date | null
  }

  export type TopicMaxAggregateOutputType = {
    id: string | null
    boardId: string | null
    authorId: string | null
    title: string | null
    status: string | null
    pinned: boolean | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    lastPostAt: Date | null
  }

  export type TopicCountAggregateOutputType = {
    id: number
    boardId: number
    authorId: number
    title: number
    status: number
    pinned: number
    isDeleted: number
    createdAt: number
    updatedAt: number
    lastPostAt: number
    _all: number
  }


  export type TopicMinAggregateInputType = {
    id?: true
    boardId?: true
    authorId?: true
    title?: true
    status?: true
    pinned?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    lastPostAt?: true
  }

  export type TopicMaxAggregateInputType = {
    id?: true
    boardId?: true
    authorId?: true
    title?: true
    status?: true
    pinned?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    lastPostAt?: true
  }

  export type TopicCountAggregateInputType = {
    id?: true
    boardId?: true
    authorId?: true
    title?: true
    status?: true
    pinned?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    lastPostAt?: true
    _all?: true
  }

  export type TopicAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Topic to aggregate.
     */
    where?: TopicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Topics to fetch.
     */
    orderBy?: TopicOrderByWithRelationInput | TopicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TopicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Topics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Topics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Topics
    **/
    _count?: true | TopicCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TopicMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TopicMaxAggregateInputType
  }

  export type GetTopicAggregateType<T extends TopicAggregateArgs> = {
        [P in keyof T & keyof AggregateTopic]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTopic[P]>
      : GetScalarType<T[P], AggregateTopic[P]>
  }




  export type TopicGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TopicWhereInput
    orderBy?: TopicOrderByWithAggregationInput | TopicOrderByWithAggregationInput[]
    by: TopicScalarFieldEnum[] | TopicScalarFieldEnum
    having?: TopicScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TopicCountAggregateInputType | true
    _min?: TopicMinAggregateInputType
    _max?: TopicMaxAggregateInputType
  }

  export type TopicGroupByOutputType = {
    id: string
    boardId: string
    authorId: string
    title: string
    status: string
    pinned: boolean
    isDeleted: boolean
    createdAt: Date
    updatedAt: Date
    lastPostAt: Date
    _count: TopicCountAggregateOutputType | null
    _min: TopicMinAggregateOutputType | null
    _max: TopicMaxAggregateOutputType | null
  }

  type GetTopicGroupByPayload<T extends TopicGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TopicGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TopicGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TopicGroupByOutputType[P]>
            : GetScalarType<T[P], TopicGroupByOutputType[P]>
        }
      >
    >


  export type TopicSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    boardId?: boolean
    authorId?: boolean
    title?: boolean
    status?: boolean
    pinned?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastPostAt?: boolean
    board?: boolean | ForumBoardDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
    posts?: boolean | Topic$postsArgs<ExtArgs>
    _count?: boolean | TopicCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["topic"]>

  export type TopicSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    boardId?: boolean
    authorId?: boolean
    title?: boolean
    status?: boolean
    pinned?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastPostAt?: boolean
    board?: boolean | ForumBoardDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["topic"]>

  export type TopicSelectScalar = {
    id?: boolean
    boardId?: boolean
    authorId?: boolean
    title?: boolean
    status?: boolean
    pinned?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastPostAt?: boolean
  }

  export type TopicInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    board?: boolean | ForumBoardDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
    posts?: boolean | Topic$postsArgs<ExtArgs>
    _count?: boolean | TopicCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TopicIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    board?: boolean | ForumBoardDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TopicPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Topic"
    objects: {
      board: Prisma.$ForumBoardPayload<ExtArgs>
      author: Prisma.$UserPayload<ExtArgs>
      posts: Prisma.$PostPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      boardId: string
      authorId: string
      title: string
      status: string
      pinned: boolean
      isDeleted: boolean
      createdAt: Date
      updatedAt: Date
      lastPostAt: Date
    }, ExtArgs["result"]["topic"]>
    composites: {}
  }

  type TopicGetPayload<S extends boolean | null | undefined | TopicDefaultArgs> = $Result.GetResult<Prisma.$TopicPayload, S>

  type TopicCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TopicFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TopicCountAggregateInputType | true
    }

  export interface TopicDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Topic'], meta: { name: 'Topic' } }
    /**
     * Find zero or one Topic that matches the filter.
     * @param {TopicFindUniqueArgs} args - Arguments to find a Topic
     * @example
     * // Get one Topic
     * const topic = await prisma.topic.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TopicFindUniqueArgs>(args: SelectSubset<T, TopicFindUniqueArgs<ExtArgs>>): Prisma__TopicClient<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Topic that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TopicFindUniqueOrThrowArgs} args - Arguments to find a Topic
     * @example
     * // Get one Topic
     * const topic = await prisma.topic.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TopicFindUniqueOrThrowArgs>(args: SelectSubset<T, TopicFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TopicClient<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Topic that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopicFindFirstArgs} args - Arguments to find a Topic
     * @example
     * // Get one Topic
     * const topic = await prisma.topic.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TopicFindFirstArgs>(args?: SelectSubset<T, TopicFindFirstArgs<ExtArgs>>): Prisma__TopicClient<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Topic that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopicFindFirstOrThrowArgs} args - Arguments to find a Topic
     * @example
     * // Get one Topic
     * const topic = await prisma.topic.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TopicFindFirstOrThrowArgs>(args?: SelectSubset<T, TopicFindFirstOrThrowArgs<ExtArgs>>): Prisma__TopicClient<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Topics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopicFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Topics
     * const topics = await prisma.topic.findMany()
     * 
     * // Get first 10 Topics
     * const topics = await prisma.topic.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const topicWithIdOnly = await prisma.topic.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TopicFindManyArgs>(args?: SelectSubset<T, TopicFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Topic.
     * @param {TopicCreateArgs} args - Arguments to create a Topic.
     * @example
     * // Create one Topic
     * const Topic = await prisma.topic.create({
     *   data: {
     *     // ... data to create a Topic
     *   }
     * })
     * 
     */
    create<T extends TopicCreateArgs>(args: SelectSubset<T, TopicCreateArgs<ExtArgs>>): Prisma__TopicClient<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Topics.
     * @param {TopicCreateManyArgs} args - Arguments to create many Topics.
     * @example
     * // Create many Topics
     * const topic = await prisma.topic.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TopicCreateManyArgs>(args?: SelectSubset<T, TopicCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Topics and returns the data saved in the database.
     * @param {TopicCreateManyAndReturnArgs} args - Arguments to create many Topics.
     * @example
     * // Create many Topics
     * const topic = await prisma.topic.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Topics and only return the `id`
     * const topicWithIdOnly = await prisma.topic.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TopicCreateManyAndReturnArgs>(args?: SelectSubset<T, TopicCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Topic.
     * @param {TopicDeleteArgs} args - Arguments to delete one Topic.
     * @example
     * // Delete one Topic
     * const Topic = await prisma.topic.delete({
     *   where: {
     *     // ... filter to delete one Topic
     *   }
     * })
     * 
     */
    delete<T extends TopicDeleteArgs>(args: SelectSubset<T, TopicDeleteArgs<ExtArgs>>): Prisma__TopicClient<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Topic.
     * @param {TopicUpdateArgs} args - Arguments to update one Topic.
     * @example
     * // Update one Topic
     * const topic = await prisma.topic.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TopicUpdateArgs>(args: SelectSubset<T, TopicUpdateArgs<ExtArgs>>): Prisma__TopicClient<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Topics.
     * @param {TopicDeleteManyArgs} args - Arguments to filter Topics to delete.
     * @example
     * // Delete a few Topics
     * const { count } = await prisma.topic.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TopicDeleteManyArgs>(args?: SelectSubset<T, TopicDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Topics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopicUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Topics
     * const topic = await prisma.topic.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TopicUpdateManyArgs>(args: SelectSubset<T, TopicUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Topic.
     * @param {TopicUpsertArgs} args - Arguments to update or create a Topic.
     * @example
     * // Update or create a Topic
     * const topic = await prisma.topic.upsert({
     *   create: {
     *     // ... data to create a Topic
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Topic we want to update
     *   }
     * })
     */
    upsert<T extends TopicUpsertArgs>(args: SelectSubset<T, TopicUpsertArgs<ExtArgs>>): Prisma__TopicClient<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Topics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopicCountArgs} args - Arguments to filter Topics to count.
     * @example
     * // Count the number of Topics
     * const count = await prisma.topic.count({
     *   where: {
     *     // ... the filter for the Topics we want to count
     *   }
     * })
    **/
    count<T extends TopicCountArgs>(
      args?: Subset<T, TopicCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TopicCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Topic.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopicAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TopicAggregateArgs>(args: Subset<T, TopicAggregateArgs>): Prisma.PrismaPromise<GetTopicAggregateType<T>>

    /**
     * Group by Topic.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopicGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TopicGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TopicGroupByArgs['orderBy'] }
        : { orderBy?: TopicGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TopicGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTopicGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Topic model
   */
  readonly fields: TopicFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Topic.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TopicClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    board<T extends ForumBoardDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ForumBoardDefaultArgs<ExtArgs>>): Prisma__ForumBoardClient<$Result.GetResult<Prisma.$ForumBoardPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    author<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    posts<T extends Topic$postsArgs<ExtArgs> = {}>(args?: Subset<T, Topic$postsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Topic model
   */ 
  interface TopicFieldRefs {
    readonly id: FieldRef<"Topic", 'String'>
    readonly boardId: FieldRef<"Topic", 'String'>
    readonly authorId: FieldRef<"Topic", 'String'>
    readonly title: FieldRef<"Topic", 'String'>
    readonly status: FieldRef<"Topic", 'String'>
    readonly pinned: FieldRef<"Topic", 'Boolean'>
    readonly isDeleted: FieldRef<"Topic", 'Boolean'>
    readonly createdAt: FieldRef<"Topic", 'DateTime'>
    readonly updatedAt: FieldRef<"Topic", 'DateTime'>
    readonly lastPostAt: FieldRef<"Topic", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Topic findUnique
   */
  export type TopicFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicInclude<ExtArgs> | null
    /**
     * Filter, which Topic to fetch.
     */
    where: TopicWhereUniqueInput
  }

  /**
   * Topic findUniqueOrThrow
   */
  export type TopicFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicInclude<ExtArgs> | null
    /**
     * Filter, which Topic to fetch.
     */
    where: TopicWhereUniqueInput
  }

  /**
   * Topic findFirst
   */
  export type TopicFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicInclude<ExtArgs> | null
    /**
     * Filter, which Topic to fetch.
     */
    where?: TopicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Topics to fetch.
     */
    orderBy?: TopicOrderByWithRelationInput | TopicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Topics.
     */
    cursor?: TopicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Topics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Topics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Topics.
     */
    distinct?: TopicScalarFieldEnum | TopicScalarFieldEnum[]
  }

  /**
   * Topic findFirstOrThrow
   */
  export type TopicFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicInclude<ExtArgs> | null
    /**
     * Filter, which Topic to fetch.
     */
    where?: TopicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Topics to fetch.
     */
    orderBy?: TopicOrderByWithRelationInput | TopicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Topics.
     */
    cursor?: TopicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Topics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Topics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Topics.
     */
    distinct?: TopicScalarFieldEnum | TopicScalarFieldEnum[]
  }

  /**
   * Topic findMany
   */
  export type TopicFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicInclude<ExtArgs> | null
    /**
     * Filter, which Topics to fetch.
     */
    where?: TopicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Topics to fetch.
     */
    orderBy?: TopicOrderByWithRelationInput | TopicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Topics.
     */
    cursor?: TopicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Topics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Topics.
     */
    skip?: number
    distinct?: TopicScalarFieldEnum | TopicScalarFieldEnum[]
  }

  /**
   * Topic create
   */
  export type TopicCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicInclude<ExtArgs> | null
    /**
     * The data needed to create a Topic.
     */
    data: XOR<TopicCreateInput, TopicUncheckedCreateInput>
  }

  /**
   * Topic createMany
   */
  export type TopicCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Topics.
     */
    data: TopicCreateManyInput | TopicCreateManyInput[]
  }

  /**
   * Topic createManyAndReturn
   */
  export type TopicCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Topics.
     */
    data: TopicCreateManyInput | TopicCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Topic update
   */
  export type TopicUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicInclude<ExtArgs> | null
    /**
     * The data needed to update a Topic.
     */
    data: XOR<TopicUpdateInput, TopicUncheckedUpdateInput>
    /**
     * Choose, which Topic to update.
     */
    where: TopicWhereUniqueInput
  }

  /**
   * Topic updateMany
   */
  export type TopicUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Topics.
     */
    data: XOR<TopicUpdateManyMutationInput, TopicUncheckedUpdateManyInput>
    /**
     * Filter which Topics to update
     */
    where?: TopicWhereInput
  }

  /**
   * Topic upsert
   */
  export type TopicUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicInclude<ExtArgs> | null
    /**
     * The filter to search for the Topic to update in case it exists.
     */
    where: TopicWhereUniqueInput
    /**
     * In case the Topic found by the `where` argument doesn't exist, create a new Topic with this data.
     */
    create: XOR<TopicCreateInput, TopicUncheckedCreateInput>
    /**
     * In case the Topic was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TopicUpdateInput, TopicUncheckedUpdateInput>
  }

  /**
   * Topic delete
   */
  export type TopicDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicInclude<ExtArgs> | null
    /**
     * Filter which Topic to delete.
     */
    where: TopicWhereUniqueInput
  }

  /**
   * Topic deleteMany
   */
  export type TopicDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Topics to delete
     */
    where?: TopicWhereInput
  }

  /**
   * Topic.posts
   */
  export type Topic$postsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    where?: PostWhereInput
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    cursor?: PostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }

  /**
   * Topic without action
   */
  export type TopicDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicInclude<ExtArgs> | null
  }


  /**
   * Model Post
   */

  export type AggregatePost = {
    _count: PostCountAggregateOutputType | null
    _min: PostMinAggregateOutputType | null
    _max: PostMaxAggregateOutputType | null
  }

  export type PostMinAggregateOutputType = {
    id: string | null
    topicId: string | null
    authorId: string | null
    content: string | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PostMaxAggregateOutputType = {
    id: string | null
    topicId: string | null
    authorId: string | null
    content: string | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PostCountAggregateOutputType = {
    id: number
    topicId: number
    authorId: number
    content: number
    isDeleted: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PostMinAggregateInputType = {
    id?: true
    topicId?: true
    authorId?: true
    content?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PostMaxAggregateInputType = {
    id?: true
    topicId?: true
    authorId?: true
    content?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PostCountAggregateInputType = {
    id?: true
    topicId?: true
    authorId?: true
    content?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PostAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Post to aggregate.
     */
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Posts
    **/
    _count?: true | PostCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PostMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PostMaxAggregateInputType
  }

  export type GetPostAggregateType<T extends PostAggregateArgs> = {
        [P in keyof T & keyof AggregatePost]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePost[P]>
      : GetScalarType<T[P], AggregatePost[P]>
  }




  export type PostGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostWhereInput
    orderBy?: PostOrderByWithAggregationInput | PostOrderByWithAggregationInput[]
    by: PostScalarFieldEnum[] | PostScalarFieldEnum
    having?: PostScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PostCountAggregateInputType | true
    _min?: PostMinAggregateInputType
    _max?: PostMaxAggregateInputType
  }

  export type PostGroupByOutputType = {
    id: string
    topicId: string
    authorId: string
    content: string
    isDeleted: boolean
    createdAt: Date
    updatedAt: Date
    _count: PostCountAggregateOutputType | null
    _min: PostMinAggregateOutputType | null
    _max: PostMaxAggregateOutputType | null
  }

  type GetPostGroupByPayload<T extends PostGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PostGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PostGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PostGroupByOutputType[P]>
            : GetScalarType<T[P], PostGroupByOutputType[P]>
        }
      >
    >


  export type PostSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    topicId?: boolean
    authorId?: boolean
    content?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    topic?: boolean | TopicDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
    attachments?: boolean | Post$attachmentsArgs<ExtArgs>
    _count?: boolean | PostCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["post"]>

  export type PostSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    topicId?: boolean
    authorId?: boolean
    content?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    topic?: boolean | TopicDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["post"]>

  export type PostSelectScalar = {
    id?: boolean
    topicId?: boolean
    authorId?: boolean
    content?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PostInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    topic?: boolean | TopicDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
    attachments?: boolean | Post$attachmentsArgs<ExtArgs>
    _count?: boolean | PostCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PostIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    topic?: boolean | TopicDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PostPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Post"
    objects: {
      topic: Prisma.$TopicPayload<ExtArgs>
      author: Prisma.$UserPayload<ExtArgs>
      attachments: Prisma.$PostAttachmentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      topicId: string
      authorId: string
      content: string
      isDeleted: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["post"]>
    composites: {}
  }

  type PostGetPayload<S extends boolean | null | undefined | PostDefaultArgs> = $Result.GetResult<Prisma.$PostPayload, S>

  type PostCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PostFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PostCountAggregateInputType | true
    }

  export interface PostDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Post'], meta: { name: 'Post' } }
    /**
     * Find zero or one Post that matches the filter.
     * @param {PostFindUniqueArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PostFindUniqueArgs>(args: SelectSubset<T, PostFindUniqueArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Post that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PostFindUniqueOrThrowArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PostFindUniqueOrThrowArgs>(args: SelectSubset<T, PostFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Post that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostFindFirstArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PostFindFirstArgs>(args?: SelectSubset<T, PostFindFirstArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Post that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostFindFirstOrThrowArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PostFindFirstOrThrowArgs>(args?: SelectSubset<T, PostFindFirstOrThrowArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Posts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Posts
     * const posts = await prisma.post.findMany()
     * 
     * // Get first 10 Posts
     * const posts = await prisma.post.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const postWithIdOnly = await prisma.post.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PostFindManyArgs>(args?: SelectSubset<T, PostFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Post.
     * @param {PostCreateArgs} args - Arguments to create a Post.
     * @example
     * // Create one Post
     * const Post = await prisma.post.create({
     *   data: {
     *     // ... data to create a Post
     *   }
     * })
     * 
     */
    create<T extends PostCreateArgs>(args: SelectSubset<T, PostCreateArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Posts.
     * @param {PostCreateManyArgs} args - Arguments to create many Posts.
     * @example
     * // Create many Posts
     * const post = await prisma.post.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PostCreateManyArgs>(args?: SelectSubset<T, PostCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Posts and returns the data saved in the database.
     * @param {PostCreateManyAndReturnArgs} args - Arguments to create many Posts.
     * @example
     * // Create many Posts
     * const post = await prisma.post.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Posts and only return the `id`
     * const postWithIdOnly = await prisma.post.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PostCreateManyAndReturnArgs>(args?: SelectSubset<T, PostCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Post.
     * @param {PostDeleteArgs} args - Arguments to delete one Post.
     * @example
     * // Delete one Post
     * const Post = await prisma.post.delete({
     *   where: {
     *     // ... filter to delete one Post
     *   }
     * })
     * 
     */
    delete<T extends PostDeleteArgs>(args: SelectSubset<T, PostDeleteArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Post.
     * @param {PostUpdateArgs} args - Arguments to update one Post.
     * @example
     * // Update one Post
     * const post = await prisma.post.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PostUpdateArgs>(args: SelectSubset<T, PostUpdateArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Posts.
     * @param {PostDeleteManyArgs} args - Arguments to filter Posts to delete.
     * @example
     * // Delete a few Posts
     * const { count } = await prisma.post.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PostDeleteManyArgs>(args?: SelectSubset<T, PostDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Posts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Posts
     * const post = await prisma.post.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PostUpdateManyArgs>(args: SelectSubset<T, PostUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Post.
     * @param {PostUpsertArgs} args - Arguments to update or create a Post.
     * @example
     * // Update or create a Post
     * const post = await prisma.post.upsert({
     *   create: {
     *     // ... data to create a Post
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Post we want to update
     *   }
     * })
     */
    upsert<T extends PostUpsertArgs>(args: SelectSubset<T, PostUpsertArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Posts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostCountArgs} args - Arguments to filter Posts to count.
     * @example
     * // Count the number of Posts
     * const count = await prisma.post.count({
     *   where: {
     *     // ... the filter for the Posts we want to count
     *   }
     * })
    **/
    count<T extends PostCountArgs>(
      args?: Subset<T, PostCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PostCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Post.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PostAggregateArgs>(args: Subset<T, PostAggregateArgs>): Prisma.PrismaPromise<GetPostAggregateType<T>>

    /**
     * Group by Post.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PostGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PostGroupByArgs['orderBy'] }
        : { orderBy?: PostGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PostGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPostGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Post model
   */
  readonly fields: PostFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Post.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PostClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    topic<T extends TopicDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TopicDefaultArgs<ExtArgs>>): Prisma__TopicClient<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    author<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    attachments<T extends Post$attachmentsArgs<ExtArgs> = {}>(args?: Subset<T, Post$attachmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostAttachmentPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Post model
   */ 
  interface PostFieldRefs {
    readonly id: FieldRef<"Post", 'String'>
    readonly topicId: FieldRef<"Post", 'String'>
    readonly authorId: FieldRef<"Post", 'String'>
    readonly content: FieldRef<"Post", 'String'>
    readonly isDeleted: FieldRef<"Post", 'Boolean'>
    readonly createdAt: FieldRef<"Post", 'DateTime'>
    readonly updatedAt: FieldRef<"Post", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Post findUnique
   */
  export type PostFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Post to fetch.
     */
    where: PostWhereUniqueInput
  }

  /**
   * Post findUniqueOrThrow
   */
  export type PostFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Post to fetch.
     */
    where: PostWhereUniqueInput
  }

  /**
   * Post findFirst
   */
  export type PostFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Post to fetch.
     */
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Posts.
     */
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Posts.
     */
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }

  /**
   * Post findFirstOrThrow
   */
  export type PostFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Post to fetch.
     */
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Posts.
     */
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Posts.
     */
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }

  /**
   * Post findMany
   */
  export type PostFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Posts to fetch.
     */
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Posts.
     */
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }

  /**
   * Post create
   */
  export type PostCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * The data needed to create a Post.
     */
    data: XOR<PostCreateInput, PostUncheckedCreateInput>
  }

  /**
   * Post createMany
   */
  export type PostCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Posts.
     */
    data: PostCreateManyInput | PostCreateManyInput[]
  }

  /**
   * Post createManyAndReturn
   */
  export type PostCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Posts.
     */
    data: PostCreateManyInput | PostCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Post update
   */
  export type PostUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * The data needed to update a Post.
     */
    data: XOR<PostUpdateInput, PostUncheckedUpdateInput>
    /**
     * Choose, which Post to update.
     */
    where: PostWhereUniqueInput
  }

  /**
   * Post updateMany
   */
  export type PostUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Posts.
     */
    data: XOR<PostUpdateManyMutationInput, PostUncheckedUpdateManyInput>
    /**
     * Filter which Posts to update
     */
    where?: PostWhereInput
  }

  /**
   * Post upsert
   */
  export type PostUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * The filter to search for the Post to update in case it exists.
     */
    where: PostWhereUniqueInput
    /**
     * In case the Post found by the `where` argument doesn't exist, create a new Post with this data.
     */
    create: XOR<PostCreateInput, PostUncheckedCreateInput>
    /**
     * In case the Post was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PostUpdateInput, PostUncheckedUpdateInput>
  }

  /**
   * Post delete
   */
  export type PostDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter which Post to delete.
     */
    where: PostWhereUniqueInput
  }

  /**
   * Post deleteMany
   */
  export type PostDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Posts to delete
     */
    where?: PostWhereInput
  }

  /**
   * Post.attachments
   */
  export type Post$attachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostAttachment
     */
    select?: PostAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostAttachmentInclude<ExtArgs> | null
    where?: PostAttachmentWhereInput
    orderBy?: PostAttachmentOrderByWithRelationInput | PostAttachmentOrderByWithRelationInput[]
    cursor?: PostAttachmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PostAttachmentScalarFieldEnum | PostAttachmentScalarFieldEnum[]
  }

  /**
   * Post without action
   */
  export type PostDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
  }


  /**
   * Model PostAttachment
   */

  export type AggregatePostAttachment = {
    _count: PostAttachmentCountAggregateOutputType | null
    _avg: PostAttachmentAvgAggregateOutputType | null
    _sum: PostAttachmentSumAggregateOutputType | null
    _min: PostAttachmentMinAggregateOutputType | null
    _max: PostAttachmentMaxAggregateOutputType | null
  }

  export type PostAttachmentAvgAggregateOutputType = {
    size: number | null
  }

  export type PostAttachmentSumAggregateOutputType = {
    size: number | null
  }

  export type PostAttachmentMinAggregateOutputType = {
    id: string | null
    postId: string | null
    url: string | null
    mime: string | null
    size: number | null
    createdAt: Date | null
  }

  export type PostAttachmentMaxAggregateOutputType = {
    id: string | null
    postId: string | null
    url: string | null
    mime: string | null
    size: number | null
    createdAt: Date | null
  }

  export type PostAttachmentCountAggregateOutputType = {
    id: number
    postId: number
    url: number
    mime: number
    size: number
    createdAt: number
    _all: number
  }


  export type PostAttachmentAvgAggregateInputType = {
    size?: true
  }

  export type PostAttachmentSumAggregateInputType = {
    size?: true
  }

  export type PostAttachmentMinAggregateInputType = {
    id?: true
    postId?: true
    url?: true
    mime?: true
    size?: true
    createdAt?: true
  }

  export type PostAttachmentMaxAggregateInputType = {
    id?: true
    postId?: true
    url?: true
    mime?: true
    size?: true
    createdAt?: true
  }

  export type PostAttachmentCountAggregateInputType = {
    id?: true
    postId?: true
    url?: true
    mime?: true
    size?: true
    createdAt?: true
    _all?: true
  }

  export type PostAttachmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PostAttachment to aggregate.
     */
    where?: PostAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostAttachments to fetch.
     */
    orderBy?: PostAttachmentOrderByWithRelationInput | PostAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PostAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostAttachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PostAttachments
    **/
    _count?: true | PostAttachmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PostAttachmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PostAttachmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PostAttachmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PostAttachmentMaxAggregateInputType
  }

  export type GetPostAttachmentAggregateType<T extends PostAttachmentAggregateArgs> = {
        [P in keyof T & keyof AggregatePostAttachment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePostAttachment[P]>
      : GetScalarType<T[P], AggregatePostAttachment[P]>
  }




  export type PostAttachmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostAttachmentWhereInput
    orderBy?: PostAttachmentOrderByWithAggregationInput | PostAttachmentOrderByWithAggregationInput[]
    by: PostAttachmentScalarFieldEnum[] | PostAttachmentScalarFieldEnum
    having?: PostAttachmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PostAttachmentCountAggregateInputType | true
    _avg?: PostAttachmentAvgAggregateInputType
    _sum?: PostAttachmentSumAggregateInputType
    _min?: PostAttachmentMinAggregateInputType
    _max?: PostAttachmentMaxAggregateInputType
  }

  export type PostAttachmentGroupByOutputType = {
    id: string
    postId: string
    url: string
    mime: string | null
    size: number | null
    createdAt: Date
    _count: PostAttachmentCountAggregateOutputType | null
    _avg: PostAttachmentAvgAggregateOutputType | null
    _sum: PostAttachmentSumAggregateOutputType | null
    _min: PostAttachmentMinAggregateOutputType | null
    _max: PostAttachmentMaxAggregateOutputType | null
  }

  type GetPostAttachmentGroupByPayload<T extends PostAttachmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PostAttachmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PostAttachmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PostAttachmentGroupByOutputType[P]>
            : GetScalarType<T[P], PostAttachmentGroupByOutputType[P]>
        }
      >
    >


  export type PostAttachmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    postId?: boolean
    url?: boolean
    mime?: boolean
    size?: boolean
    createdAt?: boolean
    post?: boolean | PostDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["postAttachment"]>

  export type PostAttachmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    postId?: boolean
    url?: boolean
    mime?: boolean
    size?: boolean
    createdAt?: boolean
    post?: boolean | PostDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["postAttachment"]>

  export type PostAttachmentSelectScalar = {
    id?: boolean
    postId?: boolean
    url?: boolean
    mime?: boolean
    size?: boolean
    createdAt?: boolean
  }

  export type PostAttachmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | PostDefaultArgs<ExtArgs>
  }
  export type PostAttachmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | PostDefaultArgs<ExtArgs>
  }

  export type $PostAttachmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PostAttachment"
    objects: {
      post: Prisma.$PostPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      postId: string
      url: string
      mime: string | null
      size: number | null
      createdAt: Date
    }, ExtArgs["result"]["postAttachment"]>
    composites: {}
  }

  type PostAttachmentGetPayload<S extends boolean | null | undefined | PostAttachmentDefaultArgs> = $Result.GetResult<Prisma.$PostAttachmentPayload, S>

  type PostAttachmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PostAttachmentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PostAttachmentCountAggregateInputType | true
    }

  export interface PostAttachmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PostAttachment'], meta: { name: 'PostAttachment' } }
    /**
     * Find zero or one PostAttachment that matches the filter.
     * @param {PostAttachmentFindUniqueArgs} args - Arguments to find a PostAttachment
     * @example
     * // Get one PostAttachment
     * const postAttachment = await prisma.postAttachment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PostAttachmentFindUniqueArgs>(args: SelectSubset<T, PostAttachmentFindUniqueArgs<ExtArgs>>): Prisma__PostAttachmentClient<$Result.GetResult<Prisma.$PostAttachmentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PostAttachment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PostAttachmentFindUniqueOrThrowArgs} args - Arguments to find a PostAttachment
     * @example
     * // Get one PostAttachment
     * const postAttachment = await prisma.postAttachment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PostAttachmentFindUniqueOrThrowArgs>(args: SelectSubset<T, PostAttachmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PostAttachmentClient<$Result.GetResult<Prisma.$PostAttachmentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PostAttachment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostAttachmentFindFirstArgs} args - Arguments to find a PostAttachment
     * @example
     * // Get one PostAttachment
     * const postAttachment = await prisma.postAttachment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PostAttachmentFindFirstArgs>(args?: SelectSubset<T, PostAttachmentFindFirstArgs<ExtArgs>>): Prisma__PostAttachmentClient<$Result.GetResult<Prisma.$PostAttachmentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PostAttachment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostAttachmentFindFirstOrThrowArgs} args - Arguments to find a PostAttachment
     * @example
     * // Get one PostAttachment
     * const postAttachment = await prisma.postAttachment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PostAttachmentFindFirstOrThrowArgs>(args?: SelectSubset<T, PostAttachmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__PostAttachmentClient<$Result.GetResult<Prisma.$PostAttachmentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PostAttachments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostAttachmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PostAttachments
     * const postAttachments = await prisma.postAttachment.findMany()
     * 
     * // Get first 10 PostAttachments
     * const postAttachments = await prisma.postAttachment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const postAttachmentWithIdOnly = await prisma.postAttachment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PostAttachmentFindManyArgs>(args?: SelectSubset<T, PostAttachmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostAttachmentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PostAttachment.
     * @param {PostAttachmentCreateArgs} args - Arguments to create a PostAttachment.
     * @example
     * // Create one PostAttachment
     * const PostAttachment = await prisma.postAttachment.create({
     *   data: {
     *     // ... data to create a PostAttachment
     *   }
     * })
     * 
     */
    create<T extends PostAttachmentCreateArgs>(args: SelectSubset<T, PostAttachmentCreateArgs<ExtArgs>>): Prisma__PostAttachmentClient<$Result.GetResult<Prisma.$PostAttachmentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PostAttachments.
     * @param {PostAttachmentCreateManyArgs} args - Arguments to create many PostAttachments.
     * @example
     * // Create many PostAttachments
     * const postAttachment = await prisma.postAttachment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PostAttachmentCreateManyArgs>(args?: SelectSubset<T, PostAttachmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PostAttachments and returns the data saved in the database.
     * @param {PostAttachmentCreateManyAndReturnArgs} args - Arguments to create many PostAttachments.
     * @example
     * // Create many PostAttachments
     * const postAttachment = await prisma.postAttachment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PostAttachments and only return the `id`
     * const postAttachmentWithIdOnly = await prisma.postAttachment.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PostAttachmentCreateManyAndReturnArgs>(args?: SelectSubset<T, PostAttachmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostAttachmentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PostAttachment.
     * @param {PostAttachmentDeleteArgs} args - Arguments to delete one PostAttachment.
     * @example
     * // Delete one PostAttachment
     * const PostAttachment = await prisma.postAttachment.delete({
     *   where: {
     *     // ... filter to delete one PostAttachment
     *   }
     * })
     * 
     */
    delete<T extends PostAttachmentDeleteArgs>(args: SelectSubset<T, PostAttachmentDeleteArgs<ExtArgs>>): Prisma__PostAttachmentClient<$Result.GetResult<Prisma.$PostAttachmentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PostAttachment.
     * @param {PostAttachmentUpdateArgs} args - Arguments to update one PostAttachment.
     * @example
     * // Update one PostAttachment
     * const postAttachment = await prisma.postAttachment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PostAttachmentUpdateArgs>(args: SelectSubset<T, PostAttachmentUpdateArgs<ExtArgs>>): Prisma__PostAttachmentClient<$Result.GetResult<Prisma.$PostAttachmentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PostAttachments.
     * @param {PostAttachmentDeleteManyArgs} args - Arguments to filter PostAttachments to delete.
     * @example
     * // Delete a few PostAttachments
     * const { count } = await prisma.postAttachment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PostAttachmentDeleteManyArgs>(args?: SelectSubset<T, PostAttachmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PostAttachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostAttachmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PostAttachments
     * const postAttachment = await prisma.postAttachment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PostAttachmentUpdateManyArgs>(args: SelectSubset<T, PostAttachmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PostAttachment.
     * @param {PostAttachmentUpsertArgs} args - Arguments to update or create a PostAttachment.
     * @example
     * // Update or create a PostAttachment
     * const postAttachment = await prisma.postAttachment.upsert({
     *   create: {
     *     // ... data to create a PostAttachment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PostAttachment we want to update
     *   }
     * })
     */
    upsert<T extends PostAttachmentUpsertArgs>(args: SelectSubset<T, PostAttachmentUpsertArgs<ExtArgs>>): Prisma__PostAttachmentClient<$Result.GetResult<Prisma.$PostAttachmentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PostAttachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostAttachmentCountArgs} args - Arguments to filter PostAttachments to count.
     * @example
     * // Count the number of PostAttachments
     * const count = await prisma.postAttachment.count({
     *   where: {
     *     // ... the filter for the PostAttachments we want to count
     *   }
     * })
    **/
    count<T extends PostAttachmentCountArgs>(
      args?: Subset<T, PostAttachmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PostAttachmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PostAttachment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostAttachmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PostAttachmentAggregateArgs>(args: Subset<T, PostAttachmentAggregateArgs>): Prisma.PrismaPromise<GetPostAttachmentAggregateType<T>>

    /**
     * Group by PostAttachment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostAttachmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PostAttachmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PostAttachmentGroupByArgs['orderBy'] }
        : { orderBy?: PostAttachmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PostAttachmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPostAttachmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PostAttachment model
   */
  readonly fields: PostAttachmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PostAttachment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PostAttachmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    post<T extends PostDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PostDefaultArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PostAttachment model
   */ 
  interface PostAttachmentFieldRefs {
    readonly id: FieldRef<"PostAttachment", 'String'>
    readonly postId: FieldRef<"PostAttachment", 'String'>
    readonly url: FieldRef<"PostAttachment", 'String'>
    readonly mime: FieldRef<"PostAttachment", 'String'>
    readonly size: FieldRef<"PostAttachment", 'Int'>
    readonly createdAt: FieldRef<"PostAttachment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PostAttachment findUnique
   */
  export type PostAttachmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostAttachment
     */
    select?: PostAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which PostAttachment to fetch.
     */
    where: PostAttachmentWhereUniqueInput
  }

  /**
   * PostAttachment findUniqueOrThrow
   */
  export type PostAttachmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostAttachment
     */
    select?: PostAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which PostAttachment to fetch.
     */
    where: PostAttachmentWhereUniqueInput
  }

  /**
   * PostAttachment findFirst
   */
  export type PostAttachmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostAttachment
     */
    select?: PostAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which PostAttachment to fetch.
     */
    where?: PostAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostAttachments to fetch.
     */
    orderBy?: PostAttachmentOrderByWithRelationInput | PostAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PostAttachments.
     */
    cursor?: PostAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostAttachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PostAttachments.
     */
    distinct?: PostAttachmentScalarFieldEnum | PostAttachmentScalarFieldEnum[]
  }

  /**
   * PostAttachment findFirstOrThrow
   */
  export type PostAttachmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostAttachment
     */
    select?: PostAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which PostAttachment to fetch.
     */
    where?: PostAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostAttachments to fetch.
     */
    orderBy?: PostAttachmentOrderByWithRelationInput | PostAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PostAttachments.
     */
    cursor?: PostAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostAttachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PostAttachments.
     */
    distinct?: PostAttachmentScalarFieldEnum | PostAttachmentScalarFieldEnum[]
  }

  /**
   * PostAttachment findMany
   */
  export type PostAttachmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostAttachment
     */
    select?: PostAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which PostAttachments to fetch.
     */
    where?: PostAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostAttachments to fetch.
     */
    orderBy?: PostAttachmentOrderByWithRelationInput | PostAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PostAttachments.
     */
    cursor?: PostAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostAttachments.
     */
    skip?: number
    distinct?: PostAttachmentScalarFieldEnum | PostAttachmentScalarFieldEnum[]
  }

  /**
   * PostAttachment create
   */
  export type PostAttachmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostAttachment
     */
    select?: PostAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostAttachmentInclude<ExtArgs> | null
    /**
     * The data needed to create a PostAttachment.
     */
    data: XOR<PostAttachmentCreateInput, PostAttachmentUncheckedCreateInput>
  }

  /**
   * PostAttachment createMany
   */
  export type PostAttachmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PostAttachments.
     */
    data: PostAttachmentCreateManyInput | PostAttachmentCreateManyInput[]
  }

  /**
   * PostAttachment createManyAndReturn
   */
  export type PostAttachmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostAttachment
     */
    select?: PostAttachmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PostAttachments.
     */
    data: PostAttachmentCreateManyInput | PostAttachmentCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostAttachmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PostAttachment update
   */
  export type PostAttachmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostAttachment
     */
    select?: PostAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostAttachmentInclude<ExtArgs> | null
    /**
     * The data needed to update a PostAttachment.
     */
    data: XOR<PostAttachmentUpdateInput, PostAttachmentUncheckedUpdateInput>
    /**
     * Choose, which PostAttachment to update.
     */
    where: PostAttachmentWhereUniqueInput
  }

  /**
   * PostAttachment updateMany
   */
  export type PostAttachmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PostAttachments.
     */
    data: XOR<PostAttachmentUpdateManyMutationInput, PostAttachmentUncheckedUpdateManyInput>
    /**
     * Filter which PostAttachments to update
     */
    where?: PostAttachmentWhereInput
  }

  /**
   * PostAttachment upsert
   */
  export type PostAttachmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostAttachment
     */
    select?: PostAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostAttachmentInclude<ExtArgs> | null
    /**
     * The filter to search for the PostAttachment to update in case it exists.
     */
    where: PostAttachmentWhereUniqueInput
    /**
     * In case the PostAttachment found by the `where` argument doesn't exist, create a new PostAttachment with this data.
     */
    create: XOR<PostAttachmentCreateInput, PostAttachmentUncheckedCreateInput>
    /**
     * In case the PostAttachment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PostAttachmentUpdateInput, PostAttachmentUncheckedUpdateInput>
  }

  /**
   * PostAttachment delete
   */
  export type PostAttachmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostAttachment
     */
    select?: PostAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostAttachmentInclude<ExtArgs> | null
    /**
     * Filter which PostAttachment to delete.
     */
    where: PostAttachmentWhereUniqueInput
  }

  /**
   * PostAttachment deleteMany
   */
  export type PostAttachmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PostAttachments to delete
     */
    where?: PostAttachmentWhereInput
  }

  /**
   * PostAttachment without action
   */
  export type PostAttachmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostAttachment
     */
    select?: PostAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostAttachmentInclude<ExtArgs> | null
  }


  /**
   * Model TicketCategory
   */

  export type AggregateTicketCategory = {
    _count: TicketCategoryCountAggregateOutputType | null
    _avg: TicketCategoryAvgAggregateOutputType | null
    _sum: TicketCategorySumAggregateOutputType | null
    _min: TicketCategoryMinAggregateOutputType | null
    _max: TicketCategoryMaxAggregateOutputType | null
  }

  export type TicketCategoryAvgAggregateOutputType = {
    order: number | null
  }

  export type TicketCategorySumAggregateOutputType = {
    order: number | null
  }

  export type TicketCategoryMinAggregateOutputType = {
    id: string | null
    slug: string | null
    name: string | null
    description: string | null
    order: number | null
    createdAt: Date | null
  }

  export type TicketCategoryMaxAggregateOutputType = {
    id: string | null
    slug: string | null
    name: string | null
    description: string | null
    order: number | null
    createdAt: Date | null
  }

  export type TicketCategoryCountAggregateOutputType = {
    id: number
    slug: number
    name: number
    description: number
    order: number
    createdAt: number
    _all: number
  }


  export type TicketCategoryAvgAggregateInputType = {
    order?: true
  }

  export type TicketCategorySumAggregateInputType = {
    order?: true
  }

  export type TicketCategoryMinAggregateInputType = {
    id?: true
    slug?: true
    name?: true
    description?: true
    order?: true
    createdAt?: true
  }

  export type TicketCategoryMaxAggregateInputType = {
    id?: true
    slug?: true
    name?: true
    description?: true
    order?: true
    createdAt?: true
  }

  export type TicketCategoryCountAggregateInputType = {
    id?: true
    slug?: true
    name?: true
    description?: true
    order?: true
    createdAt?: true
    _all?: true
  }

  export type TicketCategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TicketCategory to aggregate.
     */
    where?: TicketCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketCategories to fetch.
     */
    orderBy?: TicketCategoryOrderByWithRelationInput | TicketCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TicketCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TicketCategories
    **/
    _count?: true | TicketCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TicketCategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TicketCategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TicketCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TicketCategoryMaxAggregateInputType
  }

  export type GetTicketCategoryAggregateType<T extends TicketCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateTicketCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTicketCategory[P]>
      : GetScalarType<T[P], AggregateTicketCategory[P]>
  }




  export type TicketCategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketCategoryWhereInput
    orderBy?: TicketCategoryOrderByWithAggregationInput | TicketCategoryOrderByWithAggregationInput[]
    by: TicketCategoryScalarFieldEnum[] | TicketCategoryScalarFieldEnum
    having?: TicketCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TicketCategoryCountAggregateInputType | true
    _avg?: TicketCategoryAvgAggregateInputType
    _sum?: TicketCategorySumAggregateInputType
    _min?: TicketCategoryMinAggregateInputType
    _max?: TicketCategoryMaxAggregateInputType
  }

  export type TicketCategoryGroupByOutputType = {
    id: string
    slug: string
    name: string
    description: string | null
    order: number
    createdAt: Date
    _count: TicketCategoryCountAggregateOutputType | null
    _avg: TicketCategoryAvgAggregateOutputType | null
    _sum: TicketCategorySumAggregateOutputType | null
    _min: TicketCategoryMinAggregateOutputType | null
    _max: TicketCategoryMaxAggregateOutputType | null
  }

  type GetTicketCategoryGroupByPayload<T extends TicketCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TicketCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TicketCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TicketCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], TicketCategoryGroupByOutputType[P]>
        }
      >
    >


  export type TicketCategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    slug?: boolean
    name?: boolean
    description?: boolean
    order?: boolean
    createdAt?: boolean
    tickets?: boolean | TicketCategory$ticketsArgs<ExtArgs>
    _count?: boolean | TicketCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ticketCategory"]>

  export type TicketCategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    slug?: boolean
    name?: boolean
    description?: boolean
    order?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["ticketCategory"]>

  export type TicketCategorySelectScalar = {
    id?: boolean
    slug?: boolean
    name?: boolean
    description?: boolean
    order?: boolean
    createdAt?: boolean
  }

  export type TicketCategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tickets?: boolean | TicketCategory$ticketsArgs<ExtArgs>
    _count?: boolean | TicketCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TicketCategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $TicketCategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TicketCategory"
    objects: {
      tickets: Prisma.$TicketPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      slug: string
      name: string
      description: string | null
      order: number
      createdAt: Date
    }, ExtArgs["result"]["ticketCategory"]>
    composites: {}
  }

  type TicketCategoryGetPayload<S extends boolean | null | undefined | TicketCategoryDefaultArgs> = $Result.GetResult<Prisma.$TicketCategoryPayload, S>

  type TicketCategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TicketCategoryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TicketCategoryCountAggregateInputType | true
    }

  export interface TicketCategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TicketCategory'], meta: { name: 'TicketCategory' } }
    /**
     * Find zero or one TicketCategory that matches the filter.
     * @param {TicketCategoryFindUniqueArgs} args - Arguments to find a TicketCategory
     * @example
     * // Get one TicketCategory
     * const ticketCategory = await prisma.ticketCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TicketCategoryFindUniqueArgs>(args: SelectSubset<T, TicketCategoryFindUniqueArgs<ExtArgs>>): Prisma__TicketCategoryClient<$Result.GetResult<Prisma.$TicketCategoryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TicketCategory that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TicketCategoryFindUniqueOrThrowArgs} args - Arguments to find a TicketCategory
     * @example
     * // Get one TicketCategory
     * const ticketCategory = await prisma.ticketCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TicketCategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, TicketCategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TicketCategoryClient<$Result.GetResult<Prisma.$TicketCategoryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TicketCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketCategoryFindFirstArgs} args - Arguments to find a TicketCategory
     * @example
     * // Get one TicketCategory
     * const ticketCategory = await prisma.ticketCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TicketCategoryFindFirstArgs>(args?: SelectSubset<T, TicketCategoryFindFirstArgs<ExtArgs>>): Prisma__TicketCategoryClient<$Result.GetResult<Prisma.$TicketCategoryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TicketCategory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketCategoryFindFirstOrThrowArgs} args - Arguments to find a TicketCategory
     * @example
     * // Get one TicketCategory
     * const ticketCategory = await prisma.ticketCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TicketCategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, TicketCategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__TicketCategoryClient<$Result.GetResult<Prisma.$TicketCategoryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TicketCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketCategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TicketCategories
     * const ticketCategories = await prisma.ticketCategory.findMany()
     * 
     * // Get first 10 TicketCategories
     * const ticketCategories = await prisma.ticketCategory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ticketCategoryWithIdOnly = await prisma.ticketCategory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TicketCategoryFindManyArgs>(args?: SelectSubset<T, TicketCategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketCategoryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TicketCategory.
     * @param {TicketCategoryCreateArgs} args - Arguments to create a TicketCategory.
     * @example
     * // Create one TicketCategory
     * const TicketCategory = await prisma.ticketCategory.create({
     *   data: {
     *     // ... data to create a TicketCategory
     *   }
     * })
     * 
     */
    create<T extends TicketCategoryCreateArgs>(args: SelectSubset<T, TicketCategoryCreateArgs<ExtArgs>>): Prisma__TicketCategoryClient<$Result.GetResult<Prisma.$TicketCategoryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TicketCategories.
     * @param {TicketCategoryCreateManyArgs} args - Arguments to create many TicketCategories.
     * @example
     * // Create many TicketCategories
     * const ticketCategory = await prisma.ticketCategory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TicketCategoryCreateManyArgs>(args?: SelectSubset<T, TicketCategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TicketCategories and returns the data saved in the database.
     * @param {TicketCategoryCreateManyAndReturnArgs} args - Arguments to create many TicketCategories.
     * @example
     * // Create many TicketCategories
     * const ticketCategory = await prisma.ticketCategory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TicketCategories and only return the `id`
     * const ticketCategoryWithIdOnly = await prisma.ticketCategory.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TicketCategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, TicketCategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketCategoryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TicketCategory.
     * @param {TicketCategoryDeleteArgs} args - Arguments to delete one TicketCategory.
     * @example
     * // Delete one TicketCategory
     * const TicketCategory = await prisma.ticketCategory.delete({
     *   where: {
     *     // ... filter to delete one TicketCategory
     *   }
     * })
     * 
     */
    delete<T extends TicketCategoryDeleteArgs>(args: SelectSubset<T, TicketCategoryDeleteArgs<ExtArgs>>): Prisma__TicketCategoryClient<$Result.GetResult<Prisma.$TicketCategoryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TicketCategory.
     * @param {TicketCategoryUpdateArgs} args - Arguments to update one TicketCategory.
     * @example
     * // Update one TicketCategory
     * const ticketCategory = await prisma.ticketCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TicketCategoryUpdateArgs>(args: SelectSubset<T, TicketCategoryUpdateArgs<ExtArgs>>): Prisma__TicketCategoryClient<$Result.GetResult<Prisma.$TicketCategoryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TicketCategories.
     * @param {TicketCategoryDeleteManyArgs} args - Arguments to filter TicketCategories to delete.
     * @example
     * // Delete a few TicketCategories
     * const { count } = await prisma.ticketCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TicketCategoryDeleteManyArgs>(args?: SelectSubset<T, TicketCategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TicketCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TicketCategories
     * const ticketCategory = await prisma.ticketCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TicketCategoryUpdateManyArgs>(args: SelectSubset<T, TicketCategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TicketCategory.
     * @param {TicketCategoryUpsertArgs} args - Arguments to update or create a TicketCategory.
     * @example
     * // Update or create a TicketCategory
     * const ticketCategory = await prisma.ticketCategory.upsert({
     *   create: {
     *     // ... data to create a TicketCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TicketCategory we want to update
     *   }
     * })
     */
    upsert<T extends TicketCategoryUpsertArgs>(args: SelectSubset<T, TicketCategoryUpsertArgs<ExtArgs>>): Prisma__TicketCategoryClient<$Result.GetResult<Prisma.$TicketCategoryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TicketCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketCategoryCountArgs} args - Arguments to filter TicketCategories to count.
     * @example
     * // Count the number of TicketCategories
     * const count = await prisma.ticketCategory.count({
     *   where: {
     *     // ... the filter for the TicketCategories we want to count
     *   }
     * })
    **/
    count<T extends TicketCategoryCountArgs>(
      args?: Subset<T, TicketCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TicketCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TicketCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TicketCategoryAggregateArgs>(args: Subset<T, TicketCategoryAggregateArgs>): Prisma.PrismaPromise<GetTicketCategoryAggregateType<T>>

    /**
     * Group by TicketCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TicketCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TicketCategoryGroupByArgs['orderBy'] }
        : { orderBy?: TicketCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TicketCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTicketCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TicketCategory model
   */
  readonly fields: TicketCategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TicketCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TicketCategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tickets<T extends TicketCategory$ticketsArgs<ExtArgs> = {}>(args?: Subset<T, TicketCategory$ticketsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TicketCategory model
   */ 
  interface TicketCategoryFieldRefs {
    readonly id: FieldRef<"TicketCategory", 'String'>
    readonly slug: FieldRef<"TicketCategory", 'String'>
    readonly name: FieldRef<"TicketCategory", 'String'>
    readonly description: FieldRef<"TicketCategory", 'String'>
    readonly order: FieldRef<"TicketCategory", 'Int'>
    readonly createdAt: FieldRef<"TicketCategory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TicketCategory findUnique
   */
  export type TicketCategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketCategory
     */
    select?: TicketCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketCategoryInclude<ExtArgs> | null
    /**
     * Filter, which TicketCategory to fetch.
     */
    where: TicketCategoryWhereUniqueInput
  }

  /**
   * TicketCategory findUniqueOrThrow
   */
  export type TicketCategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketCategory
     */
    select?: TicketCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketCategoryInclude<ExtArgs> | null
    /**
     * Filter, which TicketCategory to fetch.
     */
    where: TicketCategoryWhereUniqueInput
  }

  /**
   * TicketCategory findFirst
   */
  export type TicketCategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketCategory
     */
    select?: TicketCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketCategoryInclude<ExtArgs> | null
    /**
     * Filter, which TicketCategory to fetch.
     */
    where?: TicketCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketCategories to fetch.
     */
    orderBy?: TicketCategoryOrderByWithRelationInput | TicketCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TicketCategories.
     */
    cursor?: TicketCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TicketCategories.
     */
    distinct?: TicketCategoryScalarFieldEnum | TicketCategoryScalarFieldEnum[]
  }

  /**
   * TicketCategory findFirstOrThrow
   */
  export type TicketCategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketCategory
     */
    select?: TicketCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketCategoryInclude<ExtArgs> | null
    /**
     * Filter, which TicketCategory to fetch.
     */
    where?: TicketCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketCategories to fetch.
     */
    orderBy?: TicketCategoryOrderByWithRelationInput | TicketCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TicketCategories.
     */
    cursor?: TicketCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TicketCategories.
     */
    distinct?: TicketCategoryScalarFieldEnum | TicketCategoryScalarFieldEnum[]
  }

  /**
   * TicketCategory findMany
   */
  export type TicketCategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketCategory
     */
    select?: TicketCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketCategoryInclude<ExtArgs> | null
    /**
     * Filter, which TicketCategories to fetch.
     */
    where?: TicketCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketCategories to fetch.
     */
    orderBy?: TicketCategoryOrderByWithRelationInput | TicketCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TicketCategories.
     */
    cursor?: TicketCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketCategories.
     */
    skip?: number
    distinct?: TicketCategoryScalarFieldEnum | TicketCategoryScalarFieldEnum[]
  }

  /**
   * TicketCategory create
   */
  export type TicketCategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketCategory
     */
    select?: TicketCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketCategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a TicketCategory.
     */
    data: XOR<TicketCategoryCreateInput, TicketCategoryUncheckedCreateInput>
  }

  /**
   * TicketCategory createMany
   */
  export type TicketCategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TicketCategories.
     */
    data: TicketCategoryCreateManyInput | TicketCategoryCreateManyInput[]
  }

  /**
   * TicketCategory createManyAndReturn
   */
  export type TicketCategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketCategory
     */
    select?: TicketCategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TicketCategories.
     */
    data: TicketCategoryCreateManyInput | TicketCategoryCreateManyInput[]
  }

  /**
   * TicketCategory update
   */
  export type TicketCategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketCategory
     */
    select?: TicketCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketCategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a TicketCategory.
     */
    data: XOR<TicketCategoryUpdateInput, TicketCategoryUncheckedUpdateInput>
    /**
     * Choose, which TicketCategory to update.
     */
    where: TicketCategoryWhereUniqueInput
  }

  /**
   * TicketCategory updateMany
   */
  export type TicketCategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TicketCategories.
     */
    data: XOR<TicketCategoryUpdateManyMutationInput, TicketCategoryUncheckedUpdateManyInput>
    /**
     * Filter which TicketCategories to update
     */
    where?: TicketCategoryWhereInput
  }

  /**
   * TicketCategory upsert
   */
  export type TicketCategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketCategory
     */
    select?: TicketCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketCategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the TicketCategory to update in case it exists.
     */
    where: TicketCategoryWhereUniqueInput
    /**
     * In case the TicketCategory found by the `where` argument doesn't exist, create a new TicketCategory with this data.
     */
    create: XOR<TicketCategoryCreateInput, TicketCategoryUncheckedCreateInput>
    /**
     * In case the TicketCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TicketCategoryUpdateInput, TicketCategoryUncheckedUpdateInput>
  }

  /**
   * TicketCategory delete
   */
  export type TicketCategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketCategory
     */
    select?: TicketCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketCategoryInclude<ExtArgs> | null
    /**
     * Filter which TicketCategory to delete.
     */
    where: TicketCategoryWhereUniqueInput
  }

  /**
   * TicketCategory deleteMany
   */
  export type TicketCategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TicketCategories to delete
     */
    where?: TicketCategoryWhereInput
  }

  /**
   * TicketCategory.tickets
   */
  export type TicketCategory$ticketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    where?: TicketWhereInput
    orderBy?: TicketOrderByWithRelationInput | TicketOrderByWithRelationInput[]
    cursor?: TicketWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TicketScalarFieldEnum | TicketScalarFieldEnum[]
  }

  /**
   * TicketCategory without action
   */
  export type TicketCategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketCategory
     */
    select?: TicketCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketCategoryInclude<ExtArgs> | null
  }


  /**
   * Model Ticket
   */

  export type AggregateTicket = {
    _count: TicketCountAggregateOutputType | null
    _min: TicketMinAggregateOutputType | null
    _max: TicketMaxAggregateOutputType | null
  }

  export type TicketMinAggregateOutputType = {
    id: string | null
    categoryId: string | null
    authorId: string | null
    title: string | null
    status: string | null
    priority: string | null
    assignedToId: string | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    closedAt: Date | null
    closedById: string | null
  }

  export type TicketMaxAggregateOutputType = {
    id: string | null
    categoryId: string | null
    authorId: string | null
    title: string | null
    status: string | null
    priority: string | null
    assignedToId: string | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    closedAt: Date | null
    closedById: string | null
  }

  export type TicketCountAggregateOutputType = {
    id: number
    categoryId: number
    authorId: number
    title: number
    status: number
    priority: number
    assignedToId: number
    isDeleted: number
    createdAt: number
    updatedAt: number
    closedAt: number
    closedById: number
    _all: number
  }


  export type TicketMinAggregateInputType = {
    id?: true
    categoryId?: true
    authorId?: true
    title?: true
    status?: true
    priority?: true
    assignedToId?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    closedAt?: true
    closedById?: true
  }

  export type TicketMaxAggregateInputType = {
    id?: true
    categoryId?: true
    authorId?: true
    title?: true
    status?: true
    priority?: true
    assignedToId?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    closedAt?: true
    closedById?: true
  }

  export type TicketCountAggregateInputType = {
    id?: true
    categoryId?: true
    authorId?: true
    title?: true
    status?: true
    priority?: true
    assignedToId?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    closedAt?: true
    closedById?: true
    _all?: true
  }

  export type TicketAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Ticket to aggregate.
     */
    where?: TicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tickets to fetch.
     */
    orderBy?: TicketOrderByWithRelationInput | TicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tickets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tickets
    **/
    _count?: true | TicketCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TicketMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TicketMaxAggregateInputType
  }

  export type GetTicketAggregateType<T extends TicketAggregateArgs> = {
        [P in keyof T & keyof AggregateTicket]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTicket[P]>
      : GetScalarType<T[P], AggregateTicket[P]>
  }




  export type TicketGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketWhereInput
    orderBy?: TicketOrderByWithAggregationInput | TicketOrderByWithAggregationInput[]
    by: TicketScalarFieldEnum[] | TicketScalarFieldEnum
    having?: TicketScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TicketCountAggregateInputType | true
    _min?: TicketMinAggregateInputType
    _max?: TicketMaxAggregateInputType
  }

  export type TicketGroupByOutputType = {
    id: string
    categoryId: string
    authorId: string
    title: string
    status: string
    priority: string
    assignedToId: string | null
    isDeleted: boolean
    createdAt: Date
    updatedAt: Date
    closedAt: Date | null
    closedById: string | null
    _count: TicketCountAggregateOutputType | null
    _min: TicketMinAggregateOutputType | null
    _max: TicketMaxAggregateOutputType | null
  }

  type GetTicketGroupByPayload<T extends TicketGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TicketGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TicketGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TicketGroupByOutputType[P]>
            : GetScalarType<T[P], TicketGroupByOutputType[P]>
        }
      >
    >


  export type TicketSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    categoryId?: boolean
    authorId?: boolean
    title?: boolean
    status?: boolean
    priority?: boolean
    assignedToId?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    closedAt?: boolean
    closedById?: boolean
    category?: boolean | TicketCategoryDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
    assignedTo?: boolean | Ticket$assignedToArgs<ExtArgs>
    closedBy?: boolean | Ticket$closedByArgs<ExtArgs>
    messages?: boolean | Ticket$messagesArgs<ExtArgs>
    participants?: boolean | Ticket$participantsArgs<ExtArgs>
    ratings?: boolean | Ticket$ratingsArgs<ExtArgs>
    ratingRequirements?: boolean | Ticket$ratingRequirementsArgs<ExtArgs>
    _count?: boolean | TicketCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ticket"]>

  export type TicketSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    categoryId?: boolean
    authorId?: boolean
    title?: boolean
    status?: boolean
    priority?: boolean
    assignedToId?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    closedAt?: boolean
    closedById?: boolean
    category?: boolean | TicketCategoryDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
    assignedTo?: boolean | Ticket$assignedToArgs<ExtArgs>
    closedBy?: boolean | Ticket$closedByArgs<ExtArgs>
  }, ExtArgs["result"]["ticket"]>

  export type TicketSelectScalar = {
    id?: boolean
    categoryId?: boolean
    authorId?: boolean
    title?: boolean
    status?: boolean
    priority?: boolean
    assignedToId?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    closedAt?: boolean
    closedById?: boolean
  }

  export type TicketInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | TicketCategoryDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
    assignedTo?: boolean | Ticket$assignedToArgs<ExtArgs>
    closedBy?: boolean | Ticket$closedByArgs<ExtArgs>
    messages?: boolean | Ticket$messagesArgs<ExtArgs>
    participants?: boolean | Ticket$participantsArgs<ExtArgs>
    ratings?: boolean | Ticket$ratingsArgs<ExtArgs>
    ratingRequirements?: boolean | Ticket$ratingRequirementsArgs<ExtArgs>
    _count?: boolean | TicketCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TicketIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | TicketCategoryDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
    assignedTo?: boolean | Ticket$assignedToArgs<ExtArgs>
    closedBy?: boolean | Ticket$closedByArgs<ExtArgs>
  }

  export type $TicketPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Ticket"
    objects: {
      category: Prisma.$TicketCategoryPayload<ExtArgs>
      author: Prisma.$UserPayload<ExtArgs>
      assignedTo: Prisma.$UserPayload<ExtArgs> | null
      closedBy: Prisma.$UserPayload<ExtArgs> | null
      messages: Prisma.$TicketMessagePayload<ExtArgs>[]
      participants: Prisma.$TicketParticipantPayload<ExtArgs>[]
      ratings: Prisma.$TicketRatingPayload<ExtArgs>[]
      ratingRequirements: Prisma.$TicketRatingRequirementPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      categoryId: string
      authorId: string
      title: string
      status: string
      priority: string
      assignedToId: string | null
      isDeleted: boolean
      createdAt: Date
      updatedAt: Date
      closedAt: Date | null
      closedById: string | null
    }, ExtArgs["result"]["ticket"]>
    composites: {}
  }

  type TicketGetPayload<S extends boolean | null | undefined | TicketDefaultArgs> = $Result.GetResult<Prisma.$TicketPayload, S>

  type TicketCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TicketFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TicketCountAggregateInputType | true
    }

  export interface TicketDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Ticket'], meta: { name: 'Ticket' } }
    /**
     * Find zero or one Ticket that matches the filter.
     * @param {TicketFindUniqueArgs} args - Arguments to find a Ticket
     * @example
     * // Get one Ticket
     * const ticket = await prisma.ticket.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TicketFindUniqueArgs>(args: SelectSubset<T, TicketFindUniqueArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Ticket that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TicketFindUniqueOrThrowArgs} args - Arguments to find a Ticket
     * @example
     * // Get one Ticket
     * const ticket = await prisma.ticket.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TicketFindUniqueOrThrowArgs>(args: SelectSubset<T, TicketFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Ticket that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketFindFirstArgs} args - Arguments to find a Ticket
     * @example
     * // Get one Ticket
     * const ticket = await prisma.ticket.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TicketFindFirstArgs>(args?: SelectSubset<T, TicketFindFirstArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Ticket that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketFindFirstOrThrowArgs} args - Arguments to find a Ticket
     * @example
     * // Get one Ticket
     * const ticket = await prisma.ticket.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TicketFindFirstOrThrowArgs>(args?: SelectSubset<T, TicketFindFirstOrThrowArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Tickets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tickets
     * const tickets = await prisma.ticket.findMany()
     * 
     * // Get first 10 Tickets
     * const tickets = await prisma.ticket.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ticketWithIdOnly = await prisma.ticket.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TicketFindManyArgs>(args?: SelectSubset<T, TicketFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Ticket.
     * @param {TicketCreateArgs} args - Arguments to create a Ticket.
     * @example
     * // Create one Ticket
     * const Ticket = await prisma.ticket.create({
     *   data: {
     *     // ... data to create a Ticket
     *   }
     * })
     * 
     */
    create<T extends TicketCreateArgs>(args: SelectSubset<T, TicketCreateArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Tickets.
     * @param {TicketCreateManyArgs} args - Arguments to create many Tickets.
     * @example
     * // Create many Tickets
     * const ticket = await prisma.ticket.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TicketCreateManyArgs>(args?: SelectSubset<T, TicketCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tickets and returns the data saved in the database.
     * @param {TicketCreateManyAndReturnArgs} args - Arguments to create many Tickets.
     * @example
     * // Create many Tickets
     * const ticket = await prisma.ticket.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tickets and only return the `id`
     * const ticketWithIdOnly = await prisma.ticket.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TicketCreateManyAndReturnArgs>(args?: SelectSubset<T, TicketCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Ticket.
     * @param {TicketDeleteArgs} args - Arguments to delete one Ticket.
     * @example
     * // Delete one Ticket
     * const Ticket = await prisma.ticket.delete({
     *   where: {
     *     // ... filter to delete one Ticket
     *   }
     * })
     * 
     */
    delete<T extends TicketDeleteArgs>(args: SelectSubset<T, TicketDeleteArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Ticket.
     * @param {TicketUpdateArgs} args - Arguments to update one Ticket.
     * @example
     * // Update one Ticket
     * const ticket = await prisma.ticket.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TicketUpdateArgs>(args: SelectSubset<T, TicketUpdateArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Tickets.
     * @param {TicketDeleteManyArgs} args - Arguments to filter Tickets to delete.
     * @example
     * // Delete a few Tickets
     * const { count } = await prisma.ticket.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TicketDeleteManyArgs>(args?: SelectSubset<T, TicketDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tickets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tickets
     * const ticket = await prisma.ticket.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TicketUpdateManyArgs>(args: SelectSubset<T, TicketUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Ticket.
     * @param {TicketUpsertArgs} args - Arguments to update or create a Ticket.
     * @example
     * // Update or create a Ticket
     * const ticket = await prisma.ticket.upsert({
     *   create: {
     *     // ... data to create a Ticket
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ticket we want to update
     *   }
     * })
     */
    upsert<T extends TicketUpsertArgs>(args: SelectSubset<T, TicketUpsertArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Tickets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketCountArgs} args - Arguments to filter Tickets to count.
     * @example
     * // Count the number of Tickets
     * const count = await prisma.ticket.count({
     *   where: {
     *     // ... the filter for the Tickets we want to count
     *   }
     * })
    **/
    count<T extends TicketCountArgs>(
      args?: Subset<T, TicketCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TicketCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ticket.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TicketAggregateArgs>(args: Subset<T, TicketAggregateArgs>): Prisma.PrismaPromise<GetTicketAggregateType<T>>

    /**
     * Group by Ticket.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TicketGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TicketGroupByArgs['orderBy'] }
        : { orderBy?: TicketGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TicketGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTicketGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Ticket model
   */
  readonly fields: TicketFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Ticket.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TicketClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    category<T extends TicketCategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TicketCategoryDefaultArgs<ExtArgs>>): Prisma__TicketCategoryClient<$Result.GetResult<Prisma.$TicketCategoryPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    author<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    assignedTo<T extends Ticket$assignedToArgs<ExtArgs> = {}>(args?: Subset<T, Ticket$assignedToArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    closedBy<T extends Ticket$closedByArgs<ExtArgs> = {}>(args?: Subset<T, Ticket$closedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    messages<T extends Ticket$messagesArgs<ExtArgs> = {}>(args?: Subset<T, Ticket$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketMessagePayload<ExtArgs>, T, "findMany"> | Null>
    participants<T extends Ticket$participantsArgs<ExtArgs> = {}>(args?: Subset<T, Ticket$participantsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketParticipantPayload<ExtArgs>, T, "findMany"> | Null>
    ratings<T extends Ticket$ratingsArgs<ExtArgs> = {}>(args?: Subset<T, Ticket$ratingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketRatingPayload<ExtArgs>, T, "findMany"> | Null>
    ratingRequirements<T extends Ticket$ratingRequirementsArgs<ExtArgs> = {}>(args?: Subset<T, Ticket$ratingRequirementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketRatingRequirementPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Ticket model
   */ 
  interface TicketFieldRefs {
    readonly id: FieldRef<"Ticket", 'String'>
    readonly categoryId: FieldRef<"Ticket", 'String'>
    readonly authorId: FieldRef<"Ticket", 'String'>
    readonly title: FieldRef<"Ticket", 'String'>
    readonly status: FieldRef<"Ticket", 'String'>
    readonly priority: FieldRef<"Ticket", 'String'>
    readonly assignedToId: FieldRef<"Ticket", 'String'>
    readonly isDeleted: FieldRef<"Ticket", 'Boolean'>
    readonly createdAt: FieldRef<"Ticket", 'DateTime'>
    readonly updatedAt: FieldRef<"Ticket", 'DateTime'>
    readonly closedAt: FieldRef<"Ticket", 'DateTime'>
    readonly closedById: FieldRef<"Ticket", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Ticket findUnique
   */
  export type TicketFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * Filter, which Ticket to fetch.
     */
    where: TicketWhereUniqueInput
  }

  /**
   * Ticket findUniqueOrThrow
   */
  export type TicketFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * Filter, which Ticket to fetch.
     */
    where: TicketWhereUniqueInput
  }

  /**
   * Ticket findFirst
   */
  export type TicketFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * Filter, which Ticket to fetch.
     */
    where?: TicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tickets to fetch.
     */
    orderBy?: TicketOrderByWithRelationInput | TicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tickets.
     */
    cursor?: TicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tickets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tickets.
     */
    distinct?: TicketScalarFieldEnum | TicketScalarFieldEnum[]
  }

  /**
   * Ticket findFirstOrThrow
   */
  export type TicketFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * Filter, which Ticket to fetch.
     */
    where?: TicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tickets to fetch.
     */
    orderBy?: TicketOrderByWithRelationInput | TicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tickets.
     */
    cursor?: TicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tickets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tickets.
     */
    distinct?: TicketScalarFieldEnum | TicketScalarFieldEnum[]
  }

  /**
   * Ticket findMany
   */
  export type TicketFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * Filter, which Tickets to fetch.
     */
    where?: TicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tickets to fetch.
     */
    orderBy?: TicketOrderByWithRelationInput | TicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tickets.
     */
    cursor?: TicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tickets.
     */
    skip?: number
    distinct?: TicketScalarFieldEnum | TicketScalarFieldEnum[]
  }

  /**
   * Ticket create
   */
  export type TicketCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * The data needed to create a Ticket.
     */
    data: XOR<TicketCreateInput, TicketUncheckedCreateInput>
  }

  /**
   * Ticket createMany
   */
  export type TicketCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tickets.
     */
    data: TicketCreateManyInput | TicketCreateManyInput[]
  }

  /**
   * Ticket createManyAndReturn
   */
  export type TicketCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Tickets.
     */
    data: TicketCreateManyInput | TicketCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Ticket update
   */
  export type TicketUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * The data needed to update a Ticket.
     */
    data: XOR<TicketUpdateInput, TicketUncheckedUpdateInput>
    /**
     * Choose, which Ticket to update.
     */
    where: TicketWhereUniqueInput
  }

  /**
   * Ticket updateMany
   */
  export type TicketUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tickets.
     */
    data: XOR<TicketUpdateManyMutationInput, TicketUncheckedUpdateManyInput>
    /**
     * Filter which Tickets to update
     */
    where?: TicketWhereInput
  }

  /**
   * Ticket upsert
   */
  export type TicketUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * The filter to search for the Ticket to update in case it exists.
     */
    where: TicketWhereUniqueInput
    /**
     * In case the Ticket found by the `where` argument doesn't exist, create a new Ticket with this data.
     */
    create: XOR<TicketCreateInput, TicketUncheckedCreateInput>
    /**
     * In case the Ticket was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TicketUpdateInput, TicketUncheckedUpdateInput>
  }

  /**
   * Ticket delete
   */
  export type TicketDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * Filter which Ticket to delete.
     */
    where: TicketWhereUniqueInput
  }

  /**
   * Ticket deleteMany
   */
  export type TicketDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tickets to delete
     */
    where?: TicketWhereInput
  }

  /**
   * Ticket.assignedTo
   */
  export type Ticket$assignedToArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Ticket.closedBy
   */
  export type Ticket$closedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Ticket.messages
   */
  export type Ticket$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketMessage
     */
    select?: TicketMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketMessageInclude<ExtArgs> | null
    where?: TicketMessageWhereInput
    orderBy?: TicketMessageOrderByWithRelationInput | TicketMessageOrderByWithRelationInput[]
    cursor?: TicketMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TicketMessageScalarFieldEnum | TicketMessageScalarFieldEnum[]
  }

  /**
   * Ticket.participants
   */
  export type Ticket$participantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketParticipant
     */
    select?: TicketParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketParticipantInclude<ExtArgs> | null
    where?: TicketParticipantWhereInput
    orderBy?: TicketParticipantOrderByWithRelationInput | TicketParticipantOrderByWithRelationInput[]
    cursor?: TicketParticipantWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TicketParticipantScalarFieldEnum | TicketParticipantScalarFieldEnum[]
  }

  /**
   * Ticket.ratings
   */
  export type Ticket$ratingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketRating
     */
    select?: TicketRatingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketRatingInclude<ExtArgs> | null
    where?: TicketRatingWhereInput
    orderBy?: TicketRatingOrderByWithRelationInput | TicketRatingOrderByWithRelationInput[]
    cursor?: TicketRatingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TicketRatingScalarFieldEnum | TicketRatingScalarFieldEnum[]
  }

  /**
   * Ticket.ratingRequirements
   */
  export type Ticket$ratingRequirementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketRatingRequirement
     */
    select?: TicketRatingRequirementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketRatingRequirementInclude<ExtArgs> | null
    where?: TicketRatingRequirementWhereInput
    orderBy?: TicketRatingRequirementOrderByWithRelationInput | TicketRatingRequirementOrderByWithRelationInput[]
    cursor?: TicketRatingRequirementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TicketRatingRequirementScalarFieldEnum | TicketRatingRequirementScalarFieldEnum[]
  }

  /**
   * Ticket without action
   */
  export type TicketDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
  }


  /**
   * Model TicketMessage
   */

  export type AggregateTicketMessage = {
    _count: TicketMessageCountAggregateOutputType | null
    _min: TicketMessageMinAggregateOutputType | null
    _max: TicketMessageMaxAggregateOutputType | null
  }

  export type TicketMessageMinAggregateOutputType = {
    id: string | null
    ticketId: string | null
    authorId: string | null
    content: string | null
    isDeleted: boolean | null
    createdAt: Date | null
  }

  export type TicketMessageMaxAggregateOutputType = {
    id: string | null
    ticketId: string | null
    authorId: string | null
    content: string | null
    isDeleted: boolean | null
    createdAt: Date | null
  }

  export type TicketMessageCountAggregateOutputType = {
    id: number
    ticketId: number
    authorId: number
    content: number
    isDeleted: number
    createdAt: number
    _all: number
  }


  export type TicketMessageMinAggregateInputType = {
    id?: true
    ticketId?: true
    authorId?: true
    content?: true
    isDeleted?: true
    createdAt?: true
  }

  export type TicketMessageMaxAggregateInputType = {
    id?: true
    ticketId?: true
    authorId?: true
    content?: true
    isDeleted?: true
    createdAt?: true
  }

  export type TicketMessageCountAggregateInputType = {
    id?: true
    ticketId?: true
    authorId?: true
    content?: true
    isDeleted?: true
    createdAt?: true
    _all?: true
  }

  export type TicketMessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TicketMessage to aggregate.
     */
    where?: TicketMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketMessages to fetch.
     */
    orderBy?: TicketMessageOrderByWithRelationInput | TicketMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TicketMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TicketMessages
    **/
    _count?: true | TicketMessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TicketMessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TicketMessageMaxAggregateInputType
  }

  export type GetTicketMessageAggregateType<T extends TicketMessageAggregateArgs> = {
        [P in keyof T & keyof AggregateTicketMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTicketMessage[P]>
      : GetScalarType<T[P], AggregateTicketMessage[P]>
  }




  export type TicketMessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketMessageWhereInput
    orderBy?: TicketMessageOrderByWithAggregationInput | TicketMessageOrderByWithAggregationInput[]
    by: TicketMessageScalarFieldEnum[] | TicketMessageScalarFieldEnum
    having?: TicketMessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TicketMessageCountAggregateInputType | true
    _min?: TicketMessageMinAggregateInputType
    _max?: TicketMessageMaxAggregateInputType
  }

  export type TicketMessageGroupByOutputType = {
    id: string
    ticketId: string
    authorId: string
    content: string
    isDeleted: boolean
    createdAt: Date
    _count: TicketMessageCountAggregateOutputType | null
    _min: TicketMessageMinAggregateOutputType | null
    _max: TicketMessageMaxAggregateOutputType | null
  }

  type GetTicketMessageGroupByPayload<T extends TicketMessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TicketMessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TicketMessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TicketMessageGroupByOutputType[P]>
            : GetScalarType<T[P], TicketMessageGroupByOutputType[P]>
        }
      >
    >


  export type TicketMessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ticketId?: boolean
    authorId?: boolean
    content?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    ticket?: boolean | TicketDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ticketMessage"]>

  export type TicketMessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ticketId?: boolean
    authorId?: boolean
    content?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    ticket?: boolean | TicketDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ticketMessage"]>

  export type TicketMessageSelectScalar = {
    id?: boolean
    ticketId?: boolean
    authorId?: boolean
    content?: boolean
    isDeleted?: boolean
    createdAt?: boolean
  }

  export type TicketMessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ticket?: boolean | TicketDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TicketMessageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ticket?: boolean | TicketDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TicketMessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TicketMessage"
    objects: {
      ticket: Prisma.$TicketPayload<ExtArgs>
      author: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      ticketId: string
      authorId: string
      content: string
      isDeleted: boolean
      createdAt: Date
    }, ExtArgs["result"]["ticketMessage"]>
    composites: {}
  }

  type TicketMessageGetPayload<S extends boolean | null | undefined | TicketMessageDefaultArgs> = $Result.GetResult<Prisma.$TicketMessagePayload, S>

  type TicketMessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TicketMessageFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TicketMessageCountAggregateInputType | true
    }

  export interface TicketMessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TicketMessage'], meta: { name: 'TicketMessage' } }
    /**
     * Find zero or one TicketMessage that matches the filter.
     * @param {TicketMessageFindUniqueArgs} args - Arguments to find a TicketMessage
     * @example
     * // Get one TicketMessage
     * const ticketMessage = await prisma.ticketMessage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TicketMessageFindUniqueArgs>(args: SelectSubset<T, TicketMessageFindUniqueArgs<ExtArgs>>): Prisma__TicketMessageClient<$Result.GetResult<Prisma.$TicketMessagePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TicketMessage that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TicketMessageFindUniqueOrThrowArgs} args - Arguments to find a TicketMessage
     * @example
     * // Get one TicketMessage
     * const ticketMessage = await prisma.ticketMessage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TicketMessageFindUniqueOrThrowArgs>(args: SelectSubset<T, TicketMessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TicketMessageClient<$Result.GetResult<Prisma.$TicketMessagePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TicketMessage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketMessageFindFirstArgs} args - Arguments to find a TicketMessage
     * @example
     * // Get one TicketMessage
     * const ticketMessage = await prisma.ticketMessage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TicketMessageFindFirstArgs>(args?: SelectSubset<T, TicketMessageFindFirstArgs<ExtArgs>>): Prisma__TicketMessageClient<$Result.GetResult<Prisma.$TicketMessagePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TicketMessage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketMessageFindFirstOrThrowArgs} args - Arguments to find a TicketMessage
     * @example
     * // Get one TicketMessage
     * const ticketMessage = await prisma.ticketMessage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TicketMessageFindFirstOrThrowArgs>(args?: SelectSubset<T, TicketMessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__TicketMessageClient<$Result.GetResult<Prisma.$TicketMessagePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TicketMessages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketMessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TicketMessages
     * const ticketMessages = await prisma.ticketMessage.findMany()
     * 
     * // Get first 10 TicketMessages
     * const ticketMessages = await prisma.ticketMessage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ticketMessageWithIdOnly = await prisma.ticketMessage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TicketMessageFindManyArgs>(args?: SelectSubset<T, TicketMessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketMessagePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TicketMessage.
     * @param {TicketMessageCreateArgs} args - Arguments to create a TicketMessage.
     * @example
     * // Create one TicketMessage
     * const TicketMessage = await prisma.ticketMessage.create({
     *   data: {
     *     // ... data to create a TicketMessage
     *   }
     * })
     * 
     */
    create<T extends TicketMessageCreateArgs>(args: SelectSubset<T, TicketMessageCreateArgs<ExtArgs>>): Prisma__TicketMessageClient<$Result.GetResult<Prisma.$TicketMessagePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TicketMessages.
     * @param {TicketMessageCreateManyArgs} args - Arguments to create many TicketMessages.
     * @example
     * // Create many TicketMessages
     * const ticketMessage = await prisma.ticketMessage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TicketMessageCreateManyArgs>(args?: SelectSubset<T, TicketMessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TicketMessages and returns the data saved in the database.
     * @param {TicketMessageCreateManyAndReturnArgs} args - Arguments to create many TicketMessages.
     * @example
     * // Create many TicketMessages
     * const ticketMessage = await prisma.ticketMessage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TicketMessages and only return the `id`
     * const ticketMessageWithIdOnly = await prisma.ticketMessage.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TicketMessageCreateManyAndReturnArgs>(args?: SelectSubset<T, TicketMessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketMessagePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TicketMessage.
     * @param {TicketMessageDeleteArgs} args - Arguments to delete one TicketMessage.
     * @example
     * // Delete one TicketMessage
     * const TicketMessage = await prisma.ticketMessage.delete({
     *   where: {
     *     // ... filter to delete one TicketMessage
     *   }
     * })
     * 
     */
    delete<T extends TicketMessageDeleteArgs>(args: SelectSubset<T, TicketMessageDeleteArgs<ExtArgs>>): Prisma__TicketMessageClient<$Result.GetResult<Prisma.$TicketMessagePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TicketMessage.
     * @param {TicketMessageUpdateArgs} args - Arguments to update one TicketMessage.
     * @example
     * // Update one TicketMessage
     * const ticketMessage = await prisma.ticketMessage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TicketMessageUpdateArgs>(args: SelectSubset<T, TicketMessageUpdateArgs<ExtArgs>>): Prisma__TicketMessageClient<$Result.GetResult<Prisma.$TicketMessagePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TicketMessages.
     * @param {TicketMessageDeleteManyArgs} args - Arguments to filter TicketMessages to delete.
     * @example
     * // Delete a few TicketMessages
     * const { count } = await prisma.ticketMessage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TicketMessageDeleteManyArgs>(args?: SelectSubset<T, TicketMessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TicketMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketMessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TicketMessages
     * const ticketMessage = await prisma.ticketMessage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TicketMessageUpdateManyArgs>(args: SelectSubset<T, TicketMessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TicketMessage.
     * @param {TicketMessageUpsertArgs} args - Arguments to update or create a TicketMessage.
     * @example
     * // Update or create a TicketMessage
     * const ticketMessage = await prisma.ticketMessage.upsert({
     *   create: {
     *     // ... data to create a TicketMessage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TicketMessage we want to update
     *   }
     * })
     */
    upsert<T extends TicketMessageUpsertArgs>(args: SelectSubset<T, TicketMessageUpsertArgs<ExtArgs>>): Prisma__TicketMessageClient<$Result.GetResult<Prisma.$TicketMessagePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TicketMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketMessageCountArgs} args - Arguments to filter TicketMessages to count.
     * @example
     * // Count the number of TicketMessages
     * const count = await prisma.ticketMessage.count({
     *   where: {
     *     // ... the filter for the TicketMessages we want to count
     *   }
     * })
    **/
    count<T extends TicketMessageCountArgs>(
      args?: Subset<T, TicketMessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TicketMessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TicketMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketMessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TicketMessageAggregateArgs>(args: Subset<T, TicketMessageAggregateArgs>): Prisma.PrismaPromise<GetTicketMessageAggregateType<T>>

    /**
     * Group by TicketMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketMessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TicketMessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TicketMessageGroupByArgs['orderBy'] }
        : { orderBy?: TicketMessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TicketMessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTicketMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TicketMessage model
   */
  readonly fields: TicketMessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TicketMessage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TicketMessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ticket<T extends TicketDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TicketDefaultArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    author<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TicketMessage model
   */ 
  interface TicketMessageFieldRefs {
    readonly id: FieldRef<"TicketMessage", 'String'>
    readonly ticketId: FieldRef<"TicketMessage", 'String'>
    readonly authorId: FieldRef<"TicketMessage", 'String'>
    readonly content: FieldRef<"TicketMessage", 'String'>
    readonly isDeleted: FieldRef<"TicketMessage", 'Boolean'>
    readonly createdAt: FieldRef<"TicketMessage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TicketMessage findUnique
   */
  export type TicketMessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketMessage
     */
    select?: TicketMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketMessageInclude<ExtArgs> | null
    /**
     * Filter, which TicketMessage to fetch.
     */
    where: TicketMessageWhereUniqueInput
  }

  /**
   * TicketMessage findUniqueOrThrow
   */
  export type TicketMessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketMessage
     */
    select?: TicketMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketMessageInclude<ExtArgs> | null
    /**
     * Filter, which TicketMessage to fetch.
     */
    where: TicketMessageWhereUniqueInput
  }

  /**
   * TicketMessage findFirst
   */
  export type TicketMessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketMessage
     */
    select?: TicketMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketMessageInclude<ExtArgs> | null
    /**
     * Filter, which TicketMessage to fetch.
     */
    where?: TicketMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketMessages to fetch.
     */
    orderBy?: TicketMessageOrderByWithRelationInput | TicketMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TicketMessages.
     */
    cursor?: TicketMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TicketMessages.
     */
    distinct?: TicketMessageScalarFieldEnum | TicketMessageScalarFieldEnum[]
  }

  /**
   * TicketMessage findFirstOrThrow
   */
  export type TicketMessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketMessage
     */
    select?: TicketMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketMessageInclude<ExtArgs> | null
    /**
     * Filter, which TicketMessage to fetch.
     */
    where?: TicketMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketMessages to fetch.
     */
    orderBy?: TicketMessageOrderByWithRelationInput | TicketMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TicketMessages.
     */
    cursor?: TicketMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TicketMessages.
     */
    distinct?: TicketMessageScalarFieldEnum | TicketMessageScalarFieldEnum[]
  }

  /**
   * TicketMessage findMany
   */
  export type TicketMessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketMessage
     */
    select?: TicketMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketMessageInclude<ExtArgs> | null
    /**
     * Filter, which TicketMessages to fetch.
     */
    where?: TicketMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketMessages to fetch.
     */
    orderBy?: TicketMessageOrderByWithRelationInput | TicketMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TicketMessages.
     */
    cursor?: TicketMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketMessages.
     */
    skip?: number
    distinct?: TicketMessageScalarFieldEnum | TicketMessageScalarFieldEnum[]
  }

  /**
   * TicketMessage create
   */
  export type TicketMessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketMessage
     */
    select?: TicketMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketMessageInclude<ExtArgs> | null
    /**
     * The data needed to create a TicketMessage.
     */
    data: XOR<TicketMessageCreateInput, TicketMessageUncheckedCreateInput>
  }

  /**
   * TicketMessage createMany
   */
  export type TicketMessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TicketMessages.
     */
    data: TicketMessageCreateManyInput | TicketMessageCreateManyInput[]
  }

  /**
   * TicketMessage createManyAndReturn
   */
  export type TicketMessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketMessage
     */
    select?: TicketMessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TicketMessages.
     */
    data: TicketMessageCreateManyInput | TicketMessageCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketMessageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TicketMessage update
   */
  export type TicketMessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketMessage
     */
    select?: TicketMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketMessageInclude<ExtArgs> | null
    /**
     * The data needed to update a TicketMessage.
     */
    data: XOR<TicketMessageUpdateInput, TicketMessageUncheckedUpdateInput>
    /**
     * Choose, which TicketMessage to update.
     */
    where: TicketMessageWhereUniqueInput
  }

  /**
   * TicketMessage updateMany
   */
  export type TicketMessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TicketMessages.
     */
    data: XOR<TicketMessageUpdateManyMutationInput, TicketMessageUncheckedUpdateManyInput>
    /**
     * Filter which TicketMessages to update
     */
    where?: TicketMessageWhereInput
  }

  /**
   * TicketMessage upsert
   */
  export type TicketMessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketMessage
     */
    select?: TicketMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketMessageInclude<ExtArgs> | null
    /**
     * The filter to search for the TicketMessage to update in case it exists.
     */
    where: TicketMessageWhereUniqueInput
    /**
     * In case the TicketMessage found by the `where` argument doesn't exist, create a new TicketMessage with this data.
     */
    create: XOR<TicketMessageCreateInput, TicketMessageUncheckedCreateInput>
    /**
     * In case the TicketMessage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TicketMessageUpdateInput, TicketMessageUncheckedUpdateInput>
  }

  /**
   * TicketMessage delete
   */
  export type TicketMessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketMessage
     */
    select?: TicketMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketMessageInclude<ExtArgs> | null
    /**
     * Filter which TicketMessage to delete.
     */
    where: TicketMessageWhereUniqueInput
  }

  /**
   * TicketMessage deleteMany
   */
  export type TicketMessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TicketMessages to delete
     */
    where?: TicketMessageWhereInput
  }

  /**
   * TicketMessage without action
   */
  export type TicketMessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketMessage
     */
    select?: TicketMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketMessageInclude<ExtArgs> | null
  }


  /**
   * Model Purchase
   */

  export type AggregatePurchase = {
    _count: PurchaseCountAggregateOutputType | null
    _avg: PurchaseAvgAggregateOutputType | null
    _sum: PurchaseSumAggregateOutputType | null
    _min: PurchaseMinAggregateOutputType | null
    _max: PurchaseMaxAggregateOutputType | null
  }

  export type PurchaseAvgAggregateOutputType = {
    amountCents: number | null
  }

  export type PurchaseSumAggregateOutputType = {
    amountCents: number | null
  }

  export type PurchaseMinAggregateOutputType = {
    id: string | null
    userId: string | null
    provider: string | null
    externalId: string | null
    status: string | null
    amountCents: number | null
    currency: string | null
    meta: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PurchaseMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    provider: string | null
    externalId: string | null
    status: string | null
    amountCents: number | null
    currency: string | null
    meta: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PurchaseCountAggregateOutputType = {
    id: number
    userId: number
    provider: number
    externalId: number
    status: number
    amountCents: number
    currency: number
    meta: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PurchaseAvgAggregateInputType = {
    amountCents?: true
  }

  export type PurchaseSumAggregateInputType = {
    amountCents?: true
  }

  export type PurchaseMinAggregateInputType = {
    id?: true
    userId?: true
    provider?: true
    externalId?: true
    status?: true
    amountCents?: true
    currency?: true
    meta?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PurchaseMaxAggregateInputType = {
    id?: true
    userId?: true
    provider?: true
    externalId?: true
    status?: true
    amountCents?: true
    currency?: true
    meta?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PurchaseCountAggregateInputType = {
    id?: true
    userId?: true
    provider?: true
    externalId?: true
    status?: true
    amountCents?: true
    currency?: true
    meta?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PurchaseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Purchase to aggregate.
     */
    where?: PurchaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Purchases to fetch.
     */
    orderBy?: PurchaseOrderByWithRelationInput | PurchaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PurchaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Purchases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Purchases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Purchases
    **/
    _count?: true | PurchaseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PurchaseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PurchaseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PurchaseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PurchaseMaxAggregateInputType
  }

  export type GetPurchaseAggregateType<T extends PurchaseAggregateArgs> = {
        [P in keyof T & keyof AggregatePurchase]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePurchase[P]>
      : GetScalarType<T[P], AggregatePurchase[P]>
  }




  export type PurchaseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseWhereInput
    orderBy?: PurchaseOrderByWithAggregationInput | PurchaseOrderByWithAggregationInput[]
    by: PurchaseScalarFieldEnum[] | PurchaseScalarFieldEnum
    having?: PurchaseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PurchaseCountAggregateInputType | true
    _avg?: PurchaseAvgAggregateInputType
    _sum?: PurchaseSumAggregateInputType
    _min?: PurchaseMinAggregateInputType
    _max?: PurchaseMaxAggregateInputType
  }

  export type PurchaseGroupByOutputType = {
    id: string
    userId: string
    provider: string
    externalId: string | null
    status: string
    amountCents: number
    currency: string
    meta: string | null
    createdAt: Date
    updatedAt: Date
    _count: PurchaseCountAggregateOutputType | null
    _avg: PurchaseAvgAggregateOutputType | null
    _sum: PurchaseSumAggregateOutputType | null
    _min: PurchaseMinAggregateOutputType | null
    _max: PurchaseMaxAggregateOutputType | null
  }

  type GetPurchaseGroupByPayload<T extends PurchaseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PurchaseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PurchaseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PurchaseGroupByOutputType[P]>
            : GetScalarType<T[P], PurchaseGroupByOutputType[P]>
        }
      >
    >


  export type PurchaseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    provider?: boolean
    externalId?: boolean
    status?: boolean
    amountCents?: boolean
    currency?: boolean
    meta?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    items?: boolean | Purchase$itemsArgs<ExtArgs>
    _count?: boolean | PurchaseCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchase"]>

  export type PurchaseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    provider?: boolean
    externalId?: boolean
    status?: boolean
    amountCents?: boolean
    currency?: boolean
    meta?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchase"]>

  export type PurchaseSelectScalar = {
    id?: boolean
    userId?: boolean
    provider?: boolean
    externalId?: boolean
    status?: boolean
    amountCents?: boolean
    currency?: boolean
    meta?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PurchaseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    items?: boolean | Purchase$itemsArgs<ExtArgs>
    _count?: boolean | PurchaseCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PurchaseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PurchasePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Purchase"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      items: Prisma.$PurchaseItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      provider: string
      externalId: string | null
      status: string
      amountCents: number
      currency: string
      meta: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["purchase"]>
    composites: {}
  }

  type PurchaseGetPayload<S extends boolean | null | undefined | PurchaseDefaultArgs> = $Result.GetResult<Prisma.$PurchasePayload, S>

  type PurchaseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PurchaseFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PurchaseCountAggregateInputType | true
    }

  export interface PurchaseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Purchase'], meta: { name: 'Purchase' } }
    /**
     * Find zero or one Purchase that matches the filter.
     * @param {PurchaseFindUniqueArgs} args - Arguments to find a Purchase
     * @example
     * // Get one Purchase
     * const purchase = await prisma.purchase.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PurchaseFindUniqueArgs>(args: SelectSubset<T, PurchaseFindUniqueArgs<ExtArgs>>): Prisma__PurchaseClient<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Purchase that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PurchaseFindUniqueOrThrowArgs} args - Arguments to find a Purchase
     * @example
     * // Get one Purchase
     * const purchase = await prisma.purchase.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PurchaseFindUniqueOrThrowArgs>(args: SelectSubset<T, PurchaseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PurchaseClient<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Purchase that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseFindFirstArgs} args - Arguments to find a Purchase
     * @example
     * // Get one Purchase
     * const purchase = await prisma.purchase.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PurchaseFindFirstArgs>(args?: SelectSubset<T, PurchaseFindFirstArgs<ExtArgs>>): Prisma__PurchaseClient<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Purchase that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseFindFirstOrThrowArgs} args - Arguments to find a Purchase
     * @example
     * // Get one Purchase
     * const purchase = await prisma.purchase.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PurchaseFindFirstOrThrowArgs>(args?: SelectSubset<T, PurchaseFindFirstOrThrowArgs<ExtArgs>>): Prisma__PurchaseClient<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Purchases that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Purchases
     * const purchases = await prisma.purchase.findMany()
     * 
     * // Get first 10 Purchases
     * const purchases = await prisma.purchase.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const purchaseWithIdOnly = await prisma.purchase.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PurchaseFindManyArgs>(args?: SelectSubset<T, PurchaseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Purchase.
     * @param {PurchaseCreateArgs} args - Arguments to create a Purchase.
     * @example
     * // Create one Purchase
     * const Purchase = await prisma.purchase.create({
     *   data: {
     *     // ... data to create a Purchase
     *   }
     * })
     * 
     */
    create<T extends PurchaseCreateArgs>(args: SelectSubset<T, PurchaseCreateArgs<ExtArgs>>): Prisma__PurchaseClient<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Purchases.
     * @param {PurchaseCreateManyArgs} args - Arguments to create many Purchases.
     * @example
     * // Create many Purchases
     * const purchase = await prisma.purchase.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PurchaseCreateManyArgs>(args?: SelectSubset<T, PurchaseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Purchases and returns the data saved in the database.
     * @param {PurchaseCreateManyAndReturnArgs} args - Arguments to create many Purchases.
     * @example
     * // Create many Purchases
     * const purchase = await prisma.purchase.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Purchases and only return the `id`
     * const purchaseWithIdOnly = await prisma.purchase.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PurchaseCreateManyAndReturnArgs>(args?: SelectSubset<T, PurchaseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Purchase.
     * @param {PurchaseDeleteArgs} args - Arguments to delete one Purchase.
     * @example
     * // Delete one Purchase
     * const Purchase = await prisma.purchase.delete({
     *   where: {
     *     // ... filter to delete one Purchase
     *   }
     * })
     * 
     */
    delete<T extends PurchaseDeleteArgs>(args: SelectSubset<T, PurchaseDeleteArgs<ExtArgs>>): Prisma__PurchaseClient<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Purchase.
     * @param {PurchaseUpdateArgs} args - Arguments to update one Purchase.
     * @example
     * // Update one Purchase
     * const purchase = await prisma.purchase.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PurchaseUpdateArgs>(args: SelectSubset<T, PurchaseUpdateArgs<ExtArgs>>): Prisma__PurchaseClient<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Purchases.
     * @param {PurchaseDeleteManyArgs} args - Arguments to filter Purchases to delete.
     * @example
     * // Delete a few Purchases
     * const { count } = await prisma.purchase.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PurchaseDeleteManyArgs>(args?: SelectSubset<T, PurchaseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Purchases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Purchases
     * const purchase = await prisma.purchase.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PurchaseUpdateManyArgs>(args: SelectSubset<T, PurchaseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Purchase.
     * @param {PurchaseUpsertArgs} args - Arguments to update or create a Purchase.
     * @example
     * // Update or create a Purchase
     * const purchase = await prisma.purchase.upsert({
     *   create: {
     *     // ... data to create a Purchase
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Purchase we want to update
     *   }
     * })
     */
    upsert<T extends PurchaseUpsertArgs>(args: SelectSubset<T, PurchaseUpsertArgs<ExtArgs>>): Prisma__PurchaseClient<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Purchases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseCountArgs} args - Arguments to filter Purchases to count.
     * @example
     * // Count the number of Purchases
     * const count = await prisma.purchase.count({
     *   where: {
     *     // ... the filter for the Purchases we want to count
     *   }
     * })
    **/
    count<T extends PurchaseCountArgs>(
      args?: Subset<T, PurchaseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PurchaseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Purchase.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PurchaseAggregateArgs>(args: Subset<T, PurchaseAggregateArgs>): Prisma.PrismaPromise<GetPurchaseAggregateType<T>>

    /**
     * Group by Purchase.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PurchaseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PurchaseGroupByArgs['orderBy'] }
        : { orderBy?: PurchaseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PurchaseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPurchaseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Purchase model
   */
  readonly fields: PurchaseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Purchase.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PurchaseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    items<T extends Purchase$itemsArgs<ExtArgs> = {}>(args?: Subset<T, Purchase$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseItemPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Purchase model
   */ 
  interface PurchaseFieldRefs {
    readonly id: FieldRef<"Purchase", 'String'>
    readonly userId: FieldRef<"Purchase", 'String'>
    readonly provider: FieldRef<"Purchase", 'String'>
    readonly externalId: FieldRef<"Purchase", 'String'>
    readonly status: FieldRef<"Purchase", 'String'>
    readonly amountCents: FieldRef<"Purchase", 'Int'>
    readonly currency: FieldRef<"Purchase", 'String'>
    readonly meta: FieldRef<"Purchase", 'String'>
    readonly createdAt: FieldRef<"Purchase", 'DateTime'>
    readonly updatedAt: FieldRef<"Purchase", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Purchase findUnique
   */
  export type PurchaseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    /**
     * Filter, which Purchase to fetch.
     */
    where: PurchaseWhereUniqueInput
  }

  /**
   * Purchase findUniqueOrThrow
   */
  export type PurchaseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    /**
     * Filter, which Purchase to fetch.
     */
    where: PurchaseWhereUniqueInput
  }

  /**
   * Purchase findFirst
   */
  export type PurchaseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    /**
     * Filter, which Purchase to fetch.
     */
    where?: PurchaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Purchases to fetch.
     */
    orderBy?: PurchaseOrderByWithRelationInput | PurchaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Purchases.
     */
    cursor?: PurchaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Purchases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Purchases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Purchases.
     */
    distinct?: PurchaseScalarFieldEnum | PurchaseScalarFieldEnum[]
  }

  /**
   * Purchase findFirstOrThrow
   */
  export type PurchaseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    /**
     * Filter, which Purchase to fetch.
     */
    where?: PurchaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Purchases to fetch.
     */
    orderBy?: PurchaseOrderByWithRelationInput | PurchaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Purchases.
     */
    cursor?: PurchaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Purchases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Purchases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Purchases.
     */
    distinct?: PurchaseScalarFieldEnum | PurchaseScalarFieldEnum[]
  }

  /**
   * Purchase findMany
   */
  export type PurchaseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    /**
     * Filter, which Purchases to fetch.
     */
    where?: PurchaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Purchases to fetch.
     */
    orderBy?: PurchaseOrderByWithRelationInput | PurchaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Purchases.
     */
    cursor?: PurchaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Purchases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Purchases.
     */
    skip?: number
    distinct?: PurchaseScalarFieldEnum | PurchaseScalarFieldEnum[]
  }

  /**
   * Purchase create
   */
  export type PurchaseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    /**
     * The data needed to create a Purchase.
     */
    data: XOR<PurchaseCreateInput, PurchaseUncheckedCreateInput>
  }

  /**
   * Purchase createMany
   */
  export type PurchaseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Purchases.
     */
    data: PurchaseCreateManyInput | PurchaseCreateManyInput[]
  }

  /**
   * Purchase createManyAndReturn
   */
  export type PurchaseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Purchases.
     */
    data: PurchaseCreateManyInput | PurchaseCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Purchase update
   */
  export type PurchaseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    /**
     * The data needed to update a Purchase.
     */
    data: XOR<PurchaseUpdateInput, PurchaseUncheckedUpdateInput>
    /**
     * Choose, which Purchase to update.
     */
    where: PurchaseWhereUniqueInput
  }

  /**
   * Purchase updateMany
   */
  export type PurchaseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Purchases.
     */
    data: XOR<PurchaseUpdateManyMutationInput, PurchaseUncheckedUpdateManyInput>
    /**
     * Filter which Purchases to update
     */
    where?: PurchaseWhereInput
  }

  /**
   * Purchase upsert
   */
  export type PurchaseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    /**
     * The filter to search for the Purchase to update in case it exists.
     */
    where: PurchaseWhereUniqueInput
    /**
     * In case the Purchase found by the `where` argument doesn't exist, create a new Purchase with this data.
     */
    create: XOR<PurchaseCreateInput, PurchaseUncheckedCreateInput>
    /**
     * In case the Purchase was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PurchaseUpdateInput, PurchaseUncheckedUpdateInput>
  }

  /**
   * Purchase delete
   */
  export type PurchaseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    /**
     * Filter which Purchase to delete.
     */
    where: PurchaseWhereUniqueInput
  }

  /**
   * Purchase deleteMany
   */
  export type PurchaseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Purchases to delete
     */
    where?: PurchaseWhereInput
  }

  /**
   * Purchase.items
   */
  export type Purchase$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseItem
     */
    select?: PurchaseItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseItemInclude<ExtArgs> | null
    where?: PurchaseItemWhereInput
    orderBy?: PurchaseItemOrderByWithRelationInput | PurchaseItemOrderByWithRelationInput[]
    cursor?: PurchaseItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseItemScalarFieldEnum | PurchaseItemScalarFieldEnum[]
  }

  /**
   * Purchase without action
   */
  export type PurchaseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
  }


  /**
   * Model AuditLog
   */

  export type AggregateAuditLog = {
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  export type AuditLogMinAggregateOutputType = {
    id: string | null
    actorId: string | null
    action: string | null
    entityType: string | null
    entityId: string | null
    ip: string | null
    userAgent: string | null
    meta: string | null
    createdAt: Date | null
  }

  export type AuditLogMaxAggregateOutputType = {
    id: string | null
    actorId: string | null
    action: string | null
    entityType: string | null
    entityId: string | null
    ip: string | null
    userAgent: string | null
    meta: string | null
    createdAt: Date | null
  }

  export type AuditLogCountAggregateOutputType = {
    id: number
    actorId: number
    action: number
    entityType: number
    entityId: number
    ip: number
    userAgent: number
    meta: number
    createdAt: number
    _all: number
  }


  export type AuditLogMinAggregateInputType = {
    id?: true
    actorId?: true
    action?: true
    entityType?: true
    entityId?: true
    ip?: true
    userAgent?: true
    meta?: true
    createdAt?: true
  }

  export type AuditLogMaxAggregateInputType = {
    id?: true
    actorId?: true
    action?: true
    entityType?: true
    entityId?: true
    ip?: true
    userAgent?: true
    meta?: true
    createdAt?: true
  }

  export type AuditLogCountAggregateInputType = {
    id?: true
    actorId?: true
    action?: true
    entityType?: true
    entityId?: true
    ip?: true
    userAgent?: true
    meta?: true
    createdAt?: true
    _all?: true
  }

  export type AuditLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLog to aggregate.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditLogs
    **/
    _count?: true | AuditLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditLogMaxAggregateInputType
  }

  export type GetAuditLogAggregateType<T extends AuditLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditLog[P]>
      : GetScalarType<T[P], AggregateAuditLog[P]>
  }




  export type AuditLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithAggregationInput | AuditLogOrderByWithAggregationInput[]
    by: AuditLogScalarFieldEnum[] | AuditLogScalarFieldEnum
    having?: AuditLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditLogCountAggregateInputType | true
    _min?: AuditLogMinAggregateInputType
    _max?: AuditLogMaxAggregateInputType
  }

  export type AuditLogGroupByOutputType = {
    id: string
    actorId: string | null
    action: string
    entityType: string
    entityId: string | null
    ip: string | null
    userAgent: string | null
    meta: string | null
    createdAt: Date
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  type GetAuditLogGroupByPayload<T extends AuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
        }
      >
    >


  export type AuditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    actorId?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    ip?: boolean
    userAgent?: boolean
    meta?: boolean
    createdAt?: boolean
    actor?: boolean | AuditLog$actorArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    actorId?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    ip?: boolean
    userAgent?: boolean
    meta?: boolean
    createdAt?: boolean
    actor?: boolean | AuditLog$actorArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectScalar = {
    id?: boolean
    actorId?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    ip?: boolean
    userAgent?: boolean
    meta?: boolean
    createdAt?: boolean
  }

  export type AuditLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    actor?: boolean | AuditLog$actorArgs<ExtArgs>
  }
  export type AuditLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    actor?: boolean | AuditLog$actorArgs<ExtArgs>
  }

  export type $AuditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditLog"
    objects: {
      actor: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      actorId: string | null
      action: string
      entityType: string
      entityId: string | null
      ip: string | null
      userAgent: string | null
      meta: string | null
      createdAt: Date
    }, ExtArgs["result"]["auditLog"]>
    composites: {}
  }

  type AuditLogGetPayload<S extends boolean | null | undefined | AuditLogDefaultArgs> = $Result.GetResult<Prisma.$AuditLogPayload, S>

  type AuditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AuditLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AuditLogCountAggregateInputType | true
    }

  export interface AuditLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditLog'], meta: { name: 'AuditLog' } }
    /**
     * Find zero or one AuditLog that matches the filter.
     * @param {AuditLogFindUniqueArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditLogFindUniqueArgs>(args: SelectSubset<T, AuditLogFindUniqueArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AuditLog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AuditLogFindUniqueOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditLogFindFirstArgs>(args?: SelectSubset<T, AuditLogFindFirstArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditLogs
     * const auditLogs = await prisma.auditLog.findMany()
     * 
     * // Get first 10 AuditLogs
     * const auditLogs = await prisma.auditLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditLogFindManyArgs>(args?: SelectSubset<T, AuditLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AuditLog.
     * @param {AuditLogCreateArgs} args - Arguments to create a AuditLog.
     * @example
     * // Create one AuditLog
     * const AuditLog = await prisma.auditLog.create({
     *   data: {
     *     // ... data to create a AuditLog
     *   }
     * })
     * 
     */
    create<T extends AuditLogCreateArgs>(args: SelectSubset<T, AuditLogCreateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AuditLogs.
     * @param {AuditLogCreateManyArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditLogCreateManyArgs>(args?: SelectSubset<T, AuditLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuditLogs and returns the data saved in the database.
     * @param {AuditLogCreateManyAndReturnArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuditLogCreateManyAndReturnArgs>(args?: SelectSubset<T, AuditLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AuditLog.
     * @param {AuditLogDeleteArgs} args - Arguments to delete one AuditLog.
     * @example
     * // Delete one AuditLog
     * const AuditLog = await prisma.auditLog.delete({
     *   where: {
     *     // ... filter to delete one AuditLog
     *   }
     * })
     * 
     */
    delete<T extends AuditLogDeleteArgs>(args: SelectSubset<T, AuditLogDeleteArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AuditLog.
     * @param {AuditLogUpdateArgs} args - Arguments to update one AuditLog.
     * @example
     * // Update one AuditLog
     * const auditLog = await prisma.auditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditLogUpdateArgs>(args: SelectSubset<T, AuditLogUpdateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AuditLogs.
     * @param {AuditLogDeleteManyArgs} args - Arguments to filter AuditLogs to delete.
     * @example
     * // Delete a few AuditLogs
     * const { count } = await prisma.auditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditLogDeleteManyArgs>(args?: SelectSubset<T, AuditLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditLogUpdateManyArgs>(args: SelectSubset<T, AuditLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AuditLog.
     * @param {AuditLogUpsertArgs} args - Arguments to update or create a AuditLog.
     * @example
     * // Update or create a AuditLog
     * const auditLog = await prisma.auditLog.upsert({
     *   create: {
     *     // ... data to create a AuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditLog we want to update
     *   }
     * })
     */
    upsert<T extends AuditLogUpsertArgs>(args: SelectSubset<T, AuditLogUpsertArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogCountArgs} args - Arguments to filter AuditLogs to count.
     * @example
     * // Count the number of AuditLogs
     * const count = await prisma.auditLog.count({
     *   where: {
     *     // ... the filter for the AuditLogs we want to count
     *   }
     * })
    **/
    count<T extends AuditLogCountArgs>(
      args?: Subset<T, AuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditLogAggregateArgs>(args: Subset<T, AuditLogAggregateArgs>): Prisma.PrismaPromise<GetAuditLogAggregateType<T>>

    /**
     * Group by AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditLogGroupByArgs['orderBy'] }
        : { orderBy?: AuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditLog model
   */
  readonly fields: AuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    actor<T extends AuditLog$actorArgs<ExtArgs> = {}>(args?: Subset<T, AuditLog$actorArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuditLog model
   */ 
  interface AuditLogFieldRefs {
    readonly id: FieldRef<"AuditLog", 'String'>
    readonly actorId: FieldRef<"AuditLog", 'String'>
    readonly action: FieldRef<"AuditLog", 'String'>
    readonly entityType: FieldRef<"AuditLog", 'String'>
    readonly entityId: FieldRef<"AuditLog", 'String'>
    readonly ip: FieldRef<"AuditLog", 'String'>
    readonly userAgent: FieldRef<"AuditLog", 'String'>
    readonly meta: FieldRef<"AuditLog", 'String'>
    readonly createdAt: FieldRef<"AuditLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AuditLog findUnique
   */
  export type AuditLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findUniqueOrThrow
   */
  export type AuditLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findFirst
   */
  export type AuditLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findFirstOrThrow
   */
  export type AuditLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findMany
   */
  export type AuditLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLogs to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog create
   */
  export type AuditLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to create a AuditLog.
     */
    data: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
  }

  /**
   * AuditLog createMany
   */
  export type AuditLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
  }

  /**
   * AuditLog createManyAndReturn
   */
  export type AuditLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLog update
   */
  export type AuditLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to update a AuditLog.
     */
    data: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
    /**
     * Choose, which AuditLog to update.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog updateMany
   */
  export type AuditLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
  }

  /**
   * AuditLog upsert
   */
  export type AuditLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The filter to search for the AuditLog to update in case it exists.
     */
    where: AuditLogWhereUniqueInput
    /**
     * In case the AuditLog found by the `where` argument doesn't exist, create a new AuditLog with this data.
     */
    create: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
    /**
     * In case the AuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
  }

  /**
   * AuditLog delete
   */
  export type AuditLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter which AuditLog to delete.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog deleteMany
   */
  export type AuditLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLogs to delete
     */
    where?: AuditLogWhereInput
  }

  /**
   * AuditLog.actor
   */
  export type AuditLog$actorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * AuditLog without action
   */
  export type AuditLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
  }


  /**
   * Model MpWebhookEvent
   */

  export type AggregateMpWebhookEvent = {
    _count: MpWebhookEventCountAggregateOutputType | null
    _min: MpWebhookEventMinAggregateOutputType | null
    _max: MpWebhookEventMaxAggregateOutputType | null
  }

  export type MpWebhookEventMinAggregateOutputType = {
    id: string | null
    eventType: string | null
    externalId: string | null
    payload: string | null
    processed: boolean | null
    createdAt: Date | null
  }

  export type MpWebhookEventMaxAggregateOutputType = {
    id: string | null
    eventType: string | null
    externalId: string | null
    payload: string | null
    processed: boolean | null
    createdAt: Date | null
  }

  export type MpWebhookEventCountAggregateOutputType = {
    id: number
    eventType: number
    externalId: number
    payload: number
    processed: number
    createdAt: number
    _all: number
  }


  export type MpWebhookEventMinAggregateInputType = {
    id?: true
    eventType?: true
    externalId?: true
    payload?: true
    processed?: true
    createdAt?: true
  }

  export type MpWebhookEventMaxAggregateInputType = {
    id?: true
    eventType?: true
    externalId?: true
    payload?: true
    processed?: true
    createdAt?: true
  }

  export type MpWebhookEventCountAggregateInputType = {
    id?: true
    eventType?: true
    externalId?: true
    payload?: true
    processed?: true
    createdAt?: true
    _all?: true
  }

  export type MpWebhookEventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MpWebhookEvent to aggregate.
     */
    where?: MpWebhookEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MpWebhookEvents to fetch.
     */
    orderBy?: MpWebhookEventOrderByWithRelationInput | MpWebhookEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MpWebhookEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MpWebhookEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MpWebhookEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MpWebhookEvents
    **/
    _count?: true | MpWebhookEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MpWebhookEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MpWebhookEventMaxAggregateInputType
  }

  export type GetMpWebhookEventAggregateType<T extends MpWebhookEventAggregateArgs> = {
        [P in keyof T & keyof AggregateMpWebhookEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMpWebhookEvent[P]>
      : GetScalarType<T[P], AggregateMpWebhookEvent[P]>
  }




  export type MpWebhookEventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MpWebhookEventWhereInput
    orderBy?: MpWebhookEventOrderByWithAggregationInput | MpWebhookEventOrderByWithAggregationInput[]
    by: MpWebhookEventScalarFieldEnum[] | MpWebhookEventScalarFieldEnum
    having?: MpWebhookEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MpWebhookEventCountAggregateInputType | true
    _min?: MpWebhookEventMinAggregateInputType
    _max?: MpWebhookEventMaxAggregateInputType
  }

  export type MpWebhookEventGroupByOutputType = {
    id: string
    eventType: string | null
    externalId: string | null
    payload: string
    processed: boolean
    createdAt: Date
    _count: MpWebhookEventCountAggregateOutputType | null
    _min: MpWebhookEventMinAggregateOutputType | null
    _max: MpWebhookEventMaxAggregateOutputType | null
  }

  type GetMpWebhookEventGroupByPayload<T extends MpWebhookEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MpWebhookEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MpWebhookEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MpWebhookEventGroupByOutputType[P]>
            : GetScalarType<T[P], MpWebhookEventGroupByOutputType[P]>
        }
      >
    >


  export type MpWebhookEventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eventType?: boolean
    externalId?: boolean
    payload?: boolean
    processed?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["mpWebhookEvent"]>

  export type MpWebhookEventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eventType?: boolean
    externalId?: boolean
    payload?: boolean
    processed?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["mpWebhookEvent"]>

  export type MpWebhookEventSelectScalar = {
    id?: boolean
    eventType?: boolean
    externalId?: boolean
    payload?: boolean
    processed?: boolean
    createdAt?: boolean
  }


  export type $MpWebhookEventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MpWebhookEvent"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      eventType: string | null
      externalId: string | null
      payload: string
      processed: boolean
      createdAt: Date
    }, ExtArgs["result"]["mpWebhookEvent"]>
    composites: {}
  }

  type MpWebhookEventGetPayload<S extends boolean | null | undefined | MpWebhookEventDefaultArgs> = $Result.GetResult<Prisma.$MpWebhookEventPayload, S>

  type MpWebhookEventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MpWebhookEventFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MpWebhookEventCountAggregateInputType | true
    }

  export interface MpWebhookEventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MpWebhookEvent'], meta: { name: 'MpWebhookEvent' } }
    /**
     * Find zero or one MpWebhookEvent that matches the filter.
     * @param {MpWebhookEventFindUniqueArgs} args - Arguments to find a MpWebhookEvent
     * @example
     * // Get one MpWebhookEvent
     * const mpWebhookEvent = await prisma.mpWebhookEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MpWebhookEventFindUniqueArgs>(args: SelectSubset<T, MpWebhookEventFindUniqueArgs<ExtArgs>>): Prisma__MpWebhookEventClient<$Result.GetResult<Prisma.$MpWebhookEventPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one MpWebhookEvent that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MpWebhookEventFindUniqueOrThrowArgs} args - Arguments to find a MpWebhookEvent
     * @example
     * // Get one MpWebhookEvent
     * const mpWebhookEvent = await prisma.mpWebhookEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MpWebhookEventFindUniqueOrThrowArgs>(args: SelectSubset<T, MpWebhookEventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MpWebhookEventClient<$Result.GetResult<Prisma.$MpWebhookEventPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first MpWebhookEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MpWebhookEventFindFirstArgs} args - Arguments to find a MpWebhookEvent
     * @example
     * // Get one MpWebhookEvent
     * const mpWebhookEvent = await prisma.mpWebhookEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MpWebhookEventFindFirstArgs>(args?: SelectSubset<T, MpWebhookEventFindFirstArgs<ExtArgs>>): Prisma__MpWebhookEventClient<$Result.GetResult<Prisma.$MpWebhookEventPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first MpWebhookEvent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MpWebhookEventFindFirstOrThrowArgs} args - Arguments to find a MpWebhookEvent
     * @example
     * // Get one MpWebhookEvent
     * const mpWebhookEvent = await prisma.mpWebhookEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MpWebhookEventFindFirstOrThrowArgs>(args?: SelectSubset<T, MpWebhookEventFindFirstOrThrowArgs<ExtArgs>>): Prisma__MpWebhookEventClient<$Result.GetResult<Prisma.$MpWebhookEventPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more MpWebhookEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MpWebhookEventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MpWebhookEvents
     * const mpWebhookEvents = await prisma.mpWebhookEvent.findMany()
     * 
     * // Get first 10 MpWebhookEvents
     * const mpWebhookEvents = await prisma.mpWebhookEvent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mpWebhookEventWithIdOnly = await prisma.mpWebhookEvent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MpWebhookEventFindManyArgs>(args?: SelectSubset<T, MpWebhookEventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MpWebhookEventPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a MpWebhookEvent.
     * @param {MpWebhookEventCreateArgs} args - Arguments to create a MpWebhookEvent.
     * @example
     * // Create one MpWebhookEvent
     * const MpWebhookEvent = await prisma.mpWebhookEvent.create({
     *   data: {
     *     // ... data to create a MpWebhookEvent
     *   }
     * })
     * 
     */
    create<T extends MpWebhookEventCreateArgs>(args: SelectSubset<T, MpWebhookEventCreateArgs<ExtArgs>>): Prisma__MpWebhookEventClient<$Result.GetResult<Prisma.$MpWebhookEventPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many MpWebhookEvents.
     * @param {MpWebhookEventCreateManyArgs} args - Arguments to create many MpWebhookEvents.
     * @example
     * // Create many MpWebhookEvents
     * const mpWebhookEvent = await prisma.mpWebhookEvent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MpWebhookEventCreateManyArgs>(args?: SelectSubset<T, MpWebhookEventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MpWebhookEvents and returns the data saved in the database.
     * @param {MpWebhookEventCreateManyAndReturnArgs} args - Arguments to create many MpWebhookEvents.
     * @example
     * // Create many MpWebhookEvents
     * const mpWebhookEvent = await prisma.mpWebhookEvent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MpWebhookEvents and only return the `id`
     * const mpWebhookEventWithIdOnly = await prisma.mpWebhookEvent.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MpWebhookEventCreateManyAndReturnArgs>(args?: SelectSubset<T, MpWebhookEventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MpWebhookEventPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a MpWebhookEvent.
     * @param {MpWebhookEventDeleteArgs} args - Arguments to delete one MpWebhookEvent.
     * @example
     * // Delete one MpWebhookEvent
     * const MpWebhookEvent = await prisma.mpWebhookEvent.delete({
     *   where: {
     *     // ... filter to delete one MpWebhookEvent
     *   }
     * })
     * 
     */
    delete<T extends MpWebhookEventDeleteArgs>(args: SelectSubset<T, MpWebhookEventDeleteArgs<ExtArgs>>): Prisma__MpWebhookEventClient<$Result.GetResult<Prisma.$MpWebhookEventPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one MpWebhookEvent.
     * @param {MpWebhookEventUpdateArgs} args - Arguments to update one MpWebhookEvent.
     * @example
     * // Update one MpWebhookEvent
     * const mpWebhookEvent = await prisma.mpWebhookEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MpWebhookEventUpdateArgs>(args: SelectSubset<T, MpWebhookEventUpdateArgs<ExtArgs>>): Prisma__MpWebhookEventClient<$Result.GetResult<Prisma.$MpWebhookEventPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more MpWebhookEvents.
     * @param {MpWebhookEventDeleteManyArgs} args - Arguments to filter MpWebhookEvents to delete.
     * @example
     * // Delete a few MpWebhookEvents
     * const { count } = await prisma.mpWebhookEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MpWebhookEventDeleteManyArgs>(args?: SelectSubset<T, MpWebhookEventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MpWebhookEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MpWebhookEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MpWebhookEvents
     * const mpWebhookEvent = await prisma.mpWebhookEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MpWebhookEventUpdateManyArgs>(args: SelectSubset<T, MpWebhookEventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MpWebhookEvent.
     * @param {MpWebhookEventUpsertArgs} args - Arguments to update or create a MpWebhookEvent.
     * @example
     * // Update or create a MpWebhookEvent
     * const mpWebhookEvent = await prisma.mpWebhookEvent.upsert({
     *   create: {
     *     // ... data to create a MpWebhookEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MpWebhookEvent we want to update
     *   }
     * })
     */
    upsert<T extends MpWebhookEventUpsertArgs>(args: SelectSubset<T, MpWebhookEventUpsertArgs<ExtArgs>>): Prisma__MpWebhookEventClient<$Result.GetResult<Prisma.$MpWebhookEventPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of MpWebhookEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MpWebhookEventCountArgs} args - Arguments to filter MpWebhookEvents to count.
     * @example
     * // Count the number of MpWebhookEvents
     * const count = await prisma.mpWebhookEvent.count({
     *   where: {
     *     // ... the filter for the MpWebhookEvents we want to count
     *   }
     * })
    **/
    count<T extends MpWebhookEventCountArgs>(
      args?: Subset<T, MpWebhookEventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MpWebhookEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MpWebhookEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MpWebhookEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MpWebhookEventAggregateArgs>(args: Subset<T, MpWebhookEventAggregateArgs>): Prisma.PrismaPromise<GetMpWebhookEventAggregateType<T>>

    /**
     * Group by MpWebhookEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MpWebhookEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MpWebhookEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MpWebhookEventGroupByArgs['orderBy'] }
        : { orderBy?: MpWebhookEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MpWebhookEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMpWebhookEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MpWebhookEvent model
   */
  readonly fields: MpWebhookEventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MpWebhookEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MpWebhookEventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MpWebhookEvent model
   */ 
  interface MpWebhookEventFieldRefs {
    readonly id: FieldRef<"MpWebhookEvent", 'String'>
    readonly eventType: FieldRef<"MpWebhookEvent", 'String'>
    readonly externalId: FieldRef<"MpWebhookEvent", 'String'>
    readonly payload: FieldRef<"MpWebhookEvent", 'String'>
    readonly processed: FieldRef<"MpWebhookEvent", 'Boolean'>
    readonly createdAt: FieldRef<"MpWebhookEvent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MpWebhookEvent findUnique
   */
  export type MpWebhookEventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MpWebhookEvent
     */
    select?: MpWebhookEventSelect<ExtArgs> | null
    /**
     * Filter, which MpWebhookEvent to fetch.
     */
    where: MpWebhookEventWhereUniqueInput
  }

  /**
   * MpWebhookEvent findUniqueOrThrow
   */
  export type MpWebhookEventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MpWebhookEvent
     */
    select?: MpWebhookEventSelect<ExtArgs> | null
    /**
     * Filter, which MpWebhookEvent to fetch.
     */
    where: MpWebhookEventWhereUniqueInput
  }

  /**
   * MpWebhookEvent findFirst
   */
  export type MpWebhookEventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MpWebhookEvent
     */
    select?: MpWebhookEventSelect<ExtArgs> | null
    /**
     * Filter, which MpWebhookEvent to fetch.
     */
    where?: MpWebhookEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MpWebhookEvents to fetch.
     */
    orderBy?: MpWebhookEventOrderByWithRelationInput | MpWebhookEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MpWebhookEvents.
     */
    cursor?: MpWebhookEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MpWebhookEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MpWebhookEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MpWebhookEvents.
     */
    distinct?: MpWebhookEventScalarFieldEnum | MpWebhookEventScalarFieldEnum[]
  }

  /**
   * MpWebhookEvent findFirstOrThrow
   */
  export type MpWebhookEventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MpWebhookEvent
     */
    select?: MpWebhookEventSelect<ExtArgs> | null
    /**
     * Filter, which MpWebhookEvent to fetch.
     */
    where?: MpWebhookEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MpWebhookEvents to fetch.
     */
    orderBy?: MpWebhookEventOrderByWithRelationInput | MpWebhookEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MpWebhookEvents.
     */
    cursor?: MpWebhookEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MpWebhookEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MpWebhookEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MpWebhookEvents.
     */
    distinct?: MpWebhookEventScalarFieldEnum | MpWebhookEventScalarFieldEnum[]
  }

  /**
   * MpWebhookEvent findMany
   */
  export type MpWebhookEventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MpWebhookEvent
     */
    select?: MpWebhookEventSelect<ExtArgs> | null
    /**
     * Filter, which MpWebhookEvents to fetch.
     */
    where?: MpWebhookEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MpWebhookEvents to fetch.
     */
    orderBy?: MpWebhookEventOrderByWithRelationInput | MpWebhookEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MpWebhookEvents.
     */
    cursor?: MpWebhookEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MpWebhookEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MpWebhookEvents.
     */
    skip?: number
    distinct?: MpWebhookEventScalarFieldEnum | MpWebhookEventScalarFieldEnum[]
  }

  /**
   * MpWebhookEvent create
   */
  export type MpWebhookEventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MpWebhookEvent
     */
    select?: MpWebhookEventSelect<ExtArgs> | null
    /**
     * The data needed to create a MpWebhookEvent.
     */
    data: XOR<MpWebhookEventCreateInput, MpWebhookEventUncheckedCreateInput>
  }

  /**
   * MpWebhookEvent createMany
   */
  export type MpWebhookEventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MpWebhookEvents.
     */
    data: MpWebhookEventCreateManyInput | MpWebhookEventCreateManyInput[]
  }

  /**
   * MpWebhookEvent createManyAndReturn
   */
  export type MpWebhookEventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MpWebhookEvent
     */
    select?: MpWebhookEventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many MpWebhookEvents.
     */
    data: MpWebhookEventCreateManyInput | MpWebhookEventCreateManyInput[]
  }

  /**
   * MpWebhookEvent update
   */
  export type MpWebhookEventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MpWebhookEvent
     */
    select?: MpWebhookEventSelect<ExtArgs> | null
    /**
     * The data needed to update a MpWebhookEvent.
     */
    data: XOR<MpWebhookEventUpdateInput, MpWebhookEventUncheckedUpdateInput>
    /**
     * Choose, which MpWebhookEvent to update.
     */
    where: MpWebhookEventWhereUniqueInput
  }

  /**
   * MpWebhookEvent updateMany
   */
  export type MpWebhookEventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MpWebhookEvents.
     */
    data: XOR<MpWebhookEventUpdateManyMutationInput, MpWebhookEventUncheckedUpdateManyInput>
    /**
     * Filter which MpWebhookEvents to update
     */
    where?: MpWebhookEventWhereInput
  }

  /**
   * MpWebhookEvent upsert
   */
  export type MpWebhookEventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MpWebhookEvent
     */
    select?: MpWebhookEventSelect<ExtArgs> | null
    /**
     * The filter to search for the MpWebhookEvent to update in case it exists.
     */
    where: MpWebhookEventWhereUniqueInput
    /**
     * In case the MpWebhookEvent found by the `where` argument doesn't exist, create a new MpWebhookEvent with this data.
     */
    create: XOR<MpWebhookEventCreateInput, MpWebhookEventUncheckedCreateInput>
    /**
     * In case the MpWebhookEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MpWebhookEventUpdateInput, MpWebhookEventUncheckedUpdateInput>
  }

  /**
   * MpWebhookEvent delete
   */
  export type MpWebhookEventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MpWebhookEvent
     */
    select?: MpWebhookEventSelect<ExtArgs> | null
    /**
     * Filter which MpWebhookEvent to delete.
     */
    where: MpWebhookEventWhereUniqueInput
  }

  /**
   * MpWebhookEvent deleteMany
   */
  export type MpWebhookEventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MpWebhookEvents to delete
     */
    where?: MpWebhookEventWhereInput
  }

  /**
   * MpWebhookEvent without action
   */
  export type MpWebhookEventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MpWebhookEvent
     */
    select?: MpWebhookEventSelect<ExtArgs> | null
  }


  /**
   * Model Role
   */

  export type AggregateRole = {
    _count: RoleCountAggregateOutputType | null
    _avg: RoleAvgAggregateOutputType | null
    _sum: RoleSumAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  export type RoleAvgAggregateOutputType = {
    rank: number | null
  }

  export type RoleSumAggregateOutputType = {
    rank: number | null
  }

  export type RoleMinAggregateOutputType = {
    id: string | null
    name: string | null
    rank: number | null
    category: string | null
    description: string | null
    createdAt: Date | null
    colorHex: string | null
  }

  export type RoleMaxAggregateOutputType = {
    id: string | null
    name: string | null
    rank: number | null
    category: string | null
    description: string | null
    createdAt: Date | null
    colorHex: string | null
  }

  export type RoleCountAggregateOutputType = {
    id: number
    name: number
    rank: number
    category: number
    description: number
    createdAt: number
    colorHex: number
    _all: number
  }


  export type RoleAvgAggregateInputType = {
    rank?: true
  }

  export type RoleSumAggregateInputType = {
    rank?: true
  }

  export type RoleMinAggregateInputType = {
    id?: true
    name?: true
    rank?: true
    category?: true
    description?: true
    createdAt?: true
    colorHex?: true
  }

  export type RoleMaxAggregateInputType = {
    id?: true
    name?: true
    rank?: true
    category?: true
    description?: true
    createdAt?: true
    colorHex?: true
  }

  export type RoleCountAggregateInputType = {
    id?: true
    name?: true
    rank?: true
    category?: true
    description?: true
    createdAt?: true
    colorHex?: true
    _all?: true
  }

  export type RoleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Role to aggregate.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Roles
    **/
    _count?: true | RoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RoleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RoleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoleMaxAggregateInputType
  }

  export type GetRoleAggregateType<T extends RoleAggregateArgs> = {
        [P in keyof T & keyof AggregateRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRole[P]>
      : GetScalarType<T[P], AggregateRole[P]>
  }




  export type RoleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoleWhereInput
    orderBy?: RoleOrderByWithAggregationInput | RoleOrderByWithAggregationInput[]
    by: RoleScalarFieldEnum[] | RoleScalarFieldEnum
    having?: RoleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoleCountAggregateInputType | true
    _avg?: RoleAvgAggregateInputType
    _sum?: RoleSumAggregateInputType
    _min?: RoleMinAggregateInputType
    _max?: RoleMaxAggregateInputType
  }

  export type RoleGroupByOutputType = {
    id: string
    name: string
    rank: number
    category: string
    description: string | null
    createdAt: Date
    colorHex: string | null
    _count: RoleCountAggregateOutputType | null
    _avg: RoleAvgAggregateOutputType | null
    _sum: RoleSumAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  type GetRoleGroupByPayload<T extends RoleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoleGroupByOutputType[P]>
            : GetScalarType<T[P], RoleGroupByOutputType[P]>
        }
      >
    >


  export type RoleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    rank?: boolean
    category?: boolean
    description?: boolean
    createdAt?: boolean
    colorHex?: boolean
    permissions?: boolean | Role$permissionsArgs<ExtArgs>
    users?: boolean | Role$usersArgs<ExtArgs>
    _count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["role"]>

  export type RoleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    rank?: boolean
    category?: boolean
    description?: boolean
    createdAt?: boolean
    colorHex?: boolean
  }, ExtArgs["result"]["role"]>

  export type RoleSelectScalar = {
    id?: boolean
    name?: boolean
    rank?: boolean
    category?: boolean
    description?: boolean
    createdAt?: boolean
    colorHex?: boolean
  }

  export type RoleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    permissions?: boolean | Role$permissionsArgs<ExtArgs>
    users?: boolean | Role$usersArgs<ExtArgs>
    _count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RoleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $RolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Role"
    objects: {
      permissions: Prisma.$RolePermissionPayload<ExtArgs>[]
      users: Prisma.$UserRolePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      rank: number
      category: string
      description: string | null
      createdAt: Date
      colorHex: string | null
    }, ExtArgs["result"]["role"]>
    composites: {}
  }

  type RoleGetPayload<S extends boolean | null | undefined | RoleDefaultArgs> = $Result.GetResult<Prisma.$RolePayload, S>

  type RoleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RoleFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RoleCountAggregateInputType | true
    }

  export interface RoleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Role'], meta: { name: 'Role' } }
    /**
     * Find zero or one Role that matches the filter.
     * @param {RoleFindUniqueArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RoleFindUniqueArgs>(args: SelectSubset<T, RoleFindUniqueArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Role that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RoleFindUniqueOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RoleFindUniqueOrThrowArgs>(args: SelectSubset<T, RoleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Role that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RoleFindFirstArgs>(args?: SelectSubset<T, RoleFindFirstArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Role that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RoleFindFirstOrThrowArgs>(args?: SelectSubset<T, RoleFindFirstOrThrowArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Roles
     * const roles = await prisma.role.findMany()
     * 
     * // Get first 10 Roles
     * const roles = await prisma.role.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roleWithIdOnly = await prisma.role.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RoleFindManyArgs>(args?: SelectSubset<T, RoleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Role.
     * @param {RoleCreateArgs} args - Arguments to create a Role.
     * @example
     * // Create one Role
     * const Role = await prisma.role.create({
     *   data: {
     *     // ... data to create a Role
     *   }
     * })
     * 
     */
    create<T extends RoleCreateArgs>(args: SelectSubset<T, RoleCreateArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Roles.
     * @param {RoleCreateManyArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const role = await prisma.role.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RoleCreateManyArgs>(args?: SelectSubset<T, RoleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Roles and returns the data saved in the database.
     * @param {RoleCreateManyAndReturnArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const role = await prisma.role.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Roles and only return the `id`
     * const roleWithIdOnly = await prisma.role.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RoleCreateManyAndReturnArgs>(args?: SelectSubset<T, RoleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Role.
     * @param {RoleDeleteArgs} args - Arguments to delete one Role.
     * @example
     * // Delete one Role
     * const Role = await prisma.role.delete({
     *   where: {
     *     // ... filter to delete one Role
     *   }
     * })
     * 
     */
    delete<T extends RoleDeleteArgs>(args: SelectSubset<T, RoleDeleteArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Role.
     * @param {RoleUpdateArgs} args - Arguments to update one Role.
     * @example
     * // Update one Role
     * const role = await prisma.role.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RoleUpdateArgs>(args: SelectSubset<T, RoleUpdateArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Roles.
     * @param {RoleDeleteManyArgs} args - Arguments to filter Roles to delete.
     * @example
     * // Delete a few Roles
     * const { count } = await prisma.role.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RoleDeleteManyArgs>(args?: SelectSubset<T, RoleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Roles
     * const role = await prisma.role.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RoleUpdateManyArgs>(args: SelectSubset<T, RoleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Role.
     * @param {RoleUpsertArgs} args - Arguments to update or create a Role.
     * @example
     * // Update or create a Role
     * const role = await prisma.role.upsert({
     *   create: {
     *     // ... data to create a Role
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Role we want to update
     *   }
     * })
     */
    upsert<T extends RoleUpsertArgs>(args: SelectSubset<T, RoleUpsertArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleCountArgs} args - Arguments to filter Roles to count.
     * @example
     * // Count the number of Roles
     * const count = await prisma.role.count({
     *   where: {
     *     // ... the filter for the Roles we want to count
     *   }
     * })
    **/
    count<T extends RoleCountArgs>(
      args?: Subset<T, RoleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoleAggregateArgs>(args: Subset<T, RoleAggregateArgs>): Prisma.PrismaPromise<GetRoleAggregateType<T>>

    /**
     * Group by Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoleGroupByArgs['orderBy'] }
        : { orderBy?: RoleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Role model
   */
  readonly fields: RoleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Role.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    permissions<T extends Role$permissionsArgs<ExtArgs> = {}>(args?: Subset<T, Role$permissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findMany"> | Null>
    users<T extends Role$usersArgs<ExtArgs> = {}>(args?: Subset<T, Role$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Role model
   */ 
  interface RoleFieldRefs {
    readonly id: FieldRef<"Role", 'String'>
    readonly name: FieldRef<"Role", 'String'>
    readonly rank: FieldRef<"Role", 'Int'>
    readonly category: FieldRef<"Role", 'String'>
    readonly description: FieldRef<"Role", 'String'>
    readonly createdAt: FieldRef<"Role", 'DateTime'>
    readonly colorHex: FieldRef<"Role", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Role findUnique
   */
  export type RoleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role findUniqueOrThrow
   */
  export type RoleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role findFirst
   */
  export type RoleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role findFirstOrThrow
   */
  export type RoleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role findMany
   */
  export type RoleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Roles to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role create
   */
  export type RoleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The data needed to create a Role.
     */
    data: XOR<RoleCreateInput, RoleUncheckedCreateInput>
  }

  /**
   * Role createMany
   */
  export type RoleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Roles.
     */
    data: RoleCreateManyInput | RoleCreateManyInput[]
  }

  /**
   * Role createManyAndReturn
   */
  export type RoleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Roles.
     */
    data: RoleCreateManyInput | RoleCreateManyInput[]
  }

  /**
   * Role update
   */
  export type RoleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The data needed to update a Role.
     */
    data: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
    /**
     * Choose, which Role to update.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role updateMany
   */
  export type RoleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Roles.
     */
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyInput>
    /**
     * Filter which Roles to update
     */
    where?: RoleWhereInput
  }

  /**
   * Role upsert
   */
  export type RoleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The filter to search for the Role to update in case it exists.
     */
    where: RoleWhereUniqueInput
    /**
     * In case the Role found by the `where` argument doesn't exist, create a new Role with this data.
     */
    create: XOR<RoleCreateInput, RoleUncheckedCreateInput>
    /**
     * In case the Role was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
  }

  /**
   * Role delete
   */
  export type RoleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter which Role to delete.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role deleteMany
   */
  export type RoleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Roles to delete
     */
    where?: RoleWhereInput
  }

  /**
   * Role.permissions
   */
  export type Role$permissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    where?: RolePermissionWhereInput
    orderBy?: RolePermissionOrderByWithRelationInput | RolePermissionOrderByWithRelationInput[]
    cursor?: RolePermissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RolePermissionScalarFieldEnum | RolePermissionScalarFieldEnum[]
  }

  /**
   * Role.users
   */
  export type Role$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    where?: UserRoleWhereInput
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    cursor?: UserRoleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[]
  }

  /**
   * Role without action
   */
  export type RoleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
  }


  /**
   * Model Permission
   */

  export type AggregatePermission = {
    _count: PermissionCountAggregateOutputType | null
    _min: PermissionMinAggregateOutputType | null
    _max: PermissionMaxAggregateOutputType | null
  }

  export type PermissionMinAggregateOutputType = {
    id: string | null
    key: string | null
    description: string | null
    createdAt: Date | null
  }

  export type PermissionMaxAggregateOutputType = {
    id: string | null
    key: string | null
    description: string | null
    createdAt: Date | null
  }

  export type PermissionCountAggregateOutputType = {
    id: number
    key: number
    description: number
    createdAt: number
    _all: number
  }


  export type PermissionMinAggregateInputType = {
    id?: true
    key?: true
    description?: true
    createdAt?: true
  }

  export type PermissionMaxAggregateInputType = {
    id?: true
    key?: true
    description?: true
    createdAt?: true
  }

  export type PermissionCountAggregateInputType = {
    id?: true
    key?: true
    description?: true
    createdAt?: true
    _all?: true
  }

  export type PermissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Permission to aggregate.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Permissions
    **/
    _count?: true | PermissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PermissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PermissionMaxAggregateInputType
  }

  export type GetPermissionAggregateType<T extends PermissionAggregateArgs> = {
        [P in keyof T & keyof AggregatePermission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePermission[P]>
      : GetScalarType<T[P], AggregatePermission[P]>
  }




  export type PermissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PermissionWhereInput
    orderBy?: PermissionOrderByWithAggregationInput | PermissionOrderByWithAggregationInput[]
    by: PermissionScalarFieldEnum[] | PermissionScalarFieldEnum
    having?: PermissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PermissionCountAggregateInputType | true
    _min?: PermissionMinAggregateInputType
    _max?: PermissionMaxAggregateInputType
  }

  export type PermissionGroupByOutputType = {
    id: string
    key: string
    description: string | null
    createdAt: Date
    _count: PermissionCountAggregateOutputType | null
    _min: PermissionMinAggregateOutputType | null
    _max: PermissionMaxAggregateOutputType | null
  }

  type GetPermissionGroupByPayload<T extends PermissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PermissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PermissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PermissionGroupByOutputType[P]>
            : GetScalarType<T[P], PermissionGroupByOutputType[P]>
        }
      >
    >


  export type PermissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    description?: boolean
    createdAt?: boolean
    roles?: boolean | Permission$rolesArgs<ExtArgs>
    _count?: boolean | PermissionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["permission"]>

  export type PermissionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    description?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["permission"]>

  export type PermissionSelectScalar = {
    id?: boolean
    key?: boolean
    description?: boolean
    createdAt?: boolean
  }

  export type PermissionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    roles?: boolean | Permission$rolesArgs<ExtArgs>
    _count?: boolean | PermissionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PermissionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PermissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Permission"
    objects: {
      roles: Prisma.$RolePermissionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      key: string
      description: string | null
      createdAt: Date
    }, ExtArgs["result"]["permission"]>
    composites: {}
  }

  type PermissionGetPayload<S extends boolean | null | undefined | PermissionDefaultArgs> = $Result.GetResult<Prisma.$PermissionPayload, S>

  type PermissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PermissionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PermissionCountAggregateInputType | true
    }

  export interface PermissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Permission'], meta: { name: 'Permission' } }
    /**
     * Find zero or one Permission that matches the filter.
     * @param {PermissionFindUniqueArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PermissionFindUniqueArgs>(args: SelectSubset<T, PermissionFindUniqueArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Permission that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PermissionFindUniqueOrThrowArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PermissionFindUniqueOrThrowArgs>(args: SelectSubset<T, PermissionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Permission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionFindFirstArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PermissionFindFirstArgs>(args?: SelectSubset<T, PermissionFindFirstArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Permission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionFindFirstOrThrowArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PermissionFindFirstOrThrowArgs>(args?: SelectSubset<T, PermissionFindFirstOrThrowArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Permissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Permissions
     * const permissions = await prisma.permission.findMany()
     * 
     * // Get first 10 Permissions
     * const permissions = await prisma.permission.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const permissionWithIdOnly = await prisma.permission.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PermissionFindManyArgs>(args?: SelectSubset<T, PermissionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Permission.
     * @param {PermissionCreateArgs} args - Arguments to create a Permission.
     * @example
     * // Create one Permission
     * const Permission = await prisma.permission.create({
     *   data: {
     *     // ... data to create a Permission
     *   }
     * })
     * 
     */
    create<T extends PermissionCreateArgs>(args: SelectSubset<T, PermissionCreateArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Permissions.
     * @param {PermissionCreateManyArgs} args - Arguments to create many Permissions.
     * @example
     * // Create many Permissions
     * const permission = await prisma.permission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PermissionCreateManyArgs>(args?: SelectSubset<T, PermissionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Permissions and returns the data saved in the database.
     * @param {PermissionCreateManyAndReturnArgs} args - Arguments to create many Permissions.
     * @example
     * // Create many Permissions
     * const permission = await prisma.permission.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Permissions and only return the `id`
     * const permissionWithIdOnly = await prisma.permission.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PermissionCreateManyAndReturnArgs>(args?: SelectSubset<T, PermissionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Permission.
     * @param {PermissionDeleteArgs} args - Arguments to delete one Permission.
     * @example
     * // Delete one Permission
     * const Permission = await prisma.permission.delete({
     *   where: {
     *     // ... filter to delete one Permission
     *   }
     * })
     * 
     */
    delete<T extends PermissionDeleteArgs>(args: SelectSubset<T, PermissionDeleteArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Permission.
     * @param {PermissionUpdateArgs} args - Arguments to update one Permission.
     * @example
     * // Update one Permission
     * const permission = await prisma.permission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PermissionUpdateArgs>(args: SelectSubset<T, PermissionUpdateArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Permissions.
     * @param {PermissionDeleteManyArgs} args - Arguments to filter Permissions to delete.
     * @example
     * // Delete a few Permissions
     * const { count } = await prisma.permission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PermissionDeleteManyArgs>(args?: SelectSubset<T, PermissionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Permissions
     * const permission = await prisma.permission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PermissionUpdateManyArgs>(args: SelectSubset<T, PermissionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Permission.
     * @param {PermissionUpsertArgs} args - Arguments to update or create a Permission.
     * @example
     * // Update or create a Permission
     * const permission = await prisma.permission.upsert({
     *   create: {
     *     // ... data to create a Permission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Permission we want to update
     *   }
     * })
     */
    upsert<T extends PermissionUpsertArgs>(args: SelectSubset<T, PermissionUpsertArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionCountArgs} args - Arguments to filter Permissions to count.
     * @example
     * // Count the number of Permissions
     * const count = await prisma.permission.count({
     *   where: {
     *     // ... the filter for the Permissions we want to count
     *   }
     * })
    **/
    count<T extends PermissionCountArgs>(
      args?: Subset<T, PermissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PermissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Permission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PermissionAggregateArgs>(args: Subset<T, PermissionAggregateArgs>): Prisma.PrismaPromise<GetPermissionAggregateType<T>>

    /**
     * Group by Permission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PermissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PermissionGroupByArgs['orderBy'] }
        : { orderBy?: PermissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PermissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPermissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Permission model
   */
  readonly fields: PermissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Permission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PermissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    roles<T extends Permission$rolesArgs<ExtArgs> = {}>(args?: Subset<T, Permission$rolesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Permission model
   */ 
  interface PermissionFieldRefs {
    readonly id: FieldRef<"Permission", 'String'>
    readonly key: FieldRef<"Permission", 'String'>
    readonly description: FieldRef<"Permission", 'String'>
    readonly createdAt: FieldRef<"Permission", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Permission findUnique
   */
  export type PermissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permission to fetch.
     */
    where: PermissionWhereUniqueInput
  }

  /**
   * Permission findUniqueOrThrow
   */
  export type PermissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permission to fetch.
     */
    where: PermissionWhereUniqueInput
  }

  /**
   * Permission findFirst
   */
  export type PermissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permission to fetch.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Permissions.
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Permissions.
     */
    distinct?: PermissionScalarFieldEnum | PermissionScalarFieldEnum[]
  }

  /**
   * Permission findFirstOrThrow
   */
  export type PermissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permission to fetch.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Permissions.
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Permissions.
     */
    distinct?: PermissionScalarFieldEnum | PermissionScalarFieldEnum[]
  }

  /**
   * Permission findMany
   */
  export type PermissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permissions to fetch.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Permissions.
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    distinct?: PermissionScalarFieldEnum | PermissionScalarFieldEnum[]
  }

  /**
   * Permission create
   */
  export type PermissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * The data needed to create a Permission.
     */
    data: XOR<PermissionCreateInput, PermissionUncheckedCreateInput>
  }

  /**
   * Permission createMany
   */
  export type PermissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Permissions.
     */
    data: PermissionCreateManyInput | PermissionCreateManyInput[]
  }

  /**
   * Permission createManyAndReturn
   */
  export type PermissionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Permissions.
     */
    data: PermissionCreateManyInput | PermissionCreateManyInput[]
  }

  /**
   * Permission update
   */
  export type PermissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * The data needed to update a Permission.
     */
    data: XOR<PermissionUpdateInput, PermissionUncheckedUpdateInput>
    /**
     * Choose, which Permission to update.
     */
    where: PermissionWhereUniqueInput
  }

  /**
   * Permission updateMany
   */
  export type PermissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Permissions.
     */
    data: XOR<PermissionUpdateManyMutationInput, PermissionUncheckedUpdateManyInput>
    /**
     * Filter which Permissions to update
     */
    where?: PermissionWhereInput
  }

  /**
   * Permission upsert
   */
  export type PermissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * The filter to search for the Permission to update in case it exists.
     */
    where: PermissionWhereUniqueInput
    /**
     * In case the Permission found by the `where` argument doesn't exist, create a new Permission with this data.
     */
    create: XOR<PermissionCreateInput, PermissionUncheckedCreateInput>
    /**
     * In case the Permission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PermissionUpdateInput, PermissionUncheckedUpdateInput>
  }

  /**
   * Permission delete
   */
  export type PermissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter which Permission to delete.
     */
    where: PermissionWhereUniqueInput
  }

  /**
   * Permission deleteMany
   */
  export type PermissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Permissions to delete
     */
    where?: PermissionWhereInput
  }

  /**
   * Permission.roles
   */
  export type Permission$rolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    where?: RolePermissionWhereInput
    orderBy?: RolePermissionOrderByWithRelationInput | RolePermissionOrderByWithRelationInput[]
    cursor?: RolePermissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RolePermissionScalarFieldEnum | RolePermissionScalarFieldEnum[]
  }

  /**
   * Permission without action
   */
  export type PermissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
  }


  /**
   * Model RolePermission
   */

  export type AggregateRolePermission = {
    _count: RolePermissionCountAggregateOutputType | null
    _min: RolePermissionMinAggregateOutputType | null
    _max: RolePermissionMaxAggregateOutputType | null
  }

  export type RolePermissionMinAggregateOutputType = {
    roleId: string | null
    permissionId: string | null
  }

  export type RolePermissionMaxAggregateOutputType = {
    roleId: string | null
    permissionId: string | null
  }

  export type RolePermissionCountAggregateOutputType = {
    roleId: number
    permissionId: number
    _all: number
  }


  export type RolePermissionMinAggregateInputType = {
    roleId?: true
    permissionId?: true
  }

  export type RolePermissionMaxAggregateInputType = {
    roleId?: true
    permissionId?: true
  }

  export type RolePermissionCountAggregateInputType = {
    roleId?: true
    permissionId?: true
    _all?: true
  }

  export type RolePermissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RolePermission to aggregate.
     */
    where?: RolePermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolePermissions to fetch.
     */
    orderBy?: RolePermissionOrderByWithRelationInput | RolePermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RolePermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolePermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RolePermissions
    **/
    _count?: true | RolePermissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RolePermissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RolePermissionMaxAggregateInputType
  }

  export type GetRolePermissionAggregateType<T extends RolePermissionAggregateArgs> = {
        [P in keyof T & keyof AggregateRolePermission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRolePermission[P]>
      : GetScalarType<T[P], AggregateRolePermission[P]>
  }




  export type RolePermissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RolePermissionWhereInput
    orderBy?: RolePermissionOrderByWithAggregationInput | RolePermissionOrderByWithAggregationInput[]
    by: RolePermissionScalarFieldEnum[] | RolePermissionScalarFieldEnum
    having?: RolePermissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RolePermissionCountAggregateInputType | true
    _min?: RolePermissionMinAggregateInputType
    _max?: RolePermissionMaxAggregateInputType
  }

  export type RolePermissionGroupByOutputType = {
    roleId: string
    permissionId: string
    _count: RolePermissionCountAggregateOutputType | null
    _min: RolePermissionMinAggregateOutputType | null
    _max: RolePermissionMaxAggregateOutputType | null
  }

  type GetRolePermissionGroupByPayload<T extends RolePermissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RolePermissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RolePermissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RolePermissionGroupByOutputType[P]>
            : GetScalarType<T[P], RolePermissionGroupByOutputType[P]>
        }
      >
    >


  export type RolePermissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    roleId?: boolean
    permissionId?: boolean
    role?: boolean | RoleDefaultArgs<ExtArgs>
    permission?: boolean | PermissionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rolePermission"]>

  export type RolePermissionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    roleId?: boolean
    permissionId?: boolean
    role?: boolean | RoleDefaultArgs<ExtArgs>
    permission?: boolean | PermissionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rolePermission"]>

  export type RolePermissionSelectScalar = {
    roleId?: boolean
    permissionId?: boolean
  }

  export type RolePermissionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    role?: boolean | RoleDefaultArgs<ExtArgs>
    permission?: boolean | PermissionDefaultArgs<ExtArgs>
  }
  export type RolePermissionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    role?: boolean | RoleDefaultArgs<ExtArgs>
    permission?: boolean | PermissionDefaultArgs<ExtArgs>
  }

  export type $RolePermissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RolePermission"
    objects: {
      role: Prisma.$RolePayload<ExtArgs>
      permission: Prisma.$PermissionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      roleId: string
      permissionId: string
    }, ExtArgs["result"]["rolePermission"]>
    composites: {}
  }

  type RolePermissionGetPayload<S extends boolean | null | undefined | RolePermissionDefaultArgs> = $Result.GetResult<Prisma.$RolePermissionPayload, S>

  type RolePermissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RolePermissionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RolePermissionCountAggregateInputType | true
    }

  export interface RolePermissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RolePermission'], meta: { name: 'RolePermission' } }
    /**
     * Find zero or one RolePermission that matches the filter.
     * @param {RolePermissionFindUniqueArgs} args - Arguments to find a RolePermission
     * @example
     * // Get one RolePermission
     * const rolePermission = await prisma.rolePermission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RolePermissionFindUniqueArgs>(args: SelectSubset<T, RolePermissionFindUniqueArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one RolePermission that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RolePermissionFindUniqueOrThrowArgs} args - Arguments to find a RolePermission
     * @example
     * // Get one RolePermission
     * const rolePermission = await prisma.rolePermission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RolePermissionFindUniqueOrThrowArgs>(args: SelectSubset<T, RolePermissionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first RolePermission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionFindFirstArgs} args - Arguments to find a RolePermission
     * @example
     * // Get one RolePermission
     * const rolePermission = await prisma.rolePermission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RolePermissionFindFirstArgs>(args?: SelectSubset<T, RolePermissionFindFirstArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first RolePermission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionFindFirstOrThrowArgs} args - Arguments to find a RolePermission
     * @example
     * // Get one RolePermission
     * const rolePermission = await prisma.rolePermission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RolePermissionFindFirstOrThrowArgs>(args?: SelectSubset<T, RolePermissionFindFirstOrThrowArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more RolePermissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RolePermissions
     * const rolePermissions = await prisma.rolePermission.findMany()
     * 
     * // Get first 10 RolePermissions
     * const rolePermissions = await prisma.rolePermission.findMany({ take: 10 })
     * 
     * // Only select the `roleId`
     * const rolePermissionWithRoleIdOnly = await prisma.rolePermission.findMany({ select: { roleId: true } })
     * 
     */
    findMany<T extends RolePermissionFindManyArgs>(args?: SelectSubset<T, RolePermissionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a RolePermission.
     * @param {RolePermissionCreateArgs} args - Arguments to create a RolePermission.
     * @example
     * // Create one RolePermission
     * const RolePermission = await prisma.rolePermission.create({
     *   data: {
     *     // ... data to create a RolePermission
     *   }
     * })
     * 
     */
    create<T extends RolePermissionCreateArgs>(args: SelectSubset<T, RolePermissionCreateArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many RolePermissions.
     * @param {RolePermissionCreateManyArgs} args - Arguments to create many RolePermissions.
     * @example
     * // Create many RolePermissions
     * const rolePermission = await prisma.rolePermission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RolePermissionCreateManyArgs>(args?: SelectSubset<T, RolePermissionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RolePermissions and returns the data saved in the database.
     * @param {RolePermissionCreateManyAndReturnArgs} args - Arguments to create many RolePermissions.
     * @example
     * // Create many RolePermissions
     * const rolePermission = await prisma.rolePermission.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RolePermissions and only return the `roleId`
     * const rolePermissionWithRoleIdOnly = await prisma.rolePermission.createManyAndReturn({ 
     *   select: { roleId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RolePermissionCreateManyAndReturnArgs>(args?: SelectSubset<T, RolePermissionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a RolePermission.
     * @param {RolePermissionDeleteArgs} args - Arguments to delete one RolePermission.
     * @example
     * // Delete one RolePermission
     * const RolePermission = await prisma.rolePermission.delete({
     *   where: {
     *     // ... filter to delete one RolePermission
     *   }
     * })
     * 
     */
    delete<T extends RolePermissionDeleteArgs>(args: SelectSubset<T, RolePermissionDeleteArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one RolePermission.
     * @param {RolePermissionUpdateArgs} args - Arguments to update one RolePermission.
     * @example
     * // Update one RolePermission
     * const rolePermission = await prisma.rolePermission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RolePermissionUpdateArgs>(args: SelectSubset<T, RolePermissionUpdateArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more RolePermissions.
     * @param {RolePermissionDeleteManyArgs} args - Arguments to filter RolePermissions to delete.
     * @example
     * // Delete a few RolePermissions
     * const { count } = await prisma.rolePermission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RolePermissionDeleteManyArgs>(args?: SelectSubset<T, RolePermissionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RolePermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RolePermissions
     * const rolePermission = await prisma.rolePermission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RolePermissionUpdateManyArgs>(args: SelectSubset<T, RolePermissionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RolePermission.
     * @param {RolePermissionUpsertArgs} args - Arguments to update or create a RolePermission.
     * @example
     * // Update or create a RolePermission
     * const rolePermission = await prisma.rolePermission.upsert({
     *   create: {
     *     // ... data to create a RolePermission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RolePermission we want to update
     *   }
     * })
     */
    upsert<T extends RolePermissionUpsertArgs>(args: SelectSubset<T, RolePermissionUpsertArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of RolePermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionCountArgs} args - Arguments to filter RolePermissions to count.
     * @example
     * // Count the number of RolePermissions
     * const count = await prisma.rolePermission.count({
     *   where: {
     *     // ... the filter for the RolePermissions we want to count
     *   }
     * })
    **/
    count<T extends RolePermissionCountArgs>(
      args?: Subset<T, RolePermissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RolePermissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RolePermission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RolePermissionAggregateArgs>(args: Subset<T, RolePermissionAggregateArgs>): Prisma.PrismaPromise<GetRolePermissionAggregateType<T>>

    /**
     * Group by RolePermission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RolePermissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RolePermissionGroupByArgs['orderBy'] }
        : { orderBy?: RolePermissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RolePermissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRolePermissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RolePermission model
   */
  readonly fields: RolePermissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RolePermission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RolePermissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    role<T extends RoleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoleDefaultArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    permission<T extends PermissionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PermissionDefaultArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RolePermission model
   */ 
  interface RolePermissionFieldRefs {
    readonly roleId: FieldRef<"RolePermission", 'String'>
    readonly permissionId: FieldRef<"RolePermission", 'String'>
  }
    

  // Custom InputTypes
  /**
   * RolePermission findUnique
   */
  export type RolePermissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * Filter, which RolePermission to fetch.
     */
    where: RolePermissionWhereUniqueInput
  }

  /**
   * RolePermission findUniqueOrThrow
   */
  export type RolePermissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * Filter, which RolePermission to fetch.
     */
    where: RolePermissionWhereUniqueInput
  }

  /**
   * RolePermission findFirst
   */
  export type RolePermissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * Filter, which RolePermission to fetch.
     */
    where?: RolePermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolePermissions to fetch.
     */
    orderBy?: RolePermissionOrderByWithRelationInput | RolePermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RolePermissions.
     */
    cursor?: RolePermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolePermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RolePermissions.
     */
    distinct?: RolePermissionScalarFieldEnum | RolePermissionScalarFieldEnum[]
  }

  /**
   * RolePermission findFirstOrThrow
   */
  export type RolePermissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * Filter, which RolePermission to fetch.
     */
    where?: RolePermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolePermissions to fetch.
     */
    orderBy?: RolePermissionOrderByWithRelationInput | RolePermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RolePermissions.
     */
    cursor?: RolePermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolePermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RolePermissions.
     */
    distinct?: RolePermissionScalarFieldEnum | RolePermissionScalarFieldEnum[]
  }

  /**
   * RolePermission findMany
   */
  export type RolePermissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * Filter, which RolePermissions to fetch.
     */
    where?: RolePermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolePermissions to fetch.
     */
    orderBy?: RolePermissionOrderByWithRelationInput | RolePermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RolePermissions.
     */
    cursor?: RolePermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolePermissions.
     */
    skip?: number
    distinct?: RolePermissionScalarFieldEnum | RolePermissionScalarFieldEnum[]
  }

  /**
   * RolePermission create
   */
  export type RolePermissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * The data needed to create a RolePermission.
     */
    data: XOR<RolePermissionCreateInput, RolePermissionUncheckedCreateInput>
  }

  /**
   * RolePermission createMany
   */
  export type RolePermissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RolePermissions.
     */
    data: RolePermissionCreateManyInput | RolePermissionCreateManyInput[]
  }

  /**
   * RolePermission createManyAndReturn
   */
  export type RolePermissionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many RolePermissions.
     */
    data: RolePermissionCreateManyInput | RolePermissionCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RolePermission update
   */
  export type RolePermissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * The data needed to update a RolePermission.
     */
    data: XOR<RolePermissionUpdateInput, RolePermissionUncheckedUpdateInput>
    /**
     * Choose, which RolePermission to update.
     */
    where: RolePermissionWhereUniqueInput
  }

  /**
   * RolePermission updateMany
   */
  export type RolePermissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RolePermissions.
     */
    data: XOR<RolePermissionUpdateManyMutationInput, RolePermissionUncheckedUpdateManyInput>
    /**
     * Filter which RolePermissions to update
     */
    where?: RolePermissionWhereInput
  }

  /**
   * RolePermission upsert
   */
  export type RolePermissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * The filter to search for the RolePermission to update in case it exists.
     */
    where: RolePermissionWhereUniqueInput
    /**
     * In case the RolePermission found by the `where` argument doesn't exist, create a new RolePermission with this data.
     */
    create: XOR<RolePermissionCreateInput, RolePermissionUncheckedCreateInput>
    /**
     * In case the RolePermission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RolePermissionUpdateInput, RolePermissionUncheckedUpdateInput>
  }

  /**
   * RolePermission delete
   */
  export type RolePermissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * Filter which RolePermission to delete.
     */
    where: RolePermissionWhereUniqueInput
  }

  /**
   * RolePermission deleteMany
   */
  export type RolePermissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RolePermissions to delete
     */
    where?: RolePermissionWhereInput
  }

  /**
   * RolePermission without action
   */
  export type RolePermissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
  }


  /**
   * Model UserRole
   */

  export type AggregateUserRole = {
    _count: UserRoleCountAggregateOutputType | null
    _min: UserRoleMinAggregateOutputType | null
    _max: UserRoleMaxAggregateOutputType | null
  }

  export type UserRoleMinAggregateOutputType = {
    userId: string | null
    roleId: string | null
  }

  export type UserRoleMaxAggregateOutputType = {
    userId: string | null
    roleId: string | null
  }

  export type UserRoleCountAggregateOutputType = {
    userId: number
    roleId: number
    _all: number
  }


  export type UserRoleMinAggregateInputType = {
    userId?: true
    roleId?: true
  }

  export type UserRoleMaxAggregateInputType = {
    userId?: true
    roleId?: true
  }

  export type UserRoleCountAggregateInputType = {
    userId?: true
    roleId?: true
    _all?: true
  }

  export type UserRoleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserRole to aggregate.
     */
    where?: UserRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoles to fetch.
     */
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserRoles
    **/
    _count?: true | UserRoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserRoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserRoleMaxAggregateInputType
  }

  export type GetUserRoleAggregateType<T extends UserRoleAggregateArgs> = {
        [P in keyof T & keyof AggregateUserRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserRole[P]>
      : GetScalarType<T[P], AggregateUserRole[P]>
  }




  export type UserRoleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserRoleWhereInput
    orderBy?: UserRoleOrderByWithAggregationInput | UserRoleOrderByWithAggregationInput[]
    by: UserRoleScalarFieldEnum[] | UserRoleScalarFieldEnum
    having?: UserRoleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserRoleCountAggregateInputType | true
    _min?: UserRoleMinAggregateInputType
    _max?: UserRoleMaxAggregateInputType
  }

  export type UserRoleGroupByOutputType = {
    userId: string
    roleId: string
    _count: UserRoleCountAggregateOutputType | null
    _min: UserRoleMinAggregateOutputType | null
    _max: UserRoleMaxAggregateOutputType | null
  }

  type GetUserRoleGroupByPayload<T extends UserRoleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserRoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserRoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserRoleGroupByOutputType[P]>
            : GetScalarType<T[P], UserRoleGroupByOutputType[P]>
        }
      >
    >


  export type UserRoleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    roleId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userRole"]>

  export type UserRoleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    roleId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userRole"]>

  export type UserRoleSelectScalar = {
    userId?: boolean
    roleId?: boolean
  }

  export type UserRoleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }
  export type UserRoleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }

  export type $UserRolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserRole"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      role: Prisma.$RolePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      userId: string
      roleId: string
    }, ExtArgs["result"]["userRole"]>
    composites: {}
  }

  type UserRoleGetPayload<S extends boolean | null | undefined | UserRoleDefaultArgs> = $Result.GetResult<Prisma.$UserRolePayload, S>

  type UserRoleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserRoleFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserRoleCountAggregateInputType | true
    }

  export interface UserRoleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserRole'], meta: { name: 'UserRole' } }
    /**
     * Find zero or one UserRole that matches the filter.
     * @param {UserRoleFindUniqueArgs} args - Arguments to find a UserRole
     * @example
     * // Get one UserRole
     * const userRole = await prisma.userRole.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserRoleFindUniqueArgs>(args: SelectSubset<T, UserRoleFindUniqueArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UserRole that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserRoleFindUniqueOrThrowArgs} args - Arguments to find a UserRole
     * @example
     * // Get one UserRole
     * const userRole = await prisma.userRole.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserRoleFindUniqueOrThrowArgs>(args: SelectSubset<T, UserRoleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UserRole that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleFindFirstArgs} args - Arguments to find a UserRole
     * @example
     * // Get one UserRole
     * const userRole = await prisma.userRole.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserRoleFindFirstArgs>(args?: SelectSubset<T, UserRoleFindFirstArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UserRole that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleFindFirstOrThrowArgs} args - Arguments to find a UserRole
     * @example
     * // Get one UserRole
     * const userRole = await prisma.userRole.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserRoleFindFirstOrThrowArgs>(args?: SelectSubset<T, UserRoleFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UserRoles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserRoles
     * const userRoles = await prisma.userRole.findMany()
     * 
     * // Get first 10 UserRoles
     * const userRoles = await prisma.userRole.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const userRoleWithUserIdOnly = await prisma.userRole.findMany({ select: { userId: true } })
     * 
     */
    findMany<T extends UserRoleFindManyArgs>(args?: SelectSubset<T, UserRoleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UserRole.
     * @param {UserRoleCreateArgs} args - Arguments to create a UserRole.
     * @example
     * // Create one UserRole
     * const UserRole = await prisma.userRole.create({
     *   data: {
     *     // ... data to create a UserRole
     *   }
     * })
     * 
     */
    create<T extends UserRoleCreateArgs>(args: SelectSubset<T, UserRoleCreateArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UserRoles.
     * @param {UserRoleCreateManyArgs} args - Arguments to create many UserRoles.
     * @example
     * // Create many UserRoles
     * const userRole = await prisma.userRole.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserRoleCreateManyArgs>(args?: SelectSubset<T, UserRoleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserRoles and returns the data saved in the database.
     * @param {UserRoleCreateManyAndReturnArgs} args - Arguments to create many UserRoles.
     * @example
     * // Create many UserRoles
     * const userRole = await prisma.userRole.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserRoles and only return the `userId`
     * const userRoleWithUserIdOnly = await prisma.userRole.createManyAndReturn({ 
     *   select: { userId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserRoleCreateManyAndReturnArgs>(args?: SelectSubset<T, UserRoleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a UserRole.
     * @param {UserRoleDeleteArgs} args - Arguments to delete one UserRole.
     * @example
     * // Delete one UserRole
     * const UserRole = await prisma.userRole.delete({
     *   where: {
     *     // ... filter to delete one UserRole
     *   }
     * })
     * 
     */
    delete<T extends UserRoleDeleteArgs>(args: SelectSubset<T, UserRoleDeleteArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UserRole.
     * @param {UserRoleUpdateArgs} args - Arguments to update one UserRole.
     * @example
     * // Update one UserRole
     * const userRole = await prisma.userRole.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserRoleUpdateArgs>(args: SelectSubset<T, UserRoleUpdateArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UserRoles.
     * @param {UserRoleDeleteManyArgs} args - Arguments to filter UserRoles to delete.
     * @example
     * // Delete a few UserRoles
     * const { count } = await prisma.userRole.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserRoleDeleteManyArgs>(args?: SelectSubset<T, UserRoleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserRoles
     * const userRole = await prisma.userRole.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserRoleUpdateManyArgs>(args: SelectSubset<T, UserRoleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserRole.
     * @param {UserRoleUpsertArgs} args - Arguments to update or create a UserRole.
     * @example
     * // Update or create a UserRole
     * const userRole = await prisma.userRole.upsert({
     *   create: {
     *     // ... data to create a UserRole
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserRole we want to update
     *   }
     * })
     */
    upsert<T extends UserRoleUpsertArgs>(args: SelectSubset<T, UserRoleUpsertArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UserRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleCountArgs} args - Arguments to filter UserRoles to count.
     * @example
     * // Count the number of UserRoles
     * const count = await prisma.userRole.count({
     *   where: {
     *     // ... the filter for the UserRoles we want to count
     *   }
     * })
    **/
    count<T extends UserRoleCountArgs>(
      args?: Subset<T, UserRoleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserRoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserRole.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserRoleAggregateArgs>(args: Subset<T, UserRoleAggregateArgs>): Prisma.PrismaPromise<GetUserRoleAggregateType<T>>

    /**
     * Group by UserRole.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserRoleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserRoleGroupByArgs['orderBy'] }
        : { orderBy?: UserRoleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserRoleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserRoleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserRole model
   */
  readonly fields: UserRoleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserRole.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserRoleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    role<T extends RoleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoleDefaultArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserRole model
   */ 
  interface UserRoleFieldRefs {
    readonly userId: FieldRef<"UserRole", 'String'>
    readonly roleId: FieldRef<"UserRole", 'String'>
  }
    

  // Custom InputTypes
  /**
   * UserRole findUnique
   */
  export type UserRoleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter, which UserRole to fetch.
     */
    where: UserRoleWhereUniqueInput
  }

  /**
   * UserRole findUniqueOrThrow
   */
  export type UserRoleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter, which UserRole to fetch.
     */
    where: UserRoleWhereUniqueInput
  }

  /**
   * UserRole findFirst
   */
  export type UserRoleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter, which UserRole to fetch.
     */
    where?: UserRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoles to fetch.
     */
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserRoles.
     */
    cursor?: UserRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserRoles.
     */
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[]
  }

  /**
   * UserRole findFirstOrThrow
   */
  export type UserRoleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter, which UserRole to fetch.
     */
    where?: UserRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoles to fetch.
     */
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserRoles.
     */
    cursor?: UserRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserRoles.
     */
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[]
  }

  /**
   * UserRole findMany
   */
  export type UserRoleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter, which UserRoles to fetch.
     */
    where?: UserRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoles to fetch.
     */
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserRoles.
     */
    cursor?: UserRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoles.
     */
    skip?: number
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[]
  }

  /**
   * UserRole create
   */
  export type UserRoleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * The data needed to create a UserRole.
     */
    data: XOR<UserRoleCreateInput, UserRoleUncheckedCreateInput>
  }

  /**
   * UserRole createMany
   */
  export type UserRoleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserRoles.
     */
    data: UserRoleCreateManyInput | UserRoleCreateManyInput[]
  }

  /**
   * UserRole createManyAndReturn
   */
  export type UserRoleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many UserRoles.
     */
    data: UserRoleCreateManyInput | UserRoleCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserRole update
   */
  export type UserRoleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * The data needed to update a UserRole.
     */
    data: XOR<UserRoleUpdateInput, UserRoleUncheckedUpdateInput>
    /**
     * Choose, which UserRole to update.
     */
    where: UserRoleWhereUniqueInput
  }

  /**
   * UserRole updateMany
   */
  export type UserRoleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserRoles.
     */
    data: XOR<UserRoleUpdateManyMutationInput, UserRoleUncheckedUpdateManyInput>
    /**
     * Filter which UserRoles to update
     */
    where?: UserRoleWhereInput
  }

  /**
   * UserRole upsert
   */
  export type UserRoleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * The filter to search for the UserRole to update in case it exists.
     */
    where: UserRoleWhereUniqueInput
    /**
     * In case the UserRole found by the `where` argument doesn't exist, create a new UserRole with this data.
     */
    create: XOR<UserRoleCreateInput, UserRoleUncheckedCreateInput>
    /**
     * In case the UserRole was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserRoleUpdateInput, UserRoleUncheckedUpdateInput>
  }

  /**
   * UserRole delete
   */
  export type UserRoleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter which UserRole to delete.
     */
    where: UserRoleWhereUniqueInput
  }

  /**
   * UserRole deleteMany
   */
  export type UserRoleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserRoles to delete
     */
    where?: UserRoleWhereInput
  }

  /**
   * UserRole without action
   */
  export type UserRoleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
  }


  /**
   * Model WhitelistConfig
   */

  export type AggregateWhitelistConfig = {
    _count: WhitelistConfigCountAggregateOutputType | null
    _min: WhitelistConfigMinAggregateOutputType | null
    _max: WhitelistConfigMaxAggregateOutputType | null
  }

  export type WhitelistConfigMinAggregateOutputType = {
    id: string | null
    enabled: boolean | null
    pausedUntil: Date | null
    successTitle: string | null
    successBody: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WhitelistConfigMaxAggregateOutputType = {
    id: string | null
    enabled: boolean | null
    pausedUntil: Date | null
    successTitle: string | null
    successBody: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WhitelistConfigCountAggregateOutputType = {
    id: number
    enabled: number
    pausedUntil: number
    successTitle: number
    successBody: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WhitelistConfigMinAggregateInputType = {
    id?: true
    enabled?: true
    pausedUntil?: true
    successTitle?: true
    successBody?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WhitelistConfigMaxAggregateInputType = {
    id?: true
    enabled?: true
    pausedUntil?: true
    successTitle?: true
    successBody?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WhitelistConfigCountAggregateInputType = {
    id?: true
    enabled?: true
    pausedUntil?: true
    successTitle?: true
    successBody?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WhitelistConfigAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WhitelistConfig to aggregate.
     */
    where?: WhitelistConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WhitelistConfigs to fetch.
     */
    orderBy?: WhitelistConfigOrderByWithRelationInput | WhitelistConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WhitelistConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WhitelistConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WhitelistConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WhitelistConfigs
    **/
    _count?: true | WhitelistConfigCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WhitelistConfigMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WhitelistConfigMaxAggregateInputType
  }

  export type GetWhitelistConfigAggregateType<T extends WhitelistConfigAggregateArgs> = {
        [P in keyof T & keyof AggregateWhitelistConfig]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWhitelistConfig[P]>
      : GetScalarType<T[P], AggregateWhitelistConfig[P]>
  }




  export type WhitelistConfigGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WhitelistConfigWhereInput
    orderBy?: WhitelistConfigOrderByWithAggregationInput | WhitelistConfigOrderByWithAggregationInput[]
    by: WhitelistConfigScalarFieldEnum[] | WhitelistConfigScalarFieldEnum
    having?: WhitelistConfigScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WhitelistConfigCountAggregateInputType | true
    _min?: WhitelistConfigMinAggregateInputType
    _max?: WhitelistConfigMaxAggregateInputType
  }

  export type WhitelistConfigGroupByOutputType = {
    id: string
    enabled: boolean
    pausedUntil: Date | null
    successTitle: string
    successBody: string
    createdAt: Date
    updatedAt: Date
    _count: WhitelistConfigCountAggregateOutputType | null
    _min: WhitelistConfigMinAggregateOutputType | null
    _max: WhitelistConfigMaxAggregateOutputType | null
  }

  type GetWhitelistConfigGroupByPayload<T extends WhitelistConfigGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WhitelistConfigGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WhitelistConfigGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WhitelistConfigGroupByOutputType[P]>
            : GetScalarType<T[P], WhitelistConfigGroupByOutputType[P]>
        }
      >
    >


  export type WhitelistConfigSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    enabled?: boolean
    pausedUntil?: boolean
    successTitle?: boolean
    successBody?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["whitelistConfig"]>

  export type WhitelistConfigSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    enabled?: boolean
    pausedUntil?: boolean
    successTitle?: boolean
    successBody?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["whitelistConfig"]>

  export type WhitelistConfigSelectScalar = {
    id?: boolean
    enabled?: boolean
    pausedUntil?: boolean
    successTitle?: boolean
    successBody?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $WhitelistConfigPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WhitelistConfig"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      enabled: boolean
      pausedUntil: Date | null
      successTitle: string
      successBody: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["whitelistConfig"]>
    composites: {}
  }

  type WhitelistConfigGetPayload<S extends boolean | null | undefined | WhitelistConfigDefaultArgs> = $Result.GetResult<Prisma.$WhitelistConfigPayload, S>

  type WhitelistConfigCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WhitelistConfigFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WhitelistConfigCountAggregateInputType | true
    }

  export interface WhitelistConfigDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WhitelistConfig'], meta: { name: 'WhitelistConfig' } }
    /**
     * Find zero or one WhitelistConfig that matches the filter.
     * @param {WhitelistConfigFindUniqueArgs} args - Arguments to find a WhitelistConfig
     * @example
     * // Get one WhitelistConfig
     * const whitelistConfig = await prisma.whitelistConfig.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WhitelistConfigFindUniqueArgs>(args: SelectSubset<T, WhitelistConfigFindUniqueArgs<ExtArgs>>): Prisma__WhitelistConfigClient<$Result.GetResult<Prisma.$WhitelistConfigPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one WhitelistConfig that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WhitelistConfigFindUniqueOrThrowArgs} args - Arguments to find a WhitelistConfig
     * @example
     * // Get one WhitelistConfig
     * const whitelistConfig = await prisma.whitelistConfig.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WhitelistConfigFindUniqueOrThrowArgs>(args: SelectSubset<T, WhitelistConfigFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WhitelistConfigClient<$Result.GetResult<Prisma.$WhitelistConfigPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first WhitelistConfig that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhitelistConfigFindFirstArgs} args - Arguments to find a WhitelistConfig
     * @example
     * // Get one WhitelistConfig
     * const whitelistConfig = await prisma.whitelistConfig.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WhitelistConfigFindFirstArgs>(args?: SelectSubset<T, WhitelistConfigFindFirstArgs<ExtArgs>>): Prisma__WhitelistConfigClient<$Result.GetResult<Prisma.$WhitelistConfigPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first WhitelistConfig that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhitelistConfigFindFirstOrThrowArgs} args - Arguments to find a WhitelistConfig
     * @example
     * // Get one WhitelistConfig
     * const whitelistConfig = await prisma.whitelistConfig.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WhitelistConfigFindFirstOrThrowArgs>(args?: SelectSubset<T, WhitelistConfigFindFirstOrThrowArgs<ExtArgs>>): Prisma__WhitelistConfigClient<$Result.GetResult<Prisma.$WhitelistConfigPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more WhitelistConfigs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhitelistConfigFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WhitelistConfigs
     * const whitelistConfigs = await prisma.whitelistConfig.findMany()
     * 
     * // Get first 10 WhitelistConfigs
     * const whitelistConfigs = await prisma.whitelistConfig.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const whitelistConfigWithIdOnly = await prisma.whitelistConfig.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WhitelistConfigFindManyArgs>(args?: SelectSubset<T, WhitelistConfigFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WhitelistConfigPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a WhitelistConfig.
     * @param {WhitelistConfigCreateArgs} args - Arguments to create a WhitelistConfig.
     * @example
     * // Create one WhitelistConfig
     * const WhitelistConfig = await prisma.whitelistConfig.create({
     *   data: {
     *     // ... data to create a WhitelistConfig
     *   }
     * })
     * 
     */
    create<T extends WhitelistConfigCreateArgs>(args: SelectSubset<T, WhitelistConfigCreateArgs<ExtArgs>>): Prisma__WhitelistConfigClient<$Result.GetResult<Prisma.$WhitelistConfigPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many WhitelistConfigs.
     * @param {WhitelistConfigCreateManyArgs} args - Arguments to create many WhitelistConfigs.
     * @example
     * // Create many WhitelistConfigs
     * const whitelistConfig = await prisma.whitelistConfig.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WhitelistConfigCreateManyArgs>(args?: SelectSubset<T, WhitelistConfigCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WhitelistConfigs and returns the data saved in the database.
     * @param {WhitelistConfigCreateManyAndReturnArgs} args - Arguments to create many WhitelistConfigs.
     * @example
     * // Create many WhitelistConfigs
     * const whitelistConfig = await prisma.whitelistConfig.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WhitelistConfigs and only return the `id`
     * const whitelistConfigWithIdOnly = await prisma.whitelistConfig.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WhitelistConfigCreateManyAndReturnArgs>(args?: SelectSubset<T, WhitelistConfigCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WhitelistConfigPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a WhitelistConfig.
     * @param {WhitelistConfigDeleteArgs} args - Arguments to delete one WhitelistConfig.
     * @example
     * // Delete one WhitelistConfig
     * const WhitelistConfig = await prisma.whitelistConfig.delete({
     *   where: {
     *     // ... filter to delete one WhitelistConfig
     *   }
     * })
     * 
     */
    delete<T extends WhitelistConfigDeleteArgs>(args: SelectSubset<T, WhitelistConfigDeleteArgs<ExtArgs>>): Prisma__WhitelistConfigClient<$Result.GetResult<Prisma.$WhitelistConfigPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one WhitelistConfig.
     * @param {WhitelistConfigUpdateArgs} args - Arguments to update one WhitelistConfig.
     * @example
     * // Update one WhitelistConfig
     * const whitelistConfig = await prisma.whitelistConfig.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WhitelistConfigUpdateArgs>(args: SelectSubset<T, WhitelistConfigUpdateArgs<ExtArgs>>): Prisma__WhitelistConfigClient<$Result.GetResult<Prisma.$WhitelistConfigPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more WhitelistConfigs.
     * @param {WhitelistConfigDeleteManyArgs} args - Arguments to filter WhitelistConfigs to delete.
     * @example
     * // Delete a few WhitelistConfigs
     * const { count } = await prisma.whitelistConfig.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WhitelistConfigDeleteManyArgs>(args?: SelectSubset<T, WhitelistConfigDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WhitelistConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhitelistConfigUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WhitelistConfigs
     * const whitelistConfig = await prisma.whitelistConfig.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WhitelistConfigUpdateManyArgs>(args: SelectSubset<T, WhitelistConfigUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WhitelistConfig.
     * @param {WhitelistConfigUpsertArgs} args - Arguments to update or create a WhitelistConfig.
     * @example
     * // Update or create a WhitelistConfig
     * const whitelistConfig = await prisma.whitelistConfig.upsert({
     *   create: {
     *     // ... data to create a WhitelistConfig
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WhitelistConfig we want to update
     *   }
     * })
     */
    upsert<T extends WhitelistConfigUpsertArgs>(args: SelectSubset<T, WhitelistConfigUpsertArgs<ExtArgs>>): Prisma__WhitelistConfigClient<$Result.GetResult<Prisma.$WhitelistConfigPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of WhitelistConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhitelistConfigCountArgs} args - Arguments to filter WhitelistConfigs to count.
     * @example
     * // Count the number of WhitelistConfigs
     * const count = await prisma.whitelistConfig.count({
     *   where: {
     *     // ... the filter for the WhitelistConfigs we want to count
     *   }
     * })
    **/
    count<T extends WhitelistConfigCountArgs>(
      args?: Subset<T, WhitelistConfigCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WhitelistConfigCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WhitelistConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhitelistConfigAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WhitelistConfigAggregateArgs>(args: Subset<T, WhitelistConfigAggregateArgs>): Prisma.PrismaPromise<GetWhitelistConfigAggregateType<T>>

    /**
     * Group by WhitelistConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhitelistConfigGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WhitelistConfigGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WhitelistConfigGroupByArgs['orderBy'] }
        : { orderBy?: WhitelistConfigGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WhitelistConfigGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWhitelistConfigGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WhitelistConfig model
   */
  readonly fields: WhitelistConfigFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WhitelistConfig.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WhitelistConfigClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WhitelistConfig model
   */ 
  interface WhitelistConfigFieldRefs {
    readonly id: FieldRef<"WhitelistConfig", 'String'>
    readonly enabled: FieldRef<"WhitelistConfig", 'Boolean'>
    readonly pausedUntil: FieldRef<"WhitelistConfig", 'DateTime'>
    readonly successTitle: FieldRef<"WhitelistConfig", 'String'>
    readonly successBody: FieldRef<"WhitelistConfig", 'String'>
    readonly createdAt: FieldRef<"WhitelistConfig", 'DateTime'>
    readonly updatedAt: FieldRef<"WhitelistConfig", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WhitelistConfig findUnique
   */
  export type WhitelistConfigFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhitelistConfig
     */
    select?: WhitelistConfigSelect<ExtArgs> | null
    /**
     * Filter, which WhitelistConfig to fetch.
     */
    where: WhitelistConfigWhereUniqueInput
  }

  /**
   * WhitelistConfig findUniqueOrThrow
   */
  export type WhitelistConfigFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhitelistConfig
     */
    select?: WhitelistConfigSelect<ExtArgs> | null
    /**
     * Filter, which WhitelistConfig to fetch.
     */
    where: WhitelistConfigWhereUniqueInput
  }

  /**
   * WhitelistConfig findFirst
   */
  export type WhitelistConfigFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhitelistConfig
     */
    select?: WhitelistConfigSelect<ExtArgs> | null
    /**
     * Filter, which WhitelistConfig to fetch.
     */
    where?: WhitelistConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WhitelistConfigs to fetch.
     */
    orderBy?: WhitelistConfigOrderByWithRelationInput | WhitelistConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WhitelistConfigs.
     */
    cursor?: WhitelistConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WhitelistConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WhitelistConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WhitelistConfigs.
     */
    distinct?: WhitelistConfigScalarFieldEnum | WhitelistConfigScalarFieldEnum[]
  }

  /**
   * WhitelistConfig findFirstOrThrow
   */
  export type WhitelistConfigFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhitelistConfig
     */
    select?: WhitelistConfigSelect<ExtArgs> | null
    /**
     * Filter, which WhitelistConfig to fetch.
     */
    where?: WhitelistConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WhitelistConfigs to fetch.
     */
    orderBy?: WhitelistConfigOrderByWithRelationInput | WhitelistConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WhitelistConfigs.
     */
    cursor?: WhitelistConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WhitelistConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WhitelistConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WhitelistConfigs.
     */
    distinct?: WhitelistConfigScalarFieldEnum | WhitelistConfigScalarFieldEnum[]
  }

  /**
   * WhitelistConfig findMany
   */
  export type WhitelistConfigFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhitelistConfig
     */
    select?: WhitelistConfigSelect<ExtArgs> | null
    /**
     * Filter, which WhitelistConfigs to fetch.
     */
    where?: WhitelistConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WhitelistConfigs to fetch.
     */
    orderBy?: WhitelistConfigOrderByWithRelationInput | WhitelistConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WhitelistConfigs.
     */
    cursor?: WhitelistConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WhitelistConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WhitelistConfigs.
     */
    skip?: number
    distinct?: WhitelistConfigScalarFieldEnum | WhitelistConfigScalarFieldEnum[]
  }

  /**
   * WhitelistConfig create
   */
  export type WhitelistConfigCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhitelistConfig
     */
    select?: WhitelistConfigSelect<ExtArgs> | null
    /**
     * The data needed to create a WhitelistConfig.
     */
    data: XOR<WhitelistConfigCreateInput, WhitelistConfigUncheckedCreateInput>
  }

  /**
   * WhitelistConfig createMany
   */
  export type WhitelistConfigCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WhitelistConfigs.
     */
    data: WhitelistConfigCreateManyInput | WhitelistConfigCreateManyInput[]
  }

  /**
   * WhitelistConfig createManyAndReturn
   */
  export type WhitelistConfigCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhitelistConfig
     */
    select?: WhitelistConfigSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many WhitelistConfigs.
     */
    data: WhitelistConfigCreateManyInput | WhitelistConfigCreateManyInput[]
  }

  /**
   * WhitelistConfig update
   */
  export type WhitelistConfigUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhitelistConfig
     */
    select?: WhitelistConfigSelect<ExtArgs> | null
    /**
     * The data needed to update a WhitelistConfig.
     */
    data: XOR<WhitelistConfigUpdateInput, WhitelistConfigUncheckedUpdateInput>
    /**
     * Choose, which WhitelistConfig to update.
     */
    where: WhitelistConfigWhereUniqueInput
  }

  /**
   * WhitelistConfig updateMany
   */
  export type WhitelistConfigUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WhitelistConfigs.
     */
    data: XOR<WhitelistConfigUpdateManyMutationInput, WhitelistConfigUncheckedUpdateManyInput>
    /**
     * Filter which WhitelistConfigs to update
     */
    where?: WhitelistConfigWhereInput
  }

  /**
   * WhitelistConfig upsert
   */
  export type WhitelistConfigUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhitelistConfig
     */
    select?: WhitelistConfigSelect<ExtArgs> | null
    /**
     * The filter to search for the WhitelistConfig to update in case it exists.
     */
    where: WhitelistConfigWhereUniqueInput
    /**
     * In case the WhitelistConfig found by the `where` argument doesn't exist, create a new WhitelistConfig with this data.
     */
    create: XOR<WhitelistConfigCreateInput, WhitelistConfigUncheckedCreateInput>
    /**
     * In case the WhitelistConfig was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WhitelistConfigUpdateInput, WhitelistConfigUncheckedUpdateInput>
  }

  /**
   * WhitelistConfig delete
   */
  export type WhitelistConfigDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhitelistConfig
     */
    select?: WhitelistConfigSelect<ExtArgs> | null
    /**
     * Filter which WhitelistConfig to delete.
     */
    where: WhitelistConfigWhereUniqueInput
  }

  /**
   * WhitelistConfig deleteMany
   */
  export type WhitelistConfigDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WhitelistConfigs to delete
     */
    where?: WhitelistConfigWhereInput
  }

  /**
   * WhitelistConfig without action
   */
  export type WhitelistConfigDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhitelistConfig
     */
    select?: WhitelistConfigSelect<ExtArgs> | null
  }


  /**
   * Model WhitelistQuestion
   */

  export type AggregateWhitelistQuestion = {
    _count: WhitelistQuestionCountAggregateOutputType | null
    _avg: WhitelistQuestionAvgAggregateOutputType | null
    _sum: WhitelistQuestionSumAggregateOutputType | null
    _min: WhitelistQuestionMinAggregateOutputType | null
    _max: WhitelistQuestionMaxAggregateOutputType | null
  }

  export type WhitelistQuestionAvgAggregateOutputType = {
    order: number | null
  }

  export type WhitelistQuestionSumAggregateOutputType = {
    order: number | null
  }

  export type WhitelistQuestionMinAggregateOutputType = {
    id: string | null
    prompt: string | null
    required: boolean | null
    order: number | null
    createdAt: Date | null
  }

  export type WhitelistQuestionMaxAggregateOutputType = {
    id: string | null
    prompt: string | null
    required: boolean | null
    order: number | null
    createdAt: Date | null
  }

  export type WhitelistQuestionCountAggregateOutputType = {
    id: number
    prompt: number
    required: number
    order: number
    createdAt: number
    _all: number
  }


  export type WhitelistQuestionAvgAggregateInputType = {
    order?: true
  }

  export type WhitelistQuestionSumAggregateInputType = {
    order?: true
  }

  export type WhitelistQuestionMinAggregateInputType = {
    id?: true
    prompt?: true
    required?: true
    order?: true
    createdAt?: true
  }

  export type WhitelistQuestionMaxAggregateInputType = {
    id?: true
    prompt?: true
    required?: true
    order?: true
    createdAt?: true
  }

  export type WhitelistQuestionCountAggregateInputType = {
    id?: true
    prompt?: true
    required?: true
    order?: true
    createdAt?: true
    _all?: true
  }

  export type WhitelistQuestionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WhitelistQuestion to aggregate.
     */
    where?: WhitelistQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WhitelistQuestions to fetch.
     */
    orderBy?: WhitelistQuestionOrderByWithRelationInput | WhitelistQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WhitelistQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WhitelistQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WhitelistQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WhitelistQuestions
    **/
    _count?: true | WhitelistQuestionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WhitelistQuestionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WhitelistQuestionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WhitelistQuestionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WhitelistQuestionMaxAggregateInputType
  }

  export type GetWhitelistQuestionAggregateType<T extends WhitelistQuestionAggregateArgs> = {
        [P in keyof T & keyof AggregateWhitelistQuestion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWhitelistQuestion[P]>
      : GetScalarType<T[P], AggregateWhitelistQuestion[P]>
  }




  export type WhitelistQuestionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WhitelistQuestionWhereInput
    orderBy?: WhitelistQuestionOrderByWithAggregationInput | WhitelistQuestionOrderByWithAggregationInput[]
    by: WhitelistQuestionScalarFieldEnum[] | WhitelistQuestionScalarFieldEnum
    having?: WhitelistQuestionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WhitelistQuestionCountAggregateInputType | true
    _avg?: WhitelistQuestionAvgAggregateInputType
    _sum?: WhitelistQuestionSumAggregateInputType
    _min?: WhitelistQuestionMinAggregateInputType
    _max?: WhitelistQuestionMaxAggregateInputType
  }

  export type WhitelistQuestionGroupByOutputType = {
    id: string
    prompt: string
    required: boolean
    order: number
    createdAt: Date
    _count: WhitelistQuestionCountAggregateOutputType | null
    _avg: WhitelistQuestionAvgAggregateOutputType | null
    _sum: WhitelistQuestionSumAggregateOutputType | null
    _min: WhitelistQuestionMinAggregateOutputType | null
    _max: WhitelistQuestionMaxAggregateOutputType | null
  }

  type GetWhitelistQuestionGroupByPayload<T extends WhitelistQuestionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WhitelistQuestionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WhitelistQuestionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WhitelistQuestionGroupByOutputType[P]>
            : GetScalarType<T[P], WhitelistQuestionGroupByOutputType[P]>
        }
      >
    >


  export type WhitelistQuestionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    prompt?: boolean
    required?: boolean
    order?: boolean
    createdAt?: boolean
    answers?: boolean | WhitelistQuestion$answersArgs<ExtArgs>
    _count?: boolean | WhitelistQuestionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["whitelistQuestion"]>

  export type WhitelistQuestionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    prompt?: boolean
    required?: boolean
    order?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["whitelistQuestion"]>

  export type WhitelistQuestionSelectScalar = {
    id?: boolean
    prompt?: boolean
    required?: boolean
    order?: boolean
    createdAt?: boolean
  }

  export type WhitelistQuestionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    answers?: boolean | WhitelistQuestion$answersArgs<ExtArgs>
    _count?: boolean | WhitelistQuestionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type WhitelistQuestionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $WhitelistQuestionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WhitelistQuestion"
    objects: {
      answers: Prisma.$WhitelistAnswerPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      prompt: string
      required: boolean
      order: number
      createdAt: Date
    }, ExtArgs["result"]["whitelistQuestion"]>
    composites: {}
  }

  type WhitelistQuestionGetPayload<S extends boolean | null | undefined | WhitelistQuestionDefaultArgs> = $Result.GetResult<Prisma.$WhitelistQuestionPayload, S>

  type WhitelistQuestionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WhitelistQuestionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WhitelistQuestionCountAggregateInputType | true
    }

  export interface WhitelistQuestionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WhitelistQuestion'], meta: { name: 'WhitelistQuestion' } }
    /**
     * Find zero or one WhitelistQuestion that matches the filter.
     * @param {WhitelistQuestionFindUniqueArgs} args - Arguments to find a WhitelistQuestion
     * @example
     * // Get one WhitelistQuestion
     * const whitelistQuestion = await prisma.whitelistQuestion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WhitelistQuestionFindUniqueArgs>(args: SelectSubset<T, WhitelistQuestionFindUniqueArgs<ExtArgs>>): Prisma__WhitelistQuestionClient<$Result.GetResult<Prisma.$WhitelistQuestionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one WhitelistQuestion that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WhitelistQuestionFindUniqueOrThrowArgs} args - Arguments to find a WhitelistQuestion
     * @example
     * // Get one WhitelistQuestion
     * const whitelistQuestion = await prisma.whitelistQuestion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WhitelistQuestionFindUniqueOrThrowArgs>(args: SelectSubset<T, WhitelistQuestionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WhitelistQuestionClient<$Result.GetResult<Prisma.$WhitelistQuestionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first WhitelistQuestion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhitelistQuestionFindFirstArgs} args - Arguments to find a WhitelistQuestion
     * @example
     * // Get one WhitelistQuestion
     * const whitelistQuestion = await prisma.whitelistQuestion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WhitelistQuestionFindFirstArgs>(args?: SelectSubset<T, WhitelistQuestionFindFirstArgs<ExtArgs>>): Prisma__WhitelistQuestionClient<$Result.GetResult<Prisma.$WhitelistQuestionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first WhitelistQuestion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhitelistQuestionFindFirstOrThrowArgs} args - Arguments to find a WhitelistQuestion
     * @example
     * // Get one WhitelistQuestion
     * const whitelistQuestion = await prisma.whitelistQuestion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WhitelistQuestionFindFirstOrThrowArgs>(args?: SelectSubset<T, WhitelistQuestionFindFirstOrThrowArgs<ExtArgs>>): Prisma__WhitelistQuestionClient<$Result.GetResult<Prisma.$WhitelistQuestionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more WhitelistQuestions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhitelistQuestionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WhitelistQuestions
     * const whitelistQuestions = await prisma.whitelistQuestion.findMany()
     * 
     * // Get first 10 WhitelistQuestions
     * const whitelistQuestions = await prisma.whitelistQuestion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const whitelistQuestionWithIdOnly = await prisma.whitelistQuestion.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WhitelistQuestionFindManyArgs>(args?: SelectSubset<T, WhitelistQuestionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WhitelistQuestionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a WhitelistQuestion.
     * @param {WhitelistQuestionCreateArgs} args - Arguments to create a WhitelistQuestion.
     * @example
     * // Create one WhitelistQuestion
     * const WhitelistQuestion = await prisma.whitelistQuestion.create({
     *   data: {
     *     // ... data to create a WhitelistQuestion
     *   }
     * })
     * 
     */
    create<T extends WhitelistQuestionCreateArgs>(args: SelectSubset<T, WhitelistQuestionCreateArgs<ExtArgs>>): Prisma__WhitelistQuestionClient<$Result.GetResult<Prisma.$WhitelistQuestionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many WhitelistQuestions.
     * @param {WhitelistQuestionCreateManyArgs} args - Arguments to create many WhitelistQuestions.
     * @example
     * // Create many WhitelistQuestions
     * const whitelistQuestion = await prisma.whitelistQuestion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WhitelistQuestionCreateManyArgs>(args?: SelectSubset<T, WhitelistQuestionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WhitelistQuestions and returns the data saved in the database.
     * @param {WhitelistQuestionCreateManyAndReturnArgs} args - Arguments to create many WhitelistQuestions.
     * @example
     * // Create many WhitelistQuestions
     * const whitelistQuestion = await prisma.whitelistQuestion.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WhitelistQuestions and only return the `id`
     * const whitelistQuestionWithIdOnly = await prisma.whitelistQuestion.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WhitelistQuestionCreateManyAndReturnArgs>(args?: SelectSubset<T, WhitelistQuestionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WhitelistQuestionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a WhitelistQuestion.
     * @param {WhitelistQuestionDeleteArgs} args - Arguments to delete one WhitelistQuestion.
     * @example
     * // Delete one WhitelistQuestion
     * const WhitelistQuestion = await prisma.whitelistQuestion.delete({
     *   where: {
     *     // ... filter to delete one WhitelistQuestion
     *   }
     * })
     * 
     */
    delete<T extends WhitelistQuestionDeleteArgs>(args: SelectSubset<T, WhitelistQuestionDeleteArgs<ExtArgs>>): Prisma__WhitelistQuestionClient<$Result.GetResult<Prisma.$WhitelistQuestionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one WhitelistQuestion.
     * @param {WhitelistQuestionUpdateArgs} args - Arguments to update one WhitelistQuestion.
     * @example
     * // Update one WhitelistQuestion
     * const whitelistQuestion = await prisma.whitelistQuestion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WhitelistQuestionUpdateArgs>(args: SelectSubset<T, WhitelistQuestionUpdateArgs<ExtArgs>>): Prisma__WhitelistQuestionClient<$Result.GetResult<Prisma.$WhitelistQuestionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more WhitelistQuestions.
     * @param {WhitelistQuestionDeleteManyArgs} args - Arguments to filter WhitelistQuestions to delete.
     * @example
     * // Delete a few WhitelistQuestions
     * const { count } = await prisma.whitelistQuestion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WhitelistQuestionDeleteManyArgs>(args?: SelectSubset<T, WhitelistQuestionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WhitelistQuestions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhitelistQuestionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WhitelistQuestions
     * const whitelistQuestion = await prisma.whitelistQuestion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WhitelistQuestionUpdateManyArgs>(args: SelectSubset<T, WhitelistQuestionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WhitelistQuestion.
     * @param {WhitelistQuestionUpsertArgs} args - Arguments to update or create a WhitelistQuestion.
     * @example
     * // Update or create a WhitelistQuestion
     * const whitelistQuestion = await prisma.whitelistQuestion.upsert({
     *   create: {
     *     // ... data to create a WhitelistQuestion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WhitelistQuestion we want to update
     *   }
     * })
     */
    upsert<T extends WhitelistQuestionUpsertArgs>(args: SelectSubset<T, WhitelistQuestionUpsertArgs<ExtArgs>>): Prisma__WhitelistQuestionClient<$Result.GetResult<Prisma.$WhitelistQuestionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of WhitelistQuestions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhitelistQuestionCountArgs} args - Arguments to filter WhitelistQuestions to count.
     * @example
     * // Count the number of WhitelistQuestions
     * const count = await prisma.whitelistQuestion.count({
     *   where: {
     *     // ... the filter for the WhitelistQuestions we want to count
     *   }
     * })
    **/
    count<T extends WhitelistQuestionCountArgs>(
      args?: Subset<T, WhitelistQuestionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WhitelistQuestionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WhitelistQuestion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhitelistQuestionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WhitelistQuestionAggregateArgs>(args: Subset<T, WhitelistQuestionAggregateArgs>): Prisma.PrismaPromise<GetWhitelistQuestionAggregateType<T>>

    /**
     * Group by WhitelistQuestion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhitelistQuestionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WhitelistQuestionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WhitelistQuestionGroupByArgs['orderBy'] }
        : { orderBy?: WhitelistQuestionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WhitelistQuestionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWhitelistQuestionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WhitelistQuestion model
   */
  readonly fields: WhitelistQuestionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WhitelistQuestion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WhitelistQuestionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    answers<T extends WhitelistQuestion$answersArgs<ExtArgs> = {}>(args?: Subset<T, WhitelistQuestion$answersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WhitelistAnswerPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WhitelistQuestion model
   */ 
  interface WhitelistQuestionFieldRefs {
    readonly id: FieldRef<"WhitelistQuestion", 'String'>
    readonly prompt: FieldRef<"WhitelistQuestion", 'String'>
    readonly required: FieldRef<"WhitelistQuestion", 'Boolean'>
    readonly order: FieldRef<"WhitelistQuestion", 'Int'>
    readonly createdAt: FieldRef<"WhitelistQuestion", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WhitelistQuestion findUnique
   */
  export type WhitelistQuestionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhitelistQuestion
     */
    select?: WhitelistQuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhitelistQuestionInclude<ExtArgs> | null
    /**
     * Filter, which WhitelistQuestion to fetch.
     */
    where: WhitelistQuestionWhereUniqueInput
  }

  /**
   * WhitelistQuestion findUniqueOrThrow
   */
  export type WhitelistQuestionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhitelistQuestion
     */
    select?: WhitelistQuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhitelistQuestionInclude<ExtArgs> | null
    /**
     * Filter, which WhitelistQuestion to fetch.
     */
    where: WhitelistQuestionWhereUniqueInput
  }

  /**
   * WhitelistQuestion findFirst
   */
  export type WhitelistQuestionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhitelistQuestion
     */
    select?: WhitelistQuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhitelistQuestionInclude<ExtArgs> | null
    /**
     * Filter, which WhitelistQuestion to fetch.
     */
    where?: WhitelistQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WhitelistQuestions to fetch.
     */
    orderBy?: WhitelistQuestionOrderByWithRelationInput | WhitelistQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WhitelistQuestions.
     */
    cursor?: WhitelistQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WhitelistQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WhitelistQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WhitelistQuestions.
     */
    distinct?: WhitelistQuestionScalarFieldEnum | WhitelistQuestionScalarFieldEnum[]
  }

  /**
   * WhitelistQuestion findFirstOrThrow
   */
  export type WhitelistQuestionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhitelistQuestion
     */
    select?: WhitelistQuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhitelistQuestionInclude<ExtArgs> | null
    /**
     * Filter, which WhitelistQuestion to fetch.
     */
    where?: WhitelistQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WhitelistQuestions to fetch.
     */
    orderBy?: WhitelistQuestionOrderByWithRelationInput | WhitelistQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WhitelistQuestions.
     */
    cursor?: WhitelistQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WhitelistQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WhitelistQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WhitelistQuestions.
     */
    distinct?: WhitelistQuestionScalarFieldEnum | WhitelistQuestionScalarFieldEnum[]
  }

  /**
   * WhitelistQuestion findMany
   */
  export type WhitelistQuestionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhitelistQuestion
     */
    select?: WhitelistQuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhitelistQuestionInclude<ExtArgs> | null
    /**
     * Filter, which WhitelistQuestions to fetch.
     */
    where?: WhitelistQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WhitelistQuestions to fetch.
     */
    orderBy?: WhitelistQuestionOrderByWithRelationInput | WhitelistQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WhitelistQuestions.
     */
    cursor?: WhitelistQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WhitelistQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WhitelistQuestions.
     */
    skip?: number
    distinct?: WhitelistQuestionScalarFieldEnum | WhitelistQuestionScalarFieldEnum[]
  }

  /**
   * WhitelistQuestion create
   */
  export type WhitelistQuestionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhitelistQuestion
     */
    select?: WhitelistQuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhitelistQuestionInclude<ExtArgs> | null
    /**
     * The data needed to create a WhitelistQuestion.
     */
    data: XOR<WhitelistQuestionCreateInput, WhitelistQuestionUncheckedCreateInput>
  }

  /**
   * WhitelistQuestion createMany
   */
  export type WhitelistQuestionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WhitelistQuestions.
     */
    data: WhitelistQuestionCreateManyInput | WhitelistQuestionCreateManyInput[]
  }

  /**
   * WhitelistQuestion createManyAndReturn
   */
  export type WhitelistQuestionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhitelistQuestion
     */
    select?: WhitelistQuestionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many WhitelistQuestions.
     */
    data: WhitelistQuestionCreateManyInput | WhitelistQuestionCreateManyInput[]
  }

  /**
   * WhitelistQuestion update
   */
  export type WhitelistQuestionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhitelistQuestion
     */
    select?: WhitelistQuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhitelistQuestionInclude<ExtArgs> | null
    /**
     * The data needed to update a WhitelistQuestion.
     */
    data: XOR<WhitelistQuestionUpdateInput, WhitelistQuestionUncheckedUpdateInput>
    /**
     * Choose, which WhitelistQuestion to update.
     */
    where: WhitelistQuestionWhereUniqueInput
  }

  /**
   * WhitelistQuestion updateMany
   */
  export type WhitelistQuestionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WhitelistQuestions.
     */
    data: XOR<WhitelistQuestionUpdateManyMutationInput, WhitelistQuestionUncheckedUpdateManyInput>
    /**
     * Filter which WhitelistQuestions to update
     */
    where?: WhitelistQuestionWhereInput
  }

  /**
   * WhitelistQuestion upsert
   */
  export type WhitelistQuestionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhitelistQuestion
     */
    select?: WhitelistQuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhitelistQuestionInclude<ExtArgs> | null
    /**
     * The filter to search for the WhitelistQuestion to update in case it exists.
     */
    where: WhitelistQuestionWhereUniqueInput
    /**
     * In case the WhitelistQuestion found by the `where` argument doesn't exist, create a new WhitelistQuestion with this data.
     */
    create: XOR<WhitelistQuestionCreateInput, WhitelistQuestionUncheckedCreateInput>
    /**
     * In case the WhitelistQuestion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WhitelistQuestionUpdateInput, WhitelistQuestionUncheckedUpdateInput>
  }

  /**
   * WhitelistQuestion delete
   */
  export type WhitelistQuestionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhitelistQuestion
     */
    select?: WhitelistQuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhitelistQuestionInclude<ExtArgs> | null
    /**
     * Filter which WhitelistQuestion to delete.
     */
    where: WhitelistQuestionWhereUniqueInput
  }

  /**
   * WhitelistQuestion deleteMany
   */
  export type WhitelistQuestionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WhitelistQuestions to delete
     */
    where?: WhitelistQuestionWhereInput
  }

  /**
   * WhitelistQuestion.answers
   */
  export type WhitelistQuestion$answersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhitelistAnswer
     */
    select?: WhitelistAnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhitelistAnswerInclude<ExtArgs> | null
    where?: WhitelistAnswerWhereInput
    orderBy?: WhitelistAnswerOrderByWithRelationInput | WhitelistAnswerOrderByWithRelationInput[]
    cursor?: WhitelistAnswerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WhitelistAnswerScalarFieldEnum | WhitelistAnswerScalarFieldEnum[]
  }

  /**
   * WhitelistQuestion without action
   */
  export type WhitelistQuestionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhitelistQuestion
     */
    select?: WhitelistQuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhitelistQuestionInclude<ExtArgs> | null
  }


  /**
   * Model WhitelistApplication
   */

  export type AggregateWhitelistApplication = {
    _count: WhitelistApplicationCountAggregateOutputType | null
    _min: WhitelistApplicationMinAggregateOutputType | null
    _max: WhitelistApplicationMaxAggregateOutputType | null
  }

  export type WhitelistApplicationMinAggregateOutputType = {
    id: string | null
    userId: string | null
    status: string | null
    reviewerId: string | null
    rejectReason: string | null
    createdAt: Date | null
    reviewedAt: Date | null
  }

  export type WhitelistApplicationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    status: string | null
    reviewerId: string | null
    rejectReason: string | null
    createdAt: Date | null
    reviewedAt: Date | null
  }

  export type WhitelistApplicationCountAggregateOutputType = {
    id: number
    userId: number
    status: number
    reviewerId: number
    rejectReason: number
    createdAt: number
    reviewedAt: number
    _all: number
  }


  export type WhitelistApplicationMinAggregateInputType = {
    id?: true
    userId?: true
    status?: true
    reviewerId?: true
    rejectReason?: true
    createdAt?: true
    reviewedAt?: true
  }

  export type WhitelistApplicationMaxAggregateInputType = {
    id?: true
    userId?: true
    status?: true
    reviewerId?: true
    rejectReason?: true
    createdAt?: true
    reviewedAt?: true
  }

  export type WhitelistApplicationCountAggregateInputType = {
    id?: true
    userId?: true
    status?: true
    reviewerId?: true
    rejectReason?: true
    createdAt?: true
    reviewedAt?: true
    _all?: true
  }

  export type WhitelistApplicationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WhitelistApplication to aggregate.
     */
    where?: WhitelistApplicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WhitelistApplications to fetch.
     */
    orderBy?: WhitelistApplicationOrderByWithRelationInput | WhitelistApplicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WhitelistApplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WhitelistApplications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WhitelistApplications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WhitelistApplications
    **/
    _count?: true | WhitelistApplicationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WhitelistApplicationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WhitelistApplicationMaxAggregateInputType
  }

  export type GetWhitelistApplicationAggregateType<T extends WhitelistApplicationAggregateArgs> = {
        [P in keyof T & keyof AggregateWhitelistApplication]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWhitelistApplication[P]>
      : GetScalarType<T[P], AggregateWhitelistApplication[P]>
  }




  export type WhitelistApplicationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WhitelistApplicationWhereInput
    orderBy?: WhitelistApplicationOrderByWithAggregationInput | WhitelistApplicationOrderByWithAggregationInput[]
    by: WhitelistApplicationScalarFieldEnum[] | WhitelistApplicationScalarFieldEnum
    having?: WhitelistApplicationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WhitelistApplicationCountAggregateInputType | true
    _min?: WhitelistApplicationMinAggregateInputType
    _max?: WhitelistApplicationMaxAggregateInputType
  }

  export type WhitelistApplicationGroupByOutputType = {
    id: string
    userId: string
    status: string
    reviewerId: string | null
    rejectReason: string | null
    createdAt: Date
    reviewedAt: Date | null
    _count: WhitelistApplicationCountAggregateOutputType | null
    _min: WhitelistApplicationMinAggregateOutputType | null
    _max: WhitelistApplicationMaxAggregateOutputType | null
  }

  type GetWhitelistApplicationGroupByPayload<T extends WhitelistApplicationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WhitelistApplicationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WhitelistApplicationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WhitelistApplicationGroupByOutputType[P]>
            : GetScalarType<T[P], WhitelistApplicationGroupByOutputType[P]>
        }
      >
    >


  export type WhitelistApplicationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    status?: boolean
    reviewerId?: boolean
    rejectReason?: boolean
    createdAt?: boolean
    reviewedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    reviewer?: boolean | WhitelistApplication$reviewerArgs<ExtArgs>
    answers?: boolean | WhitelistApplication$answersArgs<ExtArgs>
    _count?: boolean | WhitelistApplicationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["whitelistApplication"]>

  export type WhitelistApplicationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    status?: boolean
    reviewerId?: boolean
    rejectReason?: boolean
    createdAt?: boolean
    reviewedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    reviewer?: boolean | WhitelistApplication$reviewerArgs<ExtArgs>
  }, ExtArgs["result"]["whitelistApplication"]>

  export type WhitelistApplicationSelectScalar = {
    id?: boolean
    userId?: boolean
    status?: boolean
    reviewerId?: boolean
    rejectReason?: boolean
    createdAt?: boolean
    reviewedAt?: boolean
  }

  export type WhitelistApplicationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    reviewer?: boolean | WhitelistApplication$reviewerArgs<ExtArgs>
    answers?: boolean | WhitelistApplication$answersArgs<ExtArgs>
    _count?: boolean | WhitelistApplicationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type WhitelistApplicationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    reviewer?: boolean | WhitelistApplication$reviewerArgs<ExtArgs>
  }

  export type $WhitelistApplicationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WhitelistApplication"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      reviewer: Prisma.$UserPayload<ExtArgs> | null
      answers: Prisma.$WhitelistAnswerPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      status: string
      reviewerId: string | null
      rejectReason: string | null
      createdAt: Date
      reviewedAt: Date | null
    }, ExtArgs["result"]["whitelistApplication"]>
    composites: {}
  }

  type WhitelistApplicationGetPayload<S extends boolean | null | undefined | WhitelistApplicationDefaultArgs> = $Result.GetResult<Prisma.$WhitelistApplicationPayload, S>

  type WhitelistApplicationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WhitelistApplicationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WhitelistApplicationCountAggregateInputType | true
    }

  export interface WhitelistApplicationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WhitelistApplication'], meta: { name: 'WhitelistApplication' } }
    /**
     * Find zero or one WhitelistApplication that matches the filter.
     * @param {WhitelistApplicationFindUniqueArgs} args - Arguments to find a WhitelistApplication
     * @example
     * // Get one WhitelistApplication
     * const whitelistApplication = await prisma.whitelistApplication.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WhitelistApplicationFindUniqueArgs>(args: SelectSubset<T, WhitelistApplicationFindUniqueArgs<ExtArgs>>): Prisma__WhitelistApplicationClient<$Result.GetResult<Prisma.$WhitelistApplicationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one WhitelistApplication that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WhitelistApplicationFindUniqueOrThrowArgs} args - Arguments to find a WhitelistApplication
     * @example
     * // Get one WhitelistApplication
     * const whitelistApplication = await prisma.whitelistApplication.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WhitelistApplicationFindUniqueOrThrowArgs>(args: SelectSubset<T, WhitelistApplicationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WhitelistApplicationClient<$Result.GetResult<Prisma.$WhitelistApplicationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first WhitelistApplication that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhitelistApplicationFindFirstArgs} args - Arguments to find a WhitelistApplication
     * @example
     * // Get one WhitelistApplication
     * const whitelistApplication = await prisma.whitelistApplication.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WhitelistApplicationFindFirstArgs>(args?: SelectSubset<T, WhitelistApplicationFindFirstArgs<ExtArgs>>): Prisma__WhitelistApplicationClient<$Result.GetResult<Prisma.$WhitelistApplicationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first WhitelistApplication that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhitelistApplicationFindFirstOrThrowArgs} args - Arguments to find a WhitelistApplication
     * @example
     * // Get one WhitelistApplication
     * const whitelistApplication = await prisma.whitelistApplication.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WhitelistApplicationFindFirstOrThrowArgs>(args?: SelectSubset<T, WhitelistApplicationFindFirstOrThrowArgs<ExtArgs>>): Prisma__WhitelistApplicationClient<$Result.GetResult<Prisma.$WhitelistApplicationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more WhitelistApplications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhitelistApplicationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WhitelistApplications
     * const whitelistApplications = await prisma.whitelistApplication.findMany()
     * 
     * // Get first 10 WhitelistApplications
     * const whitelistApplications = await prisma.whitelistApplication.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const whitelistApplicationWithIdOnly = await prisma.whitelistApplication.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WhitelistApplicationFindManyArgs>(args?: SelectSubset<T, WhitelistApplicationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WhitelistApplicationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a WhitelistApplication.
     * @param {WhitelistApplicationCreateArgs} args - Arguments to create a WhitelistApplication.
     * @example
     * // Create one WhitelistApplication
     * const WhitelistApplication = await prisma.whitelistApplication.create({
     *   data: {
     *     // ... data to create a WhitelistApplication
     *   }
     * })
     * 
     */
    create<T extends WhitelistApplicationCreateArgs>(args: SelectSubset<T, WhitelistApplicationCreateArgs<ExtArgs>>): Prisma__WhitelistApplicationClient<$Result.GetResult<Prisma.$WhitelistApplicationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many WhitelistApplications.
     * @param {WhitelistApplicationCreateManyArgs} args - Arguments to create many WhitelistApplications.
     * @example
     * // Create many WhitelistApplications
     * const whitelistApplication = await prisma.whitelistApplication.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WhitelistApplicationCreateManyArgs>(args?: SelectSubset<T, WhitelistApplicationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WhitelistApplications and returns the data saved in the database.
     * @param {WhitelistApplicationCreateManyAndReturnArgs} args - Arguments to create many WhitelistApplications.
     * @example
     * // Create many WhitelistApplications
     * const whitelistApplication = await prisma.whitelistApplication.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WhitelistApplications and only return the `id`
     * const whitelistApplicationWithIdOnly = await prisma.whitelistApplication.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WhitelistApplicationCreateManyAndReturnArgs>(args?: SelectSubset<T, WhitelistApplicationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WhitelistApplicationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a WhitelistApplication.
     * @param {WhitelistApplicationDeleteArgs} args - Arguments to delete one WhitelistApplication.
     * @example
     * // Delete one WhitelistApplication
     * const WhitelistApplication = await prisma.whitelistApplication.delete({
     *   where: {
     *     // ... filter to delete one WhitelistApplication
     *   }
     * })
     * 
     */
    delete<T extends WhitelistApplicationDeleteArgs>(args: SelectSubset<T, WhitelistApplicationDeleteArgs<ExtArgs>>): Prisma__WhitelistApplicationClient<$Result.GetResult<Prisma.$WhitelistApplicationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one WhitelistApplication.
     * @param {WhitelistApplicationUpdateArgs} args - Arguments to update one WhitelistApplication.
     * @example
     * // Update one WhitelistApplication
     * const whitelistApplication = await prisma.whitelistApplication.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WhitelistApplicationUpdateArgs>(args: SelectSubset<T, WhitelistApplicationUpdateArgs<ExtArgs>>): Prisma__WhitelistApplicationClient<$Result.GetResult<Prisma.$WhitelistApplicationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more WhitelistApplications.
     * @param {WhitelistApplicationDeleteManyArgs} args - Arguments to filter WhitelistApplications to delete.
     * @example
     * // Delete a few WhitelistApplications
     * const { count } = await prisma.whitelistApplication.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WhitelistApplicationDeleteManyArgs>(args?: SelectSubset<T, WhitelistApplicationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WhitelistApplications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhitelistApplicationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WhitelistApplications
     * const whitelistApplication = await prisma.whitelistApplication.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WhitelistApplicationUpdateManyArgs>(args: SelectSubset<T, WhitelistApplicationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WhitelistApplication.
     * @param {WhitelistApplicationUpsertArgs} args - Arguments to update or create a WhitelistApplication.
     * @example
     * // Update or create a WhitelistApplication
     * const whitelistApplication = await prisma.whitelistApplication.upsert({
     *   create: {
     *     // ... data to create a WhitelistApplication
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WhitelistApplication we want to update
     *   }
     * })
     */
    upsert<T extends WhitelistApplicationUpsertArgs>(args: SelectSubset<T, WhitelistApplicationUpsertArgs<ExtArgs>>): Prisma__WhitelistApplicationClient<$Result.GetResult<Prisma.$WhitelistApplicationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of WhitelistApplications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhitelistApplicationCountArgs} args - Arguments to filter WhitelistApplications to count.
     * @example
     * // Count the number of WhitelistApplications
     * const count = await prisma.whitelistApplication.count({
     *   where: {
     *     // ... the filter for the WhitelistApplications we want to count
     *   }
     * })
    **/
    count<T extends WhitelistApplicationCountArgs>(
      args?: Subset<T, WhitelistApplicationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WhitelistApplicationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WhitelistApplication.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhitelistApplicationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WhitelistApplicationAggregateArgs>(args: Subset<T, WhitelistApplicationAggregateArgs>): Prisma.PrismaPromise<GetWhitelistApplicationAggregateType<T>>

    /**
     * Group by WhitelistApplication.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhitelistApplicationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WhitelistApplicationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WhitelistApplicationGroupByArgs['orderBy'] }
        : { orderBy?: WhitelistApplicationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WhitelistApplicationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWhitelistApplicationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WhitelistApplication model
   */
  readonly fields: WhitelistApplicationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WhitelistApplication.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WhitelistApplicationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    reviewer<T extends WhitelistApplication$reviewerArgs<ExtArgs> = {}>(args?: Subset<T, WhitelistApplication$reviewerArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    answers<T extends WhitelistApplication$answersArgs<ExtArgs> = {}>(args?: Subset<T, WhitelistApplication$answersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WhitelistAnswerPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WhitelistApplication model
   */ 
  interface WhitelistApplicationFieldRefs {
    readonly id: FieldRef<"WhitelistApplication", 'String'>
    readonly userId: FieldRef<"WhitelistApplication", 'String'>
    readonly status: FieldRef<"WhitelistApplication", 'String'>
    readonly reviewerId: FieldRef<"WhitelistApplication", 'String'>
    readonly rejectReason: FieldRef<"WhitelistApplication", 'String'>
    readonly createdAt: FieldRef<"WhitelistApplication", 'DateTime'>
    readonly reviewedAt: FieldRef<"WhitelistApplication", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WhitelistApplication findUnique
   */
  export type WhitelistApplicationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhitelistApplication
     */
    select?: WhitelistApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhitelistApplicationInclude<ExtArgs> | null
    /**
     * Filter, which WhitelistApplication to fetch.
     */
    where: WhitelistApplicationWhereUniqueInput
  }

  /**
   * WhitelistApplication findUniqueOrThrow
   */
  export type WhitelistApplicationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhitelistApplication
     */
    select?: WhitelistApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhitelistApplicationInclude<ExtArgs> | null
    /**
     * Filter, which WhitelistApplication to fetch.
     */
    where: WhitelistApplicationWhereUniqueInput
  }

  /**
   * WhitelistApplication findFirst
   */
  export type WhitelistApplicationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhitelistApplication
     */
    select?: WhitelistApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhitelistApplicationInclude<ExtArgs> | null
    /**
     * Filter, which WhitelistApplication to fetch.
     */
    where?: WhitelistApplicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WhitelistApplications to fetch.
     */
    orderBy?: WhitelistApplicationOrderByWithRelationInput | WhitelistApplicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WhitelistApplications.
     */
    cursor?: WhitelistApplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WhitelistApplications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WhitelistApplications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WhitelistApplications.
     */
    distinct?: WhitelistApplicationScalarFieldEnum | WhitelistApplicationScalarFieldEnum[]
  }

  /**
   * WhitelistApplication findFirstOrThrow
   */
  export type WhitelistApplicationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhitelistApplication
     */
    select?: WhitelistApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhitelistApplicationInclude<ExtArgs> | null
    /**
     * Filter, which WhitelistApplication to fetch.
     */
    where?: WhitelistApplicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WhitelistApplications to fetch.
     */
    orderBy?: WhitelistApplicationOrderByWithRelationInput | WhitelistApplicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WhitelistApplications.
     */
    cursor?: WhitelistApplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WhitelistApplications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WhitelistApplications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WhitelistApplications.
     */
    distinct?: WhitelistApplicationScalarFieldEnum | WhitelistApplicationScalarFieldEnum[]
  }

  /**
   * WhitelistApplication findMany
   */
  export type WhitelistApplicationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhitelistApplication
     */
    select?: WhitelistApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhitelistApplicationInclude<ExtArgs> | null
    /**
     * Filter, which WhitelistApplications to fetch.
     */
    where?: WhitelistApplicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WhitelistApplications to fetch.
     */
    orderBy?: WhitelistApplicationOrderByWithRelationInput | WhitelistApplicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WhitelistApplications.
     */
    cursor?: WhitelistApplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WhitelistApplications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WhitelistApplications.
     */
    skip?: number
    distinct?: WhitelistApplicationScalarFieldEnum | WhitelistApplicationScalarFieldEnum[]
  }

  /**
   * WhitelistApplication create
   */
  export type WhitelistApplicationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhitelistApplication
     */
    select?: WhitelistApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhitelistApplicationInclude<ExtArgs> | null
    /**
     * The data needed to create a WhitelistApplication.
     */
    data: XOR<WhitelistApplicationCreateInput, WhitelistApplicationUncheckedCreateInput>
  }

  /**
   * WhitelistApplication createMany
   */
  export type WhitelistApplicationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WhitelistApplications.
     */
    data: WhitelistApplicationCreateManyInput | WhitelistApplicationCreateManyInput[]
  }

  /**
   * WhitelistApplication createManyAndReturn
   */
  export type WhitelistApplicationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhitelistApplication
     */
    select?: WhitelistApplicationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many WhitelistApplications.
     */
    data: WhitelistApplicationCreateManyInput | WhitelistApplicationCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhitelistApplicationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WhitelistApplication update
   */
  export type WhitelistApplicationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhitelistApplication
     */
    select?: WhitelistApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhitelistApplicationInclude<ExtArgs> | null
    /**
     * The data needed to update a WhitelistApplication.
     */
    data: XOR<WhitelistApplicationUpdateInput, WhitelistApplicationUncheckedUpdateInput>
    /**
     * Choose, which WhitelistApplication to update.
     */
    where: WhitelistApplicationWhereUniqueInput
  }

  /**
   * WhitelistApplication updateMany
   */
  export type WhitelistApplicationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WhitelistApplications.
     */
    data: XOR<WhitelistApplicationUpdateManyMutationInput, WhitelistApplicationUncheckedUpdateManyInput>
    /**
     * Filter which WhitelistApplications to update
     */
    where?: WhitelistApplicationWhereInput
  }

  /**
   * WhitelistApplication upsert
   */
  export type WhitelistApplicationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhitelistApplication
     */
    select?: WhitelistApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhitelistApplicationInclude<ExtArgs> | null
    /**
     * The filter to search for the WhitelistApplication to update in case it exists.
     */
    where: WhitelistApplicationWhereUniqueInput
    /**
     * In case the WhitelistApplication found by the `where` argument doesn't exist, create a new WhitelistApplication with this data.
     */
    create: XOR<WhitelistApplicationCreateInput, WhitelistApplicationUncheckedCreateInput>
    /**
     * In case the WhitelistApplication was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WhitelistApplicationUpdateInput, WhitelistApplicationUncheckedUpdateInput>
  }

  /**
   * WhitelistApplication delete
   */
  export type WhitelistApplicationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhitelistApplication
     */
    select?: WhitelistApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhitelistApplicationInclude<ExtArgs> | null
    /**
     * Filter which WhitelistApplication to delete.
     */
    where: WhitelistApplicationWhereUniqueInput
  }

  /**
   * WhitelistApplication deleteMany
   */
  export type WhitelistApplicationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WhitelistApplications to delete
     */
    where?: WhitelistApplicationWhereInput
  }

  /**
   * WhitelistApplication.reviewer
   */
  export type WhitelistApplication$reviewerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * WhitelistApplication.answers
   */
  export type WhitelistApplication$answersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhitelistAnswer
     */
    select?: WhitelistAnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhitelistAnswerInclude<ExtArgs> | null
    where?: WhitelistAnswerWhereInput
    orderBy?: WhitelistAnswerOrderByWithRelationInput | WhitelistAnswerOrderByWithRelationInput[]
    cursor?: WhitelistAnswerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WhitelistAnswerScalarFieldEnum | WhitelistAnswerScalarFieldEnum[]
  }

  /**
   * WhitelistApplication without action
   */
  export type WhitelistApplicationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhitelistApplication
     */
    select?: WhitelistApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhitelistApplicationInclude<ExtArgs> | null
  }


  /**
   * Model WhitelistAnswer
   */

  export type AggregateWhitelistAnswer = {
    _count: WhitelistAnswerCountAggregateOutputType | null
    _min: WhitelistAnswerMinAggregateOutputType | null
    _max: WhitelistAnswerMaxAggregateOutputType | null
  }

  export type WhitelistAnswerMinAggregateOutputType = {
    id: string | null
    applicationId: string | null
    questionId: string | null
    value: string | null
    createdAt: Date | null
  }

  export type WhitelistAnswerMaxAggregateOutputType = {
    id: string | null
    applicationId: string | null
    questionId: string | null
    value: string | null
    createdAt: Date | null
  }

  export type WhitelistAnswerCountAggregateOutputType = {
    id: number
    applicationId: number
    questionId: number
    value: number
    createdAt: number
    _all: number
  }


  export type WhitelistAnswerMinAggregateInputType = {
    id?: true
    applicationId?: true
    questionId?: true
    value?: true
    createdAt?: true
  }

  export type WhitelistAnswerMaxAggregateInputType = {
    id?: true
    applicationId?: true
    questionId?: true
    value?: true
    createdAt?: true
  }

  export type WhitelistAnswerCountAggregateInputType = {
    id?: true
    applicationId?: true
    questionId?: true
    value?: true
    createdAt?: true
    _all?: true
  }

  export type WhitelistAnswerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WhitelistAnswer to aggregate.
     */
    where?: WhitelistAnswerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WhitelistAnswers to fetch.
     */
    orderBy?: WhitelistAnswerOrderByWithRelationInput | WhitelistAnswerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WhitelistAnswerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WhitelistAnswers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WhitelistAnswers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WhitelistAnswers
    **/
    _count?: true | WhitelistAnswerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WhitelistAnswerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WhitelistAnswerMaxAggregateInputType
  }

  export type GetWhitelistAnswerAggregateType<T extends WhitelistAnswerAggregateArgs> = {
        [P in keyof T & keyof AggregateWhitelistAnswer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWhitelistAnswer[P]>
      : GetScalarType<T[P], AggregateWhitelistAnswer[P]>
  }




  export type WhitelistAnswerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WhitelistAnswerWhereInput
    orderBy?: WhitelistAnswerOrderByWithAggregationInput | WhitelistAnswerOrderByWithAggregationInput[]
    by: WhitelistAnswerScalarFieldEnum[] | WhitelistAnswerScalarFieldEnum
    having?: WhitelistAnswerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WhitelistAnswerCountAggregateInputType | true
    _min?: WhitelistAnswerMinAggregateInputType
    _max?: WhitelistAnswerMaxAggregateInputType
  }

  export type WhitelistAnswerGroupByOutputType = {
    id: string
    applicationId: string
    questionId: string
    value: string
    createdAt: Date
    _count: WhitelistAnswerCountAggregateOutputType | null
    _min: WhitelistAnswerMinAggregateOutputType | null
    _max: WhitelistAnswerMaxAggregateOutputType | null
  }

  type GetWhitelistAnswerGroupByPayload<T extends WhitelistAnswerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WhitelistAnswerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WhitelistAnswerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WhitelistAnswerGroupByOutputType[P]>
            : GetScalarType<T[P], WhitelistAnswerGroupByOutputType[P]>
        }
      >
    >


  export type WhitelistAnswerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    applicationId?: boolean
    questionId?: boolean
    value?: boolean
    createdAt?: boolean
    application?: boolean | WhitelistApplicationDefaultArgs<ExtArgs>
    question?: boolean | WhitelistQuestionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["whitelistAnswer"]>

  export type WhitelistAnswerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    applicationId?: boolean
    questionId?: boolean
    value?: boolean
    createdAt?: boolean
    application?: boolean | WhitelistApplicationDefaultArgs<ExtArgs>
    question?: boolean | WhitelistQuestionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["whitelistAnswer"]>

  export type WhitelistAnswerSelectScalar = {
    id?: boolean
    applicationId?: boolean
    questionId?: boolean
    value?: boolean
    createdAt?: boolean
  }

  export type WhitelistAnswerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    application?: boolean | WhitelistApplicationDefaultArgs<ExtArgs>
    question?: boolean | WhitelistQuestionDefaultArgs<ExtArgs>
  }
  export type WhitelistAnswerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    application?: boolean | WhitelistApplicationDefaultArgs<ExtArgs>
    question?: boolean | WhitelistQuestionDefaultArgs<ExtArgs>
  }

  export type $WhitelistAnswerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WhitelistAnswer"
    objects: {
      application: Prisma.$WhitelistApplicationPayload<ExtArgs>
      question: Prisma.$WhitelistQuestionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      applicationId: string
      questionId: string
      value: string
      createdAt: Date
    }, ExtArgs["result"]["whitelistAnswer"]>
    composites: {}
  }

  type WhitelistAnswerGetPayload<S extends boolean | null | undefined | WhitelistAnswerDefaultArgs> = $Result.GetResult<Prisma.$WhitelistAnswerPayload, S>

  type WhitelistAnswerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WhitelistAnswerFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WhitelistAnswerCountAggregateInputType | true
    }

  export interface WhitelistAnswerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WhitelistAnswer'], meta: { name: 'WhitelistAnswer' } }
    /**
     * Find zero or one WhitelistAnswer that matches the filter.
     * @param {WhitelistAnswerFindUniqueArgs} args - Arguments to find a WhitelistAnswer
     * @example
     * // Get one WhitelistAnswer
     * const whitelistAnswer = await prisma.whitelistAnswer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WhitelistAnswerFindUniqueArgs>(args: SelectSubset<T, WhitelistAnswerFindUniqueArgs<ExtArgs>>): Prisma__WhitelistAnswerClient<$Result.GetResult<Prisma.$WhitelistAnswerPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one WhitelistAnswer that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WhitelistAnswerFindUniqueOrThrowArgs} args - Arguments to find a WhitelistAnswer
     * @example
     * // Get one WhitelistAnswer
     * const whitelistAnswer = await prisma.whitelistAnswer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WhitelistAnswerFindUniqueOrThrowArgs>(args: SelectSubset<T, WhitelistAnswerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WhitelistAnswerClient<$Result.GetResult<Prisma.$WhitelistAnswerPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first WhitelistAnswer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhitelistAnswerFindFirstArgs} args - Arguments to find a WhitelistAnswer
     * @example
     * // Get one WhitelistAnswer
     * const whitelistAnswer = await prisma.whitelistAnswer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WhitelistAnswerFindFirstArgs>(args?: SelectSubset<T, WhitelistAnswerFindFirstArgs<ExtArgs>>): Prisma__WhitelistAnswerClient<$Result.GetResult<Prisma.$WhitelistAnswerPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first WhitelistAnswer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhitelistAnswerFindFirstOrThrowArgs} args - Arguments to find a WhitelistAnswer
     * @example
     * // Get one WhitelistAnswer
     * const whitelistAnswer = await prisma.whitelistAnswer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WhitelistAnswerFindFirstOrThrowArgs>(args?: SelectSubset<T, WhitelistAnswerFindFirstOrThrowArgs<ExtArgs>>): Prisma__WhitelistAnswerClient<$Result.GetResult<Prisma.$WhitelistAnswerPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more WhitelistAnswers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhitelistAnswerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WhitelistAnswers
     * const whitelistAnswers = await prisma.whitelistAnswer.findMany()
     * 
     * // Get first 10 WhitelistAnswers
     * const whitelistAnswers = await prisma.whitelistAnswer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const whitelistAnswerWithIdOnly = await prisma.whitelistAnswer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WhitelistAnswerFindManyArgs>(args?: SelectSubset<T, WhitelistAnswerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WhitelistAnswerPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a WhitelistAnswer.
     * @param {WhitelistAnswerCreateArgs} args - Arguments to create a WhitelistAnswer.
     * @example
     * // Create one WhitelistAnswer
     * const WhitelistAnswer = await prisma.whitelistAnswer.create({
     *   data: {
     *     // ... data to create a WhitelistAnswer
     *   }
     * })
     * 
     */
    create<T extends WhitelistAnswerCreateArgs>(args: SelectSubset<T, WhitelistAnswerCreateArgs<ExtArgs>>): Prisma__WhitelistAnswerClient<$Result.GetResult<Prisma.$WhitelistAnswerPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many WhitelistAnswers.
     * @param {WhitelistAnswerCreateManyArgs} args - Arguments to create many WhitelistAnswers.
     * @example
     * // Create many WhitelistAnswers
     * const whitelistAnswer = await prisma.whitelistAnswer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WhitelistAnswerCreateManyArgs>(args?: SelectSubset<T, WhitelistAnswerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WhitelistAnswers and returns the data saved in the database.
     * @param {WhitelistAnswerCreateManyAndReturnArgs} args - Arguments to create many WhitelistAnswers.
     * @example
     * // Create many WhitelistAnswers
     * const whitelistAnswer = await prisma.whitelistAnswer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WhitelistAnswers and only return the `id`
     * const whitelistAnswerWithIdOnly = await prisma.whitelistAnswer.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WhitelistAnswerCreateManyAndReturnArgs>(args?: SelectSubset<T, WhitelistAnswerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WhitelistAnswerPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a WhitelistAnswer.
     * @param {WhitelistAnswerDeleteArgs} args - Arguments to delete one WhitelistAnswer.
     * @example
     * // Delete one WhitelistAnswer
     * const WhitelistAnswer = await prisma.whitelistAnswer.delete({
     *   where: {
     *     // ... filter to delete one WhitelistAnswer
     *   }
     * })
     * 
     */
    delete<T extends WhitelistAnswerDeleteArgs>(args: SelectSubset<T, WhitelistAnswerDeleteArgs<ExtArgs>>): Prisma__WhitelistAnswerClient<$Result.GetResult<Prisma.$WhitelistAnswerPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one WhitelistAnswer.
     * @param {WhitelistAnswerUpdateArgs} args - Arguments to update one WhitelistAnswer.
     * @example
     * // Update one WhitelistAnswer
     * const whitelistAnswer = await prisma.whitelistAnswer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WhitelistAnswerUpdateArgs>(args: SelectSubset<T, WhitelistAnswerUpdateArgs<ExtArgs>>): Prisma__WhitelistAnswerClient<$Result.GetResult<Prisma.$WhitelistAnswerPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more WhitelistAnswers.
     * @param {WhitelistAnswerDeleteManyArgs} args - Arguments to filter WhitelistAnswers to delete.
     * @example
     * // Delete a few WhitelistAnswers
     * const { count } = await prisma.whitelistAnswer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WhitelistAnswerDeleteManyArgs>(args?: SelectSubset<T, WhitelistAnswerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WhitelistAnswers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhitelistAnswerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WhitelistAnswers
     * const whitelistAnswer = await prisma.whitelistAnswer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WhitelistAnswerUpdateManyArgs>(args: SelectSubset<T, WhitelistAnswerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WhitelistAnswer.
     * @param {WhitelistAnswerUpsertArgs} args - Arguments to update or create a WhitelistAnswer.
     * @example
     * // Update or create a WhitelistAnswer
     * const whitelistAnswer = await prisma.whitelistAnswer.upsert({
     *   create: {
     *     // ... data to create a WhitelistAnswer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WhitelistAnswer we want to update
     *   }
     * })
     */
    upsert<T extends WhitelistAnswerUpsertArgs>(args: SelectSubset<T, WhitelistAnswerUpsertArgs<ExtArgs>>): Prisma__WhitelistAnswerClient<$Result.GetResult<Prisma.$WhitelistAnswerPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of WhitelistAnswers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhitelistAnswerCountArgs} args - Arguments to filter WhitelistAnswers to count.
     * @example
     * // Count the number of WhitelistAnswers
     * const count = await prisma.whitelistAnswer.count({
     *   where: {
     *     // ... the filter for the WhitelistAnswers we want to count
     *   }
     * })
    **/
    count<T extends WhitelistAnswerCountArgs>(
      args?: Subset<T, WhitelistAnswerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WhitelistAnswerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WhitelistAnswer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhitelistAnswerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WhitelistAnswerAggregateArgs>(args: Subset<T, WhitelistAnswerAggregateArgs>): Prisma.PrismaPromise<GetWhitelistAnswerAggregateType<T>>

    /**
     * Group by WhitelistAnswer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhitelistAnswerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WhitelistAnswerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WhitelistAnswerGroupByArgs['orderBy'] }
        : { orderBy?: WhitelistAnswerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WhitelistAnswerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWhitelistAnswerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WhitelistAnswer model
   */
  readonly fields: WhitelistAnswerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WhitelistAnswer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WhitelistAnswerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    application<T extends WhitelistApplicationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WhitelistApplicationDefaultArgs<ExtArgs>>): Prisma__WhitelistApplicationClient<$Result.GetResult<Prisma.$WhitelistApplicationPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    question<T extends WhitelistQuestionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WhitelistQuestionDefaultArgs<ExtArgs>>): Prisma__WhitelistQuestionClient<$Result.GetResult<Prisma.$WhitelistQuestionPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WhitelistAnswer model
   */ 
  interface WhitelistAnswerFieldRefs {
    readonly id: FieldRef<"WhitelistAnswer", 'String'>
    readonly applicationId: FieldRef<"WhitelistAnswer", 'String'>
    readonly questionId: FieldRef<"WhitelistAnswer", 'String'>
    readonly value: FieldRef<"WhitelistAnswer", 'String'>
    readonly createdAt: FieldRef<"WhitelistAnswer", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WhitelistAnswer findUnique
   */
  export type WhitelistAnswerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhitelistAnswer
     */
    select?: WhitelistAnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhitelistAnswerInclude<ExtArgs> | null
    /**
     * Filter, which WhitelistAnswer to fetch.
     */
    where: WhitelistAnswerWhereUniqueInput
  }

  /**
   * WhitelistAnswer findUniqueOrThrow
   */
  export type WhitelistAnswerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhitelistAnswer
     */
    select?: WhitelistAnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhitelistAnswerInclude<ExtArgs> | null
    /**
     * Filter, which WhitelistAnswer to fetch.
     */
    where: WhitelistAnswerWhereUniqueInput
  }

  /**
   * WhitelistAnswer findFirst
   */
  export type WhitelistAnswerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhitelistAnswer
     */
    select?: WhitelistAnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhitelistAnswerInclude<ExtArgs> | null
    /**
     * Filter, which WhitelistAnswer to fetch.
     */
    where?: WhitelistAnswerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WhitelistAnswers to fetch.
     */
    orderBy?: WhitelistAnswerOrderByWithRelationInput | WhitelistAnswerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WhitelistAnswers.
     */
    cursor?: WhitelistAnswerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WhitelistAnswers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WhitelistAnswers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WhitelistAnswers.
     */
    distinct?: WhitelistAnswerScalarFieldEnum | WhitelistAnswerScalarFieldEnum[]
  }

  /**
   * WhitelistAnswer findFirstOrThrow
   */
  export type WhitelistAnswerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhitelistAnswer
     */
    select?: WhitelistAnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhitelistAnswerInclude<ExtArgs> | null
    /**
     * Filter, which WhitelistAnswer to fetch.
     */
    where?: WhitelistAnswerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WhitelistAnswers to fetch.
     */
    orderBy?: WhitelistAnswerOrderByWithRelationInput | WhitelistAnswerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WhitelistAnswers.
     */
    cursor?: WhitelistAnswerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WhitelistAnswers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WhitelistAnswers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WhitelistAnswers.
     */
    distinct?: WhitelistAnswerScalarFieldEnum | WhitelistAnswerScalarFieldEnum[]
  }

  /**
   * WhitelistAnswer findMany
   */
  export type WhitelistAnswerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhitelistAnswer
     */
    select?: WhitelistAnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhitelistAnswerInclude<ExtArgs> | null
    /**
     * Filter, which WhitelistAnswers to fetch.
     */
    where?: WhitelistAnswerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WhitelistAnswers to fetch.
     */
    orderBy?: WhitelistAnswerOrderByWithRelationInput | WhitelistAnswerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WhitelistAnswers.
     */
    cursor?: WhitelistAnswerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WhitelistAnswers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WhitelistAnswers.
     */
    skip?: number
    distinct?: WhitelistAnswerScalarFieldEnum | WhitelistAnswerScalarFieldEnum[]
  }

  /**
   * WhitelistAnswer create
   */
  export type WhitelistAnswerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhitelistAnswer
     */
    select?: WhitelistAnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhitelistAnswerInclude<ExtArgs> | null
    /**
     * The data needed to create a WhitelistAnswer.
     */
    data: XOR<WhitelistAnswerCreateInput, WhitelistAnswerUncheckedCreateInput>
  }

  /**
   * WhitelistAnswer createMany
   */
  export type WhitelistAnswerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WhitelistAnswers.
     */
    data: WhitelistAnswerCreateManyInput | WhitelistAnswerCreateManyInput[]
  }

  /**
   * WhitelistAnswer createManyAndReturn
   */
  export type WhitelistAnswerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhitelistAnswer
     */
    select?: WhitelistAnswerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many WhitelistAnswers.
     */
    data: WhitelistAnswerCreateManyInput | WhitelistAnswerCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhitelistAnswerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WhitelistAnswer update
   */
  export type WhitelistAnswerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhitelistAnswer
     */
    select?: WhitelistAnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhitelistAnswerInclude<ExtArgs> | null
    /**
     * The data needed to update a WhitelistAnswer.
     */
    data: XOR<WhitelistAnswerUpdateInput, WhitelistAnswerUncheckedUpdateInput>
    /**
     * Choose, which WhitelistAnswer to update.
     */
    where: WhitelistAnswerWhereUniqueInput
  }

  /**
   * WhitelistAnswer updateMany
   */
  export type WhitelistAnswerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WhitelistAnswers.
     */
    data: XOR<WhitelistAnswerUpdateManyMutationInput, WhitelistAnswerUncheckedUpdateManyInput>
    /**
     * Filter which WhitelistAnswers to update
     */
    where?: WhitelistAnswerWhereInput
  }

  /**
   * WhitelistAnswer upsert
   */
  export type WhitelistAnswerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhitelistAnswer
     */
    select?: WhitelistAnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhitelistAnswerInclude<ExtArgs> | null
    /**
     * The filter to search for the WhitelistAnswer to update in case it exists.
     */
    where: WhitelistAnswerWhereUniqueInput
    /**
     * In case the WhitelistAnswer found by the `where` argument doesn't exist, create a new WhitelistAnswer with this data.
     */
    create: XOR<WhitelistAnswerCreateInput, WhitelistAnswerUncheckedCreateInput>
    /**
     * In case the WhitelistAnswer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WhitelistAnswerUpdateInput, WhitelistAnswerUncheckedUpdateInput>
  }

  /**
   * WhitelistAnswer delete
   */
  export type WhitelistAnswerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhitelistAnswer
     */
    select?: WhitelistAnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhitelistAnswerInclude<ExtArgs> | null
    /**
     * Filter which WhitelistAnswer to delete.
     */
    where: WhitelistAnswerWhereUniqueInput
  }

  /**
   * WhitelistAnswer deleteMany
   */
  export type WhitelistAnswerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WhitelistAnswers to delete
     */
    where?: WhitelistAnswerWhereInput
  }

  /**
   * WhitelistAnswer without action
   */
  export type WhitelistAnswerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhitelistAnswer
     */
    select?: WhitelistAnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhitelistAnswerInclude<ExtArgs> | null
  }


  /**
   * Model Badge
   */

  export type AggregateBadge = {
    _count: BadgeCountAggregateOutputType | null
    _min: BadgeMinAggregateOutputType | null
    _max: BadgeMaxAggregateOutputType | null
  }

  export type BadgeMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    icon: string | null
    createdAt: Date | null
  }

  export type BadgeMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    icon: string | null
    createdAt: Date | null
  }

  export type BadgeCountAggregateOutputType = {
    id: number
    name: number
    description: number
    icon: number
    createdAt: number
    _all: number
  }


  export type BadgeMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    icon?: true
    createdAt?: true
  }

  export type BadgeMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    icon?: true
    createdAt?: true
  }

  export type BadgeCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    icon?: true
    createdAt?: true
    _all?: true
  }

  export type BadgeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Badge to aggregate.
     */
    where?: BadgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Badges to fetch.
     */
    orderBy?: BadgeOrderByWithRelationInput | BadgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BadgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Badges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Badges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Badges
    **/
    _count?: true | BadgeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BadgeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BadgeMaxAggregateInputType
  }

  export type GetBadgeAggregateType<T extends BadgeAggregateArgs> = {
        [P in keyof T & keyof AggregateBadge]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBadge[P]>
      : GetScalarType<T[P], AggregateBadge[P]>
  }




  export type BadgeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BadgeWhereInput
    orderBy?: BadgeOrderByWithAggregationInput | BadgeOrderByWithAggregationInput[]
    by: BadgeScalarFieldEnum[] | BadgeScalarFieldEnum
    having?: BadgeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BadgeCountAggregateInputType | true
    _min?: BadgeMinAggregateInputType
    _max?: BadgeMaxAggregateInputType
  }

  export type BadgeGroupByOutputType = {
    id: string
    name: string
    description: string | null
    icon: string | null
    createdAt: Date
    _count: BadgeCountAggregateOutputType | null
    _min: BadgeMinAggregateOutputType | null
    _max: BadgeMaxAggregateOutputType | null
  }

  type GetBadgeGroupByPayload<T extends BadgeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BadgeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BadgeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BadgeGroupByOutputType[P]>
            : GetScalarType<T[P], BadgeGroupByOutputType[P]>
        }
      >
    >


  export type BadgeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    icon?: boolean
    createdAt?: boolean
    users?: boolean | Badge$usersArgs<ExtArgs>
    _count?: boolean | BadgeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["badge"]>

  export type BadgeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    icon?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["badge"]>

  export type BadgeSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    icon?: boolean
    createdAt?: boolean
  }

  export type BadgeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | Badge$usersArgs<ExtArgs>
    _count?: boolean | BadgeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BadgeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $BadgePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Badge"
    objects: {
      users: Prisma.$UserBadgePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      icon: string | null
      createdAt: Date
    }, ExtArgs["result"]["badge"]>
    composites: {}
  }

  type BadgeGetPayload<S extends boolean | null | undefined | BadgeDefaultArgs> = $Result.GetResult<Prisma.$BadgePayload, S>

  type BadgeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BadgeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BadgeCountAggregateInputType | true
    }

  export interface BadgeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Badge'], meta: { name: 'Badge' } }
    /**
     * Find zero or one Badge that matches the filter.
     * @param {BadgeFindUniqueArgs} args - Arguments to find a Badge
     * @example
     * // Get one Badge
     * const badge = await prisma.badge.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BadgeFindUniqueArgs>(args: SelectSubset<T, BadgeFindUniqueArgs<ExtArgs>>): Prisma__BadgeClient<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Badge that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BadgeFindUniqueOrThrowArgs} args - Arguments to find a Badge
     * @example
     * // Get one Badge
     * const badge = await prisma.badge.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BadgeFindUniqueOrThrowArgs>(args: SelectSubset<T, BadgeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BadgeClient<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Badge that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgeFindFirstArgs} args - Arguments to find a Badge
     * @example
     * // Get one Badge
     * const badge = await prisma.badge.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BadgeFindFirstArgs>(args?: SelectSubset<T, BadgeFindFirstArgs<ExtArgs>>): Prisma__BadgeClient<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Badge that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgeFindFirstOrThrowArgs} args - Arguments to find a Badge
     * @example
     * // Get one Badge
     * const badge = await prisma.badge.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BadgeFindFirstOrThrowArgs>(args?: SelectSubset<T, BadgeFindFirstOrThrowArgs<ExtArgs>>): Prisma__BadgeClient<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Badges that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Badges
     * const badges = await prisma.badge.findMany()
     * 
     * // Get first 10 Badges
     * const badges = await prisma.badge.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const badgeWithIdOnly = await prisma.badge.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BadgeFindManyArgs>(args?: SelectSubset<T, BadgeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Badge.
     * @param {BadgeCreateArgs} args - Arguments to create a Badge.
     * @example
     * // Create one Badge
     * const Badge = await prisma.badge.create({
     *   data: {
     *     // ... data to create a Badge
     *   }
     * })
     * 
     */
    create<T extends BadgeCreateArgs>(args: SelectSubset<T, BadgeCreateArgs<ExtArgs>>): Prisma__BadgeClient<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Badges.
     * @param {BadgeCreateManyArgs} args - Arguments to create many Badges.
     * @example
     * // Create many Badges
     * const badge = await prisma.badge.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BadgeCreateManyArgs>(args?: SelectSubset<T, BadgeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Badges and returns the data saved in the database.
     * @param {BadgeCreateManyAndReturnArgs} args - Arguments to create many Badges.
     * @example
     * // Create many Badges
     * const badge = await prisma.badge.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Badges and only return the `id`
     * const badgeWithIdOnly = await prisma.badge.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BadgeCreateManyAndReturnArgs>(args?: SelectSubset<T, BadgeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Badge.
     * @param {BadgeDeleteArgs} args - Arguments to delete one Badge.
     * @example
     * // Delete one Badge
     * const Badge = await prisma.badge.delete({
     *   where: {
     *     // ... filter to delete one Badge
     *   }
     * })
     * 
     */
    delete<T extends BadgeDeleteArgs>(args: SelectSubset<T, BadgeDeleteArgs<ExtArgs>>): Prisma__BadgeClient<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Badge.
     * @param {BadgeUpdateArgs} args - Arguments to update one Badge.
     * @example
     * // Update one Badge
     * const badge = await prisma.badge.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BadgeUpdateArgs>(args: SelectSubset<T, BadgeUpdateArgs<ExtArgs>>): Prisma__BadgeClient<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Badges.
     * @param {BadgeDeleteManyArgs} args - Arguments to filter Badges to delete.
     * @example
     * // Delete a few Badges
     * const { count } = await prisma.badge.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BadgeDeleteManyArgs>(args?: SelectSubset<T, BadgeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Badges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Badges
     * const badge = await prisma.badge.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BadgeUpdateManyArgs>(args: SelectSubset<T, BadgeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Badge.
     * @param {BadgeUpsertArgs} args - Arguments to update or create a Badge.
     * @example
     * // Update or create a Badge
     * const badge = await prisma.badge.upsert({
     *   create: {
     *     // ... data to create a Badge
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Badge we want to update
     *   }
     * })
     */
    upsert<T extends BadgeUpsertArgs>(args: SelectSubset<T, BadgeUpsertArgs<ExtArgs>>): Prisma__BadgeClient<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Badges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgeCountArgs} args - Arguments to filter Badges to count.
     * @example
     * // Count the number of Badges
     * const count = await prisma.badge.count({
     *   where: {
     *     // ... the filter for the Badges we want to count
     *   }
     * })
    **/
    count<T extends BadgeCountArgs>(
      args?: Subset<T, BadgeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BadgeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Badge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BadgeAggregateArgs>(args: Subset<T, BadgeAggregateArgs>): Prisma.PrismaPromise<GetBadgeAggregateType<T>>

    /**
     * Group by Badge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BadgeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BadgeGroupByArgs['orderBy'] }
        : { orderBy?: BadgeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BadgeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBadgeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Badge model
   */
  readonly fields: BadgeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Badge.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BadgeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends Badge$usersArgs<ExtArgs> = {}>(args?: Subset<T, Badge$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserBadgePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Badge model
   */ 
  interface BadgeFieldRefs {
    readonly id: FieldRef<"Badge", 'String'>
    readonly name: FieldRef<"Badge", 'String'>
    readonly description: FieldRef<"Badge", 'String'>
    readonly icon: FieldRef<"Badge", 'String'>
    readonly createdAt: FieldRef<"Badge", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Badge findUnique
   */
  export type BadgeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    /**
     * Filter, which Badge to fetch.
     */
    where: BadgeWhereUniqueInput
  }

  /**
   * Badge findUniqueOrThrow
   */
  export type BadgeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    /**
     * Filter, which Badge to fetch.
     */
    where: BadgeWhereUniqueInput
  }

  /**
   * Badge findFirst
   */
  export type BadgeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    /**
     * Filter, which Badge to fetch.
     */
    where?: BadgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Badges to fetch.
     */
    orderBy?: BadgeOrderByWithRelationInput | BadgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Badges.
     */
    cursor?: BadgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Badges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Badges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Badges.
     */
    distinct?: BadgeScalarFieldEnum | BadgeScalarFieldEnum[]
  }

  /**
   * Badge findFirstOrThrow
   */
  export type BadgeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    /**
     * Filter, which Badge to fetch.
     */
    where?: BadgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Badges to fetch.
     */
    orderBy?: BadgeOrderByWithRelationInput | BadgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Badges.
     */
    cursor?: BadgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Badges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Badges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Badges.
     */
    distinct?: BadgeScalarFieldEnum | BadgeScalarFieldEnum[]
  }

  /**
   * Badge findMany
   */
  export type BadgeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    /**
     * Filter, which Badges to fetch.
     */
    where?: BadgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Badges to fetch.
     */
    orderBy?: BadgeOrderByWithRelationInput | BadgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Badges.
     */
    cursor?: BadgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Badges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Badges.
     */
    skip?: number
    distinct?: BadgeScalarFieldEnum | BadgeScalarFieldEnum[]
  }

  /**
   * Badge create
   */
  export type BadgeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    /**
     * The data needed to create a Badge.
     */
    data: XOR<BadgeCreateInput, BadgeUncheckedCreateInput>
  }

  /**
   * Badge createMany
   */
  export type BadgeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Badges.
     */
    data: BadgeCreateManyInput | BadgeCreateManyInput[]
  }

  /**
   * Badge createManyAndReturn
   */
  export type BadgeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Badges.
     */
    data: BadgeCreateManyInput | BadgeCreateManyInput[]
  }

  /**
   * Badge update
   */
  export type BadgeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    /**
     * The data needed to update a Badge.
     */
    data: XOR<BadgeUpdateInput, BadgeUncheckedUpdateInput>
    /**
     * Choose, which Badge to update.
     */
    where: BadgeWhereUniqueInput
  }

  /**
   * Badge updateMany
   */
  export type BadgeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Badges.
     */
    data: XOR<BadgeUpdateManyMutationInput, BadgeUncheckedUpdateManyInput>
    /**
     * Filter which Badges to update
     */
    where?: BadgeWhereInput
  }

  /**
   * Badge upsert
   */
  export type BadgeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    /**
     * The filter to search for the Badge to update in case it exists.
     */
    where: BadgeWhereUniqueInput
    /**
     * In case the Badge found by the `where` argument doesn't exist, create a new Badge with this data.
     */
    create: XOR<BadgeCreateInput, BadgeUncheckedCreateInput>
    /**
     * In case the Badge was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BadgeUpdateInput, BadgeUncheckedUpdateInput>
  }

  /**
   * Badge delete
   */
  export type BadgeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    /**
     * Filter which Badge to delete.
     */
    where: BadgeWhereUniqueInput
  }

  /**
   * Badge deleteMany
   */
  export type BadgeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Badges to delete
     */
    where?: BadgeWhereInput
  }

  /**
   * Badge.users
   */
  export type Badge$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBadge
     */
    select?: UserBadgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBadgeInclude<ExtArgs> | null
    where?: UserBadgeWhereInput
    orderBy?: UserBadgeOrderByWithRelationInput | UserBadgeOrderByWithRelationInput[]
    cursor?: UserBadgeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserBadgeScalarFieldEnum | UserBadgeScalarFieldEnum[]
  }

  /**
   * Badge without action
   */
  export type BadgeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
  }


  /**
   * Model UserBadge
   */

  export type AggregateUserBadge = {
    _count: UserBadgeCountAggregateOutputType | null
    _min: UserBadgeMinAggregateOutputType | null
    _max: UserBadgeMaxAggregateOutputType | null
  }

  export type UserBadgeMinAggregateOutputType = {
    userId: string | null
    badgeId: string | null
    createdAt: Date | null
  }

  export type UserBadgeMaxAggregateOutputType = {
    userId: string | null
    badgeId: string | null
    createdAt: Date | null
  }

  export type UserBadgeCountAggregateOutputType = {
    userId: number
    badgeId: number
    createdAt: number
    _all: number
  }


  export type UserBadgeMinAggregateInputType = {
    userId?: true
    badgeId?: true
    createdAt?: true
  }

  export type UserBadgeMaxAggregateInputType = {
    userId?: true
    badgeId?: true
    createdAt?: true
  }

  export type UserBadgeCountAggregateInputType = {
    userId?: true
    badgeId?: true
    createdAt?: true
    _all?: true
  }

  export type UserBadgeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserBadge to aggregate.
     */
    where?: UserBadgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserBadges to fetch.
     */
    orderBy?: UserBadgeOrderByWithRelationInput | UserBadgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserBadgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserBadges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserBadges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserBadges
    **/
    _count?: true | UserBadgeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserBadgeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserBadgeMaxAggregateInputType
  }

  export type GetUserBadgeAggregateType<T extends UserBadgeAggregateArgs> = {
        [P in keyof T & keyof AggregateUserBadge]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserBadge[P]>
      : GetScalarType<T[P], AggregateUserBadge[P]>
  }




  export type UserBadgeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserBadgeWhereInput
    orderBy?: UserBadgeOrderByWithAggregationInput | UserBadgeOrderByWithAggregationInput[]
    by: UserBadgeScalarFieldEnum[] | UserBadgeScalarFieldEnum
    having?: UserBadgeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserBadgeCountAggregateInputType | true
    _min?: UserBadgeMinAggregateInputType
    _max?: UserBadgeMaxAggregateInputType
  }

  export type UserBadgeGroupByOutputType = {
    userId: string
    badgeId: string
    createdAt: Date
    _count: UserBadgeCountAggregateOutputType | null
    _min: UserBadgeMinAggregateOutputType | null
    _max: UserBadgeMaxAggregateOutputType | null
  }

  type GetUserBadgeGroupByPayload<T extends UserBadgeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserBadgeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserBadgeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserBadgeGroupByOutputType[P]>
            : GetScalarType<T[P], UserBadgeGroupByOutputType[P]>
        }
      >
    >


  export type UserBadgeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    badgeId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    badge?: boolean | BadgeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userBadge"]>

  export type UserBadgeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    badgeId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    badge?: boolean | BadgeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userBadge"]>

  export type UserBadgeSelectScalar = {
    userId?: boolean
    badgeId?: boolean
    createdAt?: boolean
  }

  export type UserBadgeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    badge?: boolean | BadgeDefaultArgs<ExtArgs>
  }
  export type UserBadgeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    badge?: boolean | BadgeDefaultArgs<ExtArgs>
  }

  export type $UserBadgePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserBadge"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      badge: Prisma.$BadgePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      userId: string
      badgeId: string
      createdAt: Date
    }, ExtArgs["result"]["userBadge"]>
    composites: {}
  }

  type UserBadgeGetPayload<S extends boolean | null | undefined | UserBadgeDefaultArgs> = $Result.GetResult<Prisma.$UserBadgePayload, S>

  type UserBadgeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserBadgeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserBadgeCountAggregateInputType | true
    }

  export interface UserBadgeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserBadge'], meta: { name: 'UserBadge' } }
    /**
     * Find zero or one UserBadge that matches the filter.
     * @param {UserBadgeFindUniqueArgs} args - Arguments to find a UserBadge
     * @example
     * // Get one UserBadge
     * const userBadge = await prisma.userBadge.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserBadgeFindUniqueArgs>(args: SelectSubset<T, UserBadgeFindUniqueArgs<ExtArgs>>): Prisma__UserBadgeClient<$Result.GetResult<Prisma.$UserBadgePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UserBadge that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserBadgeFindUniqueOrThrowArgs} args - Arguments to find a UserBadge
     * @example
     * // Get one UserBadge
     * const userBadge = await prisma.userBadge.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserBadgeFindUniqueOrThrowArgs>(args: SelectSubset<T, UserBadgeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserBadgeClient<$Result.GetResult<Prisma.$UserBadgePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UserBadge that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBadgeFindFirstArgs} args - Arguments to find a UserBadge
     * @example
     * // Get one UserBadge
     * const userBadge = await prisma.userBadge.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserBadgeFindFirstArgs>(args?: SelectSubset<T, UserBadgeFindFirstArgs<ExtArgs>>): Prisma__UserBadgeClient<$Result.GetResult<Prisma.$UserBadgePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UserBadge that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBadgeFindFirstOrThrowArgs} args - Arguments to find a UserBadge
     * @example
     * // Get one UserBadge
     * const userBadge = await prisma.userBadge.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserBadgeFindFirstOrThrowArgs>(args?: SelectSubset<T, UserBadgeFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserBadgeClient<$Result.GetResult<Prisma.$UserBadgePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UserBadges that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBadgeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserBadges
     * const userBadges = await prisma.userBadge.findMany()
     * 
     * // Get first 10 UserBadges
     * const userBadges = await prisma.userBadge.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const userBadgeWithUserIdOnly = await prisma.userBadge.findMany({ select: { userId: true } })
     * 
     */
    findMany<T extends UserBadgeFindManyArgs>(args?: SelectSubset<T, UserBadgeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserBadgePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UserBadge.
     * @param {UserBadgeCreateArgs} args - Arguments to create a UserBadge.
     * @example
     * // Create one UserBadge
     * const UserBadge = await prisma.userBadge.create({
     *   data: {
     *     // ... data to create a UserBadge
     *   }
     * })
     * 
     */
    create<T extends UserBadgeCreateArgs>(args: SelectSubset<T, UserBadgeCreateArgs<ExtArgs>>): Prisma__UserBadgeClient<$Result.GetResult<Prisma.$UserBadgePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UserBadges.
     * @param {UserBadgeCreateManyArgs} args - Arguments to create many UserBadges.
     * @example
     * // Create many UserBadges
     * const userBadge = await prisma.userBadge.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserBadgeCreateManyArgs>(args?: SelectSubset<T, UserBadgeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserBadges and returns the data saved in the database.
     * @param {UserBadgeCreateManyAndReturnArgs} args - Arguments to create many UserBadges.
     * @example
     * // Create many UserBadges
     * const userBadge = await prisma.userBadge.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserBadges and only return the `userId`
     * const userBadgeWithUserIdOnly = await prisma.userBadge.createManyAndReturn({ 
     *   select: { userId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserBadgeCreateManyAndReturnArgs>(args?: SelectSubset<T, UserBadgeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserBadgePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a UserBadge.
     * @param {UserBadgeDeleteArgs} args - Arguments to delete one UserBadge.
     * @example
     * // Delete one UserBadge
     * const UserBadge = await prisma.userBadge.delete({
     *   where: {
     *     // ... filter to delete one UserBadge
     *   }
     * })
     * 
     */
    delete<T extends UserBadgeDeleteArgs>(args: SelectSubset<T, UserBadgeDeleteArgs<ExtArgs>>): Prisma__UserBadgeClient<$Result.GetResult<Prisma.$UserBadgePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UserBadge.
     * @param {UserBadgeUpdateArgs} args - Arguments to update one UserBadge.
     * @example
     * // Update one UserBadge
     * const userBadge = await prisma.userBadge.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserBadgeUpdateArgs>(args: SelectSubset<T, UserBadgeUpdateArgs<ExtArgs>>): Prisma__UserBadgeClient<$Result.GetResult<Prisma.$UserBadgePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UserBadges.
     * @param {UserBadgeDeleteManyArgs} args - Arguments to filter UserBadges to delete.
     * @example
     * // Delete a few UserBadges
     * const { count } = await prisma.userBadge.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserBadgeDeleteManyArgs>(args?: SelectSubset<T, UserBadgeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserBadges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBadgeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserBadges
     * const userBadge = await prisma.userBadge.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserBadgeUpdateManyArgs>(args: SelectSubset<T, UserBadgeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserBadge.
     * @param {UserBadgeUpsertArgs} args - Arguments to update or create a UserBadge.
     * @example
     * // Update or create a UserBadge
     * const userBadge = await prisma.userBadge.upsert({
     *   create: {
     *     // ... data to create a UserBadge
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserBadge we want to update
     *   }
     * })
     */
    upsert<T extends UserBadgeUpsertArgs>(args: SelectSubset<T, UserBadgeUpsertArgs<ExtArgs>>): Prisma__UserBadgeClient<$Result.GetResult<Prisma.$UserBadgePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UserBadges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBadgeCountArgs} args - Arguments to filter UserBadges to count.
     * @example
     * // Count the number of UserBadges
     * const count = await prisma.userBadge.count({
     *   where: {
     *     // ... the filter for the UserBadges we want to count
     *   }
     * })
    **/
    count<T extends UserBadgeCountArgs>(
      args?: Subset<T, UserBadgeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserBadgeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserBadge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBadgeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserBadgeAggregateArgs>(args: Subset<T, UserBadgeAggregateArgs>): Prisma.PrismaPromise<GetUserBadgeAggregateType<T>>

    /**
     * Group by UserBadge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBadgeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserBadgeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserBadgeGroupByArgs['orderBy'] }
        : { orderBy?: UserBadgeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserBadgeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserBadgeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserBadge model
   */
  readonly fields: UserBadgeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserBadge.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserBadgeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    badge<T extends BadgeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BadgeDefaultArgs<ExtArgs>>): Prisma__BadgeClient<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserBadge model
   */ 
  interface UserBadgeFieldRefs {
    readonly userId: FieldRef<"UserBadge", 'String'>
    readonly badgeId: FieldRef<"UserBadge", 'String'>
    readonly createdAt: FieldRef<"UserBadge", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserBadge findUnique
   */
  export type UserBadgeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBadge
     */
    select?: UserBadgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBadgeInclude<ExtArgs> | null
    /**
     * Filter, which UserBadge to fetch.
     */
    where: UserBadgeWhereUniqueInput
  }

  /**
   * UserBadge findUniqueOrThrow
   */
  export type UserBadgeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBadge
     */
    select?: UserBadgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBadgeInclude<ExtArgs> | null
    /**
     * Filter, which UserBadge to fetch.
     */
    where: UserBadgeWhereUniqueInput
  }

  /**
   * UserBadge findFirst
   */
  export type UserBadgeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBadge
     */
    select?: UserBadgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBadgeInclude<ExtArgs> | null
    /**
     * Filter, which UserBadge to fetch.
     */
    where?: UserBadgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserBadges to fetch.
     */
    orderBy?: UserBadgeOrderByWithRelationInput | UserBadgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserBadges.
     */
    cursor?: UserBadgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserBadges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserBadges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserBadges.
     */
    distinct?: UserBadgeScalarFieldEnum | UserBadgeScalarFieldEnum[]
  }

  /**
   * UserBadge findFirstOrThrow
   */
  export type UserBadgeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBadge
     */
    select?: UserBadgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBadgeInclude<ExtArgs> | null
    /**
     * Filter, which UserBadge to fetch.
     */
    where?: UserBadgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserBadges to fetch.
     */
    orderBy?: UserBadgeOrderByWithRelationInput | UserBadgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserBadges.
     */
    cursor?: UserBadgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserBadges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserBadges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserBadges.
     */
    distinct?: UserBadgeScalarFieldEnum | UserBadgeScalarFieldEnum[]
  }

  /**
   * UserBadge findMany
   */
  export type UserBadgeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBadge
     */
    select?: UserBadgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBadgeInclude<ExtArgs> | null
    /**
     * Filter, which UserBadges to fetch.
     */
    where?: UserBadgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserBadges to fetch.
     */
    orderBy?: UserBadgeOrderByWithRelationInput | UserBadgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserBadges.
     */
    cursor?: UserBadgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserBadges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserBadges.
     */
    skip?: number
    distinct?: UserBadgeScalarFieldEnum | UserBadgeScalarFieldEnum[]
  }

  /**
   * UserBadge create
   */
  export type UserBadgeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBadge
     */
    select?: UserBadgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBadgeInclude<ExtArgs> | null
    /**
     * The data needed to create a UserBadge.
     */
    data: XOR<UserBadgeCreateInput, UserBadgeUncheckedCreateInput>
  }

  /**
   * UserBadge createMany
   */
  export type UserBadgeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserBadges.
     */
    data: UserBadgeCreateManyInput | UserBadgeCreateManyInput[]
  }

  /**
   * UserBadge createManyAndReturn
   */
  export type UserBadgeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBadge
     */
    select?: UserBadgeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many UserBadges.
     */
    data: UserBadgeCreateManyInput | UserBadgeCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBadgeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserBadge update
   */
  export type UserBadgeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBadge
     */
    select?: UserBadgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBadgeInclude<ExtArgs> | null
    /**
     * The data needed to update a UserBadge.
     */
    data: XOR<UserBadgeUpdateInput, UserBadgeUncheckedUpdateInput>
    /**
     * Choose, which UserBadge to update.
     */
    where: UserBadgeWhereUniqueInput
  }

  /**
   * UserBadge updateMany
   */
  export type UserBadgeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserBadges.
     */
    data: XOR<UserBadgeUpdateManyMutationInput, UserBadgeUncheckedUpdateManyInput>
    /**
     * Filter which UserBadges to update
     */
    where?: UserBadgeWhereInput
  }

  /**
   * UserBadge upsert
   */
  export type UserBadgeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBadge
     */
    select?: UserBadgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBadgeInclude<ExtArgs> | null
    /**
     * The filter to search for the UserBadge to update in case it exists.
     */
    where: UserBadgeWhereUniqueInput
    /**
     * In case the UserBadge found by the `where` argument doesn't exist, create a new UserBadge with this data.
     */
    create: XOR<UserBadgeCreateInput, UserBadgeUncheckedCreateInput>
    /**
     * In case the UserBadge was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserBadgeUpdateInput, UserBadgeUncheckedUpdateInput>
  }

  /**
   * UserBadge delete
   */
  export type UserBadgeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBadge
     */
    select?: UserBadgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBadgeInclude<ExtArgs> | null
    /**
     * Filter which UserBadge to delete.
     */
    where: UserBadgeWhereUniqueInput
  }

  /**
   * UserBadge deleteMany
   */
  export type UserBadgeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserBadges to delete
     */
    where?: UserBadgeWhereInput
  }

  /**
   * UserBadge without action
   */
  export type UserBadgeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBadge
     */
    select?: UserBadgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBadgeInclude<ExtArgs> | null
  }


  /**
   * Model Conversation
   */

  export type AggregateConversation = {
    _count: ConversationCountAggregateOutputType | null
    _min: ConversationMinAggregateOutputType | null
    _max: ConversationMaxAggregateOutputType | null
  }

  export type ConversationMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ConversationMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ConversationCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ConversationMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ConversationMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ConversationCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ConversationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Conversation to aggregate.
     */
    where?: ConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conversations to fetch.
     */
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conversations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Conversations
    **/
    _count?: true | ConversationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConversationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConversationMaxAggregateInputType
  }

  export type GetConversationAggregateType<T extends ConversationAggregateArgs> = {
        [P in keyof T & keyof AggregateConversation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConversation[P]>
      : GetScalarType<T[P], AggregateConversation[P]>
  }




  export type ConversationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConversationWhereInput
    orderBy?: ConversationOrderByWithAggregationInput | ConversationOrderByWithAggregationInput[]
    by: ConversationScalarFieldEnum[] | ConversationScalarFieldEnum
    having?: ConversationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConversationCountAggregateInputType | true
    _min?: ConversationMinAggregateInputType
    _max?: ConversationMaxAggregateInputType
  }

  export type ConversationGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    _count: ConversationCountAggregateOutputType | null
    _min: ConversationMinAggregateOutputType | null
    _max: ConversationMaxAggregateOutputType | null
  }

  type GetConversationGroupByPayload<T extends ConversationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConversationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConversationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConversationGroupByOutputType[P]>
            : GetScalarType<T[P], ConversationGroupByOutputType[P]>
        }
      >
    >


  export type ConversationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    participants?: boolean | Conversation$participantsArgs<ExtArgs>
    messages?: boolean | Conversation$messagesArgs<ExtArgs>
    _count?: boolean | ConversationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conversation"]>

  export type ConversationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["conversation"]>

  export type ConversationSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ConversationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    participants?: boolean | Conversation$participantsArgs<ExtArgs>
    messages?: boolean | Conversation$messagesArgs<ExtArgs>
    _count?: boolean | ConversationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ConversationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ConversationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Conversation"
    objects: {
      participants: Prisma.$ConversationParticipantPayload<ExtArgs>[]
      messages: Prisma.$DirectMessagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["conversation"]>
    composites: {}
  }

  type ConversationGetPayload<S extends boolean | null | undefined | ConversationDefaultArgs> = $Result.GetResult<Prisma.$ConversationPayload, S>

  type ConversationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ConversationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ConversationCountAggregateInputType | true
    }

  export interface ConversationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Conversation'], meta: { name: 'Conversation' } }
    /**
     * Find zero or one Conversation that matches the filter.
     * @param {ConversationFindUniqueArgs} args - Arguments to find a Conversation
     * @example
     * // Get one Conversation
     * const conversation = await prisma.conversation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ConversationFindUniqueArgs>(args: SelectSubset<T, ConversationFindUniqueArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Conversation that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ConversationFindUniqueOrThrowArgs} args - Arguments to find a Conversation
     * @example
     * // Get one Conversation
     * const conversation = await prisma.conversation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ConversationFindUniqueOrThrowArgs>(args: SelectSubset<T, ConversationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Conversation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationFindFirstArgs} args - Arguments to find a Conversation
     * @example
     * // Get one Conversation
     * const conversation = await prisma.conversation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ConversationFindFirstArgs>(args?: SelectSubset<T, ConversationFindFirstArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Conversation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationFindFirstOrThrowArgs} args - Arguments to find a Conversation
     * @example
     * // Get one Conversation
     * const conversation = await prisma.conversation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ConversationFindFirstOrThrowArgs>(args?: SelectSubset<T, ConversationFindFirstOrThrowArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Conversations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Conversations
     * const conversations = await prisma.conversation.findMany()
     * 
     * // Get first 10 Conversations
     * const conversations = await prisma.conversation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const conversationWithIdOnly = await prisma.conversation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ConversationFindManyArgs>(args?: SelectSubset<T, ConversationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Conversation.
     * @param {ConversationCreateArgs} args - Arguments to create a Conversation.
     * @example
     * // Create one Conversation
     * const Conversation = await prisma.conversation.create({
     *   data: {
     *     // ... data to create a Conversation
     *   }
     * })
     * 
     */
    create<T extends ConversationCreateArgs>(args: SelectSubset<T, ConversationCreateArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Conversations.
     * @param {ConversationCreateManyArgs} args - Arguments to create many Conversations.
     * @example
     * // Create many Conversations
     * const conversation = await prisma.conversation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ConversationCreateManyArgs>(args?: SelectSubset<T, ConversationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Conversations and returns the data saved in the database.
     * @param {ConversationCreateManyAndReturnArgs} args - Arguments to create many Conversations.
     * @example
     * // Create many Conversations
     * const conversation = await prisma.conversation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Conversations and only return the `id`
     * const conversationWithIdOnly = await prisma.conversation.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ConversationCreateManyAndReturnArgs>(args?: SelectSubset<T, ConversationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Conversation.
     * @param {ConversationDeleteArgs} args - Arguments to delete one Conversation.
     * @example
     * // Delete one Conversation
     * const Conversation = await prisma.conversation.delete({
     *   where: {
     *     // ... filter to delete one Conversation
     *   }
     * })
     * 
     */
    delete<T extends ConversationDeleteArgs>(args: SelectSubset<T, ConversationDeleteArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Conversation.
     * @param {ConversationUpdateArgs} args - Arguments to update one Conversation.
     * @example
     * // Update one Conversation
     * const conversation = await prisma.conversation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ConversationUpdateArgs>(args: SelectSubset<T, ConversationUpdateArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Conversations.
     * @param {ConversationDeleteManyArgs} args - Arguments to filter Conversations to delete.
     * @example
     * // Delete a few Conversations
     * const { count } = await prisma.conversation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ConversationDeleteManyArgs>(args?: SelectSubset<T, ConversationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Conversations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Conversations
     * const conversation = await prisma.conversation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ConversationUpdateManyArgs>(args: SelectSubset<T, ConversationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Conversation.
     * @param {ConversationUpsertArgs} args - Arguments to update or create a Conversation.
     * @example
     * // Update or create a Conversation
     * const conversation = await prisma.conversation.upsert({
     *   create: {
     *     // ... data to create a Conversation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Conversation we want to update
     *   }
     * })
     */
    upsert<T extends ConversationUpsertArgs>(args: SelectSubset<T, ConversationUpsertArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Conversations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationCountArgs} args - Arguments to filter Conversations to count.
     * @example
     * // Count the number of Conversations
     * const count = await prisma.conversation.count({
     *   where: {
     *     // ... the filter for the Conversations we want to count
     *   }
     * })
    **/
    count<T extends ConversationCountArgs>(
      args?: Subset<T, ConversationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConversationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Conversation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConversationAggregateArgs>(args: Subset<T, ConversationAggregateArgs>): Prisma.PrismaPromise<GetConversationAggregateType<T>>

    /**
     * Group by Conversation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConversationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConversationGroupByArgs['orderBy'] }
        : { orderBy?: ConversationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConversationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConversationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Conversation model
   */
  readonly fields: ConversationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Conversation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConversationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    participants<T extends Conversation$participantsArgs<ExtArgs> = {}>(args?: Subset<T, Conversation$participantsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationParticipantPayload<ExtArgs>, T, "findMany"> | Null>
    messages<T extends Conversation$messagesArgs<ExtArgs> = {}>(args?: Subset<T, Conversation$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DirectMessagePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Conversation model
   */ 
  interface ConversationFieldRefs {
    readonly id: FieldRef<"Conversation", 'String'>
    readonly createdAt: FieldRef<"Conversation", 'DateTime'>
    readonly updatedAt: FieldRef<"Conversation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Conversation findUnique
   */
  export type ConversationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter, which Conversation to fetch.
     */
    where: ConversationWhereUniqueInput
  }

  /**
   * Conversation findUniqueOrThrow
   */
  export type ConversationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter, which Conversation to fetch.
     */
    where: ConversationWhereUniqueInput
  }

  /**
   * Conversation findFirst
   */
  export type ConversationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter, which Conversation to fetch.
     */
    where?: ConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conversations to fetch.
     */
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Conversations.
     */
    cursor?: ConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conversations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Conversations.
     */
    distinct?: ConversationScalarFieldEnum | ConversationScalarFieldEnum[]
  }

  /**
   * Conversation findFirstOrThrow
   */
  export type ConversationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter, which Conversation to fetch.
     */
    where?: ConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conversations to fetch.
     */
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Conversations.
     */
    cursor?: ConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conversations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Conversations.
     */
    distinct?: ConversationScalarFieldEnum | ConversationScalarFieldEnum[]
  }

  /**
   * Conversation findMany
   */
  export type ConversationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter, which Conversations to fetch.
     */
    where?: ConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conversations to fetch.
     */
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Conversations.
     */
    cursor?: ConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conversations.
     */
    skip?: number
    distinct?: ConversationScalarFieldEnum | ConversationScalarFieldEnum[]
  }

  /**
   * Conversation create
   */
  export type ConversationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * The data needed to create a Conversation.
     */
    data: XOR<ConversationCreateInput, ConversationUncheckedCreateInput>
  }

  /**
   * Conversation createMany
   */
  export type ConversationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Conversations.
     */
    data: ConversationCreateManyInput | ConversationCreateManyInput[]
  }

  /**
   * Conversation createManyAndReturn
   */
  export type ConversationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Conversations.
     */
    data: ConversationCreateManyInput | ConversationCreateManyInput[]
  }

  /**
   * Conversation update
   */
  export type ConversationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * The data needed to update a Conversation.
     */
    data: XOR<ConversationUpdateInput, ConversationUncheckedUpdateInput>
    /**
     * Choose, which Conversation to update.
     */
    where: ConversationWhereUniqueInput
  }

  /**
   * Conversation updateMany
   */
  export type ConversationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Conversations.
     */
    data: XOR<ConversationUpdateManyMutationInput, ConversationUncheckedUpdateManyInput>
    /**
     * Filter which Conversations to update
     */
    where?: ConversationWhereInput
  }

  /**
   * Conversation upsert
   */
  export type ConversationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * The filter to search for the Conversation to update in case it exists.
     */
    where: ConversationWhereUniqueInput
    /**
     * In case the Conversation found by the `where` argument doesn't exist, create a new Conversation with this data.
     */
    create: XOR<ConversationCreateInput, ConversationUncheckedCreateInput>
    /**
     * In case the Conversation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConversationUpdateInput, ConversationUncheckedUpdateInput>
  }

  /**
   * Conversation delete
   */
  export type ConversationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter which Conversation to delete.
     */
    where: ConversationWhereUniqueInput
  }

  /**
   * Conversation deleteMany
   */
  export type ConversationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Conversations to delete
     */
    where?: ConversationWhereInput
  }

  /**
   * Conversation.participants
   */
  export type Conversation$participantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationParticipant
     */
    select?: ConversationParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationParticipantInclude<ExtArgs> | null
    where?: ConversationParticipantWhereInput
    orderBy?: ConversationParticipantOrderByWithRelationInput | ConversationParticipantOrderByWithRelationInput[]
    cursor?: ConversationParticipantWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConversationParticipantScalarFieldEnum | ConversationParticipantScalarFieldEnum[]
  }

  /**
   * Conversation.messages
   */
  export type Conversation$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DirectMessage
     */
    select?: DirectMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DirectMessageInclude<ExtArgs> | null
    where?: DirectMessageWhereInput
    orderBy?: DirectMessageOrderByWithRelationInput | DirectMessageOrderByWithRelationInput[]
    cursor?: DirectMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DirectMessageScalarFieldEnum | DirectMessageScalarFieldEnum[]
  }

  /**
   * Conversation without action
   */
  export type ConversationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
  }


  /**
   * Model ConversationParticipant
   */

  export type AggregateConversationParticipant = {
    _count: ConversationParticipantCountAggregateOutputType | null
    _min: ConversationParticipantMinAggregateOutputType | null
    _max: ConversationParticipantMaxAggregateOutputType | null
  }

  export type ConversationParticipantMinAggregateOutputType = {
    conversationId: string | null
    userId: string | null
    createdAt: Date | null
  }

  export type ConversationParticipantMaxAggregateOutputType = {
    conversationId: string | null
    userId: string | null
    createdAt: Date | null
  }

  export type ConversationParticipantCountAggregateOutputType = {
    conversationId: number
    userId: number
    createdAt: number
    _all: number
  }


  export type ConversationParticipantMinAggregateInputType = {
    conversationId?: true
    userId?: true
    createdAt?: true
  }

  export type ConversationParticipantMaxAggregateInputType = {
    conversationId?: true
    userId?: true
    createdAt?: true
  }

  export type ConversationParticipantCountAggregateInputType = {
    conversationId?: true
    userId?: true
    createdAt?: true
    _all?: true
  }

  export type ConversationParticipantAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConversationParticipant to aggregate.
     */
    where?: ConversationParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConversationParticipants to fetch.
     */
    orderBy?: ConversationParticipantOrderByWithRelationInput | ConversationParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConversationParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConversationParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConversationParticipants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ConversationParticipants
    **/
    _count?: true | ConversationParticipantCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConversationParticipantMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConversationParticipantMaxAggregateInputType
  }

  export type GetConversationParticipantAggregateType<T extends ConversationParticipantAggregateArgs> = {
        [P in keyof T & keyof AggregateConversationParticipant]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConversationParticipant[P]>
      : GetScalarType<T[P], AggregateConversationParticipant[P]>
  }




  export type ConversationParticipantGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConversationParticipantWhereInput
    orderBy?: ConversationParticipantOrderByWithAggregationInput | ConversationParticipantOrderByWithAggregationInput[]
    by: ConversationParticipantScalarFieldEnum[] | ConversationParticipantScalarFieldEnum
    having?: ConversationParticipantScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConversationParticipantCountAggregateInputType | true
    _min?: ConversationParticipantMinAggregateInputType
    _max?: ConversationParticipantMaxAggregateInputType
  }

  export type ConversationParticipantGroupByOutputType = {
    conversationId: string
    userId: string
    createdAt: Date
    _count: ConversationParticipantCountAggregateOutputType | null
    _min: ConversationParticipantMinAggregateOutputType | null
    _max: ConversationParticipantMaxAggregateOutputType | null
  }

  type GetConversationParticipantGroupByPayload<T extends ConversationParticipantGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConversationParticipantGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConversationParticipantGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConversationParticipantGroupByOutputType[P]>
            : GetScalarType<T[P], ConversationParticipantGroupByOutputType[P]>
        }
      >
    >


  export type ConversationParticipantSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    conversationId?: boolean
    userId?: boolean
    createdAt?: boolean
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conversationParticipant"]>

  export type ConversationParticipantSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    conversationId?: boolean
    userId?: boolean
    createdAt?: boolean
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conversationParticipant"]>

  export type ConversationParticipantSelectScalar = {
    conversationId?: boolean
    userId?: boolean
    createdAt?: boolean
  }

  export type ConversationParticipantInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ConversationParticipantIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ConversationParticipantPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ConversationParticipant"
    objects: {
      conversation: Prisma.$ConversationPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      conversationId: string
      userId: string
      createdAt: Date
    }, ExtArgs["result"]["conversationParticipant"]>
    composites: {}
  }

  type ConversationParticipantGetPayload<S extends boolean | null | undefined | ConversationParticipantDefaultArgs> = $Result.GetResult<Prisma.$ConversationParticipantPayload, S>

  type ConversationParticipantCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ConversationParticipantFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ConversationParticipantCountAggregateInputType | true
    }

  export interface ConversationParticipantDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ConversationParticipant'], meta: { name: 'ConversationParticipant' } }
    /**
     * Find zero or one ConversationParticipant that matches the filter.
     * @param {ConversationParticipantFindUniqueArgs} args - Arguments to find a ConversationParticipant
     * @example
     * // Get one ConversationParticipant
     * const conversationParticipant = await prisma.conversationParticipant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ConversationParticipantFindUniqueArgs>(args: SelectSubset<T, ConversationParticipantFindUniqueArgs<ExtArgs>>): Prisma__ConversationParticipantClient<$Result.GetResult<Prisma.$ConversationParticipantPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ConversationParticipant that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ConversationParticipantFindUniqueOrThrowArgs} args - Arguments to find a ConversationParticipant
     * @example
     * // Get one ConversationParticipant
     * const conversationParticipant = await prisma.conversationParticipant.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ConversationParticipantFindUniqueOrThrowArgs>(args: SelectSubset<T, ConversationParticipantFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ConversationParticipantClient<$Result.GetResult<Prisma.$ConversationParticipantPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ConversationParticipant that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationParticipantFindFirstArgs} args - Arguments to find a ConversationParticipant
     * @example
     * // Get one ConversationParticipant
     * const conversationParticipant = await prisma.conversationParticipant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ConversationParticipantFindFirstArgs>(args?: SelectSubset<T, ConversationParticipantFindFirstArgs<ExtArgs>>): Prisma__ConversationParticipantClient<$Result.GetResult<Prisma.$ConversationParticipantPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ConversationParticipant that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationParticipantFindFirstOrThrowArgs} args - Arguments to find a ConversationParticipant
     * @example
     * // Get one ConversationParticipant
     * const conversationParticipant = await prisma.conversationParticipant.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ConversationParticipantFindFirstOrThrowArgs>(args?: SelectSubset<T, ConversationParticipantFindFirstOrThrowArgs<ExtArgs>>): Prisma__ConversationParticipantClient<$Result.GetResult<Prisma.$ConversationParticipantPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ConversationParticipants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationParticipantFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ConversationParticipants
     * const conversationParticipants = await prisma.conversationParticipant.findMany()
     * 
     * // Get first 10 ConversationParticipants
     * const conversationParticipants = await prisma.conversationParticipant.findMany({ take: 10 })
     * 
     * // Only select the `conversationId`
     * const conversationParticipantWithConversationIdOnly = await prisma.conversationParticipant.findMany({ select: { conversationId: true } })
     * 
     */
    findMany<T extends ConversationParticipantFindManyArgs>(args?: SelectSubset<T, ConversationParticipantFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationParticipantPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ConversationParticipant.
     * @param {ConversationParticipantCreateArgs} args - Arguments to create a ConversationParticipant.
     * @example
     * // Create one ConversationParticipant
     * const ConversationParticipant = await prisma.conversationParticipant.create({
     *   data: {
     *     // ... data to create a ConversationParticipant
     *   }
     * })
     * 
     */
    create<T extends ConversationParticipantCreateArgs>(args: SelectSubset<T, ConversationParticipantCreateArgs<ExtArgs>>): Prisma__ConversationParticipantClient<$Result.GetResult<Prisma.$ConversationParticipantPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ConversationParticipants.
     * @param {ConversationParticipantCreateManyArgs} args - Arguments to create many ConversationParticipants.
     * @example
     * // Create many ConversationParticipants
     * const conversationParticipant = await prisma.conversationParticipant.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ConversationParticipantCreateManyArgs>(args?: SelectSubset<T, ConversationParticipantCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ConversationParticipants and returns the data saved in the database.
     * @param {ConversationParticipantCreateManyAndReturnArgs} args - Arguments to create many ConversationParticipants.
     * @example
     * // Create many ConversationParticipants
     * const conversationParticipant = await prisma.conversationParticipant.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ConversationParticipants and only return the `conversationId`
     * const conversationParticipantWithConversationIdOnly = await prisma.conversationParticipant.createManyAndReturn({ 
     *   select: { conversationId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ConversationParticipantCreateManyAndReturnArgs>(args?: SelectSubset<T, ConversationParticipantCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationParticipantPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ConversationParticipant.
     * @param {ConversationParticipantDeleteArgs} args - Arguments to delete one ConversationParticipant.
     * @example
     * // Delete one ConversationParticipant
     * const ConversationParticipant = await prisma.conversationParticipant.delete({
     *   where: {
     *     // ... filter to delete one ConversationParticipant
     *   }
     * })
     * 
     */
    delete<T extends ConversationParticipantDeleteArgs>(args: SelectSubset<T, ConversationParticipantDeleteArgs<ExtArgs>>): Prisma__ConversationParticipantClient<$Result.GetResult<Prisma.$ConversationParticipantPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ConversationParticipant.
     * @param {ConversationParticipantUpdateArgs} args - Arguments to update one ConversationParticipant.
     * @example
     * // Update one ConversationParticipant
     * const conversationParticipant = await prisma.conversationParticipant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ConversationParticipantUpdateArgs>(args: SelectSubset<T, ConversationParticipantUpdateArgs<ExtArgs>>): Prisma__ConversationParticipantClient<$Result.GetResult<Prisma.$ConversationParticipantPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ConversationParticipants.
     * @param {ConversationParticipantDeleteManyArgs} args - Arguments to filter ConversationParticipants to delete.
     * @example
     * // Delete a few ConversationParticipants
     * const { count } = await prisma.conversationParticipant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ConversationParticipantDeleteManyArgs>(args?: SelectSubset<T, ConversationParticipantDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ConversationParticipants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationParticipantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ConversationParticipants
     * const conversationParticipant = await prisma.conversationParticipant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ConversationParticipantUpdateManyArgs>(args: SelectSubset<T, ConversationParticipantUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ConversationParticipant.
     * @param {ConversationParticipantUpsertArgs} args - Arguments to update or create a ConversationParticipant.
     * @example
     * // Update or create a ConversationParticipant
     * const conversationParticipant = await prisma.conversationParticipant.upsert({
     *   create: {
     *     // ... data to create a ConversationParticipant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ConversationParticipant we want to update
     *   }
     * })
     */
    upsert<T extends ConversationParticipantUpsertArgs>(args: SelectSubset<T, ConversationParticipantUpsertArgs<ExtArgs>>): Prisma__ConversationParticipantClient<$Result.GetResult<Prisma.$ConversationParticipantPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ConversationParticipants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationParticipantCountArgs} args - Arguments to filter ConversationParticipants to count.
     * @example
     * // Count the number of ConversationParticipants
     * const count = await prisma.conversationParticipant.count({
     *   where: {
     *     // ... the filter for the ConversationParticipants we want to count
     *   }
     * })
    **/
    count<T extends ConversationParticipantCountArgs>(
      args?: Subset<T, ConversationParticipantCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConversationParticipantCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ConversationParticipant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationParticipantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConversationParticipantAggregateArgs>(args: Subset<T, ConversationParticipantAggregateArgs>): Prisma.PrismaPromise<GetConversationParticipantAggregateType<T>>

    /**
     * Group by ConversationParticipant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationParticipantGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConversationParticipantGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConversationParticipantGroupByArgs['orderBy'] }
        : { orderBy?: ConversationParticipantGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConversationParticipantGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConversationParticipantGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ConversationParticipant model
   */
  readonly fields: ConversationParticipantFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ConversationParticipant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConversationParticipantClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    conversation<T extends ConversationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ConversationDefaultArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ConversationParticipant model
   */ 
  interface ConversationParticipantFieldRefs {
    readonly conversationId: FieldRef<"ConversationParticipant", 'String'>
    readonly userId: FieldRef<"ConversationParticipant", 'String'>
    readonly createdAt: FieldRef<"ConversationParticipant", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ConversationParticipant findUnique
   */
  export type ConversationParticipantFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationParticipant
     */
    select?: ConversationParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationParticipantInclude<ExtArgs> | null
    /**
     * Filter, which ConversationParticipant to fetch.
     */
    where: ConversationParticipantWhereUniqueInput
  }

  /**
   * ConversationParticipant findUniqueOrThrow
   */
  export type ConversationParticipantFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationParticipant
     */
    select?: ConversationParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationParticipantInclude<ExtArgs> | null
    /**
     * Filter, which ConversationParticipant to fetch.
     */
    where: ConversationParticipantWhereUniqueInput
  }

  /**
   * ConversationParticipant findFirst
   */
  export type ConversationParticipantFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationParticipant
     */
    select?: ConversationParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationParticipantInclude<ExtArgs> | null
    /**
     * Filter, which ConversationParticipant to fetch.
     */
    where?: ConversationParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConversationParticipants to fetch.
     */
    orderBy?: ConversationParticipantOrderByWithRelationInput | ConversationParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConversationParticipants.
     */
    cursor?: ConversationParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConversationParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConversationParticipants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConversationParticipants.
     */
    distinct?: ConversationParticipantScalarFieldEnum | ConversationParticipantScalarFieldEnum[]
  }

  /**
   * ConversationParticipant findFirstOrThrow
   */
  export type ConversationParticipantFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationParticipant
     */
    select?: ConversationParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationParticipantInclude<ExtArgs> | null
    /**
     * Filter, which ConversationParticipant to fetch.
     */
    where?: ConversationParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConversationParticipants to fetch.
     */
    orderBy?: ConversationParticipantOrderByWithRelationInput | ConversationParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConversationParticipants.
     */
    cursor?: ConversationParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConversationParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConversationParticipants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConversationParticipants.
     */
    distinct?: ConversationParticipantScalarFieldEnum | ConversationParticipantScalarFieldEnum[]
  }

  /**
   * ConversationParticipant findMany
   */
  export type ConversationParticipantFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationParticipant
     */
    select?: ConversationParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationParticipantInclude<ExtArgs> | null
    /**
     * Filter, which ConversationParticipants to fetch.
     */
    where?: ConversationParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConversationParticipants to fetch.
     */
    orderBy?: ConversationParticipantOrderByWithRelationInput | ConversationParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ConversationParticipants.
     */
    cursor?: ConversationParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConversationParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConversationParticipants.
     */
    skip?: number
    distinct?: ConversationParticipantScalarFieldEnum | ConversationParticipantScalarFieldEnum[]
  }

  /**
   * ConversationParticipant create
   */
  export type ConversationParticipantCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationParticipant
     */
    select?: ConversationParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationParticipantInclude<ExtArgs> | null
    /**
     * The data needed to create a ConversationParticipant.
     */
    data: XOR<ConversationParticipantCreateInput, ConversationParticipantUncheckedCreateInput>
  }

  /**
   * ConversationParticipant createMany
   */
  export type ConversationParticipantCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ConversationParticipants.
     */
    data: ConversationParticipantCreateManyInput | ConversationParticipantCreateManyInput[]
  }

  /**
   * ConversationParticipant createManyAndReturn
   */
  export type ConversationParticipantCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationParticipant
     */
    select?: ConversationParticipantSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ConversationParticipants.
     */
    data: ConversationParticipantCreateManyInput | ConversationParticipantCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationParticipantIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ConversationParticipant update
   */
  export type ConversationParticipantUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationParticipant
     */
    select?: ConversationParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationParticipantInclude<ExtArgs> | null
    /**
     * The data needed to update a ConversationParticipant.
     */
    data: XOR<ConversationParticipantUpdateInput, ConversationParticipantUncheckedUpdateInput>
    /**
     * Choose, which ConversationParticipant to update.
     */
    where: ConversationParticipantWhereUniqueInput
  }

  /**
   * ConversationParticipant updateMany
   */
  export type ConversationParticipantUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ConversationParticipants.
     */
    data: XOR<ConversationParticipantUpdateManyMutationInput, ConversationParticipantUncheckedUpdateManyInput>
    /**
     * Filter which ConversationParticipants to update
     */
    where?: ConversationParticipantWhereInput
  }

  /**
   * ConversationParticipant upsert
   */
  export type ConversationParticipantUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationParticipant
     */
    select?: ConversationParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationParticipantInclude<ExtArgs> | null
    /**
     * The filter to search for the ConversationParticipant to update in case it exists.
     */
    where: ConversationParticipantWhereUniqueInput
    /**
     * In case the ConversationParticipant found by the `where` argument doesn't exist, create a new ConversationParticipant with this data.
     */
    create: XOR<ConversationParticipantCreateInput, ConversationParticipantUncheckedCreateInput>
    /**
     * In case the ConversationParticipant was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConversationParticipantUpdateInput, ConversationParticipantUncheckedUpdateInput>
  }

  /**
   * ConversationParticipant delete
   */
  export type ConversationParticipantDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationParticipant
     */
    select?: ConversationParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationParticipantInclude<ExtArgs> | null
    /**
     * Filter which ConversationParticipant to delete.
     */
    where: ConversationParticipantWhereUniqueInput
  }

  /**
   * ConversationParticipant deleteMany
   */
  export type ConversationParticipantDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConversationParticipants to delete
     */
    where?: ConversationParticipantWhereInput
  }

  /**
   * ConversationParticipant without action
   */
  export type ConversationParticipantDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationParticipant
     */
    select?: ConversationParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationParticipantInclude<ExtArgs> | null
  }


  /**
   * Model DirectMessage
   */

  export type AggregateDirectMessage = {
    _count: DirectMessageCountAggregateOutputType | null
    _min: DirectMessageMinAggregateOutputType | null
    _max: DirectMessageMaxAggregateOutputType | null
  }

  export type DirectMessageMinAggregateOutputType = {
    id: string | null
    conversationId: string | null
    senderId: string | null
    receiverId: string | null
    content: string | null
    kind: string | null
    isDeleted: boolean | null
    createdAt: Date | null
  }

  export type DirectMessageMaxAggregateOutputType = {
    id: string | null
    conversationId: string | null
    senderId: string | null
    receiverId: string | null
    content: string | null
    kind: string | null
    isDeleted: boolean | null
    createdAt: Date | null
  }

  export type DirectMessageCountAggregateOutputType = {
    id: number
    conversationId: number
    senderId: number
    receiverId: number
    content: number
    kind: number
    isDeleted: number
    createdAt: number
    _all: number
  }


  export type DirectMessageMinAggregateInputType = {
    id?: true
    conversationId?: true
    senderId?: true
    receiverId?: true
    content?: true
    kind?: true
    isDeleted?: true
    createdAt?: true
  }

  export type DirectMessageMaxAggregateInputType = {
    id?: true
    conversationId?: true
    senderId?: true
    receiverId?: true
    content?: true
    kind?: true
    isDeleted?: true
    createdAt?: true
  }

  export type DirectMessageCountAggregateInputType = {
    id?: true
    conversationId?: true
    senderId?: true
    receiverId?: true
    content?: true
    kind?: true
    isDeleted?: true
    createdAt?: true
    _all?: true
  }

  export type DirectMessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DirectMessage to aggregate.
     */
    where?: DirectMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DirectMessages to fetch.
     */
    orderBy?: DirectMessageOrderByWithRelationInput | DirectMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DirectMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DirectMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DirectMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DirectMessages
    **/
    _count?: true | DirectMessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DirectMessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DirectMessageMaxAggregateInputType
  }

  export type GetDirectMessageAggregateType<T extends DirectMessageAggregateArgs> = {
        [P in keyof T & keyof AggregateDirectMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDirectMessage[P]>
      : GetScalarType<T[P], AggregateDirectMessage[P]>
  }




  export type DirectMessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DirectMessageWhereInput
    orderBy?: DirectMessageOrderByWithAggregationInput | DirectMessageOrderByWithAggregationInput[]
    by: DirectMessageScalarFieldEnum[] | DirectMessageScalarFieldEnum
    having?: DirectMessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DirectMessageCountAggregateInputType | true
    _min?: DirectMessageMinAggregateInputType
    _max?: DirectMessageMaxAggregateInputType
  }

  export type DirectMessageGroupByOutputType = {
    id: string
    conversationId: string
    senderId: string
    receiverId: string
    content: string
    kind: string
    isDeleted: boolean
    createdAt: Date
    _count: DirectMessageCountAggregateOutputType | null
    _min: DirectMessageMinAggregateOutputType | null
    _max: DirectMessageMaxAggregateOutputType | null
  }

  type GetDirectMessageGroupByPayload<T extends DirectMessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DirectMessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DirectMessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DirectMessageGroupByOutputType[P]>
            : GetScalarType<T[P], DirectMessageGroupByOutputType[P]>
        }
      >
    >


  export type DirectMessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conversationId?: boolean
    senderId?: boolean
    receiverId?: boolean
    content?: boolean
    kind?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
    receiver?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["directMessage"]>

  export type DirectMessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conversationId?: boolean
    senderId?: boolean
    receiverId?: boolean
    content?: boolean
    kind?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
    receiver?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["directMessage"]>

  export type DirectMessageSelectScalar = {
    id?: boolean
    conversationId?: boolean
    senderId?: boolean
    receiverId?: boolean
    content?: boolean
    kind?: boolean
    isDeleted?: boolean
    createdAt?: boolean
  }

  export type DirectMessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
    receiver?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type DirectMessageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
    receiver?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $DirectMessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DirectMessage"
    objects: {
      conversation: Prisma.$ConversationPayload<ExtArgs>
      sender: Prisma.$UserPayload<ExtArgs>
      receiver: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      conversationId: string
      senderId: string
      receiverId: string
      content: string
      kind: string
      isDeleted: boolean
      createdAt: Date
    }, ExtArgs["result"]["directMessage"]>
    composites: {}
  }

  type DirectMessageGetPayload<S extends boolean | null | undefined | DirectMessageDefaultArgs> = $Result.GetResult<Prisma.$DirectMessagePayload, S>

  type DirectMessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DirectMessageFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DirectMessageCountAggregateInputType | true
    }

  export interface DirectMessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DirectMessage'], meta: { name: 'DirectMessage' } }
    /**
     * Find zero or one DirectMessage that matches the filter.
     * @param {DirectMessageFindUniqueArgs} args - Arguments to find a DirectMessage
     * @example
     * // Get one DirectMessage
     * const directMessage = await prisma.directMessage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DirectMessageFindUniqueArgs>(args: SelectSubset<T, DirectMessageFindUniqueArgs<ExtArgs>>): Prisma__DirectMessageClient<$Result.GetResult<Prisma.$DirectMessagePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one DirectMessage that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DirectMessageFindUniqueOrThrowArgs} args - Arguments to find a DirectMessage
     * @example
     * // Get one DirectMessage
     * const directMessage = await prisma.directMessage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DirectMessageFindUniqueOrThrowArgs>(args: SelectSubset<T, DirectMessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DirectMessageClient<$Result.GetResult<Prisma.$DirectMessagePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first DirectMessage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DirectMessageFindFirstArgs} args - Arguments to find a DirectMessage
     * @example
     * // Get one DirectMessage
     * const directMessage = await prisma.directMessage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DirectMessageFindFirstArgs>(args?: SelectSubset<T, DirectMessageFindFirstArgs<ExtArgs>>): Prisma__DirectMessageClient<$Result.GetResult<Prisma.$DirectMessagePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first DirectMessage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DirectMessageFindFirstOrThrowArgs} args - Arguments to find a DirectMessage
     * @example
     * // Get one DirectMessage
     * const directMessage = await prisma.directMessage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DirectMessageFindFirstOrThrowArgs>(args?: SelectSubset<T, DirectMessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__DirectMessageClient<$Result.GetResult<Prisma.$DirectMessagePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more DirectMessages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DirectMessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DirectMessages
     * const directMessages = await prisma.directMessage.findMany()
     * 
     * // Get first 10 DirectMessages
     * const directMessages = await prisma.directMessage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const directMessageWithIdOnly = await prisma.directMessage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DirectMessageFindManyArgs>(args?: SelectSubset<T, DirectMessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DirectMessagePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a DirectMessage.
     * @param {DirectMessageCreateArgs} args - Arguments to create a DirectMessage.
     * @example
     * // Create one DirectMessage
     * const DirectMessage = await prisma.directMessage.create({
     *   data: {
     *     // ... data to create a DirectMessage
     *   }
     * })
     * 
     */
    create<T extends DirectMessageCreateArgs>(args: SelectSubset<T, DirectMessageCreateArgs<ExtArgs>>): Prisma__DirectMessageClient<$Result.GetResult<Prisma.$DirectMessagePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many DirectMessages.
     * @param {DirectMessageCreateManyArgs} args - Arguments to create many DirectMessages.
     * @example
     * // Create many DirectMessages
     * const directMessage = await prisma.directMessage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DirectMessageCreateManyArgs>(args?: SelectSubset<T, DirectMessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DirectMessages and returns the data saved in the database.
     * @param {DirectMessageCreateManyAndReturnArgs} args - Arguments to create many DirectMessages.
     * @example
     * // Create many DirectMessages
     * const directMessage = await prisma.directMessage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DirectMessages and only return the `id`
     * const directMessageWithIdOnly = await prisma.directMessage.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DirectMessageCreateManyAndReturnArgs>(args?: SelectSubset<T, DirectMessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DirectMessagePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a DirectMessage.
     * @param {DirectMessageDeleteArgs} args - Arguments to delete one DirectMessage.
     * @example
     * // Delete one DirectMessage
     * const DirectMessage = await prisma.directMessage.delete({
     *   where: {
     *     // ... filter to delete one DirectMessage
     *   }
     * })
     * 
     */
    delete<T extends DirectMessageDeleteArgs>(args: SelectSubset<T, DirectMessageDeleteArgs<ExtArgs>>): Prisma__DirectMessageClient<$Result.GetResult<Prisma.$DirectMessagePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one DirectMessage.
     * @param {DirectMessageUpdateArgs} args - Arguments to update one DirectMessage.
     * @example
     * // Update one DirectMessage
     * const directMessage = await prisma.directMessage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DirectMessageUpdateArgs>(args: SelectSubset<T, DirectMessageUpdateArgs<ExtArgs>>): Prisma__DirectMessageClient<$Result.GetResult<Prisma.$DirectMessagePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more DirectMessages.
     * @param {DirectMessageDeleteManyArgs} args - Arguments to filter DirectMessages to delete.
     * @example
     * // Delete a few DirectMessages
     * const { count } = await prisma.directMessage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DirectMessageDeleteManyArgs>(args?: SelectSubset<T, DirectMessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DirectMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DirectMessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DirectMessages
     * const directMessage = await prisma.directMessage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DirectMessageUpdateManyArgs>(args: SelectSubset<T, DirectMessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DirectMessage.
     * @param {DirectMessageUpsertArgs} args - Arguments to update or create a DirectMessage.
     * @example
     * // Update or create a DirectMessage
     * const directMessage = await prisma.directMessage.upsert({
     *   create: {
     *     // ... data to create a DirectMessage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DirectMessage we want to update
     *   }
     * })
     */
    upsert<T extends DirectMessageUpsertArgs>(args: SelectSubset<T, DirectMessageUpsertArgs<ExtArgs>>): Prisma__DirectMessageClient<$Result.GetResult<Prisma.$DirectMessagePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of DirectMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DirectMessageCountArgs} args - Arguments to filter DirectMessages to count.
     * @example
     * // Count the number of DirectMessages
     * const count = await prisma.directMessage.count({
     *   where: {
     *     // ... the filter for the DirectMessages we want to count
     *   }
     * })
    **/
    count<T extends DirectMessageCountArgs>(
      args?: Subset<T, DirectMessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DirectMessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DirectMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DirectMessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DirectMessageAggregateArgs>(args: Subset<T, DirectMessageAggregateArgs>): Prisma.PrismaPromise<GetDirectMessageAggregateType<T>>

    /**
     * Group by DirectMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DirectMessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DirectMessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DirectMessageGroupByArgs['orderBy'] }
        : { orderBy?: DirectMessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DirectMessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDirectMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DirectMessage model
   */
  readonly fields: DirectMessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DirectMessage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DirectMessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    conversation<T extends ConversationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ConversationDefaultArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    sender<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    receiver<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DirectMessage model
   */ 
  interface DirectMessageFieldRefs {
    readonly id: FieldRef<"DirectMessage", 'String'>
    readonly conversationId: FieldRef<"DirectMessage", 'String'>
    readonly senderId: FieldRef<"DirectMessage", 'String'>
    readonly receiverId: FieldRef<"DirectMessage", 'String'>
    readonly content: FieldRef<"DirectMessage", 'String'>
    readonly kind: FieldRef<"DirectMessage", 'String'>
    readonly isDeleted: FieldRef<"DirectMessage", 'Boolean'>
    readonly createdAt: FieldRef<"DirectMessage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DirectMessage findUnique
   */
  export type DirectMessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DirectMessage
     */
    select?: DirectMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DirectMessageInclude<ExtArgs> | null
    /**
     * Filter, which DirectMessage to fetch.
     */
    where: DirectMessageWhereUniqueInput
  }

  /**
   * DirectMessage findUniqueOrThrow
   */
  export type DirectMessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DirectMessage
     */
    select?: DirectMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DirectMessageInclude<ExtArgs> | null
    /**
     * Filter, which DirectMessage to fetch.
     */
    where: DirectMessageWhereUniqueInput
  }

  /**
   * DirectMessage findFirst
   */
  export type DirectMessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DirectMessage
     */
    select?: DirectMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DirectMessageInclude<ExtArgs> | null
    /**
     * Filter, which DirectMessage to fetch.
     */
    where?: DirectMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DirectMessages to fetch.
     */
    orderBy?: DirectMessageOrderByWithRelationInput | DirectMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DirectMessages.
     */
    cursor?: DirectMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DirectMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DirectMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DirectMessages.
     */
    distinct?: DirectMessageScalarFieldEnum | DirectMessageScalarFieldEnum[]
  }

  /**
   * DirectMessage findFirstOrThrow
   */
  export type DirectMessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DirectMessage
     */
    select?: DirectMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DirectMessageInclude<ExtArgs> | null
    /**
     * Filter, which DirectMessage to fetch.
     */
    where?: DirectMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DirectMessages to fetch.
     */
    orderBy?: DirectMessageOrderByWithRelationInput | DirectMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DirectMessages.
     */
    cursor?: DirectMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DirectMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DirectMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DirectMessages.
     */
    distinct?: DirectMessageScalarFieldEnum | DirectMessageScalarFieldEnum[]
  }

  /**
   * DirectMessage findMany
   */
  export type DirectMessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DirectMessage
     */
    select?: DirectMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DirectMessageInclude<ExtArgs> | null
    /**
     * Filter, which DirectMessages to fetch.
     */
    where?: DirectMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DirectMessages to fetch.
     */
    orderBy?: DirectMessageOrderByWithRelationInput | DirectMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DirectMessages.
     */
    cursor?: DirectMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DirectMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DirectMessages.
     */
    skip?: number
    distinct?: DirectMessageScalarFieldEnum | DirectMessageScalarFieldEnum[]
  }

  /**
   * DirectMessage create
   */
  export type DirectMessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DirectMessage
     */
    select?: DirectMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DirectMessageInclude<ExtArgs> | null
    /**
     * The data needed to create a DirectMessage.
     */
    data: XOR<DirectMessageCreateInput, DirectMessageUncheckedCreateInput>
  }

  /**
   * DirectMessage createMany
   */
  export type DirectMessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DirectMessages.
     */
    data: DirectMessageCreateManyInput | DirectMessageCreateManyInput[]
  }

  /**
   * DirectMessage createManyAndReturn
   */
  export type DirectMessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DirectMessage
     */
    select?: DirectMessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many DirectMessages.
     */
    data: DirectMessageCreateManyInput | DirectMessageCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DirectMessageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DirectMessage update
   */
  export type DirectMessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DirectMessage
     */
    select?: DirectMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DirectMessageInclude<ExtArgs> | null
    /**
     * The data needed to update a DirectMessage.
     */
    data: XOR<DirectMessageUpdateInput, DirectMessageUncheckedUpdateInput>
    /**
     * Choose, which DirectMessage to update.
     */
    where: DirectMessageWhereUniqueInput
  }

  /**
   * DirectMessage updateMany
   */
  export type DirectMessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DirectMessages.
     */
    data: XOR<DirectMessageUpdateManyMutationInput, DirectMessageUncheckedUpdateManyInput>
    /**
     * Filter which DirectMessages to update
     */
    where?: DirectMessageWhereInput
  }

  /**
   * DirectMessage upsert
   */
  export type DirectMessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DirectMessage
     */
    select?: DirectMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DirectMessageInclude<ExtArgs> | null
    /**
     * The filter to search for the DirectMessage to update in case it exists.
     */
    where: DirectMessageWhereUniqueInput
    /**
     * In case the DirectMessage found by the `where` argument doesn't exist, create a new DirectMessage with this data.
     */
    create: XOR<DirectMessageCreateInput, DirectMessageUncheckedCreateInput>
    /**
     * In case the DirectMessage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DirectMessageUpdateInput, DirectMessageUncheckedUpdateInput>
  }

  /**
   * DirectMessage delete
   */
  export type DirectMessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DirectMessage
     */
    select?: DirectMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DirectMessageInclude<ExtArgs> | null
    /**
     * Filter which DirectMessage to delete.
     */
    where: DirectMessageWhereUniqueInput
  }

  /**
   * DirectMessage deleteMany
   */
  export type DirectMessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DirectMessages to delete
     */
    where?: DirectMessageWhereInput
  }

  /**
   * DirectMessage without action
   */
  export type DirectMessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DirectMessage
     */
    select?: DirectMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DirectMessageInclude<ExtArgs> | null
  }


  /**
   * Model BankInfo
   */

  export type AggregateBankInfo = {
    _count: BankInfoCountAggregateOutputType | null
    _min: BankInfoMinAggregateOutputType | null
    _max: BankInfoMaxAggregateOutputType | null
  }

  export type BankInfoMinAggregateOutputType = {
    id: string | null
    label: string | null
    holderName: string | null
    pixKey: string | null
    bankName: string | null
    agency: string | null
    accountNumber: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BankInfoMaxAggregateOutputType = {
    id: string | null
    label: string | null
    holderName: string | null
    pixKey: string | null
    bankName: string | null
    agency: string | null
    accountNumber: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BankInfoCountAggregateOutputType = {
    id: number
    label: number
    holderName: number
    pixKey: number
    bankName: number
    agency: number
    accountNumber: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BankInfoMinAggregateInputType = {
    id?: true
    label?: true
    holderName?: true
    pixKey?: true
    bankName?: true
    agency?: true
    accountNumber?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BankInfoMaxAggregateInputType = {
    id?: true
    label?: true
    holderName?: true
    pixKey?: true
    bankName?: true
    agency?: true
    accountNumber?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BankInfoCountAggregateInputType = {
    id?: true
    label?: true
    holderName?: true
    pixKey?: true
    bankName?: true
    agency?: true
    accountNumber?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BankInfoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BankInfo to aggregate.
     */
    where?: BankInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BankInfos to fetch.
     */
    orderBy?: BankInfoOrderByWithRelationInput | BankInfoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BankInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BankInfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BankInfos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BankInfos
    **/
    _count?: true | BankInfoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BankInfoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BankInfoMaxAggregateInputType
  }

  export type GetBankInfoAggregateType<T extends BankInfoAggregateArgs> = {
        [P in keyof T & keyof AggregateBankInfo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBankInfo[P]>
      : GetScalarType<T[P], AggregateBankInfo[P]>
  }




  export type BankInfoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BankInfoWhereInput
    orderBy?: BankInfoOrderByWithAggregationInput | BankInfoOrderByWithAggregationInput[]
    by: BankInfoScalarFieldEnum[] | BankInfoScalarFieldEnum
    having?: BankInfoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BankInfoCountAggregateInputType | true
    _min?: BankInfoMinAggregateInputType
    _max?: BankInfoMaxAggregateInputType
  }

  export type BankInfoGroupByOutputType = {
    id: string
    label: string
    holderName: string | null
    pixKey: string | null
    bankName: string | null
    agency: string | null
    accountNumber: string | null
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: BankInfoCountAggregateOutputType | null
    _min: BankInfoMinAggregateOutputType | null
    _max: BankInfoMaxAggregateOutputType | null
  }

  type GetBankInfoGroupByPayload<T extends BankInfoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BankInfoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BankInfoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BankInfoGroupByOutputType[P]>
            : GetScalarType<T[P], BankInfoGroupByOutputType[P]>
        }
      >
    >


  export type BankInfoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    label?: boolean
    holderName?: boolean
    pixKey?: boolean
    bankName?: boolean
    agency?: boolean
    accountNumber?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["bankInfo"]>

  export type BankInfoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    label?: boolean
    holderName?: boolean
    pixKey?: boolean
    bankName?: boolean
    agency?: boolean
    accountNumber?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["bankInfo"]>

  export type BankInfoSelectScalar = {
    id?: boolean
    label?: boolean
    holderName?: boolean
    pixKey?: boolean
    bankName?: boolean
    agency?: boolean
    accountNumber?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $BankInfoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BankInfo"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      label: string
      holderName: string | null
      pixKey: string | null
      bankName: string | null
      agency: string | null
      accountNumber: string | null
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["bankInfo"]>
    composites: {}
  }

  type BankInfoGetPayload<S extends boolean | null | undefined | BankInfoDefaultArgs> = $Result.GetResult<Prisma.$BankInfoPayload, S>

  type BankInfoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BankInfoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BankInfoCountAggregateInputType | true
    }

  export interface BankInfoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BankInfo'], meta: { name: 'BankInfo' } }
    /**
     * Find zero or one BankInfo that matches the filter.
     * @param {BankInfoFindUniqueArgs} args - Arguments to find a BankInfo
     * @example
     * // Get one BankInfo
     * const bankInfo = await prisma.bankInfo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BankInfoFindUniqueArgs>(args: SelectSubset<T, BankInfoFindUniqueArgs<ExtArgs>>): Prisma__BankInfoClient<$Result.GetResult<Prisma.$BankInfoPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one BankInfo that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BankInfoFindUniqueOrThrowArgs} args - Arguments to find a BankInfo
     * @example
     * // Get one BankInfo
     * const bankInfo = await prisma.bankInfo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BankInfoFindUniqueOrThrowArgs>(args: SelectSubset<T, BankInfoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BankInfoClient<$Result.GetResult<Prisma.$BankInfoPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first BankInfo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankInfoFindFirstArgs} args - Arguments to find a BankInfo
     * @example
     * // Get one BankInfo
     * const bankInfo = await prisma.bankInfo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BankInfoFindFirstArgs>(args?: SelectSubset<T, BankInfoFindFirstArgs<ExtArgs>>): Prisma__BankInfoClient<$Result.GetResult<Prisma.$BankInfoPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first BankInfo that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankInfoFindFirstOrThrowArgs} args - Arguments to find a BankInfo
     * @example
     * // Get one BankInfo
     * const bankInfo = await prisma.bankInfo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BankInfoFindFirstOrThrowArgs>(args?: SelectSubset<T, BankInfoFindFirstOrThrowArgs<ExtArgs>>): Prisma__BankInfoClient<$Result.GetResult<Prisma.$BankInfoPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more BankInfos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankInfoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BankInfos
     * const bankInfos = await prisma.bankInfo.findMany()
     * 
     * // Get first 10 BankInfos
     * const bankInfos = await prisma.bankInfo.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bankInfoWithIdOnly = await prisma.bankInfo.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BankInfoFindManyArgs>(args?: SelectSubset<T, BankInfoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BankInfoPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a BankInfo.
     * @param {BankInfoCreateArgs} args - Arguments to create a BankInfo.
     * @example
     * // Create one BankInfo
     * const BankInfo = await prisma.bankInfo.create({
     *   data: {
     *     // ... data to create a BankInfo
     *   }
     * })
     * 
     */
    create<T extends BankInfoCreateArgs>(args: SelectSubset<T, BankInfoCreateArgs<ExtArgs>>): Prisma__BankInfoClient<$Result.GetResult<Prisma.$BankInfoPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many BankInfos.
     * @param {BankInfoCreateManyArgs} args - Arguments to create many BankInfos.
     * @example
     * // Create many BankInfos
     * const bankInfo = await prisma.bankInfo.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BankInfoCreateManyArgs>(args?: SelectSubset<T, BankInfoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BankInfos and returns the data saved in the database.
     * @param {BankInfoCreateManyAndReturnArgs} args - Arguments to create many BankInfos.
     * @example
     * // Create many BankInfos
     * const bankInfo = await prisma.bankInfo.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BankInfos and only return the `id`
     * const bankInfoWithIdOnly = await prisma.bankInfo.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BankInfoCreateManyAndReturnArgs>(args?: SelectSubset<T, BankInfoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BankInfoPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a BankInfo.
     * @param {BankInfoDeleteArgs} args - Arguments to delete one BankInfo.
     * @example
     * // Delete one BankInfo
     * const BankInfo = await prisma.bankInfo.delete({
     *   where: {
     *     // ... filter to delete one BankInfo
     *   }
     * })
     * 
     */
    delete<T extends BankInfoDeleteArgs>(args: SelectSubset<T, BankInfoDeleteArgs<ExtArgs>>): Prisma__BankInfoClient<$Result.GetResult<Prisma.$BankInfoPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one BankInfo.
     * @param {BankInfoUpdateArgs} args - Arguments to update one BankInfo.
     * @example
     * // Update one BankInfo
     * const bankInfo = await prisma.bankInfo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BankInfoUpdateArgs>(args: SelectSubset<T, BankInfoUpdateArgs<ExtArgs>>): Prisma__BankInfoClient<$Result.GetResult<Prisma.$BankInfoPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more BankInfos.
     * @param {BankInfoDeleteManyArgs} args - Arguments to filter BankInfos to delete.
     * @example
     * // Delete a few BankInfos
     * const { count } = await prisma.bankInfo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BankInfoDeleteManyArgs>(args?: SelectSubset<T, BankInfoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BankInfos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankInfoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BankInfos
     * const bankInfo = await prisma.bankInfo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BankInfoUpdateManyArgs>(args: SelectSubset<T, BankInfoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BankInfo.
     * @param {BankInfoUpsertArgs} args - Arguments to update or create a BankInfo.
     * @example
     * // Update or create a BankInfo
     * const bankInfo = await prisma.bankInfo.upsert({
     *   create: {
     *     // ... data to create a BankInfo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BankInfo we want to update
     *   }
     * })
     */
    upsert<T extends BankInfoUpsertArgs>(args: SelectSubset<T, BankInfoUpsertArgs<ExtArgs>>): Prisma__BankInfoClient<$Result.GetResult<Prisma.$BankInfoPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of BankInfos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankInfoCountArgs} args - Arguments to filter BankInfos to count.
     * @example
     * // Count the number of BankInfos
     * const count = await prisma.bankInfo.count({
     *   where: {
     *     // ... the filter for the BankInfos we want to count
     *   }
     * })
    **/
    count<T extends BankInfoCountArgs>(
      args?: Subset<T, BankInfoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BankInfoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BankInfo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankInfoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BankInfoAggregateArgs>(args: Subset<T, BankInfoAggregateArgs>): Prisma.PrismaPromise<GetBankInfoAggregateType<T>>

    /**
     * Group by BankInfo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankInfoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BankInfoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BankInfoGroupByArgs['orderBy'] }
        : { orderBy?: BankInfoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BankInfoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBankInfoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BankInfo model
   */
  readonly fields: BankInfoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BankInfo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BankInfoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BankInfo model
   */ 
  interface BankInfoFieldRefs {
    readonly id: FieldRef<"BankInfo", 'String'>
    readonly label: FieldRef<"BankInfo", 'String'>
    readonly holderName: FieldRef<"BankInfo", 'String'>
    readonly pixKey: FieldRef<"BankInfo", 'String'>
    readonly bankName: FieldRef<"BankInfo", 'String'>
    readonly agency: FieldRef<"BankInfo", 'String'>
    readonly accountNumber: FieldRef<"BankInfo", 'String'>
    readonly notes: FieldRef<"BankInfo", 'String'>
    readonly createdAt: FieldRef<"BankInfo", 'DateTime'>
    readonly updatedAt: FieldRef<"BankInfo", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BankInfo findUnique
   */
  export type BankInfoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankInfo
     */
    select?: BankInfoSelect<ExtArgs> | null
    /**
     * Filter, which BankInfo to fetch.
     */
    where: BankInfoWhereUniqueInput
  }

  /**
   * BankInfo findUniqueOrThrow
   */
  export type BankInfoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankInfo
     */
    select?: BankInfoSelect<ExtArgs> | null
    /**
     * Filter, which BankInfo to fetch.
     */
    where: BankInfoWhereUniqueInput
  }

  /**
   * BankInfo findFirst
   */
  export type BankInfoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankInfo
     */
    select?: BankInfoSelect<ExtArgs> | null
    /**
     * Filter, which BankInfo to fetch.
     */
    where?: BankInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BankInfos to fetch.
     */
    orderBy?: BankInfoOrderByWithRelationInput | BankInfoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BankInfos.
     */
    cursor?: BankInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BankInfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BankInfos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BankInfos.
     */
    distinct?: BankInfoScalarFieldEnum | BankInfoScalarFieldEnum[]
  }

  /**
   * BankInfo findFirstOrThrow
   */
  export type BankInfoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankInfo
     */
    select?: BankInfoSelect<ExtArgs> | null
    /**
     * Filter, which BankInfo to fetch.
     */
    where?: BankInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BankInfos to fetch.
     */
    orderBy?: BankInfoOrderByWithRelationInput | BankInfoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BankInfos.
     */
    cursor?: BankInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BankInfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BankInfos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BankInfos.
     */
    distinct?: BankInfoScalarFieldEnum | BankInfoScalarFieldEnum[]
  }

  /**
   * BankInfo findMany
   */
  export type BankInfoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankInfo
     */
    select?: BankInfoSelect<ExtArgs> | null
    /**
     * Filter, which BankInfos to fetch.
     */
    where?: BankInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BankInfos to fetch.
     */
    orderBy?: BankInfoOrderByWithRelationInput | BankInfoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BankInfos.
     */
    cursor?: BankInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BankInfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BankInfos.
     */
    skip?: number
    distinct?: BankInfoScalarFieldEnum | BankInfoScalarFieldEnum[]
  }

  /**
   * BankInfo create
   */
  export type BankInfoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankInfo
     */
    select?: BankInfoSelect<ExtArgs> | null
    /**
     * The data needed to create a BankInfo.
     */
    data: XOR<BankInfoCreateInput, BankInfoUncheckedCreateInput>
  }

  /**
   * BankInfo createMany
   */
  export type BankInfoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BankInfos.
     */
    data: BankInfoCreateManyInput | BankInfoCreateManyInput[]
  }

  /**
   * BankInfo createManyAndReturn
   */
  export type BankInfoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankInfo
     */
    select?: BankInfoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many BankInfos.
     */
    data: BankInfoCreateManyInput | BankInfoCreateManyInput[]
  }

  /**
   * BankInfo update
   */
  export type BankInfoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankInfo
     */
    select?: BankInfoSelect<ExtArgs> | null
    /**
     * The data needed to update a BankInfo.
     */
    data: XOR<BankInfoUpdateInput, BankInfoUncheckedUpdateInput>
    /**
     * Choose, which BankInfo to update.
     */
    where: BankInfoWhereUniqueInput
  }

  /**
   * BankInfo updateMany
   */
  export type BankInfoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BankInfos.
     */
    data: XOR<BankInfoUpdateManyMutationInput, BankInfoUncheckedUpdateManyInput>
    /**
     * Filter which BankInfos to update
     */
    where?: BankInfoWhereInput
  }

  /**
   * BankInfo upsert
   */
  export type BankInfoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankInfo
     */
    select?: BankInfoSelect<ExtArgs> | null
    /**
     * The filter to search for the BankInfo to update in case it exists.
     */
    where: BankInfoWhereUniqueInput
    /**
     * In case the BankInfo found by the `where` argument doesn't exist, create a new BankInfo with this data.
     */
    create: XOR<BankInfoCreateInput, BankInfoUncheckedCreateInput>
    /**
     * In case the BankInfo was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BankInfoUpdateInput, BankInfoUncheckedUpdateInput>
  }

  /**
   * BankInfo delete
   */
  export type BankInfoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankInfo
     */
    select?: BankInfoSelect<ExtArgs> | null
    /**
     * Filter which BankInfo to delete.
     */
    where: BankInfoWhereUniqueInput
  }

  /**
   * BankInfo deleteMany
   */
  export type BankInfoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BankInfos to delete
     */
    where?: BankInfoWhereInput
  }

  /**
   * BankInfo without action
   */
  export type BankInfoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankInfo
     */
    select?: BankInfoSelect<ExtArgs> | null
  }


  /**
   * Model SiteSetting
   */

  export type AggregateSiteSetting = {
    _count: SiteSettingCountAggregateOutputType | null
    _min: SiteSettingMinAggregateOutputType | null
    _max: SiteSettingMaxAggregateOutputType | null
  }

  export type SiteSettingMinAggregateOutputType = {
    key: string | null
    value: string | null
    updatedAt: Date | null
  }

  export type SiteSettingMaxAggregateOutputType = {
    key: string | null
    value: string | null
    updatedAt: Date | null
  }

  export type SiteSettingCountAggregateOutputType = {
    key: number
    value: number
    updatedAt: number
    _all: number
  }


  export type SiteSettingMinAggregateInputType = {
    key?: true
    value?: true
    updatedAt?: true
  }

  export type SiteSettingMaxAggregateInputType = {
    key?: true
    value?: true
    updatedAt?: true
  }

  export type SiteSettingCountAggregateInputType = {
    key?: true
    value?: true
    updatedAt?: true
    _all?: true
  }

  export type SiteSettingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SiteSetting to aggregate.
     */
    where?: SiteSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SiteSettings to fetch.
     */
    orderBy?: SiteSettingOrderByWithRelationInput | SiteSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SiteSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SiteSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SiteSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SiteSettings
    **/
    _count?: true | SiteSettingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SiteSettingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SiteSettingMaxAggregateInputType
  }

  export type GetSiteSettingAggregateType<T extends SiteSettingAggregateArgs> = {
        [P in keyof T & keyof AggregateSiteSetting]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSiteSetting[P]>
      : GetScalarType<T[P], AggregateSiteSetting[P]>
  }




  export type SiteSettingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SiteSettingWhereInput
    orderBy?: SiteSettingOrderByWithAggregationInput | SiteSettingOrderByWithAggregationInput[]
    by: SiteSettingScalarFieldEnum[] | SiteSettingScalarFieldEnum
    having?: SiteSettingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SiteSettingCountAggregateInputType | true
    _min?: SiteSettingMinAggregateInputType
    _max?: SiteSettingMaxAggregateInputType
  }

  export type SiteSettingGroupByOutputType = {
    key: string
    value: string
    updatedAt: Date
    _count: SiteSettingCountAggregateOutputType | null
    _min: SiteSettingMinAggregateOutputType | null
    _max: SiteSettingMaxAggregateOutputType | null
  }

  type GetSiteSettingGroupByPayload<T extends SiteSettingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SiteSettingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SiteSettingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SiteSettingGroupByOutputType[P]>
            : GetScalarType<T[P], SiteSettingGroupByOutputType[P]>
        }
      >
    >


  export type SiteSettingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    key?: boolean
    value?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["siteSetting"]>

  export type SiteSettingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    key?: boolean
    value?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["siteSetting"]>

  export type SiteSettingSelectScalar = {
    key?: boolean
    value?: boolean
    updatedAt?: boolean
  }


  export type $SiteSettingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SiteSetting"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      key: string
      value: string
      updatedAt: Date
    }, ExtArgs["result"]["siteSetting"]>
    composites: {}
  }

  type SiteSettingGetPayload<S extends boolean | null | undefined | SiteSettingDefaultArgs> = $Result.GetResult<Prisma.$SiteSettingPayload, S>

  type SiteSettingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SiteSettingFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SiteSettingCountAggregateInputType | true
    }

  export interface SiteSettingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SiteSetting'], meta: { name: 'SiteSetting' } }
    /**
     * Find zero or one SiteSetting that matches the filter.
     * @param {SiteSettingFindUniqueArgs} args - Arguments to find a SiteSetting
     * @example
     * // Get one SiteSetting
     * const siteSetting = await prisma.siteSetting.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SiteSettingFindUniqueArgs>(args: SelectSubset<T, SiteSettingFindUniqueArgs<ExtArgs>>): Prisma__SiteSettingClient<$Result.GetResult<Prisma.$SiteSettingPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SiteSetting that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SiteSettingFindUniqueOrThrowArgs} args - Arguments to find a SiteSetting
     * @example
     * // Get one SiteSetting
     * const siteSetting = await prisma.siteSetting.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SiteSettingFindUniqueOrThrowArgs>(args: SelectSubset<T, SiteSettingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SiteSettingClient<$Result.GetResult<Prisma.$SiteSettingPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SiteSetting that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteSettingFindFirstArgs} args - Arguments to find a SiteSetting
     * @example
     * // Get one SiteSetting
     * const siteSetting = await prisma.siteSetting.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SiteSettingFindFirstArgs>(args?: SelectSubset<T, SiteSettingFindFirstArgs<ExtArgs>>): Prisma__SiteSettingClient<$Result.GetResult<Prisma.$SiteSettingPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SiteSetting that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteSettingFindFirstOrThrowArgs} args - Arguments to find a SiteSetting
     * @example
     * // Get one SiteSetting
     * const siteSetting = await prisma.siteSetting.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SiteSettingFindFirstOrThrowArgs>(args?: SelectSubset<T, SiteSettingFindFirstOrThrowArgs<ExtArgs>>): Prisma__SiteSettingClient<$Result.GetResult<Prisma.$SiteSettingPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SiteSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteSettingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SiteSettings
     * const siteSettings = await prisma.siteSetting.findMany()
     * 
     * // Get first 10 SiteSettings
     * const siteSettings = await prisma.siteSetting.findMany({ take: 10 })
     * 
     * // Only select the `key`
     * const siteSettingWithKeyOnly = await prisma.siteSetting.findMany({ select: { key: true } })
     * 
     */
    findMany<T extends SiteSettingFindManyArgs>(args?: SelectSubset<T, SiteSettingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SiteSettingPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SiteSetting.
     * @param {SiteSettingCreateArgs} args - Arguments to create a SiteSetting.
     * @example
     * // Create one SiteSetting
     * const SiteSetting = await prisma.siteSetting.create({
     *   data: {
     *     // ... data to create a SiteSetting
     *   }
     * })
     * 
     */
    create<T extends SiteSettingCreateArgs>(args: SelectSubset<T, SiteSettingCreateArgs<ExtArgs>>): Prisma__SiteSettingClient<$Result.GetResult<Prisma.$SiteSettingPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SiteSettings.
     * @param {SiteSettingCreateManyArgs} args - Arguments to create many SiteSettings.
     * @example
     * // Create many SiteSettings
     * const siteSetting = await prisma.siteSetting.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SiteSettingCreateManyArgs>(args?: SelectSubset<T, SiteSettingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SiteSettings and returns the data saved in the database.
     * @param {SiteSettingCreateManyAndReturnArgs} args - Arguments to create many SiteSettings.
     * @example
     * // Create many SiteSettings
     * const siteSetting = await prisma.siteSetting.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SiteSettings and only return the `key`
     * const siteSettingWithKeyOnly = await prisma.siteSetting.createManyAndReturn({ 
     *   select: { key: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SiteSettingCreateManyAndReturnArgs>(args?: SelectSubset<T, SiteSettingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SiteSettingPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SiteSetting.
     * @param {SiteSettingDeleteArgs} args - Arguments to delete one SiteSetting.
     * @example
     * // Delete one SiteSetting
     * const SiteSetting = await prisma.siteSetting.delete({
     *   where: {
     *     // ... filter to delete one SiteSetting
     *   }
     * })
     * 
     */
    delete<T extends SiteSettingDeleteArgs>(args: SelectSubset<T, SiteSettingDeleteArgs<ExtArgs>>): Prisma__SiteSettingClient<$Result.GetResult<Prisma.$SiteSettingPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SiteSetting.
     * @param {SiteSettingUpdateArgs} args - Arguments to update one SiteSetting.
     * @example
     * // Update one SiteSetting
     * const siteSetting = await prisma.siteSetting.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SiteSettingUpdateArgs>(args: SelectSubset<T, SiteSettingUpdateArgs<ExtArgs>>): Prisma__SiteSettingClient<$Result.GetResult<Prisma.$SiteSettingPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SiteSettings.
     * @param {SiteSettingDeleteManyArgs} args - Arguments to filter SiteSettings to delete.
     * @example
     * // Delete a few SiteSettings
     * const { count } = await prisma.siteSetting.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SiteSettingDeleteManyArgs>(args?: SelectSubset<T, SiteSettingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SiteSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteSettingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SiteSettings
     * const siteSetting = await prisma.siteSetting.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SiteSettingUpdateManyArgs>(args: SelectSubset<T, SiteSettingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SiteSetting.
     * @param {SiteSettingUpsertArgs} args - Arguments to update or create a SiteSetting.
     * @example
     * // Update or create a SiteSetting
     * const siteSetting = await prisma.siteSetting.upsert({
     *   create: {
     *     // ... data to create a SiteSetting
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SiteSetting we want to update
     *   }
     * })
     */
    upsert<T extends SiteSettingUpsertArgs>(args: SelectSubset<T, SiteSettingUpsertArgs<ExtArgs>>): Prisma__SiteSettingClient<$Result.GetResult<Prisma.$SiteSettingPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SiteSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteSettingCountArgs} args - Arguments to filter SiteSettings to count.
     * @example
     * // Count the number of SiteSettings
     * const count = await prisma.siteSetting.count({
     *   where: {
     *     // ... the filter for the SiteSettings we want to count
     *   }
     * })
    **/
    count<T extends SiteSettingCountArgs>(
      args?: Subset<T, SiteSettingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SiteSettingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SiteSetting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteSettingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SiteSettingAggregateArgs>(args: Subset<T, SiteSettingAggregateArgs>): Prisma.PrismaPromise<GetSiteSettingAggregateType<T>>

    /**
     * Group by SiteSetting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteSettingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SiteSettingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SiteSettingGroupByArgs['orderBy'] }
        : { orderBy?: SiteSettingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SiteSettingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSiteSettingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SiteSetting model
   */
  readonly fields: SiteSettingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SiteSetting.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SiteSettingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SiteSetting model
   */ 
  interface SiteSettingFieldRefs {
    readonly key: FieldRef<"SiteSetting", 'String'>
    readonly value: FieldRef<"SiteSetting", 'String'>
    readonly updatedAt: FieldRef<"SiteSetting", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SiteSetting findUnique
   */
  export type SiteSettingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteSetting
     */
    select?: SiteSettingSelect<ExtArgs> | null
    /**
     * Filter, which SiteSetting to fetch.
     */
    where: SiteSettingWhereUniqueInput
  }

  /**
   * SiteSetting findUniqueOrThrow
   */
  export type SiteSettingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteSetting
     */
    select?: SiteSettingSelect<ExtArgs> | null
    /**
     * Filter, which SiteSetting to fetch.
     */
    where: SiteSettingWhereUniqueInput
  }

  /**
   * SiteSetting findFirst
   */
  export type SiteSettingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteSetting
     */
    select?: SiteSettingSelect<ExtArgs> | null
    /**
     * Filter, which SiteSetting to fetch.
     */
    where?: SiteSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SiteSettings to fetch.
     */
    orderBy?: SiteSettingOrderByWithRelationInput | SiteSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SiteSettings.
     */
    cursor?: SiteSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SiteSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SiteSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SiteSettings.
     */
    distinct?: SiteSettingScalarFieldEnum | SiteSettingScalarFieldEnum[]
  }

  /**
   * SiteSetting findFirstOrThrow
   */
  export type SiteSettingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteSetting
     */
    select?: SiteSettingSelect<ExtArgs> | null
    /**
     * Filter, which SiteSetting to fetch.
     */
    where?: SiteSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SiteSettings to fetch.
     */
    orderBy?: SiteSettingOrderByWithRelationInput | SiteSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SiteSettings.
     */
    cursor?: SiteSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SiteSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SiteSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SiteSettings.
     */
    distinct?: SiteSettingScalarFieldEnum | SiteSettingScalarFieldEnum[]
  }

  /**
   * SiteSetting findMany
   */
  export type SiteSettingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteSetting
     */
    select?: SiteSettingSelect<ExtArgs> | null
    /**
     * Filter, which SiteSettings to fetch.
     */
    where?: SiteSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SiteSettings to fetch.
     */
    orderBy?: SiteSettingOrderByWithRelationInput | SiteSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SiteSettings.
     */
    cursor?: SiteSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SiteSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SiteSettings.
     */
    skip?: number
    distinct?: SiteSettingScalarFieldEnum | SiteSettingScalarFieldEnum[]
  }

  /**
   * SiteSetting create
   */
  export type SiteSettingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteSetting
     */
    select?: SiteSettingSelect<ExtArgs> | null
    /**
     * The data needed to create a SiteSetting.
     */
    data: XOR<SiteSettingCreateInput, SiteSettingUncheckedCreateInput>
  }

  /**
   * SiteSetting createMany
   */
  export type SiteSettingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SiteSettings.
     */
    data: SiteSettingCreateManyInput | SiteSettingCreateManyInput[]
  }

  /**
   * SiteSetting createManyAndReturn
   */
  export type SiteSettingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteSetting
     */
    select?: SiteSettingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SiteSettings.
     */
    data: SiteSettingCreateManyInput | SiteSettingCreateManyInput[]
  }

  /**
   * SiteSetting update
   */
  export type SiteSettingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteSetting
     */
    select?: SiteSettingSelect<ExtArgs> | null
    /**
     * The data needed to update a SiteSetting.
     */
    data: XOR<SiteSettingUpdateInput, SiteSettingUncheckedUpdateInput>
    /**
     * Choose, which SiteSetting to update.
     */
    where: SiteSettingWhereUniqueInput
  }

  /**
   * SiteSetting updateMany
   */
  export type SiteSettingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SiteSettings.
     */
    data: XOR<SiteSettingUpdateManyMutationInput, SiteSettingUncheckedUpdateManyInput>
    /**
     * Filter which SiteSettings to update
     */
    where?: SiteSettingWhereInput
  }

  /**
   * SiteSetting upsert
   */
  export type SiteSettingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteSetting
     */
    select?: SiteSettingSelect<ExtArgs> | null
    /**
     * The filter to search for the SiteSetting to update in case it exists.
     */
    where: SiteSettingWhereUniqueInput
    /**
     * In case the SiteSetting found by the `where` argument doesn't exist, create a new SiteSetting with this data.
     */
    create: XOR<SiteSettingCreateInput, SiteSettingUncheckedCreateInput>
    /**
     * In case the SiteSetting was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SiteSettingUpdateInput, SiteSettingUncheckedUpdateInput>
  }

  /**
   * SiteSetting delete
   */
  export type SiteSettingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteSetting
     */
    select?: SiteSettingSelect<ExtArgs> | null
    /**
     * Filter which SiteSetting to delete.
     */
    where: SiteSettingWhereUniqueInput
  }

  /**
   * SiteSetting deleteMany
   */
  export type SiteSettingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SiteSettings to delete
     */
    where?: SiteSettingWhereInput
  }

  /**
   * SiteSetting without action
   */
  export type SiteSettingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteSetting
     */
    select?: SiteSettingSelect<ExtArgs> | null
  }


  /**
   * Model GameAccount
   */

  export type AggregateGameAccount = {
    _count: GameAccountCountAggregateOutputType | null
    _min: GameAccountMinAggregateOutputType | null
    _max: GameAccountMaxAggregateOutputType | null
  }

  export type GameAccountMinAggregateOutputType = {
    id: string | null
    userId: string | null
    mtaSerial: string | null
    mtaAccount: string | null
    locked: boolean | null
    changedAfterApproved: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GameAccountMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    mtaSerial: string | null
    mtaAccount: string | null
    locked: boolean | null
    changedAfterApproved: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GameAccountCountAggregateOutputType = {
    id: number
    userId: number
    mtaSerial: number
    mtaAccount: number
    locked: number
    changedAfterApproved: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type GameAccountMinAggregateInputType = {
    id?: true
    userId?: true
    mtaSerial?: true
    mtaAccount?: true
    locked?: true
    changedAfterApproved?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GameAccountMaxAggregateInputType = {
    id?: true
    userId?: true
    mtaSerial?: true
    mtaAccount?: true
    locked?: true
    changedAfterApproved?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GameAccountCountAggregateInputType = {
    id?: true
    userId?: true
    mtaSerial?: true
    mtaAccount?: true
    locked?: true
    changedAfterApproved?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type GameAccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GameAccount to aggregate.
     */
    where?: GameAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GameAccounts to fetch.
     */
    orderBy?: GameAccountOrderByWithRelationInput | GameAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GameAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GameAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GameAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GameAccounts
    **/
    _count?: true | GameAccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GameAccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GameAccountMaxAggregateInputType
  }

  export type GetGameAccountAggregateType<T extends GameAccountAggregateArgs> = {
        [P in keyof T & keyof AggregateGameAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGameAccount[P]>
      : GetScalarType<T[P], AggregateGameAccount[P]>
  }




  export type GameAccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GameAccountWhereInput
    orderBy?: GameAccountOrderByWithAggregationInput | GameAccountOrderByWithAggregationInput[]
    by: GameAccountScalarFieldEnum[] | GameAccountScalarFieldEnum
    having?: GameAccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GameAccountCountAggregateInputType | true
    _min?: GameAccountMinAggregateInputType
    _max?: GameAccountMaxAggregateInputType
  }

  export type GameAccountGroupByOutputType = {
    id: string
    userId: string
    mtaSerial: string
    mtaAccount: string | null
    locked: boolean
    changedAfterApproved: boolean
    createdAt: Date
    updatedAt: Date
    _count: GameAccountCountAggregateOutputType | null
    _min: GameAccountMinAggregateOutputType | null
    _max: GameAccountMaxAggregateOutputType | null
  }

  type GetGameAccountGroupByPayload<T extends GameAccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GameAccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GameAccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GameAccountGroupByOutputType[P]>
            : GetScalarType<T[P], GameAccountGroupByOutputType[P]>
        }
      >
    >


  export type GameAccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    mtaSerial?: boolean
    mtaAccount?: boolean
    locked?: boolean
    changedAfterApproved?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gameAccount"]>

  export type GameAccountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    mtaSerial?: boolean
    mtaAccount?: boolean
    locked?: boolean
    changedAfterApproved?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gameAccount"]>

  export type GameAccountSelectScalar = {
    id?: boolean
    userId?: boolean
    mtaSerial?: boolean
    mtaAccount?: boolean
    locked?: boolean
    changedAfterApproved?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type GameAccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type GameAccountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $GameAccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GameAccount"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      mtaSerial: string
      mtaAccount: string | null
      locked: boolean
      changedAfterApproved: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["gameAccount"]>
    composites: {}
  }

  type GameAccountGetPayload<S extends boolean | null | undefined | GameAccountDefaultArgs> = $Result.GetResult<Prisma.$GameAccountPayload, S>

  type GameAccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<GameAccountFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: GameAccountCountAggregateInputType | true
    }

  export interface GameAccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GameAccount'], meta: { name: 'GameAccount' } }
    /**
     * Find zero or one GameAccount that matches the filter.
     * @param {GameAccountFindUniqueArgs} args - Arguments to find a GameAccount
     * @example
     * // Get one GameAccount
     * const gameAccount = await prisma.gameAccount.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GameAccountFindUniqueArgs>(args: SelectSubset<T, GameAccountFindUniqueArgs<ExtArgs>>): Prisma__GameAccountClient<$Result.GetResult<Prisma.$GameAccountPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one GameAccount that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {GameAccountFindUniqueOrThrowArgs} args - Arguments to find a GameAccount
     * @example
     * // Get one GameAccount
     * const gameAccount = await prisma.gameAccount.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GameAccountFindUniqueOrThrowArgs>(args: SelectSubset<T, GameAccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GameAccountClient<$Result.GetResult<Prisma.$GameAccountPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first GameAccount that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameAccountFindFirstArgs} args - Arguments to find a GameAccount
     * @example
     * // Get one GameAccount
     * const gameAccount = await prisma.gameAccount.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GameAccountFindFirstArgs>(args?: SelectSubset<T, GameAccountFindFirstArgs<ExtArgs>>): Prisma__GameAccountClient<$Result.GetResult<Prisma.$GameAccountPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first GameAccount that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameAccountFindFirstOrThrowArgs} args - Arguments to find a GameAccount
     * @example
     * // Get one GameAccount
     * const gameAccount = await prisma.gameAccount.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GameAccountFindFirstOrThrowArgs>(args?: SelectSubset<T, GameAccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__GameAccountClient<$Result.GetResult<Prisma.$GameAccountPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more GameAccounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameAccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GameAccounts
     * const gameAccounts = await prisma.gameAccount.findMany()
     * 
     * // Get first 10 GameAccounts
     * const gameAccounts = await prisma.gameAccount.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const gameAccountWithIdOnly = await prisma.gameAccount.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GameAccountFindManyArgs>(args?: SelectSubset<T, GameAccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GameAccountPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a GameAccount.
     * @param {GameAccountCreateArgs} args - Arguments to create a GameAccount.
     * @example
     * // Create one GameAccount
     * const GameAccount = await prisma.gameAccount.create({
     *   data: {
     *     // ... data to create a GameAccount
     *   }
     * })
     * 
     */
    create<T extends GameAccountCreateArgs>(args: SelectSubset<T, GameAccountCreateArgs<ExtArgs>>): Prisma__GameAccountClient<$Result.GetResult<Prisma.$GameAccountPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many GameAccounts.
     * @param {GameAccountCreateManyArgs} args - Arguments to create many GameAccounts.
     * @example
     * // Create many GameAccounts
     * const gameAccount = await prisma.gameAccount.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GameAccountCreateManyArgs>(args?: SelectSubset<T, GameAccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GameAccounts and returns the data saved in the database.
     * @param {GameAccountCreateManyAndReturnArgs} args - Arguments to create many GameAccounts.
     * @example
     * // Create many GameAccounts
     * const gameAccount = await prisma.gameAccount.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GameAccounts and only return the `id`
     * const gameAccountWithIdOnly = await prisma.gameAccount.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GameAccountCreateManyAndReturnArgs>(args?: SelectSubset<T, GameAccountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GameAccountPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a GameAccount.
     * @param {GameAccountDeleteArgs} args - Arguments to delete one GameAccount.
     * @example
     * // Delete one GameAccount
     * const GameAccount = await prisma.gameAccount.delete({
     *   where: {
     *     // ... filter to delete one GameAccount
     *   }
     * })
     * 
     */
    delete<T extends GameAccountDeleteArgs>(args: SelectSubset<T, GameAccountDeleteArgs<ExtArgs>>): Prisma__GameAccountClient<$Result.GetResult<Prisma.$GameAccountPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one GameAccount.
     * @param {GameAccountUpdateArgs} args - Arguments to update one GameAccount.
     * @example
     * // Update one GameAccount
     * const gameAccount = await prisma.gameAccount.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GameAccountUpdateArgs>(args: SelectSubset<T, GameAccountUpdateArgs<ExtArgs>>): Prisma__GameAccountClient<$Result.GetResult<Prisma.$GameAccountPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more GameAccounts.
     * @param {GameAccountDeleteManyArgs} args - Arguments to filter GameAccounts to delete.
     * @example
     * // Delete a few GameAccounts
     * const { count } = await prisma.gameAccount.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GameAccountDeleteManyArgs>(args?: SelectSubset<T, GameAccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GameAccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameAccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GameAccounts
     * const gameAccount = await prisma.gameAccount.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GameAccountUpdateManyArgs>(args: SelectSubset<T, GameAccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one GameAccount.
     * @param {GameAccountUpsertArgs} args - Arguments to update or create a GameAccount.
     * @example
     * // Update or create a GameAccount
     * const gameAccount = await prisma.gameAccount.upsert({
     *   create: {
     *     // ... data to create a GameAccount
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GameAccount we want to update
     *   }
     * })
     */
    upsert<T extends GameAccountUpsertArgs>(args: SelectSubset<T, GameAccountUpsertArgs<ExtArgs>>): Prisma__GameAccountClient<$Result.GetResult<Prisma.$GameAccountPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of GameAccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameAccountCountArgs} args - Arguments to filter GameAccounts to count.
     * @example
     * // Count the number of GameAccounts
     * const count = await prisma.gameAccount.count({
     *   where: {
     *     // ... the filter for the GameAccounts we want to count
     *   }
     * })
    **/
    count<T extends GameAccountCountArgs>(
      args?: Subset<T, GameAccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GameAccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GameAccount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameAccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GameAccountAggregateArgs>(args: Subset<T, GameAccountAggregateArgs>): Prisma.PrismaPromise<GetGameAccountAggregateType<T>>

    /**
     * Group by GameAccount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameAccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GameAccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GameAccountGroupByArgs['orderBy'] }
        : { orderBy?: GameAccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GameAccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGameAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GameAccount model
   */
  readonly fields: GameAccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GameAccount.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GameAccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GameAccount model
   */ 
  interface GameAccountFieldRefs {
    readonly id: FieldRef<"GameAccount", 'String'>
    readonly userId: FieldRef<"GameAccount", 'String'>
    readonly mtaSerial: FieldRef<"GameAccount", 'String'>
    readonly mtaAccount: FieldRef<"GameAccount", 'String'>
    readonly locked: FieldRef<"GameAccount", 'Boolean'>
    readonly changedAfterApproved: FieldRef<"GameAccount", 'Boolean'>
    readonly createdAt: FieldRef<"GameAccount", 'DateTime'>
    readonly updatedAt: FieldRef<"GameAccount", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * GameAccount findUnique
   */
  export type GameAccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameAccount
     */
    select?: GameAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameAccountInclude<ExtArgs> | null
    /**
     * Filter, which GameAccount to fetch.
     */
    where: GameAccountWhereUniqueInput
  }

  /**
   * GameAccount findUniqueOrThrow
   */
  export type GameAccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameAccount
     */
    select?: GameAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameAccountInclude<ExtArgs> | null
    /**
     * Filter, which GameAccount to fetch.
     */
    where: GameAccountWhereUniqueInput
  }

  /**
   * GameAccount findFirst
   */
  export type GameAccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameAccount
     */
    select?: GameAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameAccountInclude<ExtArgs> | null
    /**
     * Filter, which GameAccount to fetch.
     */
    where?: GameAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GameAccounts to fetch.
     */
    orderBy?: GameAccountOrderByWithRelationInput | GameAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GameAccounts.
     */
    cursor?: GameAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GameAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GameAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GameAccounts.
     */
    distinct?: GameAccountScalarFieldEnum | GameAccountScalarFieldEnum[]
  }

  /**
   * GameAccount findFirstOrThrow
   */
  export type GameAccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameAccount
     */
    select?: GameAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameAccountInclude<ExtArgs> | null
    /**
     * Filter, which GameAccount to fetch.
     */
    where?: GameAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GameAccounts to fetch.
     */
    orderBy?: GameAccountOrderByWithRelationInput | GameAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GameAccounts.
     */
    cursor?: GameAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GameAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GameAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GameAccounts.
     */
    distinct?: GameAccountScalarFieldEnum | GameAccountScalarFieldEnum[]
  }

  /**
   * GameAccount findMany
   */
  export type GameAccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameAccount
     */
    select?: GameAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameAccountInclude<ExtArgs> | null
    /**
     * Filter, which GameAccounts to fetch.
     */
    where?: GameAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GameAccounts to fetch.
     */
    orderBy?: GameAccountOrderByWithRelationInput | GameAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GameAccounts.
     */
    cursor?: GameAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GameAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GameAccounts.
     */
    skip?: number
    distinct?: GameAccountScalarFieldEnum | GameAccountScalarFieldEnum[]
  }

  /**
   * GameAccount create
   */
  export type GameAccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameAccount
     */
    select?: GameAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameAccountInclude<ExtArgs> | null
    /**
     * The data needed to create a GameAccount.
     */
    data: XOR<GameAccountCreateInput, GameAccountUncheckedCreateInput>
  }

  /**
   * GameAccount createMany
   */
  export type GameAccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GameAccounts.
     */
    data: GameAccountCreateManyInput | GameAccountCreateManyInput[]
  }

  /**
   * GameAccount createManyAndReturn
   */
  export type GameAccountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameAccount
     */
    select?: GameAccountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many GameAccounts.
     */
    data: GameAccountCreateManyInput | GameAccountCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameAccountIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * GameAccount update
   */
  export type GameAccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameAccount
     */
    select?: GameAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameAccountInclude<ExtArgs> | null
    /**
     * The data needed to update a GameAccount.
     */
    data: XOR<GameAccountUpdateInput, GameAccountUncheckedUpdateInput>
    /**
     * Choose, which GameAccount to update.
     */
    where: GameAccountWhereUniqueInput
  }

  /**
   * GameAccount updateMany
   */
  export type GameAccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GameAccounts.
     */
    data: XOR<GameAccountUpdateManyMutationInput, GameAccountUncheckedUpdateManyInput>
    /**
     * Filter which GameAccounts to update
     */
    where?: GameAccountWhereInput
  }

  /**
   * GameAccount upsert
   */
  export type GameAccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameAccount
     */
    select?: GameAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameAccountInclude<ExtArgs> | null
    /**
     * The filter to search for the GameAccount to update in case it exists.
     */
    where: GameAccountWhereUniqueInput
    /**
     * In case the GameAccount found by the `where` argument doesn't exist, create a new GameAccount with this data.
     */
    create: XOR<GameAccountCreateInput, GameAccountUncheckedCreateInput>
    /**
     * In case the GameAccount was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GameAccountUpdateInput, GameAccountUncheckedUpdateInput>
  }

  /**
   * GameAccount delete
   */
  export type GameAccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameAccount
     */
    select?: GameAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameAccountInclude<ExtArgs> | null
    /**
     * Filter which GameAccount to delete.
     */
    where: GameAccountWhereUniqueInput
  }

  /**
   * GameAccount deleteMany
   */
  export type GameAccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GameAccounts to delete
     */
    where?: GameAccountWhereInput
  }

  /**
   * GameAccount without action
   */
  export type GameAccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameAccount
     */
    select?: GameAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameAccountInclude<ExtArgs> | null
  }


  /**
   * Model TicketParticipant
   */

  export type AggregateTicketParticipant = {
    _count: TicketParticipantCountAggregateOutputType | null
    _min: TicketParticipantMinAggregateOutputType | null
    _max: TicketParticipantMaxAggregateOutputType | null
  }

  export type TicketParticipantMinAggregateOutputType = {
    ticketId: string | null
    userId: string | null
    addedById: string | null
    createdAt: Date | null
  }

  export type TicketParticipantMaxAggregateOutputType = {
    ticketId: string | null
    userId: string | null
    addedById: string | null
    createdAt: Date | null
  }

  export type TicketParticipantCountAggregateOutputType = {
    ticketId: number
    userId: number
    addedById: number
    createdAt: number
    _all: number
  }


  export type TicketParticipantMinAggregateInputType = {
    ticketId?: true
    userId?: true
    addedById?: true
    createdAt?: true
  }

  export type TicketParticipantMaxAggregateInputType = {
    ticketId?: true
    userId?: true
    addedById?: true
    createdAt?: true
  }

  export type TicketParticipantCountAggregateInputType = {
    ticketId?: true
    userId?: true
    addedById?: true
    createdAt?: true
    _all?: true
  }

  export type TicketParticipantAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TicketParticipant to aggregate.
     */
    where?: TicketParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketParticipants to fetch.
     */
    orderBy?: TicketParticipantOrderByWithRelationInput | TicketParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TicketParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketParticipants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TicketParticipants
    **/
    _count?: true | TicketParticipantCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TicketParticipantMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TicketParticipantMaxAggregateInputType
  }

  export type GetTicketParticipantAggregateType<T extends TicketParticipantAggregateArgs> = {
        [P in keyof T & keyof AggregateTicketParticipant]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTicketParticipant[P]>
      : GetScalarType<T[P], AggregateTicketParticipant[P]>
  }




  export type TicketParticipantGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketParticipantWhereInput
    orderBy?: TicketParticipantOrderByWithAggregationInput | TicketParticipantOrderByWithAggregationInput[]
    by: TicketParticipantScalarFieldEnum[] | TicketParticipantScalarFieldEnum
    having?: TicketParticipantScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TicketParticipantCountAggregateInputType | true
    _min?: TicketParticipantMinAggregateInputType
    _max?: TicketParticipantMaxAggregateInputType
  }

  export type TicketParticipantGroupByOutputType = {
    ticketId: string
    userId: string
    addedById: string | null
    createdAt: Date
    _count: TicketParticipantCountAggregateOutputType | null
    _min: TicketParticipantMinAggregateOutputType | null
    _max: TicketParticipantMaxAggregateOutputType | null
  }

  type GetTicketParticipantGroupByPayload<T extends TicketParticipantGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TicketParticipantGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TicketParticipantGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TicketParticipantGroupByOutputType[P]>
            : GetScalarType<T[P], TicketParticipantGroupByOutputType[P]>
        }
      >
    >


  export type TicketParticipantSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ticketId?: boolean
    userId?: boolean
    addedById?: boolean
    createdAt?: boolean
    ticket?: boolean | TicketDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    addedBy?: boolean | TicketParticipant$addedByArgs<ExtArgs>
  }, ExtArgs["result"]["ticketParticipant"]>

  export type TicketParticipantSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ticketId?: boolean
    userId?: boolean
    addedById?: boolean
    createdAt?: boolean
    ticket?: boolean | TicketDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    addedBy?: boolean | TicketParticipant$addedByArgs<ExtArgs>
  }, ExtArgs["result"]["ticketParticipant"]>

  export type TicketParticipantSelectScalar = {
    ticketId?: boolean
    userId?: boolean
    addedById?: boolean
    createdAt?: boolean
  }

  export type TicketParticipantInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ticket?: boolean | TicketDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    addedBy?: boolean | TicketParticipant$addedByArgs<ExtArgs>
  }
  export type TicketParticipantIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ticket?: boolean | TicketDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    addedBy?: boolean | TicketParticipant$addedByArgs<ExtArgs>
  }

  export type $TicketParticipantPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TicketParticipant"
    objects: {
      ticket: Prisma.$TicketPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
      addedBy: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      ticketId: string
      userId: string
      addedById: string | null
      createdAt: Date
    }, ExtArgs["result"]["ticketParticipant"]>
    composites: {}
  }

  type TicketParticipantGetPayload<S extends boolean | null | undefined | TicketParticipantDefaultArgs> = $Result.GetResult<Prisma.$TicketParticipantPayload, S>

  type TicketParticipantCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TicketParticipantFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TicketParticipantCountAggregateInputType | true
    }

  export interface TicketParticipantDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TicketParticipant'], meta: { name: 'TicketParticipant' } }
    /**
     * Find zero or one TicketParticipant that matches the filter.
     * @param {TicketParticipantFindUniqueArgs} args - Arguments to find a TicketParticipant
     * @example
     * // Get one TicketParticipant
     * const ticketParticipant = await prisma.ticketParticipant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TicketParticipantFindUniqueArgs>(args: SelectSubset<T, TicketParticipantFindUniqueArgs<ExtArgs>>): Prisma__TicketParticipantClient<$Result.GetResult<Prisma.$TicketParticipantPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TicketParticipant that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TicketParticipantFindUniqueOrThrowArgs} args - Arguments to find a TicketParticipant
     * @example
     * // Get one TicketParticipant
     * const ticketParticipant = await prisma.ticketParticipant.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TicketParticipantFindUniqueOrThrowArgs>(args: SelectSubset<T, TicketParticipantFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TicketParticipantClient<$Result.GetResult<Prisma.$TicketParticipantPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TicketParticipant that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketParticipantFindFirstArgs} args - Arguments to find a TicketParticipant
     * @example
     * // Get one TicketParticipant
     * const ticketParticipant = await prisma.ticketParticipant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TicketParticipantFindFirstArgs>(args?: SelectSubset<T, TicketParticipantFindFirstArgs<ExtArgs>>): Prisma__TicketParticipantClient<$Result.GetResult<Prisma.$TicketParticipantPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TicketParticipant that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketParticipantFindFirstOrThrowArgs} args - Arguments to find a TicketParticipant
     * @example
     * // Get one TicketParticipant
     * const ticketParticipant = await prisma.ticketParticipant.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TicketParticipantFindFirstOrThrowArgs>(args?: SelectSubset<T, TicketParticipantFindFirstOrThrowArgs<ExtArgs>>): Prisma__TicketParticipantClient<$Result.GetResult<Prisma.$TicketParticipantPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TicketParticipants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketParticipantFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TicketParticipants
     * const ticketParticipants = await prisma.ticketParticipant.findMany()
     * 
     * // Get first 10 TicketParticipants
     * const ticketParticipants = await prisma.ticketParticipant.findMany({ take: 10 })
     * 
     * // Only select the `ticketId`
     * const ticketParticipantWithTicketIdOnly = await prisma.ticketParticipant.findMany({ select: { ticketId: true } })
     * 
     */
    findMany<T extends TicketParticipantFindManyArgs>(args?: SelectSubset<T, TicketParticipantFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketParticipantPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TicketParticipant.
     * @param {TicketParticipantCreateArgs} args - Arguments to create a TicketParticipant.
     * @example
     * // Create one TicketParticipant
     * const TicketParticipant = await prisma.ticketParticipant.create({
     *   data: {
     *     // ... data to create a TicketParticipant
     *   }
     * })
     * 
     */
    create<T extends TicketParticipantCreateArgs>(args: SelectSubset<T, TicketParticipantCreateArgs<ExtArgs>>): Prisma__TicketParticipantClient<$Result.GetResult<Prisma.$TicketParticipantPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TicketParticipants.
     * @param {TicketParticipantCreateManyArgs} args - Arguments to create many TicketParticipants.
     * @example
     * // Create many TicketParticipants
     * const ticketParticipant = await prisma.ticketParticipant.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TicketParticipantCreateManyArgs>(args?: SelectSubset<T, TicketParticipantCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TicketParticipants and returns the data saved in the database.
     * @param {TicketParticipantCreateManyAndReturnArgs} args - Arguments to create many TicketParticipants.
     * @example
     * // Create many TicketParticipants
     * const ticketParticipant = await prisma.ticketParticipant.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TicketParticipants and only return the `ticketId`
     * const ticketParticipantWithTicketIdOnly = await prisma.ticketParticipant.createManyAndReturn({ 
     *   select: { ticketId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TicketParticipantCreateManyAndReturnArgs>(args?: SelectSubset<T, TicketParticipantCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketParticipantPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TicketParticipant.
     * @param {TicketParticipantDeleteArgs} args - Arguments to delete one TicketParticipant.
     * @example
     * // Delete one TicketParticipant
     * const TicketParticipant = await prisma.ticketParticipant.delete({
     *   where: {
     *     // ... filter to delete one TicketParticipant
     *   }
     * })
     * 
     */
    delete<T extends TicketParticipantDeleteArgs>(args: SelectSubset<T, TicketParticipantDeleteArgs<ExtArgs>>): Prisma__TicketParticipantClient<$Result.GetResult<Prisma.$TicketParticipantPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TicketParticipant.
     * @param {TicketParticipantUpdateArgs} args - Arguments to update one TicketParticipant.
     * @example
     * // Update one TicketParticipant
     * const ticketParticipant = await prisma.ticketParticipant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TicketParticipantUpdateArgs>(args: SelectSubset<T, TicketParticipantUpdateArgs<ExtArgs>>): Prisma__TicketParticipantClient<$Result.GetResult<Prisma.$TicketParticipantPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TicketParticipants.
     * @param {TicketParticipantDeleteManyArgs} args - Arguments to filter TicketParticipants to delete.
     * @example
     * // Delete a few TicketParticipants
     * const { count } = await prisma.ticketParticipant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TicketParticipantDeleteManyArgs>(args?: SelectSubset<T, TicketParticipantDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TicketParticipants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketParticipantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TicketParticipants
     * const ticketParticipant = await prisma.ticketParticipant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TicketParticipantUpdateManyArgs>(args: SelectSubset<T, TicketParticipantUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TicketParticipant.
     * @param {TicketParticipantUpsertArgs} args - Arguments to update or create a TicketParticipant.
     * @example
     * // Update or create a TicketParticipant
     * const ticketParticipant = await prisma.ticketParticipant.upsert({
     *   create: {
     *     // ... data to create a TicketParticipant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TicketParticipant we want to update
     *   }
     * })
     */
    upsert<T extends TicketParticipantUpsertArgs>(args: SelectSubset<T, TicketParticipantUpsertArgs<ExtArgs>>): Prisma__TicketParticipantClient<$Result.GetResult<Prisma.$TicketParticipantPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TicketParticipants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketParticipantCountArgs} args - Arguments to filter TicketParticipants to count.
     * @example
     * // Count the number of TicketParticipants
     * const count = await prisma.ticketParticipant.count({
     *   where: {
     *     // ... the filter for the TicketParticipants we want to count
     *   }
     * })
    **/
    count<T extends TicketParticipantCountArgs>(
      args?: Subset<T, TicketParticipantCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TicketParticipantCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TicketParticipant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketParticipantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TicketParticipantAggregateArgs>(args: Subset<T, TicketParticipantAggregateArgs>): Prisma.PrismaPromise<GetTicketParticipantAggregateType<T>>

    /**
     * Group by TicketParticipant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketParticipantGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TicketParticipantGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TicketParticipantGroupByArgs['orderBy'] }
        : { orderBy?: TicketParticipantGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TicketParticipantGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTicketParticipantGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TicketParticipant model
   */
  readonly fields: TicketParticipantFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TicketParticipant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TicketParticipantClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ticket<T extends TicketDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TicketDefaultArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    addedBy<T extends TicketParticipant$addedByArgs<ExtArgs> = {}>(args?: Subset<T, TicketParticipant$addedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TicketParticipant model
   */ 
  interface TicketParticipantFieldRefs {
    readonly ticketId: FieldRef<"TicketParticipant", 'String'>
    readonly userId: FieldRef<"TicketParticipant", 'String'>
    readonly addedById: FieldRef<"TicketParticipant", 'String'>
    readonly createdAt: FieldRef<"TicketParticipant", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TicketParticipant findUnique
   */
  export type TicketParticipantFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketParticipant
     */
    select?: TicketParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketParticipantInclude<ExtArgs> | null
    /**
     * Filter, which TicketParticipant to fetch.
     */
    where: TicketParticipantWhereUniqueInput
  }

  /**
   * TicketParticipant findUniqueOrThrow
   */
  export type TicketParticipantFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketParticipant
     */
    select?: TicketParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketParticipantInclude<ExtArgs> | null
    /**
     * Filter, which TicketParticipant to fetch.
     */
    where: TicketParticipantWhereUniqueInput
  }

  /**
   * TicketParticipant findFirst
   */
  export type TicketParticipantFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketParticipant
     */
    select?: TicketParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketParticipantInclude<ExtArgs> | null
    /**
     * Filter, which TicketParticipant to fetch.
     */
    where?: TicketParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketParticipants to fetch.
     */
    orderBy?: TicketParticipantOrderByWithRelationInput | TicketParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TicketParticipants.
     */
    cursor?: TicketParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketParticipants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TicketParticipants.
     */
    distinct?: TicketParticipantScalarFieldEnum | TicketParticipantScalarFieldEnum[]
  }

  /**
   * TicketParticipant findFirstOrThrow
   */
  export type TicketParticipantFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketParticipant
     */
    select?: TicketParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketParticipantInclude<ExtArgs> | null
    /**
     * Filter, which TicketParticipant to fetch.
     */
    where?: TicketParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketParticipants to fetch.
     */
    orderBy?: TicketParticipantOrderByWithRelationInput | TicketParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TicketParticipants.
     */
    cursor?: TicketParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketParticipants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TicketParticipants.
     */
    distinct?: TicketParticipantScalarFieldEnum | TicketParticipantScalarFieldEnum[]
  }

  /**
   * TicketParticipant findMany
   */
  export type TicketParticipantFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketParticipant
     */
    select?: TicketParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketParticipantInclude<ExtArgs> | null
    /**
     * Filter, which TicketParticipants to fetch.
     */
    where?: TicketParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketParticipants to fetch.
     */
    orderBy?: TicketParticipantOrderByWithRelationInput | TicketParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TicketParticipants.
     */
    cursor?: TicketParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketParticipants.
     */
    skip?: number
    distinct?: TicketParticipantScalarFieldEnum | TicketParticipantScalarFieldEnum[]
  }

  /**
   * TicketParticipant create
   */
  export type TicketParticipantCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketParticipant
     */
    select?: TicketParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketParticipantInclude<ExtArgs> | null
    /**
     * The data needed to create a TicketParticipant.
     */
    data: XOR<TicketParticipantCreateInput, TicketParticipantUncheckedCreateInput>
  }

  /**
   * TicketParticipant createMany
   */
  export type TicketParticipantCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TicketParticipants.
     */
    data: TicketParticipantCreateManyInput | TicketParticipantCreateManyInput[]
  }

  /**
   * TicketParticipant createManyAndReturn
   */
  export type TicketParticipantCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketParticipant
     */
    select?: TicketParticipantSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TicketParticipants.
     */
    data: TicketParticipantCreateManyInput | TicketParticipantCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketParticipantIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TicketParticipant update
   */
  export type TicketParticipantUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketParticipant
     */
    select?: TicketParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketParticipantInclude<ExtArgs> | null
    /**
     * The data needed to update a TicketParticipant.
     */
    data: XOR<TicketParticipantUpdateInput, TicketParticipantUncheckedUpdateInput>
    /**
     * Choose, which TicketParticipant to update.
     */
    where: TicketParticipantWhereUniqueInput
  }

  /**
   * TicketParticipant updateMany
   */
  export type TicketParticipantUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TicketParticipants.
     */
    data: XOR<TicketParticipantUpdateManyMutationInput, TicketParticipantUncheckedUpdateManyInput>
    /**
     * Filter which TicketParticipants to update
     */
    where?: TicketParticipantWhereInput
  }

  /**
   * TicketParticipant upsert
   */
  export type TicketParticipantUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketParticipant
     */
    select?: TicketParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketParticipantInclude<ExtArgs> | null
    /**
     * The filter to search for the TicketParticipant to update in case it exists.
     */
    where: TicketParticipantWhereUniqueInput
    /**
     * In case the TicketParticipant found by the `where` argument doesn't exist, create a new TicketParticipant with this data.
     */
    create: XOR<TicketParticipantCreateInput, TicketParticipantUncheckedCreateInput>
    /**
     * In case the TicketParticipant was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TicketParticipantUpdateInput, TicketParticipantUncheckedUpdateInput>
  }

  /**
   * TicketParticipant delete
   */
  export type TicketParticipantDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketParticipant
     */
    select?: TicketParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketParticipantInclude<ExtArgs> | null
    /**
     * Filter which TicketParticipant to delete.
     */
    where: TicketParticipantWhereUniqueInput
  }

  /**
   * TicketParticipant deleteMany
   */
  export type TicketParticipantDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TicketParticipants to delete
     */
    where?: TicketParticipantWhereInput
  }

  /**
   * TicketParticipant.addedBy
   */
  export type TicketParticipant$addedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * TicketParticipant without action
   */
  export type TicketParticipantDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketParticipant
     */
    select?: TicketParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketParticipantInclude<ExtArgs> | null
  }


  /**
   * Model TicketRating
   */

  export type AggregateTicketRating = {
    _count: TicketRatingCountAggregateOutputType | null
    _avg: TicketRatingAvgAggregateOutputType | null
    _sum: TicketRatingSumAggregateOutputType | null
    _min: TicketRatingMinAggregateOutputType | null
    _max: TicketRatingMaxAggregateOutputType | null
  }

  export type TicketRatingAvgAggregateOutputType = {
    stars: number | null
  }

  export type TicketRatingSumAggregateOutputType = {
    stars: number | null
  }

  export type TicketRatingMinAggregateOutputType = {
    id: string | null
    ticketId: string | null
    raterUserId: string | null
    targetUserId: string | null
    stars: number | null
    feedback: string | null
    createdAt: Date | null
  }

  export type TicketRatingMaxAggregateOutputType = {
    id: string | null
    ticketId: string | null
    raterUserId: string | null
    targetUserId: string | null
    stars: number | null
    feedback: string | null
    createdAt: Date | null
  }

  export type TicketRatingCountAggregateOutputType = {
    id: number
    ticketId: number
    raterUserId: number
    targetUserId: number
    stars: number
    feedback: number
    createdAt: number
    _all: number
  }


  export type TicketRatingAvgAggregateInputType = {
    stars?: true
  }

  export type TicketRatingSumAggregateInputType = {
    stars?: true
  }

  export type TicketRatingMinAggregateInputType = {
    id?: true
    ticketId?: true
    raterUserId?: true
    targetUserId?: true
    stars?: true
    feedback?: true
    createdAt?: true
  }

  export type TicketRatingMaxAggregateInputType = {
    id?: true
    ticketId?: true
    raterUserId?: true
    targetUserId?: true
    stars?: true
    feedback?: true
    createdAt?: true
  }

  export type TicketRatingCountAggregateInputType = {
    id?: true
    ticketId?: true
    raterUserId?: true
    targetUserId?: true
    stars?: true
    feedback?: true
    createdAt?: true
    _all?: true
  }

  export type TicketRatingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TicketRating to aggregate.
     */
    where?: TicketRatingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketRatings to fetch.
     */
    orderBy?: TicketRatingOrderByWithRelationInput | TicketRatingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TicketRatingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketRatings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketRatings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TicketRatings
    **/
    _count?: true | TicketRatingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TicketRatingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TicketRatingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TicketRatingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TicketRatingMaxAggregateInputType
  }

  export type GetTicketRatingAggregateType<T extends TicketRatingAggregateArgs> = {
        [P in keyof T & keyof AggregateTicketRating]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTicketRating[P]>
      : GetScalarType<T[P], AggregateTicketRating[P]>
  }




  export type TicketRatingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketRatingWhereInput
    orderBy?: TicketRatingOrderByWithAggregationInput | TicketRatingOrderByWithAggregationInput[]
    by: TicketRatingScalarFieldEnum[] | TicketRatingScalarFieldEnum
    having?: TicketRatingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TicketRatingCountAggregateInputType | true
    _avg?: TicketRatingAvgAggregateInputType
    _sum?: TicketRatingSumAggregateInputType
    _min?: TicketRatingMinAggregateInputType
    _max?: TicketRatingMaxAggregateInputType
  }

  export type TicketRatingGroupByOutputType = {
    id: string
    ticketId: string
    raterUserId: string
    targetUserId: string
    stars: number
    feedback: string
    createdAt: Date
    _count: TicketRatingCountAggregateOutputType | null
    _avg: TicketRatingAvgAggregateOutputType | null
    _sum: TicketRatingSumAggregateOutputType | null
    _min: TicketRatingMinAggregateOutputType | null
    _max: TicketRatingMaxAggregateOutputType | null
  }

  type GetTicketRatingGroupByPayload<T extends TicketRatingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TicketRatingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TicketRatingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TicketRatingGroupByOutputType[P]>
            : GetScalarType<T[P], TicketRatingGroupByOutputType[P]>
        }
      >
    >


  export type TicketRatingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ticketId?: boolean
    raterUserId?: boolean
    targetUserId?: boolean
    stars?: boolean
    feedback?: boolean
    createdAt?: boolean
    ticket?: boolean | TicketDefaultArgs<ExtArgs>
    rater?: boolean | UserDefaultArgs<ExtArgs>
    target?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ticketRating"]>

  export type TicketRatingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ticketId?: boolean
    raterUserId?: boolean
    targetUserId?: boolean
    stars?: boolean
    feedback?: boolean
    createdAt?: boolean
    ticket?: boolean | TicketDefaultArgs<ExtArgs>
    rater?: boolean | UserDefaultArgs<ExtArgs>
    target?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ticketRating"]>

  export type TicketRatingSelectScalar = {
    id?: boolean
    ticketId?: boolean
    raterUserId?: boolean
    targetUserId?: boolean
    stars?: boolean
    feedback?: boolean
    createdAt?: boolean
  }

  export type TicketRatingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ticket?: boolean | TicketDefaultArgs<ExtArgs>
    rater?: boolean | UserDefaultArgs<ExtArgs>
    target?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TicketRatingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ticket?: boolean | TicketDefaultArgs<ExtArgs>
    rater?: boolean | UserDefaultArgs<ExtArgs>
    target?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TicketRatingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TicketRating"
    objects: {
      ticket: Prisma.$TicketPayload<ExtArgs>
      rater: Prisma.$UserPayload<ExtArgs>
      target: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      ticketId: string
      raterUserId: string
      targetUserId: string
      stars: number
      feedback: string
      createdAt: Date
    }, ExtArgs["result"]["ticketRating"]>
    composites: {}
  }

  type TicketRatingGetPayload<S extends boolean | null | undefined | TicketRatingDefaultArgs> = $Result.GetResult<Prisma.$TicketRatingPayload, S>

  type TicketRatingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TicketRatingFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TicketRatingCountAggregateInputType | true
    }

  export interface TicketRatingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TicketRating'], meta: { name: 'TicketRating' } }
    /**
     * Find zero or one TicketRating that matches the filter.
     * @param {TicketRatingFindUniqueArgs} args - Arguments to find a TicketRating
     * @example
     * // Get one TicketRating
     * const ticketRating = await prisma.ticketRating.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TicketRatingFindUniqueArgs>(args: SelectSubset<T, TicketRatingFindUniqueArgs<ExtArgs>>): Prisma__TicketRatingClient<$Result.GetResult<Prisma.$TicketRatingPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TicketRating that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TicketRatingFindUniqueOrThrowArgs} args - Arguments to find a TicketRating
     * @example
     * // Get one TicketRating
     * const ticketRating = await prisma.ticketRating.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TicketRatingFindUniqueOrThrowArgs>(args: SelectSubset<T, TicketRatingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TicketRatingClient<$Result.GetResult<Prisma.$TicketRatingPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TicketRating that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketRatingFindFirstArgs} args - Arguments to find a TicketRating
     * @example
     * // Get one TicketRating
     * const ticketRating = await prisma.ticketRating.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TicketRatingFindFirstArgs>(args?: SelectSubset<T, TicketRatingFindFirstArgs<ExtArgs>>): Prisma__TicketRatingClient<$Result.GetResult<Prisma.$TicketRatingPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TicketRating that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketRatingFindFirstOrThrowArgs} args - Arguments to find a TicketRating
     * @example
     * // Get one TicketRating
     * const ticketRating = await prisma.ticketRating.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TicketRatingFindFirstOrThrowArgs>(args?: SelectSubset<T, TicketRatingFindFirstOrThrowArgs<ExtArgs>>): Prisma__TicketRatingClient<$Result.GetResult<Prisma.$TicketRatingPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TicketRatings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketRatingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TicketRatings
     * const ticketRatings = await prisma.ticketRating.findMany()
     * 
     * // Get first 10 TicketRatings
     * const ticketRatings = await prisma.ticketRating.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ticketRatingWithIdOnly = await prisma.ticketRating.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TicketRatingFindManyArgs>(args?: SelectSubset<T, TicketRatingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketRatingPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TicketRating.
     * @param {TicketRatingCreateArgs} args - Arguments to create a TicketRating.
     * @example
     * // Create one TicketRating
     * const TicketRating = await prisma.ticketRating.create({
     *   data: {
     *     // ... data to create a TicketRating
     *   }
     * })
     * 
     */
    create<T extends TicketRatingCreateArgs>(args: SelectSubset<T, TicketRatingCreateArgs<ExtArgs>>): Prisma__TicketRatingClient<$Result.GetResult<Prisma.$TicketRatingPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TicketRatings.
     * @param {TicketRatingCreateManyArgs} args - Arguments to create many TicketRatings.
     * @example
     * // Create many TicketRatings
     * const ticketRating = await prisma.ticketRating.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TicketRatingCreateManyArgs>(args?: SelectSubset<T, TicketRatingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TicketRatings and returns the data saved in the database.
     * @param {TicketRatingCreateManyAndReturnArgs} args - Arguments to create many TicketRatings.
     * @example
     * // Create many TicketRatings
     * const ticketRating = await prisma.ticketRating.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TicketRatings and only return the `id`
     * const ticketRatingWithIdOnly = await prisma.ticketRating.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TicketRatingCreateManyAndReturnArgs>(args?: SelectSubset<T, TicketRatingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketRatingPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TicketRating.
     * @param {TicketRatingDeleteArgs} args - Arguments to delete one TicketRating.
     * @example
     * // Delete one TicketRating
     * const TicketRating = await prisma.ticketRating.delete({
     *   where: {
     *     // ... filter to delete one TicketRating
     *   }
     * })
     * 
     */
    delete<T extends TicketRatingDeleteArgs>(args: SelectSubset<T, TicketRatingDeleteArgs<ExtArgs>>): Prisma__TicketRatingClient<$Result.GetResult<Prisma.$TicketRatingPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TicketRating.
     * @param {TicketRatingUpdateArgs} args - Arguments to update one TicketRating.
     * @example
     * // Update one TicketRating
     * const ticketRating = await prisma.ticketRating.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TicketRatingUpdateArgs>(args: SelectSubset<T, TicketRatingUpdateArgs<ExtArgs>>): Prisma__TicketRatingClient<$Result.GetResult<Prisma.$TicketRatingPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TicketRatings.
     * @param {TicketRatingDeleteManyArgs} args - Arguments to filter TicketRatings to delete.
     * @example
     * // Delete a few TicketRatings
     * const { count } = await prisma.ticketRating.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TicketRatingDeleteManyArgs>(args?: SelectSubset<T, TicketRatingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TicketRatings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketRatingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TicketRatings
     * const ticketRating = await prisma.ticketRating.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TicketRatingUpdateManyArgs>(args: SelectSubset<T, TicketRatingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TicketRating.
     * @param {TicketRatingUpsertArgs} args - Arguments to update or create a TicketRating.
     * @example
     * // Update or create a TicketRating
     * const ticketRating = await prisma.ticketRating.upsert({
     *   create: {
     *     // ... data to create a TicketRating
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TicketRating we want to update
     *   }
     * })
     */
    upsert<T extends TicketRatingUpsertArgs>(args: SelectSubset<T, TicketRatingUpsertArgs<ExtArgs>>): Prisma__TicketRatingClient<$Result.GetResult<Prisma.$TicketRatingPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TicketRatings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketRatingCountArgs} args - Arguments to filter TicketRatings to count.
     * @example
     * // Count the number of TicketRatings
     * const count = await prisma.ticketRating.count({
     *   where: {
     *     // ... the filter for the TicketRatings we want to count
     *   }
     * })
    **/
    count<T extends TicketRatingCountArgs>(
      args?: Subset<T, TicketRatingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TicketRatingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TicketRating.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketRatingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TicketRatingAggregateArgs>(args: Subset<T, TicketRatingAggregateArgs>): Prisma.PrismaPromise<GetTicketRatingAggregateType<T>>

    /**
     * Group by TicketRating.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketRatingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TicketRatingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TicketRatingGroupByArgs['orderBy'] }
        : { orderBy?: TicketRatingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TicketRatingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTicketRatingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TicketRating model
   */
  readonly fields: TicketRatingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TicketRating.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TicketRatingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ticket<T extends TicketDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TicketDefaultArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    rater<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    target<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TicketRating model
   */ 
  interface TicketRatingFieldRefs {
    readonly id: FieldRef<"TicketRating", 'String'>
    readonly ticketId: FieldRef<"TicketRating", 'String'>
    readonly raterUserId: FieldRef<"TicketRating", 'String'>
    readonly targetUserId: FieldRef<"TicketRating", 'String'>
    readonly stars: FieldRef<"TicketRating", 'Int'>
    readonly feedback: FieldRef<"TicketRating", 'String'>
    readonly createdAt: FieldRef<"TicketRating", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TicketRating findUnique
   */
  export type TicketRatingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketRating
     */
    select?: TicketRatingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketRatingInclude<ExtArgs> | null
    /**
     * Filter, which TicketRating to fetch.
     */
    where: TicketRatingWhereUniqueInput
  }

  /**
   * TicketRating findUniqueOrThrow
   */
  export type TicketRatingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketRating
     */
    select?: TicketRatingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketRatingInclude<ExtArgs> | null
    /**
     * Filter, which TicketRating to fetch.
     */
    where: TicketRatingWhereUniqueInput
  }

  /**
   * TicketRating findFirst
   */
  export type TicketRatingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketRating
     */
    select?: TicketRatingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketRatingInclude<ExtArgs> | null
    /**
     * Filter, which TicketRating to fetch.
     */
    where?: TicketRatingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketRatings to fetch.
     */
    orderBy?: TicketRatingOrderByWithRelationInput | TicketRatingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TicketRatings.
     */
    cursor?: TicketRatingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketRatings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketRatings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TicketRatings.
     */
    distinct?: TicketRatingScalarFieldEnum | TicketRatingScalarFieldEnum[]
  }

  /**
   * TicketRating findFirstOrThrow
   */
  export type TicketRatingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketRating
     */
    select?: TicketRatingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketRatingInclude<ExtArgs> | null
    /**
     * Filter, which TicketRating to fetch.
     */
    where?: TicketRatingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketRatings to fetch.
     */
    orderBy?: TicketRatingOrderByWithRelationInput | TicketRatingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TicketRatings.
     */
    cursor?: TicketRatingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketRatings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketRatings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TicketRatings.
     */
    distinct?: TicketRatingScalarFieldEnum | TicketRatingScalarFieldEnum[]
  }

  /**
   * TicketRating findMany
   */
  export type TicketRatingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketRating
     */
    select?: TicketRatingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketRatingInclude<ExtArgs> | null
    /**
     * Filter, which TicketRatings to fetch.
     */
    where?: TicketRatingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketRatings to fetch.
     */
    orderBy?: TicketRatingOrderByWithRelationInput | TicketRatingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TicketRatings.
     */
    cursor?: TicketRatingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketRatings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketRatings.
     */
    skip?: number
    distinct?: TicketRatingScalarFieldEnum | TicketRatingScalarFieldEnum[]
  }

  /**
   * TicketRating create
   */
  export type TicketRatingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketRating
     */
    select?: TicketRatingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketRatingInclude<ExtArgs> | null
    /**
     * The data needed to create a TicketRating.
     */
    data: XOR<TicketRatingCreateInput, TicketRatingUncheckedCreateInput>
  }

  /**
   * TicketRating createMany
   */
  export type TicketRatingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TicketRatings.
     */
    data: TicketRatingCreateManyInput | TicketRatingCreateManyInput[]
  }

  /**
   * TicketRating createManyAndReturn
   */
  export type TicketRatingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketRating
     */
    select?: TicketRatingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TicketRatings.
     */
    data: TicketRatingCreateManyInput | TicketRatingCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketRatingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TicketRating update
   */
  export type TicketRatingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketRating
     */
    select?: TicketRatingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketRatingInclude<ExtArgs> | null
    /**
     * The data needed to update a TicketRating.
     */
    data: XOR<TicketRatingUpdateInput, TicketRatingUncheckedUpdateInput>
    /**
     * Choose, which TicketRating to update.
     */
    where: TicketRatingWhereUniqueInput
  }

  /**
   * TicketRating updateMany
   */
  export type TicketRatingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TicketRatings.
     */
    data: XOR<TicketRatingUpdateManyMutationInput, TicketRatingUncheckedUpdateManyInput>
    /**
     * Filter which TicketRatings to update
     */
    where?: TicketRatingWhereInput
  }

  /**
   * TicketRating upsert
   */
  export type TicketRatingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketRating
     */
    select?: TicketRatingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketRatingInclude<ExtArgs> | null
    /**
     * The filter to search for the TicketRating to update in case it exists.
     */
    where: TicketRatingWhereUniqueInput
    /**
     * In case the TicketRating found by the `where` argument doesn't exist, create a new TicketRating with this data.
     */
    create: XOR<TicketRatingCreateInput, TicketRatingUncheckedCreateInput>
    /**
     * In case the TicketRating was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TicketRatingUpdateInput, TicketRatingUncheckedUpdateInput>
  }

  /**
   * TicketRating delete
   */
  export type TicketRatingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketRating
     */
    select?: TicketRatingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketRatingInclude<ExtArgs> | null
    /**
     * Filter which TicketRating to delete.
     */
    where: TicketRatingWhereUniqueInput
  }

  /**
   * TicketRating deleteMany
   */
  export type TicketRatingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TicketRatings to delete
     */
    where?: TicketRatingWhereInput
  }

  /**
   * TicketRating without action
   */
  export type TicketRatingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketRating
     */
    select?: TicketRatingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketRatingInclude<ExtArgs> | null
  }


  /**
   * Model MtaAccessLog
   */

  export type AggregateMtaAccessLog = {
    _count: MtaAccessLogCountAggregateOutputType | null
    _min: MtaAccessLogMinAggregateOutputType | null
    _max: MtaAccessLogMaxAggregateOutputType | null
  }

  export type MtaAccessLogMinAggregateOutputType = {
    id: string | null
    serial: string | null
    userId: string | null
    allowed: boolean | null
    reason: string | null
    ip: string | null
    createdAt: Date | null
  }

  export type MtaAccessLogMaxAggregateOutputType = {
    id: string | null
    serial: string | null
    userId: string | null
    allowed: boolean | null
    reason: string | null
    ip: string | null
    createdAt: Date | null
  }

  export type MtaAccessLogCountAggregateOutputType = {
    id: number
    serial: number
    userId: number
    allowed: number
    reason: number
    ip: number
    createdAt: number
    _all: number
  }


  export type MtaAccessLogMinAggregateInputType = {
    id?: true
    serial?: true
    userId?: true
    allowed?: true
    reason?: true
    ip?: true
    createdAt?: true
  }

  export type MtaAccessLogMaxAggregateInputType = {
    id?: true
    serial?: true
    userId?: true
    allowed?: true
    reason?: true
    ip?: true
    createdAt?: true
  }

  export type MtaAccessLogCountAggregateInputType = {
    id?: true
    serial?: true
    userId?: true
    allowed?: true
    reason?: true
    ip?: true
    createdAt?: true
    _all?: true
  }

  export type MtaAccessLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MtaAccessLog to aggregate.
     */
    where?: MtaAccessLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MtaAccessLogs to fetch.
     */
    orderBy?: MtaAccessLogOrderByWithRelationInput | MtaAccessLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MtaAccessLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MtaAccessLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MtaAccessLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MtaAccessLogs
    **/
    _count?: true | MtaAccessLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MtaAccessLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MtaAccessLogMaxAggregateInputType
  }

  export type GetMtaAccessLogAggregateType<T extends MtaAccessLogAggregateArgs> = {
        [P in keyof T & keyof AggregateMtaAccessLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMtaAccessLog[P]>
      : GetScalarType<T[P], AggregateMtaAccessLog[P]>
  }




  export type MtaAccessLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MtaAccessLogWhereInput
    orderBy?: MtaAccessLogOrderByWithAggregationInput | MtaAccessLogOrderByWithAggregationInput[]
    by: MtaAccessLogScalarFieldEnum[] | MtaAccessLogScalarFieldEnum
    having?: MtaAccessLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MtaAccessLogCountAggregateInputType | true
    _min?: MtaAccessLogMinAggregateInputType
    _max?: MtaAccessLogMaxAggregateInputType
  }

  export type MtaAccessLogGroupByOutputType = {
    id: string
    serial: string
    userId: string | null
    allowed: boolean
    reason: string | null
    ip: string | null
    createdAt: Date
    _count: MtaAccessLogCountAggregateOutputType | null
    _min: MtaAccessLogMinAggregateOutputType | null
    _max: MtaAccessLogMaxAggregateOutputType | null
  }

  type GetMtaAccessLogGroupByPayload<T extends MtaAccessLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MtaAccessLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MtaAccessLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MtaAccessLogGroupByOutputType[P]>
            : GetScalarType<T[P], MtaAccessLogGroupByOutputType[P]>
        }
      >
    >


  export type MtaAccessLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    serial?: boolean
    userId?: boolean
    allowed?: boolean
    reason?: boolean
    ip?: boolean
    createdAt?: boolean
    user?: boolean | MtaAccessLog$userArgs<ExtArgs>
  }, ExtArgs["result"]["mtaAccessLog"]>

  export type MtaAccessLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    serial?: boolean
    userId?: boolean
    allowed?: boolean
    reason?: boolean
    ip?: boolean
    createdAt?: boolean
    user?: boolean | MtaAccessLog$userArgs<ExtArgs>
  }, ExtArgs["result"]["mtaAccessLog"]>

  export type MtaAccessLogSelectScalar = {
    id?: boolean
    serial?: boolean
    userId?: boolean
    allowed?: boolean
    reason?: boolean
    ip?: boolean
    createdAt?: boolean
  }

  export type MtaAccessLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | MtaAccessLog$userArgs<ExtArgs>
  }
  export type MtaAccessLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | MtaAccessLog$userArgs<ExtArgs>
  }

  export type $MtaAccessLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MtaAccessLog"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      serial: string
      userId: string | null
      allowed: boolean
      reason: string | null
      ip: string | null
      createdAt: Date
    }, ExtArgs["result"]["mtaAccessLog"]>
    composites: {}
  }

  type MtaAccessLogGetPayload<S extends boolean | null | undefined | MtaAccessLogDefaultArgs> = $Result.GetResult<Prisma.$MtaAccessLogPayload, S>

  type MtaAccessLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MtaAccessLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MtaAccessLogCountAggregateInputType | true
    }

  export interface MtaAccessLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MtaAccessLog'], meta: { name: 'MtaAccessLog' } }
    /**
     * Find zero or one MtaAccessLog that matches the filter.
     * @param {MtaAccessLogFindUniqueArgs} args - Arguments to find a MtaAccessLog
     * @example
     * // Get one MtaAccessLog
     * const mtaAccessLog = await prisma.mtaAccessLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MtaAccessLogFindUniqueArgs>(args: SelectSubset<T, MtaAccessLogFindUniqueArgs<ExtArgs>>): Prisma__MtaAccessLogClient<$Result.GetResult<Prisma.$MtaAccessLogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one MtaAccessLog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MtaAccessLogFindUniqueOrThrowArgs} args - Arguments to find a MtaAccessLog
     * @example
     * // Get one MtaAccessLog
     * const mtaAccessLog = await prisma.mtaAccessLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MtaAccessLogFindUniqueOrThrowArgs>(args: SelectSubset<T, MtaAccessLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MtaAccessLogClient<$Result.GetResult<Prisma.$MtaAccessLogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first MtaAccessLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MtaAccessLogFindFirstArgs} args - Arguments to find a MtaAccessLog
     * @example
     * // Get one MtaAccessLog
     * const mtaAccessLog = await prisma.mtaAccessLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MtaAccessLogFindFirstArgs>(args?: SelectSubset<T, MtaAccessLogFindFirstArgs<ExtArgs>>): Prisma__MtaAccessLogClient<$Result.GetResult<Prisma.$MtaAccessLogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first MtaAccessLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MtaAccessLogFindFirstOrThrowArgs} args - Arguments to find a MtaAccessLog
     * @example
     * // Get one MtaAccessLog
     * const mtaAccessLog = await prisma.mtaAccessLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MtaAccessLogFindFirstOrThrowArgs>(args?: SelectSubset<T, MtaAccessLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__MtaAccessLogClient<$Result.GetResult<Prisma.$MtaAccessLogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more MtaAccessLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MtaAccessLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MtaAccessLogs
     * const mtaAccessLogs = await prisma.mtaAccessLog.findMany()
     * 
     * // Get first 10 MtaAccessLogs
     * const mtaAccessLogs = await prisma.mtaAccessLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mtaAccessLogWithIdOnly = await prisma.mtaAccessLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MtaAccessLogFindManyArgs>(args?: SelectSubset<T, MtaAccessLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MtaAccessLogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a MtaAccessLog.
     * @param {MtaAccessLogCreateArgs} args - Arguments to create a MtaAccessLog.
     * @example
     * // Create one MtaAccessLog
     * const MtaAccessLog = await prisma.mtaAccessLog.create({
     *   data: {
     *     // ... data to create a MtaAccessLog
     *   }
     * })
     * 
     */
    create<T extends MtaAccessLogCreateArgs>(args: SelectSubset<T, MtaAccessLogCreateArgs<ExtArgs>>): Prisma__MtaAccessLogClient<$Result.GetResult<Prisma.$MtaAccessLogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many MtaAccessLogs.
     * @param {MtaAccessLogCreateManyArgs} args - Arguments to create many MtaAccessLogs.
     * @example
     * // Create many MtaAccessLogs
     * const mtaAccessLog = await prisma.mtaAccessLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MtaAccessLogCreateManyArgs>(args?: SelectSubset<T, MtaAccessLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MtaAccessLogs and returns the data saved in the database.
     * @param {MtaAccessLogCreateManyAndReturnArgs} args - Arguments to create many MtaAccessLogs.
     * @example
     * // Create many MtaAccessLogs
     * const mtaAccessLog = await prisma.mtaAccessLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MtaAccessLogs and only return the `id`
     * const mtaAccessLogWithIdOnly = await prisma.mtaAccessLog.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MtaAccessLogCreateManyAndReturnArgs>(args?: SelectSubset<T, MtaAccessLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MtaAccessLogPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a MtaAccessLog.
     * @param {MtaAccessLogDeleteArgs} args - Arguments to delete one MtaAccessLog.
     * @example
     * // Delete one MtaAccessLog
     * const MtaAccessLog = await prisma.mtaAccessLog.delete({
     *   where: {
     *     // ... filter to delete one MtaAccessLog
     *   }
     * })
     * 
     */
    delete<T extends MtaAccessLogDeleteArgs>(args: SelectSubset<T, MtaAccessLogDeleteArgs<ExtArgs>>): Prisma__MtaAccessLogClient<$Result.GetResult<Prisma.$MtaAccessLogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one MtaAccessLog.
     * @param {MtaAccessLogUpdateArgs} args - Arguments to update one MtaAccessLog.
     * @example
     * // Update one MtaAccessLog
     * const mtaAccessLog = await prisma.mtaAccessLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MtaAccessLogUpdateArgs>(args: SelectSubset<T, MtaAccessLogUpdateArgs<ExtArgs>>): Prisma__MtaAccessLogClient<$Result.GetResult<Prisma.$MtaAccessLogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more MtaAccessLogs.
     * @param {MtaAccessLogDeleteManyArgs} args - Arguments to filter MtaAccessLogs to delete.
     * @example
     * // Delete a few MtaAccessLogs
     * const { count } = await prisma.mtaAccessLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MtaAccessLogDeleteManyArgs>(args?: SelectSubset<T, MtaAccessLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MtaAccessLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MtaAccessLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MtaAccessLogs
     * const mtaAccessLog = await prisma.mtaAccessLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MtaAccessLogUpdateManyArgs>(args: SelectSubset<T, MtaAccessLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MtaAccessLog.
     * @param {MtaAccessLogUpsertArgs} args - Arguments to update or create a MtaAccessLog.
     * @example
     * // Update or create a MtaAccessLog
     * const mtaAccessLog = await prisma.mtaAccessLog.upsert({
     *   create: {
     *     // ... data to create a MtaAccessLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MtaAccessLog we want to update
     *   }
     * })
     */
    upsert<T extends MtaAccessLogUpsertArgs>(args: SelectSubset<T, MtaAccessLogUpsertArgs<ExtArgs>>): Prisma__MtaAccessLogClient<$Result.GetResult<Prisma.$MtaAccessLogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of MtaAccessLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MtaAccessLogCountArgs} args - Arguments to filter MtaAccessLogs to count.
     * @example
     * // Count the number of MtaAccessLogs
     * const count = await prisma.mtaAccessLog.count({
     *   where: {
     *     // ... the filter for the MtaAccessLogs we want to count
     *   }
     * })
    **/
    count<T extends MtaAccessLogCountArgs>(
      args?: Subset<T, MtaAccessLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MtaAccessLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MtaAccessLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MtaAccessLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MtaAccessLogAggregateArgs>(args: Subset<T, MtaAccessLogAggregateArgs>): Prisma.PrismaPromise<GetMtaAccessLogAggregateType<T>>

    /**
     * Group by MtaAccessLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MtaAccessLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MtaAccessLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MtaAccessLogGroupByArgs['orderBy'] }
        : { orderBy?: MtaAccessLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MtaAccessLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMtaAccessLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MtaAccessLog model
   */
  readonly fields: MtaAccessLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MtaAccessLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MtaAccessLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends MtaAccessLog$userArgs<ExtArgs> = {}>(args?: Subset<T, MtaAccessLog$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MtaAccessLog model
   */ 
  interface MtaAccessLogFieldRefs {
    readonly id: FieldRef<"MtaAccessLog", 'String'>
    readonly serial: FieldRef<"MtaAccessLog", 'String'>
    readonly userId: FieldRef<"MtaAccessLog", 'String'>
    readonly allowed: FieldRef<"MtaAccessLog", 'Boolean'>
    readonly reason: FieldRef<"MtaAccessLog", 'String'>
    readonly ip: FieldRef<"MtaAccessLog", 'String'>
    readonly createdAt: FieldRef<"MtaAccessLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MtaAccessLog findUnique
   */
  export type MtaAccessLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MtaAccessLog
     */
    select?: MtaAccessLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MtaAccessLogInclude<ExtArgs> | null
    /**
     * Filter, which MtaAccessLog to fetch.
     */
    where: MtaAccessLogWhereUniqueInput
  }

  /**
   * MtaAccessLog findUniqueOrThrow
   */
  export type MtaAccessLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MtaAccessLog
     */
    select?: MtaAccessLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MtaAccessLogInclude<ExtArgs> | null
    /**
     * Filter, which MtaAccessLog to fetch.
     */
    where: MtaAccessLogWhereUniqueInput
  }

  /**
   * MtaAccessLog findFirst
   */
  export type MtaAccessLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MtaAccessLog
     */
    select?: MtaAccessLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MtaAccessLogInclude<ExtArgs> | null
    /**
     * Filter, which MtaAccessLog to fetch.
     */
    where?: MtaAccessLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MtaAccessLogs to fetch.
     */
    orderBy?: MtaAccessLogOrderByWithRelationInput | MtaAccessLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MtaAccessLogs.
     */
    cursor?: MtaAccessLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MtaAccessLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MtaAccessLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MtaAccessLogs.
     */
    distinct?: MtaAccessLogScalarFieldEnum | MtaAccessLogScalarFieldEnum[]
  }

  /**
   * MtaAccessLog findFirstOrThrow
   */
  export type MtaAccessLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MtaAccessLog
     */
    select?: MtaAccessLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MtaAccessLogInclude<ExtArgs> | null
    /**
     * Filter, which MtaAccessLog to fetch.
     */
    where?: MtaAccessLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MtaAccessLogs to fetch.
     */
    orderBy?: MtaAccessLogOrderByWithRelationInput | MtaAccessLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MtaAccessLogs.
     */
    cursor?: MtaAccessLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MtaAccessLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MtaAccessLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MtaAccessLogs.
     */
    distinct?: MtaAccessLogScalarFieldEnum | MtaAccessLogScalarFieldEnum[]
  }

  /**
   * MtaAccessLog findMany
   */
  export type MtaAccessLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MtaAccessLog
     */
    select?: MtaAccessLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MtaAccessLogInclude<ExtArgs> | null
    /**
     * Filter, which MtaAccessLogs to fetch.
     */
    where?: MtaAccessLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MtaAccessLogs to fetch.
     */
    orderBy?: MtaAccessLogOrderByWithRelationInput | MtaAccessLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MtaAccessLogs.
     */
    cursor?: MtaAccessLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MtaAccessLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MtaAccessLogs.
     */
    skip?: number
    distinct?: MtaAccessLogScalarFieldEnum | MtaAccessLogScalarFieldEnum[]
  }

  /**
   * MtaAccessLog create
   */
  export type MtaAccessLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MtaAccessLog
     */
    select?: MtaAccessLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MtaAccessLogInclude<ExtArgs> | null
    /**
     * The data needed to create a MtaAccessLog.
     */
    data: XOR<MtaAccessLogCreateInput, MtaAccessLogUncheckedCreateInput>
  }

  /**
   * MtaAccessLog createMany
   */
  export type MtaAccessLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MtaAccessLogs.
     */
    data: MtaAccessLogCreateManyInput | MtaAccessLogCreateManyInput[]
  }

  /**
   * MtaAccessLog createManyAndReturn
   */
  export type MtaAccessLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MtaAccessLog
     */
    select?: MtaAccessLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many MtaAccessLogs.
     */
    data: MtaAccessLogCreateManyInput | MtaAccessLogCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MtaAccessLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MtaAccessLog update
   */
  export type MtaAccessLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MtaAccessLog
     */
    select?: MtaAccessLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MtaAccessLogInclude<ExtArgs> | null
    /**
     * The data needed to update a MtaAccessLog.
     */
    data: XOR<MtaAccessLogUpdateInput, MtaAccessLogUncheckedUpdateInput>
    /**
     * Choose, which MtaAccessLog to update.
     */
    where: MtaAccessLogWhereUniqueInput
  }

  /**
   * MtaAccessLog updateMany
   */
  export type MtaAccessLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MtaAccessLogs.
     */
    data: XOR<MtaAccessLogUpdateManyMutationInput, MtaAccessLogUncheckedUpdateManyInput>
    /**
     * Filter which MtaAccessLogs to update
     */
    where?: MtaAccessLogWhereInput
  }

  /**
   * MtaAccessLog upsert
   */
  export type MtaAccessLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MtaAccessLog
     */
    select?: MtaAccessLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MtaAccessLogInclude<ExtArgs> | null
    /**
     * The filter to search for the MtaAccessLog to update in case it exists.
     */
    where: MtaAccessLogWhereUniqueInput
    /**
     * In case the MtaAccessLog found by the `where` argument doesn't exist, create a new MtaAccessLog with this data.
     */
    create: XOR<MtaAccessLogCreateInput, MtaAccessLogUncheckedCreateInput>
    /**
     * In case the MtaAccessLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MtaAccessLogUpdateInput, MtaAccessLogUncheckedUpdateInput>
  }

  /**
   * MtaAccessLog delete
   */
  export type MtaAccessLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MtaAccessLog
     */
    select?: MtaAccessLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MtaAccessLogInclude<ExtArgs> | null
    /**
     * Filter which MtaAccessLog to delete.
     */
    where: MtaAccessLogWhereUniqueInput
  }

  /**
   * MtaAccessLog deleteMany
   */
  export type MtaAccessLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MtaAccessLogs to delete
     */
    where?: MtaAccessLogWhereInput
  }

  /**
   * MtaAccessLog.user
   */
  export type MtaAccessLog$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * MtaAccessLog without action
   */
  export type MtaAccessLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MtaAccessLog
     */
    select?: MtaAccessLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MtaAccessLogInclude<ExtArgs> | null
  }


  /**
   * Model TicketRatingRequirement
   */

  export type AggregateTicketRatingRequirement = {
    _count: TicketRatingRequirementCountAggregateOutputType | null
    _min: TicketRatingRequirementMinAggregateOutputType | null
    _max: TicketRatingRequirementMaxAggregateOutputType | null
  }

  export type TicketRatingRequirementMinAggregateOutputType = {
    id: string | null
    ticketId: string | null
    raterId: string | null
    targetId: string | null
    completed: boolean | null
    createdAt: Date | null
  }

  export type TicketRatingRequirementMaxAggregateOutputType = {
    id: string | null
    ticketId: string | null
    raterId: string | null
    targetId: string | null
    completed: boolean | null
    createdAt: Date | null
  }

  export type TicketRatingRequirementCountAggregateOutputType = {
    id: number
    ticketId: number
    raterId: number
    targetId: number
    completed: number
    createdAt: number
    _all: number
  }


  export type TicketRatingRequirementMinAggregateInputType = {
    id?: true
    ticketId?: true
    raterId?: true
    targetId?: true
    completed?: true
    createdAt?: true
  }

  export type TicketRatingRequirementMaxAggregateInputType = {
    id?: true
    ticketId?: true
    raterId?: true
    targetId?: true
    completed?: true
    createdAt?: true
  }

  export type TicketRatingRequirementCountAggregateInputType = {
    id?: true
    ticketId?: true
    raterId?: true
    targetId?: true
    completed?: true
    createdAt?: true
    _all?: true
  }

  export type TicketRatingRequirementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TicketRatingRequirement to aggregate.
     */
    where?: TicketRatingRequirementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketRatingRequirements to fetch.
     */
    orderBy?: TicketRatingRequirementOrderByWithRelationInput | TicketRatingRequirementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TicketRatingRequirementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketRatingRequirements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketRatingRequirements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TicketRatingRequirements
    **/
    _count?: true | TicketRatingRequirementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TicketRatingRequirementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TicketRatingRequirementMaxAggregateInputType
  }

  export type GetTicketRatingRequirementAggregateType<T extends TicketRatingRequirementAggregateArgs> = {
        [P in keyof T & keyof AggregateTicketRatingRequirement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTicketRatingRequirement[P]>
      : GetScalarType<T[P], AggregateTicketRatingRequirement[P]>
  }




  export type TicketRatingRequirementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketRatingRequirementWhereInput
    orderBy?: TicketRatingRequirementOrderByWithAggregationInput | TicketRatingRequirementOrderByWithAggregationInput[]
    by: TicketRatingRequirementScalarFieldEnum[] | TicketRatingRequirementScalarFieldEnum
    having?: TicketRatingRequirementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TicketRatingRequirementCountAggregateInputType | true
    _min?: TicketRatingRequirementMinAggregateInputType
    _max?: TicketRatingRequirementMaxAggregateInputType
  }

  export type TicketRatingRequirementGroupByOutputType = {
    id: string
    ticketId: string
    raterId: string
    targetId: string
    completed: boolean
    createdAt: Date
    _count: TicketRatingRequirementCountAggregateOutputType | null
    _min: TicketRatingRequirementMinAggregateOutputType | null
    _max: TicketRatingRequirementMaxAggregateOutputType | null
  }

  type GetTicketRatingRequirementGroupByPayload<T extends TicketRatingRequirementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TicketRatingRequirementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TicketRatingRequirementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TicketRatingRequirementGroupByOutputType[P]>
            : GetScalarType<T[P], TicketRatingRequirementGroupByOutputType[P]>
        }
      >
    >


  export type TicketRatingRequirementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ticketId?: boolean
    raterId?: boolean
    targetId?: boolean
    completed?: boolean
    createdAt?: boolean
    ticket?: boolean | TicketDefaultArgs<ExtArgs>
    rater?: boolean | UserDefaultArgs<ExtArgs>
    target?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ticketRatingRequirement"]>

  export type TicketRatingRequirementSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ticketId?: boolean
    raterId?: boolean
    targetId?: boolean
    completed?: boolean
    createdAt?: boolean
    ticket?: boolean | TicketDefaultArgs<ExtArgs>
    rater?: boolean | UserDefaultArgs<ExtArgs>
    target?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ticketRatingRequirement"]>

  export type TicketRatingRequirementSelectScalar = {
    id?: boolean
    ticketId?: boolean
    raterId?: boolean
    targetId?: boolean
    completed?: boolean
    createdAt?: boolean
  }

  export type TicketRatingRequirementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ticket?: boolean | TicketDefaultArgs<ExtArgs>
    rater?: boolean | UserDefaultArgs<ExtArgs>
    target?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TicketRatingRequirementIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ticket?: boolean | TicketDefaultArgs<ExtArgs>
    rater?: boolean | UserDefaultArgs<ExtArgs>
    target?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TicketRatingRequirementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TicketRatingRequirement"
    objects: {
      ticket: Prisma.$TicketPayload<ExtArgs>
      rater: Prisma.$UserPayload<ExtArgs>
      target: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      ticketId: string
      raterId: string
      targetId: string
      completed: boolean
      createdAt: Date
    }, ExtArgs["result"]["ticketRatingRequirement"]>
    composites: {}
  }

  type TicketRatingRequirementGetPayload<S extends boolean | null | undefined | TicketRatingRequirementDefaultArgs> = $Result.GetResult<Prisma.$TicketRatingRequirementPayload, S>

  type TicketRatingRequirementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TicketRatingRequirementFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TicketRatingRequirementCountAggregateInputType | true
    }

  export interface TicketRatingRequirementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TicketRatingRequirement'], meta: { name: 'TicketRatingRequirement' } }
    /**
     * Find zero or one TicketRatingRequirement that matches the filter.
     * @param {TicketRatingRequirementFindUniqueArgs} args - Arguments to find a TicketRatingRequirement
     * @example
     * // Get one TicketRatingRequirement
     * const ticketRatingRequirement = await prisma.ticketRatingRequirement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TicketRatingRequirementFindUniqueArgs>(args: SelectSubset<T, TicketRatingRequirementFindUniqueArgs<ExtArgs>>): Prisma__TicketRatingRequirementClient<$Result.GetResult<Prisma.$TicketRatingRequirementPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TicketRatingRequirement that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TicketRatingRequirementFindUniqueOrThrowArgs} args - Arguments to find a TicketRatingRequirement
     * @example
     * // Get one TicketRatingRequirement
     * const ticketRatingRequirement = await prisma.ticketRatingRequirement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TicketRatingRequirementFindUniqueOrThrowArgs>(args: SelectSubset<T, TicketRatingRequirementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TicketRatingRequirementClient<$Result.GetResult<Prisma.$TicketRatingRequirementPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TicketRatingRequirement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketRatingRequirementFindFirstArgs} args - Arguments to find a TicketRatingRequirement
     * @example
     * // Get one TicketRatingRequirement
     * const ticketRatingRequirement = await prisma.ticketRatingRequirement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TicketRatingRequirementFindFirstArgs>(args?: SelectSubset<T, TicketRatingRequirementFindFirstArgs<ExtArgs>>): Prisma__TicketRatingRequirementClient<$Result.GetResult<Prisma.$TicketRatingRequirementPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TicketRatingRequirement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketRatingRequirementFindFirstOrThrowArgs} args - Arguments to find a TicketRatingRequirement
     * @example
     * // Get one TicketRatingRequirement
     * const ticketRatingRequirement = await prisma.ticketRatingRequirement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TicketRatingRequirementFindFirstOrThrowArgs>(args?: SelectSubset<T, TicketRatingRequirementFindFirstOrThrowArgs<ExtArgs>>): Prisma__TicketRatingRequirementClient<$Result.GetResult<Prisma.$TicketRatingRequirementPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TicketRatingRequirements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketRatingRequirementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TicketRatingRequirements
     * const ticketRatingRequirements = await prisma.ticketRatingRequirement.findMany()
     * 
     * // Get first 10 TicketRatingRequirements
     * const ticketRatingRequirements = await prisma.ticketRatingRequirement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ticketRatingRequirementWithIdOnly = await prisma.ticketRatingRequirement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TicketRatingRequirementFindManyArgs>(args?: SelectSubset<T, TicketRatingRequirementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketRatingRequirementPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TicketRatingRequirement.
     * @param {TicketRatingRequirementCreateArgs} args - Arguments to create a TicketRatingRequirement.
     * @example
     * // Create one TicketRatingRequirement
     * const TicketRatingRequirement = await prisma.ticketRatingRequirement.create({
     *   data: {
     *     // ... data to create a TicketRatingRequirement
     *   }
     * })
     * 
     */
    create<T extends TicketRatingRequirementCreateArgs>(args: SelectSubset<T, TicketRatingRequirementCreateArgs<ExtArgs>>): Prisma__TicketRatingRequirementClient<$Result.GetResult<Prisma.$TicketRatingRequirementPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TicketRatingRequirements.
     * @param {TicketRatingRequirementCreateManyArgs} args - Arguments to create many TicketRatingRequirements.
     * @example
     * // Create many TicketRatingRequirements
     * const ticketRatingRequirement = await prisma.ticketRatingRequirement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TicketRatingRequirementCreateManyArgs>(args?: SelectSubset<T, TicketRatingRequirementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TicketRatingRequirements and returns the data saved in the database.
     * @param {TicketRatingRequirementCreateManyAndReturnArgs} args - Arguments to create many TicketRatingRequirements.
     * @example
     * // Create many TicketRatingRequirements
     * const ticketRatingRequirement = await prisma.ticketRatingRequirement.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TicketRatingRequirements and only return the `id`
     * const ticketRatingRequirementWithIdOnly = await prisma.ticketRatingRequirement.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TicketRatingRequirementCreateManyAndReturnArgs>(args?: SelectSubset<T, TicketRatingRequirementCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketRatingRequirementPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TicketRatingRequirement.
     * @param {TicketRatingRequirementDeleteArgs} args - Arguments to delete one TicketRatingRequirement.
     * @example
     * // Delete one TicketRatingRequirement
     * const TicketRatingRequirement = await prisma.ticketRatingRequirement.delete({
     *   where: {
     *     // ... filter to delete one TicketRatingRequirement
     *   }
     * })
     * 
     */
    delete<T extends TicketRatingRequirementDeleteArgs>(args: SelectSubset<T, TicketRatingRequirementDeleteArgs<ExtArgs>>): Prisma__TicketRatingRequirementClient<$Result.GetResult<Prisma.$TicketRatingRequirementPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TicketRatingRequirement.
     * @param {TicketRatingRequirementUpdateArgs} args - Arguments to update one TicketRatingRequirement.
     * @example
     * // Update one TicketRatingRequirement
     * const ticketRatingRequirement = await prisma.ticketRatingRequirement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TicketRatingRequirementUpdateArgs>(args: SelectSubset<T, TicketRatingRequirementUpdateArgs<ExtArgs>>): Prisma__TicketRatingRequirementClient<$Result.GetResult<Prisma.$TicketRatingRequirementPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TicketRatingRequirements.
     * @param {TicketRatingRequirementDeleteManyArgs} args - Arguments to filter TicketRatingRequirements to delete.
     * @example
     * // Delete a few TicketRatingRequirements
     * const { count } = await prisma.ticketRatingRequirement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TicketRatingRequirementDeleteManyArgs>(args?: SelectSubset<T, TicketRatingRequirementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TicketRatingRequirements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketRatingRequirementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TicketRatingRequirements
     * const ticketRatingRequirement = await prisma.ticketRatingRequirement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TicketRatingRequirementUpdateManyArgs>(args: SelectSubset<T, TicketRatingRequirementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TicketRatingRequirement.
     * @param {TicketRatingRequirementUpsertArgs} args - Arguments to update or create a TicketRatingRequirement.
     * @example
     * // Update or create a TicketRatingRequirement
     * const ticketRatingRequirement = await prisma.ticketRatingRequirement.upsert({
     *   create: {
     *     // ... data to create a TicketRatingRequirement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TicketRatingRequirement we want to update
     *   }
     * })
     */
    upsert<T extends TicketRatingRequirementUpsertArgs>(args: SelectSubset<T, TicketRatingRequirementUpsertArgs<ExtArgs>>): Prisma__TicketRatingRequirementClient<$Result.GetResult<Prisma.$TicketRatingRequirementPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TicketRatingRequirements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketRatingRequirementCountArgs} args - Arguments to filter TicketRatingRequirements to count.
     * @example
     * // Count the number of TicketRatingRequirements
     * const count = await prisma.ticketRatingRequirement.count({
     *   where: {
     *     // ... the filter for the TicketRatingRequirements we want to count
     *   }
     * })
    **/
    count<T extends TicketRatingRequirementCountArgs>(
      args?: Subset<T, TicketRatingRequirementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TicketRatingRequirementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TicketRatingRequirement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketRatingRequirementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TicketRatingRequirementAggregateArgs>(args: Subset<T, TicketRatingRequirementAggregateArgs>): Prisma.PrismaPromise<GetTicketRatingRequirementAggregateType<T>>

    /**
     * Group by TicketRatingRequirement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketRatingRequirementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TicketRatingRequirementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TicketRatingRequirementGroupByArgs['orderBy'] }
        : { orderBy?: TicketRatingRequirementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TicketRatingRequirementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTicketRatingRequirementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TicketRatingRequirement model
   */
  readonly fields: TicketRatingRequirementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TicketRatingRequirement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TicketRatingRequirementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ticket<T extends TicketDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TicketDefaultArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    rater<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    target<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TicketRatingRequirement model
   */ 
  interface TicketRatingRequirementFieldRefs {
    readonly id: FieldRef<"TicketRatingRequirement", 'String'>
    readonly ticketId: FieldRef<"TicketRatingRequirement", 'String'>
    readonly raterId: FieldRef<"TicketRatingRequirement", 'String'>
    readonly targetId: FieldRef<"TicketRatingRequirement", 'String'>
    readonly completed: FieldRef<"TicketRatingRequirement", 'Boolean'>
    readonly createdAt: FieldRef<"TicketRatingRequirement", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TicketRatingRequirement findUnique
   */
  export type TicketRatingRequirementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketRatingRequirement
     */
    select?: TicketRatingRequirementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketRatingRequirementInclude<ExtArgs> | null
    /**
     * Filter, which TicketRatingRequirement to fetch.
     */
    where: TicketRatingRequirementWhereUniqueInput
  }

  /**
   * TicketRatingRequirement findUniqueOrThrow
   */
  export type TicketRatingRequirementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketRatingRequirement
     */
    select?: TicketRatingRequirementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketRatingRequirementInclude<ExtArgs> | null
    /**
     * Filter, which TicketRatingRequirement to fetch.
     */
    where: TicketRatingRequirementWhereUniqueInput
  }

  /**
   * TicketRatingRequirement findFirst
   */
  export type TicketRatingRequirementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketRatingRequirement
     */
    select?: TicketRatingRequirementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketRatingRequirementInclude<ExtArgs> | null
    /**
     * Filter, which TicketRatingRequirement to fetch.
     */
    where?: TicketRatingRequirementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketRatingRequirements to fetch.
     */
    orderBy?: TicketRatingRequirementOrderByWithRelationInput | TicketRatingRequirementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TicketRatingRequirements.
     */
    cursor?: TicketRatingRequirementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketRatingRequirements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketRatingRequirements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TicketRatingRequirements.
     */
    distinct?: TicketRatingRequirementScalarFieldEnum | TicketRatingRequirementScalarFieldEnum[]
  }

  /**
   * TicketRatingRequirement findFirstOrThrow
   */
  export type TicketRatingRequirementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketRatingRequirement
     */
    select?: TicketRatingRequirementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketRatingRequirementInclude<ExtArgs> | null
    /**
     * Filter, which TicketRatingRequirement to fetch.
     */
    where?: TicketRatingRequirementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketRatingRequirements to fetch.
     */
    orderBy?: TicketRatingRequirementOrderByWithRelationInput | TicketRatingRequirementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TicketRatingRequirements.
     */
    cursor?: TicketRatingRequirementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketRatingRequirements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketRatingRequirements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TicketRatingRequirements.
     */
    distinct?: TicketRatingRequirementScalarFieldEnum | TicketRatingRequirementScalarFieldEnum[]
  }

  /**
   * TicketRatingRequirement findMany
   */
  export type TicketRatingRequirementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketRatingRequirement
     */
    select?: TicketRatingRequirementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketRatingRequirementInclude<ExtArgs> | null
    /**
     * Filter, which TicketRatingRequirements to fetch.
     */
    where?: TicketRatingRequirementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketRatingRequirements to fetch.
     */
    orderBy?: TicketRatingRequirementOrderByWithRelationInput | TicketRatingRequirementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TicketRatingRequirements.
     */
    cursor?: TicketRatingRequirementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketRatingRequirements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketRatingRequirements.
     */
    skip?: number
    distinct?: TicketRatingRequirementScalarFieldEnum | TicketRatingRequirementScalarFieldEnum[]
  }

  /**
   * TicketRatingRequirement create
   */
  export type TicketRatingRequirementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketRatingRequirement
     */
    select?: TicketRatingRequirementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketRatingRequirementInclude<ExtArgs> | null
    /**
     * The data needed to create a TicketRatingRequirement.
     */
    data: XOR<TicketRatingRequirementCreateInput, TicketRatingRequirementUncheckedCreateInput>
  }

  /**
   * TicketRatingRequirement createMany
   */
  export type TicketRatingRequirementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TicketRatingRequirements.
     */
    data: TicketRatingRequirementCreateManyInput | TicketRatingRequirementCreateManyInput[]
  }

  /**
   * TicketRatingRequirement createManyAndReturn
   */
  export type TicketRatingRequirementCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketRatingRequirement
     */
    select?: TicketRatingRequirementSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TicketRatingRequirements.
     */
    data: TicketRatingRequirementCreateManyInput | TicketRatingRequirementCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketRatingRequirementIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TicketRatingRequirement update
   */
  export type TicketRatingRequirementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketRatingRequirement
     */
    select?: TicketRatingRequirementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketRatingRequirementInclude<ExtArgs> | null
    /**
     * The data needed to update a TicketRatingRequirement.
     */
    data: XOR<TicketRatingRequirementUpdateInput, TicketRatingRequirementUncheckedUpdateInput>
    /**
     * Choose, which TicketRatingRequirement to update.
     */
    where: TicketRatingRequirementWhereUniqueInput
  }

  /**
   * TicketRatingRequirement updateMany
   */
  export type TicketRatingRequirementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TicketRatingRequirements.
     */
    data: XOR<TicketRatingRequirementUpdateManyMutationInput, TicketRatingRequirementUncheckedUpdateManyInput>
    /**
     * Filter which TicketRatingRequirements to update
     */
    where?: TicketRatingRequirementWhereInput
  }

  /**
   * TicketRatingRequirement upsert
   */
  export type TicketRatingRequirementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketRatingRequirement
     */
    select?: TicketRatingRequirementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketRatingRequirementInclude<ExtArgs> | null
    /**
     * The filter to search for the TicketRatingRequirement to update in case it exists.
     */
    where: TicketRatingRequirementWhereUniqueInput
    /**
     * In case the TicketRatingRequirement found by the `where` argument doesn't exist, create a new TicketRatingRequirement with this data.
     */
    create: XOR<TicketRatingRequirementCreateInput, TicketRatingRequirementUncheckedCreateInput>
    /**
     * In case the TicketRatingRequirement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TicketRatingRequirementUpdateInput, TicketRatingRequirementUncheckedUpdateInput>
  }

  /**
   * TicketRatingRequirement delete
   */
  export type TicketRatingRequirementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketRatingRequirement
     */
    select?: TicketRatingRequirementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketRatingRequirementInclude<ExtArgs> | null
    /**
     * Filter which TicketRatingRequirement to delete.
     */
    where: TicketRatingRequirementWhereUniqueInput
  }

  /**
   * TicketRatingRequirement deleteMany
   */
  export type TicketRatingRequirementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TicketRatingRequirements to delete
     */
    where?: TicketRatingRequirementWhereInput
  }

  /**
   * TicketRatingRequirement without action
   */
  export type TicketRatingRequirementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketRatingRequirement
     */
    select?: TicketRatingRequirementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketRatingRequirementInclude<ExtArgs> | null
  }


  /**
   * Model PasswordResetToken
   */

  export type AggregatePasswordResetToken = {
    _count: PasswordResetTokenCountAggregateOutputType | null
    _min: PasswordResetTokenMinAggregateOutputType | null
    _max: PasswordResetTokenMaxAggregateOutputType | null
  }

  export type PasswordResetTokenMinAggregateOutputType = {
    id: string | null
    userId: string | null
    code: string | null
    expiresAt: Date | null
    usedAt: Date | null
    createdAt: Date | null
  }

  export type PasswordResetTokenMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    code: string | null
    expiresAt: Date | null
    usedAt: Date | null
    createdAt: Date | null
  }

  export type PasswordResetTokenCountAggregateOutputType = {
    id: number
    userId: number
    code: number
    expiresAt: number
    usedAt: number
    createdAt: number
    _all: number
  }


  export type PasswordResetTokenMinAggregateInputType = {
    id?: true
    userId?: true
    code?: true
    expiresAt?: true
    usedAt?: true
    createdAt?: true
  }

  export type PasswordResetTokenMaxAggregateInputType = {
    id?: true
    userId?: true
    code?: true
    expiresAt?: true
    usedAt?: true
    createdAt?: true
  }

  export type PasswordResetTokenCountAggregateInputType = {
    id?: true
    userId?: true
    code?: true
    expiresAt?: true
    usedAt?: true
    createdAt?: true
    _all?: true
  }

  export type PasswordResetTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PasswordResetToken to aggregate.
     */
    where?: PasswordResetTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordResetTokens to fetch.
     */
    orderBy?: PasswordResetTokenOrderByWithRelationInput | PasswordResetTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PasswordResetTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordResetTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordResetTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PasswordResetTokens
    **/
    _count?: true | PasswordResetTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PasswordResetTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PasswordResetTokenMaxAggregateInputType
  }

  export type GetPasswordResetTokenAggregateType<T extends PasswordResetTokenAggregateArgs> = {
        [P in keyof T & keyof AggregatePasswordResetToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePasswordResetToken[P]>
      : GetScalarType<T[P], AggregatePasswordResetToken[P]>
  }




  export type PasswordResetTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PasswordResetTokenWhereInput
    orderBy?: PasswordResetTokenOrderByWithAggregationInput | PasswordResetTokenOrderByWithAggregationInput[]
    by: PasswordResetTokenScalarFieldEnum[] | PasswordResetTokenScalarFieldEnum
    having?: PasswordResetTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PasswordResetTokenCountAggregateInputType | true
    _min?: PasswordResetTokenMinAggregateInputType
    _max?: PasswordResetTokenMaxAggregateInputType
  }

  export type PasswordResetTokenGroupByOutputType = {
    id: string
    userId: string
    code: string
    expiresAt: Date
    usedAt: Date | null
    createdAt: Date
    _count: PasswordResetTokenCountAggregateOutputType | null
    _min: PasswordResetTokenMinAggregateOutputType | null
    _max: PasswordResetTokenMaxAggregateOutputType | null
  }

  type GetPasswordResetTokenGroupByPayload<T extends PasswordResetTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PasswordResetTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PasswordResetTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PasswordResetTokenGroupByOutputType[P]>
            : GetScalarType<T[P], PasswordResetTokenGroupByOutputType[P]>
        }
      >
    >


  export type PasswordResetTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    code?: boolean
    expiresAt?: boolean
    usedAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["passwordResetToken"]>

  export type PasswordResetTokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    code?: boolean
    expiresAt?: boolean
    usedAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["passwordResetToken"]>

  export type PasswordResetTokenSelectScalar = {
    id?: boolean
    userId?: boolean
    code?: boolean
    expiresAt?: boolean
    usedAt?: boolean
    createdAt?: boolean
  }

  export type PasswordResetTokenInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PasswordResetTokenIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PasswordResetTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PasswordResetToken"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      code: string
      expiresAt: Date
      usedAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["passwordResetToken"]>
    composites: {}
  }

  type PasswordResetTokenGetPayload<S extends boolean | null | undefined | PasswordResetTokenDefaultArgs> = $Result.GetResult<Prisma.$PasswordResetTokenPayload, S>

  type PasswordResetTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PasswordResetTokenFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PasswordResetTokenCountAggregateInputType | true
    }

  export interface PasswordResetTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PasswordResetToken'], meta: { name: 'PasswordResetToken' } }
    /**
     * Find zero or one PasswordResetToken that matches the filter.
     * @param {PasswordResetTokenFindUniqueArgs} args - Arguments to find a PasswordResetToken
     * @example
     * // Get one PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PasswordResetTokenFindUniqueArgs>(args: SelectSubset<T, PasswordResetTokenFindUniqueArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PasswordResetToken that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PasswordResetTokenFindUniqueOrThrowArgs} args - Arguments to find a PasswordResetToken
     * @example
     * // Get one PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PasswordResetTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, PasswordResetTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PasswordResetToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenFindFirstArgs} args - Arguments to find a PasswordResetToken
     * @example
     * // Get one PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PasswordResetTokenFindFirstArgs>(args?: SelectSubset<T, PasswordResetTokenFindFirstArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PasswordResetToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenFindFirstOrThrowArgs} args - Arguments to find a PasswordResetToken
     * @example
     * // Get one PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PasswordResetTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, PasswordResetTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PasswordResetTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PasswordResetTokens
     * const passwordResetTokens = await prisma.passwordResetToken.findMany()
     * 
     * // Get first 10 PasswordResetTokens
     * const passwordResetTokens = await prisma.passwordResetToken.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const passwordResetTokenWithIdOnly = await prisma.passwordResetToken.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PasswordResetTokenFindManyArgs>(args?: SelectSubset<T, PasswordResetTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PasswordResetToken.
     * @param {PasswordResetTokenCreateArgs} args - Arguments to create a PasswordResetToken.
     * @example
     * // Create one PasswordResetToken
     * const PasswordResetToken = await prisma.passwordResetToken.create({
     *   data: {
     *     // ... data to create a PasswordResetToken
     *   }
     * })
     * 
     */
    create<T extends PasswordResetTokenCreateArgs>(args: SelectSubset<T, PasswordResetTokenCreateArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PasswordResetTokens.
     * @param {PasswordResetTokenCreateManyArgs} args - Arguments to create many PasswordResetTokens.
     * @example
     * // Create many PasswordResetTokens
     * const passwordResetToken = await prisma.passwordResetToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PasswordResetTokenCreateManyArgs>(args?: SelectSubset<T, PasswordResetTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PasswordResetTokens and returns the data saved in the database.
     * @param {PasswordResetTokenCreateManyAndReturnArgs} args - Arguments to create many PasswordResetTokens.
     * @example
     * // Create many PasswordResetTokens
     * const passwordResetToken = await prisma.passwordResetToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PasswordResetTokens and only return the `id`
     * const passwordResetTokenWithIdOnly = await prisma.passwordResetToken.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PasswordResetTokenCreateManyAndReturnArgs>(args?: SelectSubset<T, PasswordResetTokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PasswordResetToken.
     * @param {PasswordResetTokenDeleteArgs} args - Arguments to delete one PasswordResetToken.
     * @example
     * // Delete one PasswordResetToken
     * const PasswordResetToken = await prisma.passwordResetToken.delete({
     *   where: {
     *     // ... filter to delete one PasswordResetToken
     *   }
     * })
     * 
     */
    delete<T extends PasswordResetTokenDeleteArgs>(args: SelectSubset<T, PasswordResetTokenDeleteArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PasswordResetToken.
     * @param {PasswordResetTokenUpdateArgs} args - Arguments to update one PasswordResetToken.
     * @example
     * // Update one PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PasswordResetTokenUpdateArgs>(args: SelectSubset<T, PasswordResetTokenUpdateArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PasswordResetTokens.
     * @param {PasswordResetTokenDeleteManyArgs} args - Arguments to filter PasswordResetTokens to delete.
     * @example
     * // Delete a few PasswordResetTokens
     * const { count } = await prisma.passwordResetToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PasswordResetTokenDeleteManyArgs>(args?: SelectSubset<T, PasswordResetTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PasswordResetTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PasswordResetTokens
     * const passwordResetToken = await prisma.passwordResetToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PasswordResetTokenUpdateManyArgs>(args: SelectSubset<T, PasswordResetTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PasswordResetToken.
     * @param {PasswordResetTokenUpsertArgs} args - Arguments to update or create a PasswordResetToken.
     * @example
     * // Update or create a PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.upsert({
     *   create: {
     *     // ... data to create a PasswordResetToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PasswordResetToken we want to update
     *   }
     * })
     */
    upsert<T extends PasswordResetTokenUpsertArgs>(args: SelectSubset<T, PasswordResetTokenUpsertArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PasswordResetTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenCountArgs} args - Arguments to filter PasswordResetTokens to count.
     * @example
     * // Count the number of PasswordResetTokens
     * const count = await prisma.passwordResetToken.count({
     *   where: {
     *     // ... the filter for the PasswordResetTokens we want to count
     *   }
     * })
    **/
    count<T extends PasswordResetTokenCountArgs>(
      args?: Subset<T, PasswordResetTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PasswordResetTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PasswordResetToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PasswordResetTokenAggregateArgs>(args: Subset<T, PasswordResetTokenAggregateArgs>): Prisma.PrismaPromise<GetPasswordResetTokenAggregateType<T>>

    /**
     * Group by PasswordResetToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PasswordResetTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PasswordResetTokenGroupByArgs['orderBy'] }
        : { orderBy?: PasswordResetTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PasswordResetTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPasswordResetTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PasswordResetToken model
   */
  readonly fields: PasswordResetTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PasswordResetToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PasswordResetTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PasswordResetToken model
   */ 
  interface PasswordResetTokenFieldRefs {
    readonly id: FieldRef<"PasswordResetToken", 'String'>
    readonly userId: FieldRef<"PasswordResetToken", 'String'>
    readonly code: FieldRef<"PasswordResetToken", 'String'>
    readonly expiresAt: FieldRef<"PasswordResetToken", 'DateTime'>
    readonly usedAt: FieldRef<"PasswordResetToken", 'DateTime'>
    readonly createdAt: FieldRef<"PasswordResetToken", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PasswordResetToken findUnique
   */
  export type PasswordResetTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * Filter, which PasswordResetToken to fetch.
     */
    where: PasswordResetTokenWhereUniqueInput
  }

  /**
   * PasswordResetToken findUniqueOrThrow
   */
  export type PasswordResetTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * Filter, which PasswordResetToken to fetch.
     */
    where: PasswordResetTokenWhereUniqueInput
  }

  /**
   * PasswordResetToken findFirst
   */
  export type PasswordResetTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * Filter, which PasswordResetToken to fetch.
     */
    where?: PasswordResetTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordResetTokens to fetch.
     */
    orderBy?: PasswordResetTokenOrderByWithRelationInput | PasswordResetTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PasswordResetTokens.
     */
    cursor?: PasswordResetTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordResetTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordResetTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PasswordResetTokens.
     */
    distinct?: PasswordResetTokenScalarFieldEnum | PasswordResetTokenScalarFieldEnum[]
  }

  /**
   * PasswordResetToken findFirstOrThrow
   */
  export type PasswordResetTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * Filter, which PasswordResetToken to fetch.
     */
    where?: PasswordResetTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordResetTokens to fetch.
     */
    orderBy?: PasswordResetTokenOrderByWithRelationInput | PasswordResetTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PasswordResetTokens.
     */
    cursor?: PasswordResetTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordResetTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordResetTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PasswordResetTokens.
     */
    distinct?: PasswordResetTokenScalarFieldEnum | PasswordResetTokenScalarFieldEnum[]
  }

  /**
   * PasswordResetToken findMany
   */
  export type PasswordResetTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * Filter, which PasswordResetTokens to fetch.
     */
    where?: PasswordResetTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordResetTokens to fetch.
     */
    orderBy?: PasswordResetTokenOrderByWithRelationInput | PasswordResetTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PasswordResetTokens.
     */
    cursor?: PasswordResetTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordResetTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordResetTokens.
     */
    skip?: number
    distinct?: PasswordResetTokenScalarFieldEnum | PasswordResetTokenScalarFieldEnum[]
  }

  /**
   * PasswordResetToken create
   */
  export type PasswordResetTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * The data needed to create a PasswordResetToken.
     */
    data: XOR<PasswordResetTokenCreateInput, PasswordResetTokenUncheckedCreateInput>
  }

  /**
   * PasswordResetToken createMany
   */
  export type PasswordResetTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PasswordResetTokens.
     */
    data: PasswordResetTokenCreateManyInput | PasswordResetTokenCreateManyInput[]
  }

  /**
   * PasswordResetToken createManyAndReturn
   */
  export type PasswordResetTokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PasswordResetTokens.
     */
    data: PasswordResetTokenCreateManyInput | PasswordResetTokenCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PasswordResetToken update
   */
  export type PasswordResetTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * The data needed to update a PasswordResetToken.
     */
    data: XOR<PasswordResetTokenUpdateInput, PasswordResetTokenUncheckedUpdateInput>
    /**
     * Choose, which PasswordResetToken to update.
     */
    where: PasswordResetTokenWhereUniqueInput
  }

  /**
   * PasswordResetToken updateMany
   */
  export type PasswordResetTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PasswordResetTokens.
     */
    data: XOR<PasswordResetTokenUpdateManyMutationInput, PasswordResetTokenUncheckedUpdateManyInput>
    /**
     * Filter which PasswordResetTokens to update
     */
    where?: PasswordResetTokenWhereInput
  }

  /**
   * PasswordResetToken upsert
   */
  export type PasswordResetTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * The filter to search for the PasswordResetToken to update in case it exists.
     */
    where: PasswordResetTokenWhereUniqueInput
    /**
     * In case the PasswordResetToken found by the `where` argument doesn't exist, create a new PasswordResetToken with this data.
     */
    create: XOR<PasswordResetTokenCreateInput, PasswordResetTokenUncheckedCreateInput>
    /**
     * In case the PasswordResetToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PasswordResetTokenUpdateInput, PasswordResetTokenUncheckedUpdateInput>
  }

  /**
   * PasswordResetToken delete
   */
  export type PasswordResetTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * Filter which PasswordResetToken to delete.
     */
    where: PasswordResetTokenWhereUniqueInput
  }

  /**
   * PasswordResetToken deleteMany
   */
  export type PasswordResetTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PasswordResetTokens to delete
     */
    where?: PasswordResetTokenWhereInput
  }

  /**
   * PasswordResetToken without action
   */
  export type PasswordResetTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const ProductScalarFieldEnum: {
    id: 'id',
    sku: 'sku',
    name: 'name',
    description: 'description',
    priceCents: 'priceCents',
    currency: 'currency',
    durationDays: 'durationDays',
    grantPoints: 'grantPoints',
    grantVipRole: 'grantVipRole',
    mtaActions: 'mtaActions',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProductScalarFieldEnum = (typeof ProductScalarFieldEnum)[keyof typeof ProductScalarFieldEnum]


  export const CouponScalarFieldEnum: {
    id: 'id',
    code: 'code',
    percentOff: 'percentOff',
    amountOffCents: 'amountOffCents',
    maxUses: 'maxUses',
    uses: 'uses',
    expiresAt: 'expiresAt',
    isActive: 'isActive',
    createdAt: 'createdAt'
  };

  export type CouponScalarFieldEnum = (typeof CouponScalarFieldEnum)[keyof typeof CouponScalarFieldEnum]


  export const PurchaseItemScalarFieldEnum: {
    id: 'id',
    purchaseId: 'purchaseId',
    productId: 'productId',
    sku: 'sku',
    name: 'name',
    priceCents: 'priceCents',
    durationDays: 'durationDays',
    grantPoints: 'grantPoints',
    grantVipRole: 'grantVipRole',
    mtaActions: 'mtaActions'
  };

  export type PurchaseItemScalarFieldEnum = (typeof PurchaseItemScalarFieldEnum)[keyof typeof PurchaseItemScalarFieldEnum]


  export const EntitlementScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    roleName: 'roleName',
    expiresAt: 'expiresAt',
    source: 'source',
    createdAt: 'createdAt'
  };

  export type EntitlementScalarFieldEnum = (typeof EntitlementScalarFieldEnum)[keyof typeof EntitlementScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    message: 'message',
    href: 'href',
    read: 'read',
    createdAt: 'createdAt'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const StaffShiftScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    openedAt: 'openedAt',
    closedAt: 'closedAt',
    seconds: 'seconds',
    createdAt: 'createdAt'
  };

  export type StaffShiftScalarFieldEnum = (typeof StaffShiftScalarFieldEnum)[keyof typeof StaffShiftScalarFieldEnum]


  export const StaffWeeklyRewardScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    position: 'position',
    weekKey: 'weekKey',
    createdAt: 'createdAt'
  };

  export type StaffWeeklyRewardScalarFieldEnum = (typeof StaffWeeklyRewardScalarFieldEnum)[keyof typeof StaffWeeklyRewardScalarFieldEnum]


  export const AdminCaseScalarFieldEnum: {
    id: 'id',
    targetUserId: 'targetUserId',
    staffUserId: 'staffUserId',
    type: 'type',
    reason: 'reason',
    expiresAt: 'expiresAt',
    active: 'active',
    createdAt: 'createdAt'
  };

  export type AdminCaseScalarFieldEnum = (typeof AdminCaseScalarFieldEnum)[keyof typeof AdminCaseScalarFieldEnum]


  export const UserReputationScalarFieldEnum: {
    userId: 'userId',
    score: 'score',
    updatedAt: 'updatedAt'
  };

  export type UserReputationScalarFieldEnum = (typeof UserReputationScalarFieldEnum)[keyof typeof UserReputationScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    username: 'username',
    passwordHash: 'passwordHash',
    emailVerifiedAt: 'emailVerifiedAt',
    emailVerifyToken: 'emailVerifyToken',
    emailVerifyExpiresAt: 'emailVerifyExpiresAt',
    phone: 'phone',
    recoveryEmail: 'recoveryEmail',
    googleId: 'googleId',
    discordId: 'discordId',
    discordUsername: 'discordUsername',
    avatarKey: 'avatarKey',
    role: 'role',
    isDeleted: 'isDeleted',
    bannedUntil: 'bannedUntil',
    whitelistStatus: 'whitelistStatus',
    points: 'points',
    lastSeenAt: 'lastSeenAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    avatarUrl: 'avatarUrl'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const ForumCategoryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    order: 'order',
    createdAt: 'createdAt'
  };

  export type ForumCategoryScalarFieldEnum = (typeof ForumCategoryScalarFieldEnum)[keyof typeof ForumCategoryScalarFieldEnum]


  export const ForumBoardScalarFieldEnum: {
    id: 'id',
    categoryId: 'categoryId',
    name: 'name',
    description: 'description',
    order: 'order',
    requireWhitelist: 'requireWhitelist',
    pointsOnTopic: 'pointsOnTopic',
    pointsOnReply: 'pointsOnReply',
    allowReplies: 'allowReplies',
    createdAt: 'createdAt'
  };

  export type ForumBoardScalarFieldEnum = (typeof ForumBoardScalarFieldEnum)[keyof typeof ForumBoardScalarFieldEnum]


  export const TopicScalarFieldEnum: {
    id: 'id',
    boardId: 'boardId',
    authorId: 'authorId',
    title: 'title',
    status: 'status',
    pinned: 'pinned',
    isDeleted: 'isDeleted',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    lastPostAt: 'lastPostAt'
  };

  export type TopicScalarFieldEnum = (typeof TopicScalarFieldEnum)[keyof typeof TopicScalarFieldEnum]


  export const PostScalarFieldEnum: {
    id: 'id',
    topicId: 'topicId',
    authorId: 'authorId',
    content: 'content',
    isDeleted: 'isDeleted',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PostScalarFieldEnum = (typeof PostScalarFieldEnum)[keyof typeof PostScalarFieldEnum]


  export const PostAttachmentScalarFieldEnum: {
    id: 'id',
    postId: 'postId',
    url: 'url',
    mime: 'mime',
    size: 'size',
    createdAt: 'createdAt'
  };

  export type PostAttachmentScalarFieldEnum = (typeof PostAttachmentScalarFieldEnum)[keyof typeof PostAttachmentScalarFieldEnum]


  export const TicketCategoryScalarFieldEnum: {
    id: 'id',
    slug: 'slug',
    name: 'name',
    description: 'description',
    order: 'order',
    createdAt: 'createdAt'
  };

  export type TicketCategoryScalarFieldEnum = (typeof TicketCategoryScalarFieldEnum)[keyof typeof TicketCategoryScalarFieldEnum]


  export const TicketScalarFieldEnum: {
    id: 'id',
    categoryId: 'categoryId',
    authorId: 'authorId',
    title: 'title',
    status: 'status',
    priority: 'priority',
    assignedToId: 'assignedToId',
    isDeleted: 'isDeleted',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    closedAt: 'closedAt',
    closedById: 'closedById'
  };

  export type TicketScalarFieldEnum = (typeof TicketScalarFieldEnum)[keyof typeof TicketScalarFieldEnum]


  export const TicketMessageScalarFieldEnum: {
    id: 'id',
    ticketId: 'ticketId',
    authorId: 'authorId',
    content: 'content',
    isDeleted: 'isDeleted',
    createdAt: 'createdAt'
  };

  export type TicketMessageScalarFieldEnum = (typeof TicketMessageScalarFieldEnum)[keyof typeof TicketMessageScalarFieldEnum]


  export const PurchaseScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    provider: 'provider',
    externalId: 'externalId',
    status: 'status',
    amountCents: 'amountCents',
    currency: 'currency',
    meta: 'meta',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PurchaseScalarFieldEnum = (typeof PurchaseScalarFieldEnum)[keyof typeof PurchaseScalarFieldEnum]


  export const AuditLogScalarFieldEnum: {
    id: 'id',
    actorId: 'actorId',
    action: 'action',
    entityType: 'entityType',
    entityId: 'entityId',
    ip: 'ip',
    userAgent: 'userAgent',
    meta: 'meta',
    createdAt: 'createdAt'
  };

  export type AuditLogScalarFieldEnum = (typeof AuditLogScalarFieldEnum)[keyof typeof AuditLogScalarFieldEnum]


  export const MpWebhookEventScalarFieldEnum: {
    id: 'id',
    eventType: 'eventType',
    externalId: 'externalId',
    payload: 'payload',
    processed: 'processed',
    createdAt: 'createdAt'
  };

  export type MpWebhookEventScalarFieldEnum = (typeof MpWebhookEventScalarFieldEnum)[keyof typeof MpWebhookEventScalarFieldEnum]


  export const RoleScalarFieldEnum: {
    id: 'id',
    name: 'name',
    rank: 'rank',
    category: 'category',
    description: 'description',
    createdAt: 'createdAt',
    colorHex: 'colorHex'
  };

  export type RoleScalarFieldEnum = (typeof RoleScalarFieldEnum)[keyof typeof RoleScalarFieldEnum]


  export const PermissionScalarFieldEnum: {
    id: 'id',
    key: 'key',
    description: 'description',
    createdAt: 'createdAt'
  };

  export type PermissionScalarFieldEnum = (typeof PermissionScalarFieldEnum)[keyof typeof PermissionScalarFieldEnum]


  export const RolePermissionScalarFieldEnum: {
    roleId: 'roleId',
    permissionId: 'permissionId'
  };

  export type RolePermissionScalarFieldEnum = (typeof RolePermissionScalarFieldEnum)[keyof typeof RolePermissionScalarFieldEnum]


  export const UserRoleScalarFieldEnum: {
    userId: 'userId',
    roleId: 'roleId'
  };

  export type UserRoleScalarFieldEnum = (typeof UserRoleScalarFieldEnum)[keyof typeof UserRoleScalarFieldEnum]


  export const WhitelistConfigScalarFieldEnum: {
    id: 'id',
    enabled: 'enabled',
    pausedUntil: 'pausedUntil',
    successTitle: 'successTitle',
    successBody: 'successBody',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WhitelistConfigScalarFieldEnum = (typeof WhitelistConfigScalarFieldEnum)[keyof typeof WhitelistConfigScalarFieldEnum]


  export const WhitelistQuestionScalarFieldEnum: {
    id: 'id',
    prompt: 'prompt',
    required: 'required',
    order: 'order',
    createdAt: 'createdAt'
  };

  export type WhitelistQuestionScalarFieldEnum = (typeof WhitelistQuestionScalarFieldEnum)[keyof typeof WhitelistQuestionScalarFieldEnum]


  export const WhitelistApplicationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    status: 'status',
    reviewerId: 'reviewerId',
    rejectReason: 'rejectReason',
    createdAt: 'createdAt',
    reviewedAt: 'reviewedAt'
  };

  export type WhitelistApplicationScalarFieldEnum = (typeof WhitelistApplicationScalarFieldEnum)[keyof typeof WhitelistApplicationScalarFieldEnum]


  export const WhitelistAnswerScalarFieldEnum: {
    id: 'id',
    applicationId: 'applicationId',
    questionId: 'questionId',
    value: 'value',
    createdAt: 'createdAt'
  };

  export type WhitelistAnswerScalarFieldEnum = (typeof WhitelistAnswerScalarFieldEnum)[keyof typeof WhitelistAnswerScalarFieldEnum]


  export const BadgeScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    icon: 'icon',
    createdAt: 'createdAt'
  };

  export type BadgeScalarFieldEnum = (typeof BadgeScalarFieldEnum)[keyof typeof BadgeScalarFieldEnum]


  export const UserBadgeScalarFieldEnum: {
    userId: 'userId',
    badgeId: 'badgeId',
    createdAt: 'createdAt'
  };

  export type UserBadgeScalarFieldEnum = (typeof UserBadgeScalarFieldEnum)[keyof typeof UserBadgeScalarFieldEnum]


  export const ConversationScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ConversationScalarFieldEnum = (typeof ConversationScalarFieldEnum)[keyof typeof ConversationScalarFieldEnum]


  export const ConversationParticipantScalarFieldEnum: {
    conversationId: 'conversationId',
    userId: 'userId',
    createdAt: 'createdAt'
  };

  export type ConversationParticipantScalarFieldEnum = (typeof ConversationParticipantScalarFieldEnum)[keyof typeof ConversationParticipantScalarFieldEnum]


  export const DirectMessageScalarFieldEnum: {
    id: 'id',
    conversationId: 'conversationId',
    senderId: 'senderId',
    receiverId: 'receiverId',
    content: 'content',
    kind: 'kind',
    isDeleted: 'isDeleted',
    createdAt: 'createdAt'
  };

  export type DirectMessageScalarFieldEnum = (typeof DirectMessageScalarFieldEnum)[keyof typeof DirectMessageScalarFieldEnum]


  export const BankInfoScalarFieldEnum: {
    id: 'id',
    label: 'label',
    holderName: 'holderName',
    pixKey: 'pixKey',
    bankName: 'bankName',
    agency: 'agency',
    accountNumber: 'accountNumber',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BankInfoScalarFieldEnum = (typeof BankInfoScalarFieldEnum)[keyof typeof BankInfoScalarFieldEnum]


  export const SiteSettingScalarFieldEnum: {
    key: 'key',
    value: 'value',
    updatedAt: 'updatedAt'
  };

  export type SiteSettingScalarFieldEnum = (typeof SiteSettingScalarFieldEnum)[keyof typeof SiteSettingScalarFieldEnum]


  export const GameAccountScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    mtaSerial: 'mtaSerial',
    mtaAccount: 'mtaAccount',
    locked: 'locked',
    changedAfterApproved: 'changedAfterApproved',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type GameAccountScalarFieldEnum = (typeof GameAccountScalarFieldEnum)[keyof typeof GameAccountScalarFieldEnum]


  export const TicketParticipantScalarFieldEnum: {
    ticketId: 'ticketId',
    userId: 'userId',
    addedById: 'addedById',
    createdAt: 'createdAt'
  };

  export type TicketParticipantScalarFieldEnum = (typeof TicketParticipantScalarFieldEnum)[keyof typeof TicketParticipantScalarFieldEnum]


  export const TicketRatingScalarFieldEnum: {
    id: 'id',
    ticketId: 'ticketId',
    raterUserId: 'raterUserId',
    targetUserId: 'targetUserId',
    stars: 'stars',
    feedback: 'feedback',
    createdAt: 'createdAt'
  };

  export type TicketRatingScalarFieldEnum = (typeof TicketRatingScalarFieldEnum)[keyof typeof TicketRatingScalarFieldEnum]


  export const MtaAccessLogScalarFieldEnum: {
    id: 'id',
    serial: 'serial',
    userId: 'userId',
    allowed: 'allowed',
    reason: 'reason',
    ip: 'ip',
    createdAt: 'createdAt'
  };

  export type MtaAccessLogScalarFieldEnum = (typeof MtaAccessLogScalarFieldEnum)[keyof typeof MtaAccessLogScalarFieldEnum]


  export const TicketRatingRequirementScalarFieldEnum: {
    id: 'id',
    ticketId: 'ticketId',
    raterId: 'raterId',
    targetId: 'targetId',
    completed: 'completed',
    createdAt: 'createdAt'
  };

  export type TicketRatingRequirementScalarFieldEnum = (typeof TicketRatingRequirementScalarFieldEnum)[keyof typeof TicketRatingRequirementScalarFieldEnum]


  export const PasswordResetTokenScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    code: 'code',
    expiresAt: 'expiresAt',
    usedAt: 'usedAt',
    createdAt: 'createdAt'
  };

  export type PasswordResetTokenScalarFieldEnum = (typeof PasswordResetTokenScalarFieldEnum)[keyof typeof PasswordResetTokenScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type ProductWhereInput = {
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    id?: StringFilter<"Product"> | string
    sku?: StringFilter<"Product"> | string
    name?: StringFilter<"Product"> | string
    description?: StringNullableFilter<"Product"> | string | null
    priceCents?: IntFilter<"Product"> | number
    currency?: StringFilter<"Product"> | string
    durationDays?: IntNullableFilter<"Product"> | number | null
    grantPoints?: IntFilter<"Product"> | number
    grantVipRole?: StringNullableFilter<"Product"> | string | null
    mtaActions?: StringNullableFilter<"Product"> | string | null
    isActive?: BoolFilter<"Product"> | boolean
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
    purchaseItems?: PurchaseItemListRelationFilter
  }

  export type ProductOrderByWithRelationInput = {
    id?: SortOrder
    sku?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    priceCents?: SortOrder
    currency?: SortOrder
    durationDays?: SortOrderInput | SortOrder
    grantPoints?: SortOrder
    grantVipRole?: SortOrderInput | SortOrder
    mtaActions?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    purchaseItems?: PurchaseItemOrderByRelationAggregateInput
  }

  export type ProductWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    sku?: string
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    name?: StringFilter<"Product"> | string
    description?: StringNullableFilter<"Product"> | string | null
    priceCents?: IntFilter<"Product"> | number
    currency?: StringFilter<"Product"> | string
    durationDays?: IntNullableFilter<"Product"> | number | null
    grantPoints?: IntFilter<"Product"> | number
    grantVipRole?: StringNullableFilter<"Product"> | string | null
    mtaActions?: StringNullableFilter<"Product"> | string | null
    isActive?: BoolFilter<"Product"> | boolean
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
    purchaseItems?: PurchaseItemListRelationFilter
  }, "id" | "sku">

  export type ProductOrderByWithAggregationInput = {
    id?: SortOrder
    sku?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    priceCents?: SortOrder
    currency?: SortOrder
    durationDays?: SortOrderInput | SortOrder
    grantPoints?: SortOrder
    grantVipRole?: SortOrderInput | SortOrder
    mtaActions?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProductCountOrderByAggregateInput
    _avg?: ProductAvgOrderByAggregateInput
    _max?: ProductMaxOrderByAggregateInput
    _min?: ProductMinOrderByAggregateInput
    _sum?: ProductSumOrderByAggregateInput
  }

  export type ProductScalarWhereWithAggregatesInput = {
    AND?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    OR?: ProductScalarWhereWithAggregatesInput[]
    NOT?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Product"> | string
    sku?: StringWithAggregatesFilter<"Product"> | string
    name?: StringWithAggregatesFilter<"Product"> | string
    description?: StringNullableWithAggregatesFilter<"Product"> | string | null
    priceCents?: IntWithAggregatesFilter<"Product"> | number
    currency?: StringWithAggregatesFilter<"Product"> | string
    durationDays?: IntNullableWithAggregatesFilter<"Product"> | number | null
    grantPoints?: IntWithAggregatesFilter<"Product"> | number
    grantVipRole?: StringNullableWithAggregatesFilter<"Product"> | string | null
    mtaActions?: StringNullableWithAggregatesFilter<"Product"> | string | null
    isActive?: BoolWithAggregatesFilter<"Product"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Product"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Product"> | Date | string
  }

  export type CouponWhereInput = {
    AND?: CouponWhereInput | CouponWhereInput[]
    OR?: CouponWhereInput[]
    NOT?: CouponWhereInput | CouponWhereInput[]
    id?: StringFilter<"Coupon"> | string
    code?: StringFilter<"Coupon"> | string
    percentOff?: IntNullableFilter<"Coupon"> | number | null
    amountOffCents?: IntNullableFilter<"Coupon"> | number | null
    maxUses?: IntNullableFilter<"Coupon"> | number | null
    uses?: IntFilter<"Coupon"> | number
    expiresAt?: DateTimeNullableFilter<"Coupon"> | Date | string | null
    isActive?: BoolFilter<"Coupon"> | boolean
    createdAt?: DateTimeFilter<"Coupon"> | Date | string
  }

  export type CouponOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    percentOff?: SortOrderInput | SortOrder
    amountOffCents?: SortOrderInput | SortOrder
    maxUses?: SortOrderInput | SortOrder
    uses?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type CouponWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: CouponWhereInput | CouponWhereInput[]
    OR?: CouponWhereInput[]
    NOT?: CouponWhereInput | CouponWhereInput[]
    percentOff?: IntNullableFilter<"Coupon"> | number | null
    amountOffCents?: IntNullableFilter<"Coupon"> | number | null
    maxUses?: IntNullableFilter<"Coupon"> | number | null
    uses?: IntFilter<"Coupon"> | number
    expiresAt?: DateTimeNullableFilter<"Coupon"> | Date | string | null
    isActive?: BoolFilter<"Coupon"> | boolean
    createdAt?: DateTimeFilter<"Coupon"> | Date | string
  }, "id" | "code">

  export type CouponOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    percentOff?: SortOrderInput | SortOrder
    amountOffCents?: SortOrderInput | SortOrder
    maxUses?: SortOrderInput | SortOrder
    uses?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    _count?: CouponCountOrderByAggregateInput
    _avg?: CouponAvgOrderByAggregateInput
    _max?: CouponMaxOrderByAggregateInput
    _min?: CouponMinOrderByAggregateInput
    _sum?: CouponSumOrderByAggregateInput
  }

  export type CouponScalarWhereWithAggregatesInput = {
    AND?: CouponScalarWhereWithAggregatesInput | CouponScalarWhereWithAggregatesInput[]
    OR?: CouponScalarWhereWithAggregatesInput[]
    NOT?: CouponScalarWhereWithAggregatesInput | CouponScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Coupon"> | string
    code?: StringWithAggregatesFilter<"Coupon"> | string
    percentOff?: IntNullableWithAggregatesFilter<"Coupon"> | number | null
    amountOffCents?: IntNullableWithAggregatesFilter<"Coupon"> | number | null
    maxUses?: IntNullableWithAggregatesFilter<"Coupon"> | number | null
    uses?: IntWithAggregatesFilter<"Coupon"> | number
    expiresAt?: DateTimeNullableWithAggregatesFilter<"Coupon"> | Date | string | null
    isActive?: BoolWithAggregatesFilter<"Coupon"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Coupon"> | Date | string
  }

  export type PurchaseItemWhereInput = {
    AND?: PurchaseItemWhereInput | PurchaseItemWhereInput[]
    OR?: PurchaseItemWhereInput[]
    NOT?: PurchaseItemWhereInput | PurchaseItemWhereInput[]
    id?: StringFilter<"PurchaseItem"> | string
    purchaseId?: StringFilter<"PurchaseItem"> | string
    productId?: StringFilter<"PurchaseItem"> | string
    sku?: StringFilter<"PurchaseItem"> | string
    name?: StringFilter<"PurchaseItem"> | string
    priceCents?: IntFilter<"PurchaseItem"> | number
    durationDays?: IntNullableFilter<"PurchaseItem"> | number | null
    grantPoints?: IntFilter<"PurchaseItem"> | number
    grantVipRole?: StringNullableFilter<"PurchaseItem"> | string | null
    mtaActions?: StringNullableFilter<"PurchaseItem"> | string | null
    purchase?: XOR<PurchaseRelationFilter, PurchaseWhereInput>
    product?: XOR<ProductRelationFilter, ProductWhereInput>
  }

  export type PurchaseItemOrderByWithRelationInput = {
    id?: SortOrder
    purchaseId?: SortOrder
    productId?: SortOrder
    sku?: SortOrder
    name?: SortOrder
    priceCents?: SortOrder
    durationDays?: SortOrderInput | SortOrder
    grantPoints?: SortOrder
    grantVipRole?: SortOrderInput | SortOrder
    mtaActions?: SortOrderInput | SortOrder
    purchase?: PurchaseOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
  }

  export type PurchaseItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PurchaseItemWhereInput | PurchaseItemWhereInput[]
    OR?: PurchaseItemWhereInput[]
    NOT?: PurchaseItemWhereInput | PurchaseItemWhereInput[]
    purchaseId?: StringFilter<"PurchaseItem"> | string
    productId?: StringFilter<"PurchaseItem"> | string
    sku?: StringFilter<"PurchaseItem"> | string
    name?: StringFilter<"PurchaseItem"> | string
    priceCents?: IntFilter<"PurchaseItem"> | number
    durationDays?: IntNullableFilter<"PurchaseItem"> | number | null
    grantPoints?: IntFilter<"PurchaseItem"> | number
    grantVipRole?: StringNullableFilter<"PurchaseItem"> | string | null
    mtaActions?: StringNullableFilter<"PurchaseItem"> | string | null
    purchase?: XOR<PurchaseRelationFilter, PurchaseWhereInput>
    product?: XOR<ProductRelationFilter, ProductWhereInput>
  }, "id">

  export type PurchaseItemOrderByWithAggregationInput = {
    id?: SortOrder
    purchaseId?: SortOrder
    productId?: SortOrder
    sku?: SortOrder
    name?: SortOrder
    priceCents?: SortOrder
    durationDays?: SortOrderInput | SortOrder
    grantPoints?: SortOrder
    grantVipRole?: SortOrderInput | SortOrder
    mtaActions?: SortOrderInput | SortOrder
    _count?: PurchaseItemCountOrderByAggregateInput
    _avg?: PurchaseItemAvgOrderByAggregateInput
    _max?: PurchaseItemMaxOrderByAggregateInput
    _min?: PurchaseItemMinOrderByAggregateInput
    _sum?: PurchaseItemSumOrderByAggregateInput
  }

  export type PurchaseItemScalarWhereWithAggregatesInput = {
    AND?: PurchaseItemScalarWhereWithAggregatesInput | PurchaseItemScalarWhereWithAggregatesInput[]
    OR?: PurchaseItemScalarWhereWithAggregatesInput[]
    NOT?: PurchaseItemScalarWhereWithAggregatesInput | PurchaseItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PurchaseItem"> | string
    purchaseId?: StringWithAggregatesFilter<"PurchaseItem"> | string
    productId?: StringWithAggregatesFilter<"PurchaseItem"> | string
    sku?: StringWithAggregatesFilter<"PurchaseItem"> | string
    name?: StringWithAggregatesFilter<"PurchaseItem"> | string
    priceCents?: IntWithAggregatesFilter<"PurchaseItem"> | number
    durationDays?: IntNullableWithAggregatesFilter<"PurchaseItem"> | number | null
    grantPoints?: IntWithAggregatesFilter<"PurchaseItem"> | number
    grantVipRole?: StringNullableWithAggregatesFilter<"PurchaseItem"> | string | null
    mtaActions?: StringNullableWithAggregatesFilter<"PurchaseItem"> | string | null
  }

  export type EntitlementWhereInput = {
    AND?: EntitlementWhereInput | EntitlementWhereInput[]
    OR?: EntitlementWhereInput[]
    NOT?: EntitlementWhereInput | EntitlementWhereInput[]
    id?: StringFilter<"Entitlement"> | string
    userId?: StringFilter<"Entitlement"> | string
    roleName?: StringFilter<"Entitlement"> | string
    expiresAt?: DateTimeFilter<"Entitlement"> | Date | string
    source?: StringNullableFilter<"Entitlement"> | string | null
    createdAt?: DateTimeFilter<"Entitlement"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type EntitlementOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    roleName?: SortOrder
    expiresAt?: SortOrder
    source?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type EntitlementWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EntitlementWhereInput | EntitlementWhereInput[]
    OR?: EntitlementWhereInput[]
    NOT?: EntitlementWhereInput | EntitlementWhereInput[]
    userId?: StringFilter<"Entitlement"> | string
    roleName?: StringFilter<"Entitlement"> | string
    expiresAt?: DateTimeFilter<"Entitlement"> | Date | string
    source?: StringNullableFilter<"Entitlement"> | string | null
    createdAt?: DateTimeFilter<"Entitlement"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type EntitlementOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    roleName?: SortOrder
    expiresAt?: SortOrder
    source?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: EntitlementCountOrderByAggregateInput
    _max?: EntitlementMaxOrderByAggregateInput
    _min?: EntitlementMinOrderByAggregateInput
  }

  export type EntitlementScalarWhereWithAggregatesInput = {
    AND?: EntitlementScalarWhereWithAggregatesInput | EntitlementScalarWhereWithAggregatesInput[]
    OR?: EntitlementScalarWhereWithAggregatesInput[]
    NOT?: EntitlementScalarWhereWithAggregatesInput | EntitlementScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Entitlement"> | string
    userId?: StringWithAggregatesFilter<"Entitlement"> | string
    roleName?: StringWithAggregatesFilter<"Entitlement"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"Entitlement"> | Date | string
    source?: StringNullableWithAggregatesFilter<"Entitlement"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Entitlement"> | Date | string
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: StringFilter<"Notification"> | string
    userId?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    href?: StringNullableFilter<"Notification"> | string | null
    read?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    message?: SortOrder
    href?: SortOrderInput | SortOrder
    read?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    userId?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    href?: StringNullableFilter<"Notification"> | string | null
    read?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    message?: SortOrder
    href?: SortOrderInput | SortOrder
    read?: SortOrder
    createdAt?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Notification"> | string
    userId?: StringWithAggregatesFilter<"Notification"> | string
    message?: StringWithAggregatesFilter<"Notification"> | string
    href?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    read?: BoolWithAggregatesFilter<"Notification"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
  }

  export type StaffShiftWhereInput = {
    AND?: StaffShiftWhereInput | StaffShiftWhereInput[]
    OR?: StaffShiftWhereInput[]
    NOT?: StaffShiftWhereInput | StaffShiftWhereInput[]
    id?: StringFilter<"StaffShift"> | string
    userId?: StringFilter<"StaffShift"> | string
    openedAt?: DateTimeFilter<"StaffShift"> | Date | string
    closedAt?: DateTimeNullableFilter<"StaffShift"> | Date | string | null
    seconds?: IntFilter<"StaffShift"> | number
    createdAt?: DateTimeFilter<"StaffShift"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type StaffShiftOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    openedAt?: SortOrder
    closedAt?: SortOrderInput | SortOrder
    seconds?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type StaffShiftWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: StaffShiftWhereInput | StaffShiftWhereInput[]
    OR?: StaffShiftWhereInput[]
    NOT?: StaffShiftWhereInput | StaffShiftWhereInput[]
    userId?: StringFilter<"StaffShift"> | string
    openedAt?: DateTimeFilter<"StaffShift"> | Date | string
    closedAt?: DateTimeNullableFilter<"StaffShift"> | Date | string | null
    seconds?: IntFilter<"StaffShift"> | number
    createdAt?: DateTimeFilter<"StaffShift"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type StaffShiftOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    openedAt?: SortOrder
    closedAt?: SortOrderInput | SortOrder
    seconds?: SortOrder
    createdAt?: SortOrder
    _count?: StaffShiftCountOrderByAggregateInput
    _avg?: StaffShiftAvgOrderByAggregateInput
    _max?: StaffShiftMaxOrderByAggregateInput
    _min?: StaffShiftMinOrderByAggregateInput
    _sum?: StaffShiftSumOrderByAggregateInput
  }

  export type StaffShiftScalarWhereWithAggregatesInput = {
    AND?: StaffShiftScalarWhereWithAggregatesInput | StaffShiftScalarWhereWithAggregatesInput[]
    OR?: StaffShiftScalarWhereWithAggregatesInput[]
    NOT?: StaffShiftScalarWhereWithAggregatesInput | StaffShiftScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StaffShift"> | string
    userId?: StringWithAggregatesFilter<"StaffShift"> | string
    openedAt?: DateTimeWithAggregatesFilter<"StaffShift"> | Date | string
    closedAt?: DateTimeNullableWithAggregatesFilter<"StaffShift"> | Date | string | null
    seconds?: IntWithAggregatesFilter<"StaffShift"> | number
    createdAt?: DateTimeWithAggregatesFilter<"StaffShift"> | Date | string
  }

  export type StaffWeeklyRewardWhereInput = {
    AND?: StaffWeeklyRewardWhereInput | StaffWeeklyRewardWhereInput[]
    OR?: StaffWeeklyRewardWhereInput[]
    NOT?: StaffWeeklyRewardWhereInput | StaffWeeklyRewardWhereInput[]
    id?: StringFilter<"StaffWeeklyReward"> | string
    userId?: StringFilter<"StaffWeeklyReward"> | string
    position?: IntFilter<"StaffWeeklyReward"> | number
    weekKey?: StringFilter<"StaffWeeklyReward"> | string
    createdAt?: DateTimeFilter<"StaffWeeklyReward"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type StaffWeeklyRewardOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    position?: SortOrder
    weekKey?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type StaffWeeklyRewardWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_weekKey?: StaffWeeklyRewardUserIdWeekKeyCompoundUniqueInput
    AND?: StaffWeeklyRewardWhereInput | StaffWeeklyRewardWhereInput[]
    OR?: StaffWeeklyRewardWhereInput[]
    NOT?: StaffWeeklyRewardWhereInput | StaffWeeklyRewardWhereInput[]
    userId?: StringFilter<"StaffWeeklyReward"> | string
    position?: IntFilter<"StaffWeeklyReward"> | number
    weekKey?: StringFilter<"StaffWeeklyReward"> | string
    createdAt?: DateTimeFilter<"StaffWeeklyReward"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "userId_weekKey">

  export type StaffWeeklyRewardOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    position?: SortOrder
    weekKey?: SortOrder
    createdAt?: SortOrder
    _count?: StaffWeeklyRewardCountOrderByAggregateInput
    _avg?: StaffWeeklyRewardAvgOrderByAggregateInput
    _max?: StaffWeeklyRewardMaxOrderByAggregateInput
    _min?: StaffWeeklyRewardMinOrderByAggregateInput
    _sum?: StaffWeeklyRewardSumOrderByAggregateInput
  }

  export type StaffWeeklyRewardScalarWhereWithAggregatesInput = {
    AND?: StaffWeeklyRewardScalarWhereWithAggregatesInput | StaffWeeklyRewardScalarWhereWithAggregatesInput[]
    OR?: StaffWeeklyRewardScalarWhereWithAggregatesInput[]
    NOT?: StaffWeeklyRewardScalarWhereWithAggregatesInput | StaffWeeklyRewardScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StaffWeeklyReward"> | string
    userId?: StringWithAggregatesFilter<"StaffWeeklyReward"> | string
    position?: IntWithAggregatesFilter<"StaffWeeklyReward"> | number
    weekKey?: StringWithAggregatesFilter<"StaffWeeklyReward"> | string
    createdAt?: DateTimeWithAggregatesFilter<"StaffWeeklyReward"> | Date | string
  }

  export type AdminCaseWhereInput = {
    AND?: AdminCaseWhereInput | AdminCaseWhereInput[]
    OR?: AdminCaseWhereInput[]
    NOT?: AdminCaseWhereInput | AdminCaseWhereInput[]
    id?: StringFilter<"AdminCase"> | string
    targetUserId?: StringFilter<"AdminCase"> | string
    staffUserId?: StringFilter<"AdminCase"> | string
    type?: StringFilter<"AdminCase"> | string
    reason?: StringFilter<"AdminCase"> | string
    expiresAt?: DateTimeNullableFilter<"AdminCase"> | Date | string | null
    active?: BoolFilter<"AdminCase"> | boolean
    createdAt?: DateTimeFilter<"AdminCase"> | Date | string
    targetUser?: XOR<UserRelationFilter, UserWhereInput>
    staffUser?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type AdminCaseOrderByWithRelationInput = {
    id?: SortOrder
    targetUserId?: SortOrder
    staffUserId?: SortOrder
    type?: SortOrder
    reason?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    targetUser?: UserOrderByWithRelationInput
    staffUser?: UserOrderByWithRelationInput
  }

  export type AdminCaseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AdminCaseWhereInput | AdminCaseWhereInput[]
    OR?: AdminCaseWhereInput[]
    NOT?: AdminCaseWhereInput | AdminCaseWhereInput[]
    targetUserId?: StringFilter<"AdminCase"> | string
    staffUserId?: StringFilter<"AdminCase"> | string
    type?: StringFilter<"AdminCase"> | string
    reason?: StringFilter<"AdminCase"> | string
    expiresAt?: DateTimeNullableFilter<"AdminCase"> | Date | string | null
    active?: BoolFilter<"AdminCase"> | boolean
    createdAt?: DateTimeFilter<"AdminCase"> | Date | string
    targetUser?: XOR<UserRelationFilter, UserWhereInput>
    staffUser?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type AdminCaseOrderByWithAggregationInput = {
    id?: SortOrder
    targetUserId?: SortOrder
    staffUserId?: SortOrder
    type?: SortOrder
    reason?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    _count?: AdminCaseCountOrderByAggregateInput
    _max?: AdminCaseMaxOrderByAggregateInput
    _min?: AdminCaseMinOrderByAggregateInput
  }

  export type AdminCaseScalarWhereWithAggregatesInput = {
    AND?: AdminCaseScalarWhereWithAggregatesInput | AdminCaseScalarWhereWithAggregatesInput[]
    OR?: AdminCaseScalarWhereWithAggregatesInput[]
    NOT?: AdminCaseScalarWhereWithAggregatesInput | AdminCaseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AdminCase"> | string
    targetUserId?: StringWithAggregatesFilter<"AdminCase"> | string
    staffUserId?: StringWithAggregatesFilter<"AdminCase"> | string
    type?: StringWithAggregatesFilter<"AdminCase"> | string
    reason?: StringWithAggregatesFilter<"AdminCase"> | string
    expiresAt?: DateTimeNullableWithAggregatesFilter<"AdminCase"> | Date | string | null
    active?: BoolWithAggregatesFilter<"AdminCase"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"AdminCase"> | Date | string
  }

  export type UserReputationWhereInput = {
    AND?: UserReputationWhereInput | UserReputationWhereInput[]
    OR?: UserReputationWhereInput[]
    NOT?: UserReputationWhereInput | UserReputationWhereInput[]
    userId?: StringFilter<"UserReputation"> | string
    score?: IntFilter<"UserReputation"> | number
    updatedAt?: DateTimeFilter<"UserReputation"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type UserReputationOrderByWithRelationInput = {
    userId?: SortOrder
    score?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserReputationWhereUniqueInput = Prisma.AtLeast<{
    userId?: string
    AND?: UserReputationWhereInput | UserReputationWhereInput[]
    OR?: UserReputationWhereInput[]
    NOT?: UserReputationWhereInput | UserReputationWhereInput[]
    score?: IntFilter<"UserReputation"> | number
    updatedAt?: DateTimeFilter<"UserReputation"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "userId">

  export type UserReputationOrderByWithAggregationInput = {
    userId?: SortOrder
    score?: SortOrder
    updatedAt?: SortOrder
    _count?: UserReputationCountOrderByAggregateInput
    _avg?: UserReputationAvgOrderByAggregateInput
    _max?: UserReputationMaxOrderByAggregateInput
    _min?: UserReputationMinOrderByAggregateInput
    _sum?: UserReputationSumOrderByAggregateInput
  }

  export type UserReputationScalarWhereWithAggregatesInput = {
    AND?: UserReputationScalarWhereWithAggregatesInput | UserReputationScalarWhereWithAggregatesInput[]
    OR?: UserReputationScalarWhereWithAggregatesInput[]
    NOT?: UserReputationScalarWhereWithAggregatesInput | UserReputationScalarWhereWithAggregatesInput[]
    userId?: StringWithAggregatesFilter<"UserReputation"> | string
    score?: IntWithAggregatesFilter<"UserReputation"> | number
    updatedAt?: DateTimeWithAggregatesFilter<"UserReputation"> | Date | string
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    username?: StringFilter<"User"> | string
    passwordHash?: StringFilter<"User"> | string
    emailVerifiedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    emailVerifyToken?: StringNullableFilter<"User"> | string | null
    emailVerifyExpiresAt?: DateTimeNullableFilter<"User"> | Date | string | null
    phone?: StringNullableFilter<"User"> | string | null
    recoveryEmail?: StringNullableFilter<"User"> | string | null
    googleId?: StringNullableFilter<"User"> | string | null
    discordId?: StringNullableFilter<"User"> | string | null
    discordUsername?: StringNullableFilter<"User"> | string | null
    avatarKey?: StringFilter<"User"> | string
    role?: StringFilter<"User"> | string
    isDeleted?: BoolFilter<"User"> | boolean
    bannedUntil?: DateTimeNullableFilter<"User"> | Date | string | null
    whitelistStatus?: StringFilter<"User"> | string
    points?: IntFilter<"User"> | number
    lastSeenAt?: DateTimeFilter<"User"> | Date | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    avatarUrl?: StringNullableFilter<"User"> | string | null
    topics?: TopicListRelationFilter
    posts?: PostListRelationFilter
    tickets?: TicketListRelationFilter
    assignedTickets?: TicketListRelationFilter
    ticketMsgs?: TicketMessageListRelationFilter
    ticketParticipants?: TicketParticipantListRelationFilter
    ticketParticipantsAdded?: TicketParticipantListRelationFilter
    ticketRatingsGiven?: TicketRatingListRelationFilter
    ticketRatingsReceived?: TicketRatingListRelationFilter
    closedTickets?: TicketListRelationFilter
    purchases?: PurchaseListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    userRoles?: UserRoleListRelationFilter
    whitelistApps?: WhitelistApplicationListRelationFilter
    reviewedWhitelists?: WhitelistApplicationListRelationFilter
    convoParts?: ConversationParticipantListRelationFilter
    sentMessages?: DirectMessageListRelationFilter
    receivedMessages?: DirectMessageListRelationFilter
    userBadges?: UserBadgeListRelationFilter
    gameAccounts?: GameAccountListRelationFilter
    mtaAccessLogs?: MtaAccessLogListRelationFilter
    ticketRatingReqGiven?: TicketRatingRequirementListRelationFilter
    ticketRatingReqReceived?: TicketRatingRequirementListRelationFilter
    passwordResetTokens?: PasswordResetTokenListRelationFilter
    entitlements?: EntitlementListRelationFilter
    notifications?: NotificationListRelationFilter
    staffShifts?: StaffShiftListRelationFilter
    staffWeeklyRewards?: StaffWeeklyRewardListRelationFilter
    adminCasesTarget?: AdminCaseListRelationFilter
    adminCasesStaff?: AdminCaseListRelationFilter
    reputation?: XOR<UserReputationNullableRelationFilter, UserReputationWhereInput> | null
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    passwordHash?: SortOrder
    emailVerifiedAt?: SortOrderInput | SortOrder
    emailVerifyToken?: SortOrderInput | SortOrder
    emailVerifyExpiresAt?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    recoveryEmail?: SortOrderInput | SortOrder
    googleId?: SortOrderInput | SortOrder
    discordId?: SortOrderInput | SortOrder
    discordUsername?: SortOrderInput | SortOrder
    avatarKey?: SortOrder
    role?: SortOrder
    isDeleted?: SortOrder
    bannedUntil?: SortOrderInput | SortOrder
    whitelistStatus?: SortOrder
    points?: SortOrder
    lastSeenAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    topics?: TopicOrderByRelationAggregateInput
    posts?: PostOrderByRelationAggregateInput
    tickets?: TicketOrderByRelationAggregateInput
    assignedTickets?: TicketOrderByRelationAggregateInput
    ticketMsgs?: TicketMessageOrderByRelationAggregateInput
    ticketParticipants?: TicketParticipantOrderByRelationAggregateInput
    ticketParticipantsAdded?: TicketParticipantOrderByRelationAggregateInput
    ticketRatingsGiven?: TicketRatingOrderByRelationAggregateInput
    ticketRatingsReceived?: TicketRatingOrderByRelationAggregateInput
    closedTickets?: TicketOrderByRelationAggregateInput
    purchases?: PurchaseOrderByRelationAggregateInput
    auditLogs?: AuditLogOrderByRelationAggregateInput
    userRoles?: UserRoleOrderByRelationAggregateInput
    whitelistApps?: WhitelistApplicationOrderByRelationAggregateInput
    reviewedWhitelists?: WhitelistApplicationOrderByRelationAggregateInput
    convoParts?: ConversationParticipantOrderByRelationAggregateInput
    sentMessages?: DirectMessageOrderByRelationAggregateInput
    receivedMessages?: DirectMessageOrderByRelationAggregateInput
    userBadges?: UserBadgeOrderByRelationAggregateInput
    gameAccounts?: GameAccountOrderByRelationAggregateInput
    mtaAccessLogs?: MtaAccessLogOrderByRelationAggregateInput
    ticketRatingReqGiven?: TicketRatingRequirementOrderByRelationAggregateInput
    ticketRatingReqReceived?: TicketRatingRequirementOrderByRelationAggregateInput
    passwordResetTokens?: PasswordResetTokenOrderByRelationAggregateInput
    entitlements?: EntitlementOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
    staffShifts?: StaffShiftOrderByRelationAggregateInput
    staffWeeklyRewards?: StaffWeeklyRewardOrderByRelationAggregateInput
    adminCasesTarget?: AdminCaseOrderByRelationAggregateInput
    adminCasesStaff?: AdminCaseOrderByRelationAggregateInput
    reputation?: UserReputationOrderByWithRelationInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    username?: string
    googleId?: string
    discordId?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    passwordHash?: StringFilter<"User"> | string
    emailVerifiedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    emailVerifyToken?: StringNullableFilter<"User"> | string | null
    emailVerifyExpiresAt?: DateTimeNullableFilter<"User"> | Date | string | null
    phone?: StringNullableFilter<"User"> | string | null
    recoveryEmail?: StringNullableFilter<"User"> | string | null
    discordUsername?: StringNullableFilter<"User"> | string | null
    avatarKey?: StringFilter<"User"> | string
    role?: StringFilter<"User"> | string
    isDeleted?: BoolFilter<"User"> | boolean
    bannedUntil?: DateTimeNullableFilter<"User"> | Date | string | null
    whitelistStatus?: StringFilter<"User"> | string
    points?: IntFilter<"User"> | number
    lastSeenAt?: DateTimeFilter<"User"> | Date | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    avatarUrl?: StringNullableFilter<"User"> | string | null
    topics?: TopicListRelationFilter
    posts?: PostListRelationFilter
    tickets?: TicketListRelationFilter
    assignedTickets?: TicketListRelationFilter
    ticketMsgs?: TicketMessageListRelationFilter
    ticketParticipants?: TicketParticipantListRelationFilter
    ticketParticipantsAdded?: TicketParticipantListRelationFilter
    ticketRatingsGiven?: TicketRatingListRelationFilter
    ticketRatingsReceived?: TicketRatingListRelationFilter
    closedTickets?: TicketListRelationFilter
    purchases?: PurchaseListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    userRoles?: UserRoleListRelationFilter
    whitelistApps?: WhitelistApplicationListRelationFilter
    reviewedWhitelists?: WhitelistApplicationListRelationFilter
    convoParts?: ConversationParticipantListRelationFilter
    sentMessages?: DirectMessageListRelationFilter
    receivedMessages?: DirectMessageListRelationFilter
    userBadges?: UserBadgeListRelationFilter
    gameAccounts?: GameAccountListRelationFilter
    mtaAccessLogs?: MtaAccessLogListRelationFilter
    ticketRatingReqGiven?: TicketRatingRequirementListRelationFilter
    ticketRatingReqReceived?: TicketRatingRequirementListRelationFilter
    passwordResetTokens?: PasswordResetTokenListRelationFilter
    entitlements?: EntitlementListRelationFilter
    notifications?: NotificationListRelationFilter
    staffShifts?: StaffShiftListRelationFilter
    staffWeeklyRewards?: StaffWeeklyRewardListRelationFilter
    adminCasesTarget?: AdminCaseListRelationFilter
    adminCasesStaff?: AdminCaseListRelationFilter
    reputation?: XOR<UserReputationNullableRelationFilter, UserReputationWhereInput> | null
  }, "id" | "email" | "username" | "googleId" | "discordId">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    passwordHash?: SortOrder
    emailVerifiedAt?: SortOrderInput | SortOrder
    emailVerifyToken?: SortOrderInput | SortOrder
    emailVerifyExpiresAt?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    recoveryEmail?: SortOrderInput | SortOrder
    googleId?: SortOrderInput | SortOrder
    discordId?: SortOrderInput | SortOrder
    discordUsername?: SortOrderInput | SortOrder
    avatarKey?: SortOrder
    role?: SortOrder
    isDeleted?: SortOrder
    bannedUntil?: SortOrderInput | SortOrder
    whitelistStatus?: SortOrder
    points?: SortOrder
    lastSeenAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    username?: StringWithAggregatesFilter<"User"> | string
    passwordHash?: StringWithAggregatesFilter<"User"> | string
    emailVerifiedAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    emailVerifyToken?: StringNullableWithAggregatesFilter<"User"> | string | null
    emailVerifyExpiresAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    phone?: StringNullableWithAggregatesFilter<"User"> | string | null
    recoveryEmail?: StringNullableWithAggregatesFilter<"User"> | string | null
    googleId?: StringNullableWithAggregatesFilter<"User"> | string | null
    discordId?: StringNullableWithAggregatesFilter<"User"> | string | null
    discordUsername?: StringNullableWithAggregatesFilter<"User"> | string | null
    avatarKey?: StringWithAggregatesFilter<"User"> | string
    role?: StringWithAggregatesFilter<"User"> | string
    isDeleted?: BoolWithAggregatesFilter<"User"> | boolean
    bannedUntil?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    whitelistStatus?: StringWithAggregatesFilter<"User"> | string
    points?: IntWithAggregatesFilter<"User"> | number
    lastSeenAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    avatarUrl?: StringNullableWithAggregatesFilter<"User"> | string | null
  }

  export type ForumCategoryWhereInput = {
    AND?: ForumCategoryWhereInput | ForumCategoryWhereInput[]
    OR?: ForumCategoryWhereInput[]
    NOT?: ForumCategoryWhereInput | ForumCategoryWhereInput[]
    id?: StringFilter<"ForumCategory"> | string
    name?: StringFilter<"ForumCategory"> | string
    description?: StringNullableFilter<"ForumCategory"> | string | null
    order?: IntFilter<"ForumCategory"> | number
    createdAt?: DateTimeFilter<"ForumCategory"> | Date | string
    boards?: ForumBoardListRelationFilter
  }

  export type ForumCategoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    boards?: ForumBoardOrderByRelationAggregateInput
  }

  export type ForumCategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ForumCategoryWhereInput | ForumCategoryWhereInput[]
    OR?: ForumCategoryWhereInput[]
    NOT?: ForumCategoryWhereInput | ForumCategoryWhereInput[]
    name?: StringFilter<"ForumCategory"> | string
    description?: StringNullableFilter<"ForumCategory"> | string | null
    order?: IntFilter<"ForumCategory"> | number
    createdAt?: DateTimeFilter<"ForumCategory"> | Date | string
    boards?: ForumBoardListRelationFilter
  }, "id">

  export type ForumCategoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    _count?: ForumCategoryCountOrderByAggregateInput
    _avg?: ForumCategoryAvgOrderByAggregateInput
    _max?: ForumCategoryMaxOrderByAggregateInput
    _min?: ForumCategoryMinOrderByAggregateInput
    _sum?: ForumCategorySumOrderByAggregateInput
  }

  export type ForumCategoryScalarWhereWithAggregatesInput = {
    AND?: ForumCategoryScalarWhereWithAggregatesInput | ForumCategoryScalarWhereWithAggregatesInput[]
    OR?: ForumCategoryScalarWhereWithAggregatesInput[]
    NOT?: ForumCategoryScalarWhereWithAggregatesInput | ForumCategoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ForumCategory"> | string
    name?: StringWithAggregatesFilter<"ForumCategory"> | string
    description?: StringNullableWithAggregatesFilter<"ForumCategory"> | string | null
    order?: IntWithAggregatesFilter<"ForumCategory"> | number
    createdAt?: DateTimeWithAggregatesFilter<"ForumCategory"> | Date | string
  }

  export type ForumBoardWhereInput = {
    AND?: ForumBoardWhereInput | ForumBoardWhereInput[]
    OR?: ForumBoardWhereInput[]
    NOT?: ForumBoardWhereInput | ForumBoardWhereInput[]
    id?: StringFilter<"ForumBoard"> | string
    categoryId?: StringFilter<"ForumBoard"> | string
    name?: StringFilter<"ForumBoard"> | string
    description?: StringNullableFilter<"ForumBoard"> | string | null
    order?: IntFilter<"ForumBoard"> | number
    requireWhitelist?: BoolFilter<"ForumBoard"> | boolean
    pointsOnTopic?: IntFilter<"ForumBoard"> | number
    pointsOnReply?: IntFilter<"ForumBoard"> | number
    allowReplies?: BoolFilter<"ForumBoard"> | boolean
    createdAt?: DateTimeFilter<"ForumBoard"> | Date | string
    category?: XOR<ForumCategoryRelationFilter, ForumCategoryWhereInput>
    topics?: TopicListRelationFilter
  }

  export type ForumBoardOrderByWithRelationInput = {
    id?: SortOrder
    categoryId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    order?: SortOrder
    requireWhitelist?: SortOrder
    pointsOnTopic?: SortOrder
    pointsOnReply?: SortOrder
    allowReplies?: SortOrder
    createdAt?: SortOrder
    category?: ForumCategoryOrderByWithRelationInput
    topics?: TopicOrderByRelationAggregateInput
  }

  export type ForumBoardWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ForumBoardWhereInput | ForumBoardWhereInput[]
    OR?: ForumBoardWhereInput[]
    NOT?: ForumBoardWhereInput | ForumBoardWhereInput[]
    categoryId?: StringFilter<"ForumBoard"> | string
    name?: StringFilter<"ForumBoard"> | string
    description?: StringNullableFilter<"ForumBoard"> | string | null
    order?: IntFilter<"ForumBoard"> | number
    requireWhitelist?: BoolFilter<"ForumBoard"> | boolean
    pointsOnTopic?: IntFilter<"ForumBoard"> | number
    pointsOnReply?: IntFilter<"ForumBoard"> | number
    allowReplies?: BoolFilter<"ForumBoard"> | boolean
    createdAt?: DateTimeFilter<"ForumBoard"> | Date | string
    category?: XOR<ForumCategoryRelationFilter, ForumCategoryWhereInput>
    topics?: TopicListRelationFilter
  }, "id">

  export type ForumBoardOrderByWithAggregationInput = {
    id?: SortOrder
    categoryId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    order?: SortOrder
    requireWhitelist?: SortOrder
    pointsOnTopic?: SortOrder
    pointsOnReply?: SortOrder
    allowReplies?: SortOrder
    createdAt?: SortOrder
    _count?: ForumBoardCountOrderByAggregateInput
    _avg?: ForumBoardAvgOrderByAggregateInput
    _max?: ForumBoardMaxOrderByAggregateInput
    _min?: ForumBoardMinOrderByAggregateInput
    _sum?: ForumBoardSumOrderByAggregateInput
  }

  export type ForumBoardScalarWhereWithAggregatesInput = {
    AND?: ForumBoardScalarWhereWithAggregatesInput | ForumBoardScalarWhereWithAggregatesInput[]
    OR?: ForumBoardScalarWhereWithAggregatesInput[]
    NOT?: ForumBoardScalarWhereWithAggregatesInput | ForumBoardScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ForumBoard"> | string
    categoryId?: StringWithAggregatesFilter<"ForumBoard"> | string
    name?: StringWithAggregatesFilter<"ForumBoard"> | string
    description?: StringNullableWithAggregatesFilter<"ForumBoard"> | string | null
    order?: IntWithAggregatesFilter<"ForumBoard"> | number
    requireWhitelist?: BoolWithAggregatesFilter<"ForumBoard"> | boolean
    pointsOnTopic?: IntWithAggregatesFilter<"ForumBoard"> | number
    pointsOnReply?: IntWithAggregatesFilter<"ForumBoard"> | number
    allowReplies?: BoolWithAggregatesFilter<"ForumBoard"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"ForumBoard"> | Date | string
  }

  export type TopicWhereInput = {
    AND?: TopicWhereInput | TopicWhereInput[]
    OR?: TopicWhereInput[]
    NOT?: TopicWhereInput | TopicWhereInput[]
    id?: StringFilter<"Topic"> | string
    boardId?: StringFilter<"Topic"> | string
    authorId?: StringFilter<"Topic"> | string
    title?: StringFilter<"Topic"> | string
    status?: StringFilter<"Topic"> | string
    pinned?: BoolFilter<"Topic"> | boolean
    isDeleted?: BoolFilter<"Topic"> | boolean
    createdAt?: DateTimeFilter<"Topic"> | Date | string
    updatedAt?: DateTimeFilter<"Topic"> | Date | string
    lastPostAt?: DateTimeFilter<"Topic"> | Date | string
    board?: XOR<ForumBoardRelationFilter, ForumBoardWhereInput>
    author?: XOR<UserRelationFilter, UserWhereInput>
    posts?: PostListRelationFilter
  }

  export type TopicOrderByWithRelationInput = {
    id?: SortOrder
    boardId?: SortOrder
    authorId?: SortOrder
    title?: SortOrder
    status?: SortOrder
    pinned?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastPostAt?: SortOrder
    board?: ForumBoardOrderByWithRelationInput
    author?: UserOrderByWithRelationInput
    posts?: PostOrderByRelationAggregateInput
  }

  export type TopicWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TopicWhereInput | TopicWhereInput[]
    OR?: TopicWhereInput[]
    NOT?: TopicWhereInput | TopicWhereInput[]
    boardId?: StringFilter<"Topic"> | string
    authorId?: StringFilter<"Topic"> | string
    title?: StringFilter<"Topic"> | string
    status?: StringFilter<"Topic"> | string
    pinned?: BoolFilter<"Topic"> | boolean
    isDeleted?: BoolFilter<"Topic"> | boolean
    createdAt?: DateTimeFilter<"Topic"> | Date | string
    updatedAt?: DateTimeFilter<"Topic"> | Date | string
    lastPostAt?: DateTimeFilter<"Topic"> | Date | string
    board?: XOR<ForumBoardRelationFilter, ForumBoardWhereInput>
    author?: XOR<UserRelationFilter, UserWhereInput>
    posts?: PostListRelationFilter
  }, "id">

  export type TopicOrderByWithAggregationInput = {
    id?: SortOrder
    boardId?: SortOrder
    authorId?: SortOrder
    title?: SortOrder
    status?: SortOrder
    pinned?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastPostAt?: SortOrder
    _count?: TopicCountOrderByAggregateInput
    _max?: TopicMaxOrderByAggregateInput
    _min?: TopicMinOrderByAggregateInput
  }

  export type TopicScalarWhereWithAggregatesInput = {
    AND?: TopicScalarWhereWithAggregatesInput | TopicScalarWhereWithAggregatesInput[]
    OR?: TopicScalarWhereWithAggregatesInput[]
    NOT?: TopicScalarWhereWithAggregatesInput | TopicScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Topic"> | string
    boardId?: StringWithAggregatesFilter<"Topic"> | string
    authorId?: StringWithAggregatesFilter<"Topic"> | string
    title?: StringWithAggregatesFilter<"Topic"> | string
    status?: StringWithAggregatesFilter<"Topic"> | string
    pinned?: BoolWithAggregatesFilter<"Topic"> | boolean
    isDeleted?: BoolWithAggregatesFilter<"Topic"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Topic"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Topic"> | Date | string
    lastPostAt?: DateTimeWithAggregatesFilter<"Topic"> | Date | string
  }

  export type PostWhereInput = {
    AND?: PostWhereInput | PostWhereInput[]
    OR?: PostWhereInput[]
    NOT?: PostWhereInput | PostWhereInput[]
    id?: StringFilter<"Post"> | string
    topicId?: StringFilter<"Post"> | string
    authorId?: StringFilter<"Post"> | string
    content?: StringFilter<"Post"> | string
    isDeleted?: BoolFilter<"Post"> | boolean
    createdAt?: DateTimeFilter<"Post"> | Date | string
    updatedAt?: DateTimeFilter<"Post"> | Date | string
    topic?: XOR<TopicRelationFilter, TopicWhereInput>
    author?: XOR<UserRelationFilter, UserWhereInput>
    attachments?: PostAttachmentListRelationFilter
  }

  export type PostOrderByWithRelationInput = {
    id?: SortOrder
    topicId?: SortOrder
    authorId?: SortOrder
    content?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    topic?: TopicOrderByWithRelationInput
    author?: UserOrderByWithRelationInput
    attachments?: PostAttachmentOrderByRelationAggregateInput
  }

  export type PostWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PostWhereInput | PostWhereInput[]
    OR?: PostWhereInput[]
    NOT?: PostWhereInput | PostWhereInput[]
    topicId?: StringFilter<"Post"> | string
    authorId?: StringFilter<"Post"> | string
    content?: StringFilter<"Post"> | string
    isDeleted?: BoolFilter<"Post"> | boolean
    createdAt?: DateTimeFilter<"Post"> | Date | string
    updatedAt?: DateTimeFilter<"Post"> | Date | string
    topic?: XOR<TopicRelationFilter, TopicWhereInput>
    author?: XOR<UserRelationFilter, UserWhereInput>
    attachments?: PostAttachmentListRelationFilter
  }, "id">

  export type PostOrderByWithAggregationInput = {
    id?: SortOrder
    topicId?: SortOrder
    authorId?: SortOrder
    content?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PostCountOrderByAggregateInput
    _max?: PostMaxOrderByAggregateInput
    _min?: PostMinOrderByAggregateInput
  }

  export type PostScalarWhereWithAggregatesInput = {
    AND?: PostScalarWhereWithAggregatesInput | PostScalarWhereWithAggregatesInput[]
    OR?: PostScalarWhereWithAggregatesInput[]
    NOT?: PostScalarWhereWithAggregatesInput | PostScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Post"> | string
    topicId?: StringWithAggregatesFilter<"Post"> | string
    authorId?: StringWithAggregatesFilter<"Post"> | string
    content?: StringWithAggregatesFilter<"Post"> | string
    isDeleted?: BoolWithAggregatesFilter<"Post"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Post"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Post"> | Date | string
  }

  export type PostAttachmentWhereInput = {
    AND?: PostAttachmentWhereInput | PostAttachmentWhereInput[]
    OR?: PostAttachmentWhereInput[]
    NOT?: PostAttachmentWhereInput | PostAttachmentWhereInput[]
    id?: StringFilter<"PostAttachment"> | string
    postId?: StringFilter<"PostAttachment"> | string
    url?: StringFilter<"PostAttachment"> | string
    mime?: StringNullableFilter<"PostAttachment"> | string | null
    size?: IntNullableFilter<"PostAttachment"> | number | null
    createdAt?: DateTimeFilter<"PostAttachment"> | Date | string
    post?: XOR<PostRelationFilter, PostWhereInput>
  }

  export type PostAttachmentOrderByWithRelationInput = {
    id?: SortOrder
    postId?: SortOrder
    url?: SortOrder
    mime?: SortOrderInput | SortOrder
    size?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    post?: PostOrderByWithRelationInput
  }

  export type PostAttachmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PostAttachmentWhereInput | PostAttachmentWhereInput[]
    OR?: PostAttachmentWhereInput[]
    NOT?: PostAttachmentWhereInput | PostAttachmentWhereInput[]
    postId?: StringFilter<"PostAttachment"> | string
    url?: StringFilter<"PostAttachment"> | string
    mime?: StringNullableFilter<"PostAttachment"> | string | null
    size?: IntNullableFilter<"PostAttachment"> | number | null
    createdAt?: DateTimeFilter<"PostAttachment"> | Date | string
    post?: XOR<PostRelationFilter, PostWhereInput>
  }, "id">

  export type PostAttachmentOrderByWithAggregationInput = {
    id?: SortOrder
    postId?: SortOrder
    url?: SortOrder
    mime?: SortOrderInput | SortOrder
    size?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: PostAttachmentCountOrderByAggregateInput
    _avg?: PostAttachmentAvgOrderByAggregateInput
    _max?: PostAttachmentMaxOrderByAggregateInput
    _min?: PostAttachmentMinOrderByAggregateInput
    _sum?: PostAttachmentSumOrderByAggregateInput
  }

  export type PostAttachmentScalarWhereWithAggregatesInput = {
    AND?: PostAttachmentScalarWhereWithAggregatesInput | PostAttachmentScalarWhereWithAggregatesInput[]
    OR?: PostAttachmentScalarWhereWithAggregatesInput[]
    NOT?: PostAttachmentScalarWhereWithAggregatesInput | PostAttachmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PostAttachment"> | string
    postId?: StringWithAggregatesFilter<"PostAttachment"> | string
    url?: StringWithAggregatesFilter<"PostAttachment"> | string
    mime?: StringNullableWithAggregatesFilter<"PostAttachment"> | string | null
    size?: IntNullableWithAggregatesFilter<"PostAttachment"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"PostAttachment"> | Date | string
  }

  export type TicketCategoryWhereInput = {
    AND?: TicketCategoryWhereInput | TicketCategoryWhereInput[]
    OR?: TicketCategoryWhereInput[]
    NOT?: TicketCategoryWhereInput | TicketCategoryWhereInput[]
    id?: StringFilter<"TicketCategory"> | string
    slug?: StringFilter<"TicketCategory"> | string
    name?: StringFilter<"TicketCategory"> | string
    description?: StringNullableFilter<"TicketCategory"> | string | null
    order?: IntFilter<"TicketCategory"> | number
    createdAt?: DateTimeFilter<"TicketCategory"> | Date | string
    tickets?: TicketListRelationFilter
  }

  export type TicketCategoryOrderByWithRelationInput = {
    id?: SortOrder
    slug?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    tickets?: TicketOrderByRelationAggregateInput
  }

  export type TicketCategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: TicketCategoryWhereInput | TicketCategoryWhereInput[]
    OR?: TicketCategoryWhereInput[]
    NOT?: TicketCategoryWhereInput | TicketCategoryWhereInput[]
    name?: StringFilter<"TicketCategory"> | string
    description?: StringNullableFilter<"TicketCategory"> | string | null
    order?: IntFilter<"TicketCategory"> | number
    createdAt?: DateTimeFilter<"TicketCategory"> | Date | string
    tickets?: TicketListRelationFilter
  }, "id" | "slug">

  export type TicketCategoryOrderByWithAggregationInput = {
    id?: SortOrder
    slug?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    _count?: TicketCategoryCountOrderByAggregateInput
    _avg?: TicketCategoryAvgOrderByAggregateInput
    _max?: TicketCategoryMaxOrderByAggregateInput
    _min?: TicketCategoryMinOrderByAggregateInput
    _sum?: TicketCategorySumOrderByAggregateInput
  }

  export type TicketCategoryScalarWhereWithAggregatesInput = {
    AND?: TicketCategoryScalarWhereWithAggregatesInput | TicketCategoryScalarWhereWithAggregatesInput[]
    OR?: TicketCategoryScalarWhereWithAggregatesInput[]
    NOT?: TicketCategoryScalarWhereWithAggregatesInput | TicketCategoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TicketCategory"> | string
    slug?: StringWithAggregatesFilter<"TicketCategory"> | string
    name?: StringWithAggregatesFilter<"TicketCategory"> | string
    description?: StringNullableWithAggregatesFilter<"TicketCategory"> | string | null
    order?: IntWithAggregatesFilter<"TicketCategory"> | number
    createdAt?: DateTimeWithAggregatesFilter<"TicketCategory"> | Date | string
  }

  export type TicketWhereInput = {
    AND?: TicketWhereInput | TicketWhereInput[]
    OR?: TicketWhereInput[]
    NOT?: TicketWhereInput | TicketWhereInput[]
    id?: StringFilter<"Ticket"> | string
    categoryId?: StringFilter<"Ticket"> | string
    authorId?: StringFilter<"Ticket"> | string
    title?: StringFilter<"Ticket"> | string
    status?: StringFilter<"Ticket"> | string
    priority?: StringFilter<"Ticket"> | string
    assignedToId?: StringNullableFilter<"Ticket"> | string | null
    isDeleted?: BoolFilter<"Ticket"> | boolean
    createdAt?: DateTimeFilter<"Ticket"> | Date | string
    updatedAt?: DateTimeFilter<"Ticket"> | Date | string
    closedAt?: DateTimeNullableFilter<"Ticket"> | Date | string | null
    closedById?: StringNullableFilter<"Ticket"> | string | null
    category?: XOR<TicketCategoryRelationFilter, TicketCategoryWhereInput>
    author?: XOR<UserRelationFilter, UserWhereInput>
    assignedTo?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    closedBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    messages?: TicketMessageListRelationFilter
    participants?: TicketParticipantListRelationFilter
    ratings?: TicketRatingListRelationFilter
    ratingRequirements?: TicketRatingRequirementListRelationFilter
  }

  export type TicketOrderByWithRelationInput = {
    id?: SortOrder
    categoryId?: SortOrder
    authorId?: SortOrder
    title?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    assignedToId?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    closedAt?: SortOrderInput | SortOrder
    closedById?: SortOrderInput | SortOrder
    category?: TicketCategoryOrderByWithRelationInput
    author?: UserOrderByWithRelationInput
    assignedTo?: UserOrderByWithRelationInput
    closedBy?: UserOrderByWithRelationInput
    messages?: TicketMessageOrderByRelationAggregateInput
    participants?: TicketParticipantOrderByRelationAggregateInput
    ratings?: TicketRatingOrderByRelationAggregateInput
    ratingRequirements?: TicketRatingRequirementOrderByRelationAggregateInput
  }

  export type TicketWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TicketWhereInput | TicketWhereInput[]
    OR?: TicketWhereInput[]
    NOT?: TicketWhereInput | TicketWhereInput[]
    categoryId?: StringFilter<"Ticket"> | string
    authorId?: StringFilter<"Ticket"> | string
    title?: StringFilter<"Ticket"> | string
    status?: StringFilter<"Ticket"> | string
    priority?: StringFilter<"Ticket"> | string
    assignedToId?: StringNullableFilter<"Ticket"> | string | null
    isDeleted?: BoolFilter<"Ticket"> | boolean
    createdAt?: DateTimeFilter<"Ticket"> | Date | string
    updatedAt?: DateTimeFilter<"Ticket"> | Date | string
    closedAt?: DateTimeNullableFilter<"Ticket"> | Date | string | null
    closedById?: StringNullableFilter<"Ticket"> | string | null
    category?: XOR<TicketCategoryRelationFilter, TicketCategoryWhereInput>
    author?: XOR<UserRelationFilter, UserWhereInput>
    assignedTo?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    closedBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    messages?: TicketMessageListRelationFilter
    participants?: TicketParticipantListRelationFilter
    ratings?: TicketRatingListRelationFilter
    ratingRequirements?: TicketRatingRequirementListRelationFilter
  }, "id">

  export type TicketOrderByWithAggregationInput = {
    id?: SortOrder
    categoryId?: SortOrder
    authorId?: SortOrder
    title?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    assignedToId?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    closedAt?: SortOrderInput | SortOrder
    closedById?: SortOrderInput | SortOrder
    _count?: TicketCountOrderByAggregateInput
    _max?: TicketMaxOrderByAggregateInput
    _min?: TicketMinOrderByAggregateInput
  }

  export type TicketScalarWhereWithAggregatesInput = {
    AND?: TicketScalarWhereWithAggregatesInput | TicketScalarWhereWithAggregatesInput[]
    OR?: TicketScalarWhereWithAggregatesInput[]
    NOT?: TicketScalarWhereWithAggregatesInput | TicketScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Ticket"> | string
    categoryId?: StringWithAggregatesFilter<"Ticket"> | string
    authorId?: StringWithAggregatesFilter<"Ticket"> | string
    title?: StringWithAggregatesFilter<"Ticket"> | string
    status?: StringWithAggregatesFilter<"Ticket"> | string
    priority?: StringWithAggregatesFilter<"Ticket"> | string
    assignedToId?: StringNullableWithAggregatesFilter<"Ticket"> | string | null
    isDeleted?: BoolWithAggregatesFilter<"Ticket"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Ticket"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Ticket"> | Date | string
    closedAt?: DateTimeNullableWithAggregatesFilter<"Ticket"> | Date | string | null
    closedById?: StringNullableWithAggregatesFilter<"Ticket"> | string | null
  }

  export type TicketMessageWhereInput = {
    AND?: TicketMessageWhereInput | TicketMessageWhereInput[]
    OR?: TicketMessageWhereInput[]
    NOT?: TicketMessageWhereInput | TicketMessageWhereInput[]
    id?: StringFilter<"TicketMessage"> | string
    ticketId?: StringFilter<"TicketMessage"> | string
    authorId?: StringFilter<"TicketMessage"> | string
    content?: StringFilter<"TicketMessage"> | string
    isDeleted?: BoolFilter<"TicketMessage"> | boolean
    createdAt?: DateTimeFilter<"TicketMessage"> | Date | string
    ticket?: XOR<TicketRelationFilter, TicketWhereInput>
    author?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type TicketMessageOrderByWithRelationInput = {
    id?: SortOrder
    ticketId?: SortOrder
    authorId?: SortOrder
    content?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    ticket?: TicketOrderByWithRelationInput
    author?: UserOrderByWithRelationInput
  }

  export type TicketMessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TicketMessageWhereInput | TicketMessageWhereInput[]
    OR?: TicketMessageWhereInput[]
    NOT?: TicketMessageWhereInput | TicketMessageWhereInput[]
    ticketId?: StringFilter<"TicketMessage"> | string
    authorId?: StringFilter<"TicketMessage"> | string
    content?: StringFilter<"TicketMessage"> | string
    isDeleted?: BoolFilter<"TicketMessage"> | boolean
    createdAt?: DateTimeFilter<"TicketMessage"> | Date | string
    ticket?: XOR<TicketRelationFilter, TicketWhereInput>
    author?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type TicketMessageOrderByWithAggregationInput = {
    id?: SortOrder
    ticketId?: SortOrder
    authorId?: SortOrder
    content?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    _count?: TicketMessageCountOrderByAggregateInput
    _max?: TicketMessageMaxOrderByAggregateInput
    _min?: TicketMessageMinOrderByAggregateInput
  }

  export type TicketMessageScalarWhereWithAggregatesInput = {
    AND?: TicketMessageScalarWhereWithAggregatesInput | TicketMessageScalarWhereWithAggregatesInput[]
    OR?: TicketMessageScalarWhereWithAggregatesInput[]
    NOT?: TicketMessageScalarWhereWithAggregatesInput | TicketMessageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TicketMessage"> | string
    ticketId?: StringWithAggregatesFilter<"TicketMessage"> | string
    authorId?: StringWithAggregatesFilter<"TicketMessage"> | string
    content?: StringWithAggregatesFilter<"TicketMessage"> | string
    isDeleted?: BoolWithAggregatesFilter<"TicketMessage"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"TicketMessage"> | Date | string
  }

  export type PurchaseWhereInput = {
    AND?: PurchaseWhereInput | PurchaseWhereInput[]
    OR?: PurchaseWhereInput[]
    NOT?: PurchaseWhereInput | PurchaseWhereInput[]
    id?: StringFilter<"Purchase"> | string
    userId?: StringFilter<"Purchase"> | string
    provider?: StringFilter<"Purchase"> | string
    externalId?: StringNullableFilter<"Purchase"> | string | null
    status?: StringFilter<"Purchase"> | string
    amountCents?: IntFilter<"Purchase"> | number
    currency?: StringFilter<"Purchase"> | string
    meta?: StringNullableFilter<"Purchase"> | string | null
    createdAt?: DateTimeFilter<"Purchase"> | Date | string
    updatedAt?: DateTimeFilter<"Purchase"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    items?: PurchaseItemListRelationFilter
  }

  export type PurchaseOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    provider?: SortOrder
    externalId?: SortOrderInput | SortOrder
    status?: SortOrder
    amountCents?: SortOrder
    currency?: SortOrder
    meta?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    items?: PurchaseItemOrderByRelationAggregateInput
  }

  export type PurchaseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PurchaseWhereInput | PurchaseWhereInput[]
    OR?: PurchaseWhereInput[]
    NOT?: PurchaseWhereInput | PurchaseWhereInput[]
    userId?: StringFilter<"Purchase"> | string
    provider?: StringFilter<"Purchase"> | string
    externalId?: StringNullableFilter<"Purchase"> | string | null
    status?: StringFilter<"Purchase"> | string
    amountCents?: IntFilter<"Purchase"> | number
    currency?: StringFilter<"Purchase"> | string
    meta?: StringNullableFilter<"Purchase"> | string | null
    createdAt?: DateTimeFilter<"Purchase"> | Date | string
    updatedAt?: DateTimeFilter<"Purchase"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    items?: PurchaseItemListRelationFilter
  }, "id">

  export type PurchaseOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    provider?: SortOrder
    externalId?: SortOrderInput | SortOrder
    status?: SortOrder
    amountCents?: SortOrder
    currency?: SortOrder
    meta?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PurchaseCountOrderByAggregateInput
    _avg?: PurchaseAvgOrderByAggregateInput
    _max?: PurchaseMaxOrderByAggregateInput
    _min?: PurchaseMinOrderByAggregateInput
    _sum?: PurchaseSumOrderByAggregateInput
  }

  export type PurchaseScalarWhereWithAggregatesInput = {
    AND?: PurchaseScalarWhereWithAggregatesInput | PurchaseScalarWhereWithAggregatesInput[]
    OR?: PurchaseScalarWhereWithAggregatesInput[]
    NOT?: PurchaseScalarWhereWithAggregatesInput | PurchaseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Purchase"> | string
    userId?: StringWithAggregatesFilter<"Purchase"> | string
    provider?: StringWithAggregatesFilter<"Purchase"> | string
    externalId?: StringNullableWithAggregatesFilter<"Purchase"> | string | null
    status?: StringWithAggregatesFilter<"Purchase"> | string
    amountCents?: IntWithAggregatesFilter<"Purchase"> | number
    currency?: StringWithAggregatesFilter<"Purchase"> | string
    meta?: StringNullableWithAggregatesFilter<"Purchase"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Purchase"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Purchase"> | Date | string
  }

  export type AuditLogWhereInput = {
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    actorId?: StringNullableFilter<"AuditLog"> | string | null
    action?: StringFilter<"AuditLog"> | string
    entityType?: StringFilter<"AuditLog"> | string
    entityId?: StringNullableFilter<"AuditLog"> | string | null
    ip?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    meta?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    actor?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type AuditLogOrderByWithRelationInput = {
    id?: SortOrder
    actorId?: SortOrderInput | SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrderInput | SortOrder
    ip?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    meta?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    actor?: UserOrderByWithRelationInput
  }

  export type AuditLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    actorId?: StringNullableFilter<"AuditLog"> | string | null
    action?: StringFilter<"AuditLog"> | string
    entityType?: StringFilter<"AuditLog"> | string
    entityId?: StringNullableFilter<"AuditLog"> | string | null
    ip?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    meta?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    actor?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id">

  export type AuditLogOrderByWithAggregationInput = {
    id?: SortOrder
    actorId?: SortOrderInput | SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrderInput | SortOrder
    ip?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    meta?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AuditLogCountOrderByAggregateInput
    _max?: AuditLogMaxOrderByAggregateInput
    _min?: AuditLogMinOrderByAggregateInput
  }

  export type AuditLogScalarWhereWithAggregatesInput = {
    AND?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    OR?: AuditLogScalarWhereWithAggregatesInput[]
    NOT?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AuditLog"> | string
    actorId?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    action?: StringWithAggregatesFilter<"AuditLog"> | string
    entityType?: StringWithAggregatesFilter<"AuditLog"> | string
    entityId?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    ip?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    meta?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AuditLog"> | Date | string
  }

  export type MpWebhookEventWhereInput = {
    AND?: MpWebhookEventWhereInput | MpWebhookEventWhereInput[]
    OR?: MpWebhookEventWhereInput[]
    NOT?: MpWebhookEventWhereInput | MpWebhookEventWhereInput[]
    id?: StringFilter<"MpWebhookEvent"> | string
    eventType?: StringNullableFilter<"MpWebhookEvent"> | string | null
    externalId?: StringNullableFilter<"MpWebhookEvent"> | string | null
    payload?: StringFilter<"MpWebhookEvent"> | string
    processed?: BoolFilter<"MpWebhookEvent"> | boolean
    createdAt?: DateTimeFilter<"MpWebhookEvent"> | Date | string
  }

  export type MpWebhookEventOrderByWithRelationInput = {
    id?: SortOrder
    eventType?: SortOrderInput | SortOrder
    externalId?: SortOrderInput | SortOrder
    payload?: SortOrder
    processed?: SortOrder
    createdAt?: SortOrder
  }

  export type MpWebhookEventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MpWebhookEventWhereInput | MpWebhookEventWhereInput[]
    OR?: MpWebhookEventWhereInput[]
    NOT?: MpWebhookEventWhereInput | MpWebhookEventWhereInput[]
    eventType?: StringNullableFilter<"MpWebhookEvent"> | string | null
    externalId?: StringNullableFilter<"MpWebhookEvent"> | string | null
    payload?: StringFilter<"MpWebhookEvent"> | string
    processed?: BoolFilter<"MpWebhookEvent"> | boolean
    createdAt?: DateTimeFilter<"MpWebhookEvent"> | Date | string
  }, "id">

  export type MpWebhookEventOrderByWithAggregationInput = {
    id?: SortOrder
    eventType?: SortOrderInput | SortOrder
    externalId?: SortOrderInput | SortOrder
    payload?: SortOrder
    processed?: SortOrder
    createdAt?: SortOrder
    _count?: MpWebhookEventCountOrderByAggregateInput
    _max?: MpWebhookEventMaxOrderByAggregateInput
    _min?: MpWebhookEventMinOrderByAggregateInput
  }

  export type MpWebhookEventScalarWhereWithAggregatesInput = {
    AND?: MpWebhookEventScalarWhereWithAggregatesInput | MpWebhookEventScalarWhereWithAggregatesInput[]
    OR?: MpWebhookEventScalarWhereWithAggregatesInput[]
    NOT?: MpWebhookEventScalarWhereWithAggregatesInput | MpWebhookEventScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MpWebhookEvent"> | string
    eventType?: StringNullableWithAggregatesFilter<"MpWebhookEvent"> | string | null
    externalId?: StringNullableWithAggregatesFilter<"MpWebhookEvent"> | string | null
    payload?: StringWithAggregatesFilter<"MpWebhookEvent"> | string
    processed?: BoolWithAggregatesFilter<"MpWebhookEvent"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"MpWebhookEvent"> | Date | string
  }

  export type RoleWhereInput = {
    AND?: RoleWhereInput | RoleWhereInput[]
    OR?: RoleWhereInput[]
    NOT?: RoleWhereInput | RoleWhereInput[]
    id?: StringFilter<"Role"> | string
    name?: StringFilter<"Role"> | string
    rank?: IntFilter<"Role"> | number
    category?: StringFilter<"Role"> | string
    description?: StringNullableFilter<"Role"> | string | null
    createdAt?: DateTimeFilter<"Role"> | Date | string
    colorHex?: StringNullableFilter<"Role"> | string | null
    permissions?: RolePermissionListRelationFilter
    users?: UserRoleListRelationFilter
  }

  export type RoleOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    rank?: SortOrder
    category?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    colorHex?: SortOrderInput | SortOrder
    permissions?: RolePermissionOrderByRelationAggregateInput
    users?: UserRoleOrderByRelationAggregateInput
  }

  export type RoleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: RoleWhereInput | RoleWhereInput[]
    OR?: RoleWhereInput[]
    NOT?: RoleWhereInput | RoleWhereInput[]
    rank?: IntFilter<"Role"> | number
    category?: StringFilter<"Role"> | string
    description?: StringNullableFilter<"Role"> | string | null
    createdAt?: DateTimeFilter<"Role"> | Date | string
    colorHex?: StringNullableFilter<"Role"> | string | null
    permissions?: RolePermissionListRelationFilter
    users?: UserRoleListRelationFilter
  }, "id" | "name">

  export type RoleOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    rank?: SortOrder
    category?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    colorHex?: SortOrderInput | SortOrder
    _count?: RoleCountOrderByAggregateInput
    _avg?: RoleAvgOrderByAggregateInput
    _max?: RoleMaxOrderByAggregateInput
    _min?: RoleMinOrderByAggregateInput
    _sum?: RoleSumOrderByAggregateInput
  }

  export type RoleScalarWhereWithAggregatesInput = {
    AND?: RoleScalarWhereWithAggregatesInput | RoleScalarWhereWithAggregatesInput[]
    OR?: RoleScalarWhereWithAggregatesInput[]
    NOT?: RoleScalarWhereWithAggregatesInput | RoleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Role"> | string
    name?: StringWithAggregatesFilter<"Role"> | string
    rank?: IntWithAggregatesFilter<"Role"> | number
    category?: StringWithAggregatesFilter<"Role"> | string
    description?: StringNullableWithAggregatesFilter<"Role"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Role"> | Date | string
    colorHex?: StringNullableWithAggregatesFilter<"Role"> | string | null
  }

  export type PermissionWhereInput = {
    AND?: PermissionWhereInput | PermissionWhereInput[]
    OR?: PermissionWhereInput[]
    NOT?: PermissionWhereInput | PermissionWhereInput[]
    id?: StringFilter<"Permission"> | string
    key?: StringFilter<"Permission"> | string
    description?: StringNullableFilter<"Permission"> | string | null
    createdAt?: DateTimeFilter<"Permission"> | Date | string
    roles?: RolePermissionListRelationFilter
  }

  export type PermissionOrderByWithRelationInput = {
    id?: SortOrder
    key?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    roles?: RolePermissionOrderByRelationAggregateInput
  }

  export type PermissionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    key?: string
    AND?: PermissionWhereInput | PermissionWhereInput[]
    OR?: PermissionWhereInput[]
    NOT?: PermissionWhereInput | PermissionWhereInput[]
    description?: StringNullableFilter<"Permission"> | string | null
    createdAt?: DateTimeFilter<"Permission"> | Date | string
    roles?: RolePermissionListRelationFilter
  }, "id" | "key">

  export type PermissionOrderByWithAggregationInput = {
    id?: SortOrder
    key?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: PermissionCountOrderByAggregateInput
    _max?: PermissionMaxOrderByAggregateInput
    _min?: PermissionMinOrderByAggregateInput
  }

  export type PermissionScalarWhereWithAggregatesInput = {
    AND?: PermissionScalarWhereWithAggregatesInput | PermissionScalarWhereWithAggregatesInput[]
    OR?: PermissionScalarWhereWithAggregatesInput[]
    NOT?: PermissionScalarWhereWithAggregatesInput | PermissionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Permission"> | string
    key?: StringWithAggregatesFilter<"Permission"> | string
    description?: StringNullableWithAggregatesFilter<"Permission"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Permission"> | Date | string
  }

  export type RolePermissionWhereInput = {
    AND?: RolePermissionWhereInput | RolePermissionWhereInput[]
    OR?: RolePermissionWhereInput[]
    NOT?: RolePermissionWhereInput | RolePermissionWhereInput[]
    roleId?: StringFilter<"RolePermission"> | string
    permissionId?: StringFilter<"RolePermission"> | string
    role?: XOR<RoleRelationFilter, RoleWhereInput>
    permission?: XOR<PermissionRelationFilter, PermissionWhereInput>
  }

  export type RolePermissionOrderByWithRelationInput = {
    roleId?: SortOrder
    permissionId?: SortOrder
    role?: RoleOrderByWithRelationInput
    permission?: PermissionOrderByWithRelationInput
  }

  export type RolePermissionWhereUniqueInput = Prisma.AtLeast<{
    roleId_permissionId?: RolePermissionRoleIdPermissionIdCompoundUniqueInput
    AND?: RolePermissionWhereInput | RolePermissionWhereInput[]
    OR?: RolePermissionWhereInput[]
    NOT?: RolePermissionWhereInput | RolePermissionWhereInput[]
    roleId?: StringFilter<"RolePermission"> | string
    permissionId?: StringFilter<"RolePermission"> | string
    role?: XOR<RoleRelationFilter, RoleWhereInput>
    permission?: XOR<PermissionRelationFilter, PermissionWhereInput>
  }, "roleId_permissionId">

  export type RolePermissionOrderByWithAggregationInput = {
    roleId?: SortOrder
    permissionId?: SortOrder
    _count?: RolePermissionCountOrderByAggregateInput
    _max?: RolePermissionMaxOrderByAggregateInput
    _min?: RolePermissionMinOrderByAggregateInput
  }

  export type RolePermissionScalarWhereWithAggregatesInput = {
    AND?: RolePermissionScalarWhereWithAggregatesInput | RolePermissionScalarWhereWithAggregatesInput[]
    OR?: RolePermissionScalarWhereWithAggregatesInput[]
    NOT?: RolePermissionScalarWhereWithAggregatesInput | RolePermissionScalarWhereWithAggregatesInput[]
    roleId?: StringWithAggregatesFilter<"RolePermission"> | string
    permissionId?: StringWithAggregatesFilter<"RolePermission"> | string
  }

  export type UserRoleWhereInput = {
    AND?: UserRoleWhereInput | UserRoleWhereInput[]
    OR?: UserRoleWhereInput[]
    NOT?: UserRoleWhereInput | UserRoleWhereInput[]
    userId?: StringFilter<"UserRole"> | string
    roleId?: StringFilter<"UserRole"> | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    role?: XOR<RoleRelationFilter, RoleWhereInput>
  }

  export type UserRoleOrderByWithRelationInput = {
    userId?: SortOrder
    roleId?: SortOrder
    user?: UserOrderByWithRelationInput
    role?: RoleOrderByWithRelationInput
  }

  export type UserRoleWhereUniqueInput = Prisma.AtLeast<{
    userId_roleId?: UserRoleUserIdRoleIdCompoundUniqueInput
    AND?: UserRoleWhereInput | UserRoleWhereInput[]
    OR?: UserRoleWhereInput[]
    NOT?: UserRoleWhereInput | UserRoleWhereInput[]
    userId?: StringFilter<"UserRole"> | string
    roleId?: StringFilter<"UserRole"> | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    role?: XOR<RoleRelationFilter, RoleWhereInput>
  }, "userId_roleId">

  export type UserRoleOrderByWithAggregationInput = {
    userId?: SortOrder
    roleId?: SortOrder
    _count?: UserRoleCountOrderByAggregateInput
    _max?: UserRoleMaxOrderByAggregateInput
    _min?: UserRoleMinOrderByAggregateInput
  }

  export type UserRoleScalarWhereWithAggregatesInput = {
    AND?: UserRoleScalarWhereWithAggregatesInput | UserRoleScalarWhereWithAggregatesInput[]
    OR?: UserRoleScalarWhereWithAggregatesInput[]
    NOT?: UserRoleScalarWhereWithAggregatesInput | UserRoleScalarWhereWithAggregatesInput[]
    userId?: StringWithAggregatesFilter<"UserRole"> | string
    roleId?: StringWithAggregatesFilter<"UserRole"> | string
  }

  export type WhitelistConfigWhereInput = {
    AND?: WhitelistConfigWhereInput | WhitelistConfigWhereInput[]
    OR?: WhitelistConfigWhereInput[]
    NOT?: WhitelistConfigWhereInput | WhitelistConfigWhereInput[]
    id?: StringFilter<"WhitelistConfig"> | string
    enabled?: BoolFilter<"WhitelistConfig"> | boolean
    pausedUntil?: DateTimeNullableFilter<"WhitelistConfig"> | Date | string | null
    successTitle?: StringFilter<"WhitelistConfig"> | string
    successBody?: StringFilter<"WhitelistConfig"> | string
    createdAt?: DateTimeFilter<"WhitelistConfig"> | Date | string
    updatedAt?: DateTimeFilter<"WhitelistConfig"> | Date | string
  }

  export type WhitelistConfigOrderByWithRelationInput = {
    id?: SortOrder
    enabled?: SortOrder
    pausedUntil?: SortOrderInput | SortOrder
    successTitle?: SortOrder
    successBody?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WhitelistConfigWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WhitelistConfigWhereInput | WhitelistConfigWhereInput[]
    OR?: WhitelistConfigWhereInput[]
    NOT?: WhitelistConfigWhereInput | WhitelistConfigWhereInput[]
    enabled?: BoolFilter<"WhitelistConfig"> | boolean
    pausedUntil?: DateTimeNullableFilter<"WhitelistConfig"> | Date | string | null
    successTitle?: StringFilter<"WhitelistConfig"> | string
    successBody?: StringFilter<"WhitelistConfig"> | string
    createdAt?: DateTimeFilter<"WhitelistConfig"> | Date | string
    updatedAt?: DateTimeFilter<"WhitelistConfig"> | Date | string
  }, "id">

  export type WhitelistConfigOrderByWithAggregationInput = {
    id?: SortOrder
    enabled?: SortOrder
    pausedUntil?: SortOrderInput | SortOrder
    successTitle?: SortOrder
    successBody?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: WhitelistConfigCountOrderByAggregateInput
    _max?: WhitelistConfigMaxOrderByAggregateInput
    _min?: WhitelistConfigMinOrderByAggregateInput
  }

  export type WhitelistConfigScalarWhereWithAggregatesInput = {
    AND?: WhitelistConfigScalarWhereWithAggregatesInput | WhitelistConfigScalarWhereWithAggregatesInput[]
    OR?: WhitelistConfigScalarWhereWithAggregatesInput[]
    NOT?: WhitelistConfigScalarWhereWithAggregatesInput | WhitelistConfigScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WhitelistConfig"> | string
    enabled?: BoolWithAggregatesFilter<"WhitelistConfig"> | boolean
    pausedUntil?: DateTimeNullableWithAggregatesFilter<"WhitelistConfig"> | Date | string | null
    successTitle?: StringWithAggregatesFilter<"WhitelistConfig"> | string
    successBody?: StringWithAggregatesFilter<"WhitelistConfig"> | string
    createdAt?: DateTimeWithAggregatesFilter<"WhitelistConfig"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"WhitelistConfig"> | Date | string
  }

  export type WhitelistQuestionWhereInput = {
    AND?: WhitelistQuestionWhereInput | WhitelistQuestionWhereInput[]
    OR?: WhitelistQuestionWhereInput[]
    NOT?: WhitelistQuestionWhereInput | WhitelistQuestionWhereInput[]
    id?: StringFilter<"WhitelistQuestion"> | string
    prompt?: StringFilter<"WhitelistQuestion"> | string
    required?: BoolFilter<"WhitelistQuestion"> | boolean
    order?: IntFilter<"WhitelistQuestion"> | number
    createdAt?: DateTimeFilter<"WhitelistQuestion"> | Date | string
    answers?: WhitelistAnswerListRelationFilter
  }

  export type WhitelistQuestionOrderByWithRelationInput = {
    id?: SortOrder
    prompt?: SortOrder
    required?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    answers?: WhitelistAnswerOrderByRelationAggregateInput
  }

  export type WhitelistQuestionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WhitelistQuestionWhereInput | WhitelistQuestionWhereInput[]
    OR?: WhitelistQuestionWhereInput[]
    NOT?: WhitelistQuestionWhereInput | WhitelistQuestionWhereInput[]
    prompt?: StringFilter<"WhitelistQuestion"> | string
    required?: BoolFilter<"WhitelistQuestion"> | boolean
    order?: IntFilter<"WhitelistQuestion"> | number
    createdAt?: DateTimeFilter<"WhitelistQuestion"> | Date | string
    answers?: WhitelistAnswerListRelationFilter
  }, "id">

  export type WhitelistQuestionOrderByWithAggregationInput = {
    id?: SortOrder
    prompt?: SortOrder
    required?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    _count?: WhitelistQuestionCountOrderByAggregateInput
    _avg?: WhitelistQuestionAvgOrderByAggregateInput
    _max?: WhitelistQuestionMaxOrderByAggregateInput
    _min?: WhitelistQuestionMinOrderByAggregateInput
    _sum?: WhitelistQuestionSumOrderByAggregateInput
  }

  export type WhitelistQuestionScalarWhereWithAggregatesInput = {
    AND?: WhitelistQuestionScalarWhereWithAggregatesInput | WhitelistQuestionScalarWhereWithAggregatesInput[]
    OR?: WhitelistQuestionScalarWhereWithAggregatesInput[]
    NOT?: WhitelistQuestionScalarWhereWithAggregatesInput | WhitelistQuestionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WhitelistQuestion"> | string
    prompt?: StringWithAggregatesFilter<"WhitelistQuestion"> | string
    required?: BoolWithAggregatesFilter<"WhitelistQuestion"> | boolean
    order?: IntWithAggregatesFilter<"WhitelistQuestion"> | number
    createdAt?: DateTimeWithAggregatesFilter<"WhitelistQuestion"> | Date | string
  }

  export type WhitelistApplicationWhereInput = {
    AND?: WhitelistApplicationWhereInput | WhitelistApplicationWhereInput[]
    OR?: WhitelistApplicationWhereInput[]
    NOT?: WhitelistApplicationWhereInput | WhitelistApplicationWhereInput[]
    id?: StringFilter<"WhitelistApplication"> | string
    userId?: StringFilter<"WhitelistApplication"> | string
    status?: StringFilter<"WhitelistApplication"> | string
    reviewerId?: StringNullableFilter<"WhitelistApplication"> | string | null
    rejectReason?: StringNullableFilter<"WhitelistApplication"> | string | null
    createdAt?: DateTimeFilter<"WhitelistApplication"> | Date | string
    reviewedAt?: DateTimeNullableFilter<"WhitelistApplication"> | Date | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
    reviewer?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    answers?: WhitelistAnswerListRelationFilter
  }

  export type WhitelistApplicationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    reviewerId?: SortOrderInput | SortOrder
    rejectReason?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    reviewedAt?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    reviewer?: UserOrderByWithRelationInput
    answers?: WhitelistAnswerOrderByRelationAggregateInput
  }

  export type WhitelistApplicationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WhitelistApplicationWhereInput | WhitelistApplicationWhereInput[]
    OR?: WhitelistApplicationWhereInput[]
    NOT?: WhitelistApplicationWhereInput | WhitelistApplicationWhereInput[]
    userId?: StringFilter<"WhitelistApplication"> | string
    status?: StringFilter<"WhitelistApplication"> | string
    reviewerId?: StringNullableFilter<"WhitelistApplication"> | string | null
    rejectReason?: StringNullableFilter<"WhitelistApplication"> | string | null
    createdAt?: DateTimeFilter<"WhitelistApplication"> | Date | string
    reviewedAt?: DateTimeNullableFilter<"WhitelistApplication"> | Date | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
    reviewer?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    answers?: WhitelistAnswerListRelationFilter
  }, "id">

  export type WhitelistApplicationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    reviewerId?: SortOrderInput | SortOrder
    rejectReason?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    reviewedAt?: SortOrderInput | SortOrder
    _count?: WhitelistApplicationCountOrderByAggregateInput
    _max?: WhitelistApplicationMaxOrderByAggregateInput
    _min?: WhitelistApplicationMinOrderByAggregateInput
  }

  export type WhitelistApplicationScalarWhereWithAggregatesInput = {
    AND?: WhitelistApplicationScalarWhereWithAggregatesInput | WhitelistApplicationScalarWhereWithAggregatesInput[]
    OR?: WhitelistApplicationScalarWhereWithAggregatesInput[]
    NOT?: WhitelistApplicationScalarWhereWithAggregatesInput | WhitelistApplicationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WhitelistApplication"> | string
    userId?: StringWithAggregatesFilter<"WhitelistApplication"> | string
    status?: StringWithAggregatesFilter<"WhitelistApplication"> | string
    reviewerId?: StringNullableWithAggregatesFilter<"WhitelistApplication"> | string | null
    rejectReason?: StringNullableWithAggregatesFilter<"WhitelistApplication"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"WhitelistApplication"> | Date | string
    reviewedAt?: DateTimeNullableWithAggregatesFilter<"WhitelistApplication"> | Date | string | null
  }

  export type WhitelistAnswerWhereInput = {
    AND?: WhitelistAnswerWhereInput | WhitelistAnswerWhereInput[]
    OR?: WhitelistAnswerWhereInput[]
    NOT?: WhitelistAnswerWhereInput | WhitelistAnswerWhereInput[]
    id?: StringFilter<"WhitelistAnswer"> | string
    applicationId?: StringFilter<"WhitelistAnswer"> | string
    questionId?: StringFilter<"WhitelistAnswer"> | string
    value?: StringFilter<"WhitelistAnswer"> | string
    createdAt?: DateTimeFilter<"WhitelistAnswer"> | Date | string
    application?: XOR<WhitelistApplicationRelationFilter, WhitelistApplicationWhereInput>
    question?: XOR<WhitelistQuestionRelationFilter, WhitelistQuestionWhereInput>
  }

  export type WhitelistAnswerOrderByWithRelationInput = {
    id?: SortOrder
    applicationId?: SortOrder
    questionId?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
    application?: WhitelistApplicationOrderByWithRelationInput
    question?: WhitelistQuestionOrderByWithRelationInput
  }

  export type WhitelistAnswerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WhitelistAnswerWhereInput | WhitelistAnswerWhereInput[]
    OR?: WhitelistAnswerWhereInput[]
    NOT?: WhitelistAnswerWhereInput | WhitelistAnswerWhereInput[]
    applicationId?: StringFilter<"WhitelistAnswer"> | string
    questionId?: StringFilter<"WhitelistAnswer"> | string
    value?: StringFilter<"WhitelistAnswer"> | string
    createdAt?: DateTimeFilter<"WhitelistAnswer"> | Date | string
    application?: XOR<WhitelistApplicationRelationFilter, WhitelistApplicationWhereInput>
    question?: XOR<WhitelistQuestionRelationFilter, WhitelistQuestionWhereInput>
  }, "id">

  export type WhitelistAnswerOrderByWithAggregationInput = {
    id?: SortOrder
    applicationId?: SortOrder
    questionId?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
    _count?: WhitelistAnswerCountOrderByAggregateInput
    _max?: WhitelistAnswerMaxOrderByAggregateInput
    _min?: WhitelistAnswerMinOrderByAggregateInput
  }

  export type WhitelistAnswerScalarWhereWithAggregatesInput = {
    AND?: WhitelistAnswerScalarWhereWithAggregatesInput | WhitelistAnswerScalarWhereWithAggregatesInput[]
    OR?: WhitelistAnswerScalarWhereWithAggregatesInput[]
    NOT?: WhitelistAnswerScalarWhereWithAggregatesInput | WhitelistAnswerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WhitelistAnswer"> | string
    applicationId?: StringWithAggregatesFilter<"WhitelistAnswer"> | string
    questionId?: StringWithAggregatesFilter<"WhitelistAnswer"> | string
    value?: StringWithAggregatesFilter<"WhitelistAnswer"> | string
    createdAt?: DateTimeWithAggregatesFilter<"WhitelistAnswer"> | Date | string
  }

  export type BadgeWhereInput = {
    AND?: BadgeWhereInput | BadgeWhereInput[]
    OR?: BadgeWhereInput[]
    NOT?: BadgeWhereInput | BadgeWhereInput[]
    id?: StringFilter<"Badge"> | string
    name?: StringFilter<"Badge"> | string
    description?: StringNullableFilter<"Badge"> | string | null
    icon?: StringNullableFilter<"Badge"> | string | null
    createdAt?: DateTimeFilter<"Badge"> | Date | string
    users?: UserBadgeListRelationFilter
  }

  export type BadgeOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    users?: UserBadgeOrderByRelationAggregateInput
  }

  export type BadgeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BadgeWhereInput | BadgeWhereInput[]
    OR?: BadgeWhereInput[]
    NOT?: BadgeWhereInput | BadgeWhereInput[]
    name?: StringFilter<"Badge"> | string
    description?: StringNullableFilter<"Badge"> | string | null
    icon?: StringNullableFilter<"Badge"> | string | null
    createdAt?: DateTimeFilter<"Badge"> | Date | string
    users?: UserBadgeListRelationFilter
  }, "id">

  export type BadgeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: BadgeCountOrderByAggregateInput
    _max?: BadgeMaxOrderByAggregateInput
    _min?: BadgeMinOrderByAggregateInput
  }

  export type BadgeScalarWhereWithAggregatesInput = {
    AND?: BadgeScalarWhereWithAggregatesInput | BadgeScalarWhereWithAggregatesInput[]
    OR?: BadgeScalarWhereWithAggregatesInput[]
    NOT?: BadgeScalarWhereWithAggregatesInput | BadgeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Badge"> | string
    name?: StringWithAggregatesFilter<"Badge"> | string
    description?: StringNullableWithAggregatesFilter<"Badge"> | string | null
    icon?: StringNullableWithAggregatesFilter<"Badge"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Badge"> | Date | string
  }

  export type UserBadgeWhereInput = {
    AND?: UserBadgeWhereInput | UserBadgeWhereInput[]
    OR?: UserBadgeWhereInput[]
    NOT?: UserBadgeWhereInput | UserBadgeWhereInput[]
    userId?: StringFilter<"UserBadge"> | string
    badgeId?: StringFilter<"UserBadge"> | string
    createdAt?: DateTimeFilter<"UserBadge"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    badge?: XOR<BadgeRelationFilter, BadgeWhereInput>
  }

  export type UserBadgeOrderByWithRelationInput = {
    userId?: SortOrder
    badgeId?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    badge?: BadgeOrderByWithRelationInput
  }

  export type UserBadgeWhereUniqueInput = Prisma.AtLeast<{
    userId_badgeId?: UserBadgeUserIdBadgeIdCompoundUniqueInput
    AND?: UserBadgeWhereInput | UserBadgeWhereInput[]
    OR?: UserBadgeWhereInput[]
    NOT?: UserBadgeWhereInput | UserBadgeWhereInput[]
    userId?: StringFilter<"UserBadge"> | string
    badgeId?: StringFilter<"UserBadge"> | string
    createdAt?: DateTimeFilter<"UserBadge"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    badge?: XOR<BadgeRelationFilter, BadgeWhereInput>
  }, "userId_badgeId">

  export type UserBadgeOrderByWithAggregationInput = {
    userId?: SortOrder
    badgeId?: SortOrder
    createdAt?: SortOrder
    _count?: UserBadgeCountOrderByAggregateInput
    _max?: UserBadgeMaxOrderByAggregateInput
    _min?: UserBadgeMinOrderByAggregateInput
  }

  export type UserBadgeScalarWhereWithAggregatesInput = {
    AND?: UserBadgeScalarWhereWithAggregatesInput | UserBadgeScalarWhereWithAggregatesInput[]
    OR?: UserBadgeScalarWhereWithAggregatesInput[]
    NOT?: UserBadgeScalarWhereWithAggregatesInput | UserBadgeScalarWhereWithAggregatesInput[]
    userId?: StringWithAggregatesFilter<"UserBadge"> | string
    badgeId?: StringWithAggregatesFilter<"UserBadge"> | string
    createdAt?: DateTimeWithAggregatesFilter<"UserBadge"> | Date | string
  }

  export type ConversationWhereInput = {
    AND?: ConversationWhereInput | ConversationWhereInput[]
    OR?: ConversationWhereInput[]
    NOT?: ConversationWhereInput | ConversationWhereInput[]
    id?: StringFilter<"Conversation"> | string
    createdAt?: DateTimeFilter<"Conversation"> | Date | string
    updatedAt?: DateTimeFilter<"Conversation"> | Date | string
    participants?: ConversationParticipantListRelationFilter
    messages?: DirectMessageListRelationFilter
  }

  export type ConversationOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    participants?: ConversationParticipantOrderByRelationAggregateInput
    messages?: DirectMessageOrderByRelationAggregateInput
  }

  export type ConversationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ConversationWhereInput | ConversationWhereInput[]
    OR?: ConversationWhereInput[]
    NOT?: ConversationWhereInput | ConversationWhereInput[]
    createdAt?: DateTimeFilter<"Conversation"> | Date | string
    updatedAt?: DateTimeFilter<"Conversation"> | Date | string
    participants?: ConversationParticipantListRelationFilter
    messages?: DirectMessageListRelationFilter
  }, "id">

  export type ConversationOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ConversationCountOrderByAggregateInput
    _max?: ConversationMaxOrderByAggregateInput
    _min?: ConversationMinOrderByAggregateInput
  }

  export type ConversationScalarWhereWithAggregatesInput = {
    AND?: ConversationScalarWhereWithAggregatesInput | ConversationScalarWhereWithAggregatesInput[]
    OR?: ConversationScalarWhereWithAggregatesInput[]
    NOT?: ConversationScalarWhereWithAggregatesInput | ConversationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Conversation"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Conversation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Conversation"> | Date | string
  }

  export type ConversationParticipantWhereInput = {
    AND?: ConversationParticipantWhereInput | ConversationParticipantWhereInput[]
    OR?: ConversationParticipantWhereInput[]
    NOT?: ConversationParticipantWhereInput | ConversationParticipantWhereInput[]
    conversationId?: StringFilter<"ConversationParticipant"> | string
    userId?: StringFilter<"ConversationParticipant"> | string
    createdAt?: DateTimeFilter<"ConversationParticipant"> | Date | string
    conversation?: XOR<ConversationRelationFilter, ConversationWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type ConversationParticipantOrderByWithRelationInput = {
    conversationId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    conversation?: ConversationOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type ConversationParticipantWhereUniqueInput = Prisma.AtLeast<{
    conversationId_userId?: ConversationParticipantConversationIdUserIdCompoundUniqueInput
    AND?: ConversationParticipantWhereInput | ConversationParticipantWhereInput[]
    OR?: ConversationParticipantWhereInput[]
    NOT?: ConversationParticipantWhereInput | ConversationParticipantWhereInput[]
    conversationId?: StringFilter<"ConversationParticipant"> | string
    userId?: StringFilter<"ConversationParticipant"> | string
    createdAt?: DateTimeFilter<"ConversationParticipant"> | Date | string
    conversation?: XOR<ConversationRelationFilter, ConversationWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "conversationId_userId">

  export type ConversationParticipantOrderByWithAggregationInput = {
    conversationId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    _count?: ConversationParticipantCountOrderByAggregateInput
    _max?: ConversationParticipantMaxOrderByAggregateInput
    _min?: ConversationParticipantMinOrderByAggregateInput
  }

  export type ConversationParticipantScalarWhereWithAggregatesInput = {
    AND?: ConversationParticipantScalarWhereWithAggregatesInput | ConversationParticipantScalarWhereWithAggregatesInput[]
    OR?: ConversationParticipantScalarWhereWithAggregatesInput[]
    NOT?: ConversationParticipantScalarWhereWithAggregatesInput | ConversationParticipantScalarWhereWithAggregatesInput[]
    conversationId?: StringWithAggregatesFilter<"ConversationParticipant"> | string
    userId?: StringWithAggregatesFilter<"ConversationParticipant"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ConversationParticipant"> | Date | string
  }

  export type DirectMessageWhereInput = {
    AND?: DirectMessageWhereInput | DirectMessageWhereInput[]
    OR?: DirectMessageWhereInput[]
    NOT?: DirectMessageWhereInput | DirectMessageWhereInput[]
    id?: StringFilter<"DirectMessage"> | string
    conversationId?: StringFilter<"DirectMessage"> | string
    senderId?: StringFilter<"DirectMessage"> | string
    receiverId?: StringFilter<"DirectMessage"> | string
    content?: StringFilter<"DirectMessage"> | string
    kind?: StringFilter<"DirectMessage"> | string
    isDeleted?: BoolFilter<"DirectMessage"> | boolean
    createdAt?: DateTimeFilter<"DirectMessage"> | Date | string
    conversation?: XOR<ConversationRelationFilter, ConversationWhereInput>
    sender?: XOR<UserRelationFilter, UserWhereInput>
    receiver?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type DirectMessageOrderByWithRelationInput = {
    id?: SortOrder
    conversationId?: SortOrder
    senderId?: SortOrder
    receiverId?: SortOrder
    content?: SortOrder
    kind?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    conversation?: ConversationOrderByWithRelationInput
    sender?: UserOrderByWithRelationInput
    receiver?: UserOrderByWithRelationInput
  }

  export type DirectMessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DirectMessageWhereInput | DirectMessageWhereInput[]
    OR?: DirectMessageWhereInput[]
    NOT?: DirectMessageWhereInput | DirectMessageWhereInput[]
    conversationId?: StringFilter<"DirectMessage"> | string
    senderId?: StringFilter<"DirectMessage"> | string
    receiverId?: StringFilter<"DirectMessage"> | string
    content?: StringFilter<"DirectMessage"> | string
    kind?: StringFilter<"DirectMessage"> | string
    isDeleted?: BoolFilter<"DirectMessage"> | boolean
    createdAt?: DateTimeFilter<"DirectMessage"> | Date | string
    conversation?: XOR<ConversationRelationFilter, ConversationWhereInput>
    sender?: XOR<UserRelationFilter, UserWhereInput>
    receiver?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type DirectMessageOrderByWithAggregationInput = {
    id?: SortOrder
    conversationId?: SortOrder
    senderId?: SortOrder
    receiverId?: SortOrder
    content?: SortOrder
    kind?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    _count?: DirectMessageCountOrderByAggregateInput
    _max?: DirectMessageMaxOrderByAggregateInput
    _min?: DirectMessageMinOrderByAggregateInput
  }

  export type DirectMessageScalarWhereWithAggregatesInput = {
    AND?: DirectMessageScalarWhereWithAggregatesInput | DirectMessageScalarWhereWithAggregatesInput[]
    OR?: DirectMessageScalarWhereWithAggregatesInput[]
    NOT?: DirectMessageScalarWhereWithAggregatesInput | DirectMessageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DirectMessage"> | string
    conversationId?: StringWithAggregatesFilter<"DirectMessage"> | string
    senderId?: StringWithAggregatesFilter<"DirectMessage"> | string
    receiverId?: StringWithAggregatesFilter<"DirectMessage"> | string
    content?: StringWithAggregatesFilter<"DirectMessage"> | string
    kind?: StringWithAggregatesFilter<"DirectMessage"> | string
    isDeleted?: BoolWithAggregatesFilter<"DirectMessage"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"DirectMessage"> | Date | string
  }

  export type BankInfoWhereInput = {
    AND?: BankInfoWhereInput | BankInfoWhereInput[]
    OR?: BankInfoWhereInput[]
    NOT?: BankInfoWhereInput | BankInfoWhereInput[]
    id?: StringFilter<"BankInfo"> | string
    label?: StringFilter<"BankInfo"> | string
    holderName?: StringNullableFilter<"BankInfo"> | string | null
    pixKey?: StringNullableFilter<"BankInfo"> | string | null
    bankName?: StringNullableFilter<"BankInfo"> | string | null
    agency?: StringNullableFilter<"BankInfo"> | string | null
    accountNumber?: StringNullableFilter<"BankInfo"> | string | null
    notes?: StringNullableFilter<"BankInfo"> | string | null
    createdAt?: DateTimeFilter<"BankInfo"> | Date | string
    updatedAt?: DateTimeFilter<"BankInfo"> | Date | string
  }

  export type BankInfoOrderByWithRelationInput = {
    id?: SortOrder
    label?: SortOrder
    holderName?: SortOrderInput | SortOrder
    pixKey?: SortOrderInput | SortOrder
    bankName?: SortOrderInput | SortOrder
    agency?: SortOrderInput | SortOrder
    accountNumber?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BankInfoWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BankInfoWhereInput | BankInfoWhereInput[]
    OR?: BankInfoWhereInput[]
    NOT?: BankInfoWhereInput | BankInfoWhereInput[]
    label?: StringFilter<"BankInfo"> | string
    holderName?: StringNullableFilter<"BankInfo"> | string | null
    pixKey?: StringNullableFilter<"BankInfo"> | string | null
    bankName?: StringNullableFilter<"BankInfo"> | string | null
    agency?: StringNullableFilter<"BankInfo"> | string | null
    accountNumber?: StringNullableFilter<"BankInfo"> | string | null
    notes?: StringNullableFilter<"BankInfo"> | string | null
    createdAt?: DateTimeFilter<"BankInfo"> | Date | string
    updatedAt?: DateTimeFilter<"BankInfo"> | Date | string
  }, "id">

  export type BankInfoOrderByWithAggregationInput = {
    id?: SortOrder
    label?: SortOrder
    holderName?: SortOrderInput | SortOrder
    pixKey?: SortOrderInput | SortOrder
    bankName?: SortOrderInput | SortOrder
    agency?: SortOrderInput | SortOrder
    accountNumber?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BankInfoCountOrderByAggregateInput
    _max?: BankInfoMaxOrderByAggregateInput
    _min?: BankInfoMinOrderByAggregateInput
  }

  export type BankInfoScalarWhereWithAggregatesInput = {
    AND?: BankInfoScalarWhereWithAggregatesInput | BankInfoScalarWhereWithAggregatesInput[]
    OR?: BankInfoScalarWhereWithAggregatesInput[]
    NOT?: BankInfoScalarWhereWithAggregatesInput | BankInfoScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BankInfo"> | string
    label?: StringWithAggregatesFilter<"BankInfo"> | string
    holderName?: StringNullableWithAggregatesFilter<"BankInfo"> | string | null
    pixKey?: StringNullableWithAggregatesFilter<"BankInfo"> | string | null
    bankName?: StringNullableWithAggregatesFilter<"BankInfo"> | string | null
    agency?: StringNullableWithAggregatesFilter<"BankInfo"> | string | null
    accountNumber?: StringNullableWithAggregatesFilter<"BankInfo"> | string | null
    notes?: StringNullableWithAggregatesFilter<"BankInfo"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"BankInfo"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BankInfo"> | Date | string
  }

  export type SiteSettingWhereInput = {
    AND?: SiteSettingWhereInput | SiteSettingWhereInput[]
    OR?: SiteSettingWhereInput[]
    NOT?: SiteSettingWhereInput | SiteSettingWhereInput[]
    key?: StringFilter<"SiteSetting"> | string
    value?: StringFilter<"SiteSetting"> | string
    updatedAt?: DateTimeFilter<"SiteSetting"> | Date | string
  }

  export type SiteSettingOrderByWithRelationInput = {
    key?: SortOrder
    value?: SortOrder
    updatedAt?: SortOrder
  }

  export type SiteSettingWhereUniqueInput = Prisma.AtLeast<{
    key?: string
    AND?: SiteSettingWhereInput | SiteSettingWhereInput[]
    OR?: SiteSettingWhereInput[]
    NOT?: SiteSettingWhereInput | SiteSettingWhereInput[]
    value?: StringFilter<"SiteSetting"> | string
    updatedAt?: DateTimeFilter<"SiteSetting"> | Date | string
  }, "key">

  export type SiteSettingOrderByWithAggregationInput = {
    key?: SortOrder
    value?: SortOrder
    updatedAt?: SortOrder
    _count?: SiteSettingCountOrderByAggregateInput
    _max?: SiteSettingMaxOrderByAggregateInput
    _min?: SiteSettingMinOrderByAggregateInput
  }

  export type SiteSettingScalarWhereWithAggregatesInput = {
    AND?: SiteSettingScalarWhereWithAggregatesInput | SiteSettingScalarWhereWithAggregatesInput[]
    OR?: SiteSettingScalarWhereWithAggregatesInput[]
    NOT?: SiteSettingScalarWhereWithAggregatesInput | SiteSettingScalarWhereWithAggregatesInput[]
    key?: StringWithAggregatesFilter<"SiteSetting"> | string
    value?: StringWithAggregatesFilter<"SiteSetting"> | string
    updatedAt?: DateTimeWithAggregatesFilter<"SiteSetting"> | Date | string
  }

  export type GameAccountWhereInput = {
    AND?: GameAccountWhereInput | GameAccountWhereInput[]
    OR?: GameAccountWhereInput[]
    NOT?: GameAccountWhereInput | GameAccountWhereInput[]
    id?: StringFilter<"GameAccount"> | string
    userId?: StringFilter<"GameAccount"> | string
    mtaSerial?: StringFilter<"GameAccount"> | string
    mtaAccount?: StringNullableFilter<"GameAccount"> | string | null
    locked?: BoolFilter<"GameAccount"> | boolean
    changedAfterApproved?: BoolFilter<"GameAccount"> | boolean
    createdAt?: DateTimeFilter<"GameAccount"> | Date | string
    updatedAt?: DateTimeFilter<"GameAccount"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type GameAccountOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    mtaSerial?: SortOrder
    mtaAccount?: SortOrderInput | SortOrder
    locked?: SortOrder
    changedAfterApproved?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type GameAccountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    mtaSerial?: string
    AND?: GameAccountWhereInput | GameAccountWhereInput[]
    OR?: GameAccountWhereInput[]
    NOT?: GameAccountWhereInput | GameAccountWhereInput[]
    mtaAccount?: StringNullableFilter<"GameAccount"> | string | null
    locked?: BoolFilter<"GameAccount"> | boolean
    changedAfterApproved?: BoolFilter<"GameAccount"> | boolean
    createdAt?: DateTimeFilter<"GameAccount"> | Date | string
    updatedAt?: DateTimeFilter<"GameAccount"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "userId" | "mtaSerial">

  export type GameAccountOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    mtaSerial?: SortOrder
    mtaAccount?: SortOrderInput | SortOrder
    locked?: SortOrder
    changedAfterApproved?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: GameAccountCountOrderByAggregateInput
    _max?: GameAccountMaxOrderByAggregateInput
    _min?: GameAccountMinOrderByAggregateInput
  }

  export type GameAccountScalarWhereWithAggregatesInput = {
    AND?: GameAccountScalarWhereWithAggregatesInput | GameAccountScalarWhereWithAggregatesInput[]
    OR?: GameAccountScalarWhereWithAggregatesInput[]
    NOT?: GameAccountScalarWhereWithAggregatesInput | GameAccountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"GameAccount"> | string
    userId?: StringWithAggregatesFilter<"GameAccount"> | string
    mtaSerial?: StringWithAggregatesFilter<"GameAccount"> | string
    mtaAccount?: StringNullableWithAggregatesFilter<"GameAccount"> | string | null
    locked?: BoolWithAggregatesFilter<"GameAccount"> | boolean
    changedAfterApproved?: BoolWithAggregatesFilter<"GameAccount"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"GameAccount"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"GameAccount"> | Date | string
  }

  export type TicketParticipantWhereInput = {
    AND?: TicketParticipantWhereInput | TicketParticipantWhereInput[]
    OR?: TicketParticipantWhereInput[]
    NOT?: TicketParticipantWhereInput | TicketParticipantWhereInput[]
    ticketId?: StringFilter<"TicketParticipant"> | string
    userId?: StringFilter<"TicketParticipant"> | string
    addedById?: StringNullableFilter<"TicketParticipant"> | string | null
    createdAt?: DateTimeFilter<"TicketParticipant"> | Date | string
    ticket?: XOR<TicketRelationFilter, TicketWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
    addedBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type TicketParticipantOrderByWithRelationInput = {
    ticketId?: SortOrder
    userId?: SortOrder
    addedById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    ticket?: TicketOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    addedBy?: UserOrderByWithRelationInput
  }

  export type TicketParticipantWhereUniqueInput = Prisma.AtLeast<{
    ticketId_userId?: TicketParticipantTicketIdUserIdCompoundUniqueInput
    AND?: TicketParticipantWhereInput | TicketParticipantWhereInput[]
    OR?: TicketParticipantWhereInput[]
    NOT?: TicketParticipantWhereInput | TicketParticipantWhereInput[]
    ticketId?: StringFilter<"TicketParticipant"> | string
    userId?: StringFilter<"TicketParticipant"> | string
    addedById?: StringNullableFilter<"TicketParticipant"> | string | null
    createdAt?: DateTimeFilter<"TicketParticipant"> | Date | string
    ticket?: XOR<TicketRelationFilter, TicketWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
    addedBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "ticketId_userId">

  export type TicketParticipantOrderByWithAggregationInput = {
    ticketId?: SortOrder
    userId?: SortOrder
    addedById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: TicketParticipantCountOrderByAggregateInput
    _max?: TicketParticipantMaxOrderByAggregateInput
    _min?: TicketParticipantMinOrderByAggregateInput
  }

  export type TicketParticipantScalarWhereWithAggregatesInput = {
    AND?: TicketParticipantScalarWhereWithAggregatesInput | TicketParticipantScalarWhereWithAggregatesInput[]
    OR?: TicketParticipantScalarWhereWithAggregatesInput[]
    NOT?: TicketParticipantScalarWhereWithAggregatesInput | TicketParticipantScalarWhereWithAggregatesInput[]
    ticketId?: StringWithAggregatesFilter<"TicketParticipant"> | string
    userId?: StringWithAggregatesFilter<"TicketParticipant"> | string
    addedById?: StringNullableWithAggregatesFilter<"TicketParticipant"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"TicketParticipant"> | Date | string
  }

  export type TicketRatingWhereInput = {
    AND?: TicketRatingWhereInput | TicketRatingWhereInput[]
    OR?: TicketRatingWhereInput[]
    NOT?: TicketRatingWhereInput | TicketRatingWhereInput[]
    id?: StringFilter<"TicketRating"> | string
    ticketId?: StringFilter<"TicketRating"> | string
    raterUserId?: StringFilter<"TicketRating"> | string
    targetUserId?: StringFilter<"TicketRating"> | string
    stars?: IntFilter<"TicketRating"> | number
    feedback?: StringFilter<"TicketRating"> | string
    createdAt?: DateTimeFilter<"TicketRating"> | Date | string
    ticket?: XOR<TicketRelationFilter, TicketWhereInput>
    rater?: XOR<UserRelationFilter, UserWhereInput>
    target?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type TicketRatingOrderByWithRelationInput = {
    id?: SortOrder
    ticketId?: SortOrder
    raterUserId?: SortOrder
    targetUserId?: SortOrder
    stars?: SortOrder
    feedback?: SortOrder
    createdAt?: SortOrder
    ticket?: TicketOrderByWithRelationInput
    rater?: UserOrderByWithRelationInput
    target?: UserOrderByWithRelationInput
  }

  export type TicketRatingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    ticketId_raterUserId_targetUserId?: TicketRatingTicketIdRaterUserIdTargetUserIdCompoundUniqueInput
    AND?: TicketRatingWhereInput | TicketRatingWhereInput[]
    OR?: TicketRatingWhereInput[]
    NOT?: TicketRatingWhereInput | TicketRatingWhereInput[]
    ticketId?: StringFilter<"TicketRating"> | string
    raterUserId?: StringFilter<"TicketRating"> | string
    targetUserId?: StringFilter<"TicketRating"> | string
    stars?: IntFilter<"TicketRating"> | number
    feedback?: StringFilter<"TicketRating"> | string
    createdAt?: DateTimeFilter<"TicketRating"> | Date | string
    ticket?: XOR<TicketRelationFilter, TicketWhereInput>
    rater?: XOR<UserRelationFilter, UserWhereInput>
    target?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "ticketId_raterUserId_targetUserId">

  export type TicketRatingOrderByWithAggregationInput = {
    id?: SortOrder
    ticketId?: SortOrder
    raterUserId?: SortOrder
    targetUserId?: SortOrder
    stars?: SortOrder
    feedback?: SortOrder
    createdAt?: SortOrder
    _count?: TicketRatingCountOrderByAggregateInput
    _avg?: TicketRatingAvgOrderByAggregateInput
    _max?: TicketRatingMaxOrderByAggregateInput
    _min?: TicketRatingMinOrderByAggregateInput
    _sum?: TicketRatingSumOrderByAggregateInput
  }

  export type TicketRatingScalarWhereWithAggregatesInput = {
    AND?: TicketRatingScalarWhereWithAggregatesInput | TicketRatingScalarWhereWithAggregatesInput[]
    OR?: TicketRatingScalarWhereWithAggregatesInput[]
    NOT?: TicketRatingScalarWhereWithAggregatesInput | TicketRatingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TicketRating"> | string
    ticketId?: StringWithAggregatesFilter<"TicketRating"> | string
    raterUserId?: StringWithAggregatesFilter<"TicketRating"> | string
    targetUserId?: StringWithAggregatesFilter<"TicketRating"> | string
    stars?: IntWithAggregatesFilter<"TicketRating"> | number
    feedback?: StringWithAggregatesFilter<"TicketRating"> | string
    createdAt?: DateTimeWithAggregatesFilter<"TicketRating"> | Date | string
  }

  export type MtaAccessLogWhereInput = {
    AND?: MtaAccessLogWhereInput | MtaAccessLogWhereInput[]
    OR?: MtaAccessLogWhereInput[]
    NOT?: MtaAccessLogWhereInput | MtaAccessLogWhereInput[]
    id?: StringFilter<"MtaAccessLog"> | string
    serial?: StringFilter<"MtaAccessLog"> | string
    userId?: StringNullableFilter<"MtaAccessLog"> | string | null
    allowed?: BoolFilter<"MtaAccessLog"> | boolean
    reason?: StringNullableFilter<"MtaAccessLog"> | string | null
    ip?: StringNullableFilter<"MtaAccessLog"> | string | null
    createdAt?: DateTimeFilter<"MtaAccessLog"> | Date | string
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type MtaAccessLogOrderByWithRelationInput = {
    id?: SortOrder
    serial?: SortOrder
    userId?: SortOrderInput | SortOrder
    allowed?: SortOrder
    reason?: SortOrderInput | SortOrder
    ip?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type MtaAccessLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MtaAccessLogWhereInput | MtaAccessLogWhereInput[]
    OR?: MtaAccessLogWhereInput[]
    NOT?: MtaAccessLogWhereInput | MtaAccessLogWhereInput[]
    serial?: StringFilter<"MtaAccessLog"> | string
    userId?: StringNullableFilter<"MtaAccessLog"> | string | null
    allowed?: BoolFilter<"MtaAccessLog"> | boolean
    reason?: StringNullableFilter<"MtaAccessLog"> | string | null
    ip?: StringNullableFilter<"MtaAccessLog"> | string | null
    createdAt?: DateTimeFilter<"MtaAccessLog"> | Date | string
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id">

  export type MtaAccessLogOrderByWithAggregationInput = {
    id?: SortOrder
    serial?: SortOrder
    userId?: SortOrderInput | SortOrder
    allowed?: SortOrder
    reason?: SortOrderInput | SortOrder
    ip?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: MtaAccessLogCountOrderByAggregateInput
    _max?: MtaAccessLogMaxOrderByAggregateInput
    _min?: MtaAccessLogMinOrderByAggregateInput
  }

  export type MtaAccessLogScalarWhereWithAggregatesInput = {
    AND?: MtaAccessLogScalarWhereWithAggregatesInput | MtaAccessLogScalarWhereWithAggregatesInput[]
    OR?: MtaAccessLogScalarWhereWithAggregatesInput[]
    NOT?: MtaAccessLogScalarWhereWithAggregatesInput | MtaAccessLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MtaAccessLog"> | string
    serial?: StringWithAggregatesFilter<"MtaAccessLog"> | string
    userId?: StringNullableWithAggregatesFilter<"MtaAccessLog"> | string | null
    allowed?: BoolWithAggregatesFilter<"MtaAccessLog"> | boolean
    reason?: StringNullableWithAggregatesFilter<"MtaAccessLog"> | string | null
    ip?: StringNullableWithAggregatesFilter<"MtaAccessLog"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"MtaAccessLog"> | Date | string
  }

  export type TicketRatingRequirementWhereInput = {
    AND?: TicketRatingRequirementWhereInput | TicketRatingRequirementWhereInput[]
    OR?: TicketRatingRequirementWhereInput[]
    NOT?: TicketRatingRequirementWhereInput | TicketRatingRequirementWhereInput[]
    id?: StringFilter<"TicketRatingRequirement"> | string
    ticketId?: StringFilter<"TicketRatingRequirement"> | string
    raterId?: StringFilter<"TicketRatingRequirement"> | string
    targetId?: StringFilter<"TicketRatingRequirement"> | string
    completed?: BoolFilter<"TicketRatingRequirement"> | boolean
    createdAt?: DateTimeFilter<"TicketRatingRequirement"> | Date | string
    ticket?: XOR<TicketRelationFilter, TicketWhereInput>
    rater?: XOR<UserRelationFilter, UserWhereInput>
    target?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type TicketRatingRequirementOrderByWithRelationInput = {
    id?: SortOrder
    ticketId?: SortOrder
    raterId?: SortOrder
    targetId?: SortOrder
    completed?: SortOrder
    createdAt?: SortOrder
    ticket?: TicketOrderByWithRelationInput
    rater?: UserOrderByWithRelationInput
    target?: UserOrderByWithRelationInput
  }

  export type TicketRatingRequirementWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    ticketId_raterId_targetId?: TicketRatingRequirementTicketIdRaterIdTargetIdCompoundUniqueInput
    AND?: TicketRatingRequirementWhereInput | TicketRatingRequirementWhereInput[]
    OR?: TicketRatingRequirementWhereInput[]
    NOT?: TicketRatingRequirementWhereInput | TicketRatingRequirementWhereInput[]
    ticketId?: StringFilter<"TicketRatingRequirement"> | string
    raterId?: StringFilter<"TicketRatingRequirement"> | string
    targetId?: StringFilter<"TicketRatingRequirement"> | string
    completed?: BoolFilter<"TicketRatingRequirement"> | boolean
    createdAt?: DateTimeFilter<"TicketRatingRequirement"> | Date | string
    ticket?: XOR<TicketRelationFilter, TicketWhereInput>
    rater?: XOR<UserRelationFilter, UserWhereInput>
    target?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "ticketId_raterId_targetId">

  export type TicketRatingRequirementOrderByWithAggregationInput = {
    id?: SortOrder
    ticketId?: SortOrder
    raterId?: SortOrder
    targetId?: SortOrder
    completed?: SortOrder
    createdAt?: SortOrder
    _count?: TicketRatingRequirementCountOrderByAggregateInput
    _max?: TicketRatingRequirementMaxOrderByAggregateInput
    _min?: TicketRatingRequirementMinOrderByAggregateInput
  }

  export type TicketRatingRequirementScalarWhereWithAggregatesInput = {
    AND?: TicketRatingRequirementScalarWhereWithAggregatesInput | TicketRatingRequirementScalarWhereWithAggregatesInput[]
    OR?: TicketRatingRequirementScalarWhereWithAggregatesInput[]
    NOT?: TicketRatingRequirementScalarWhereWithAggregatesInput | TicketRatingRequirementScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TicketRatingRequirement"> | string
    ticketId?: StringWithAggregatesFilter<"TicketRatingRequirement"> | string
    raterId?: StringWithAggregatesFilter<"TicketRatingRequirement"> | string
    targetId?: StringWithAggregatesFilter<"TicketRatingRequirement"> | string
    completed?: BoolWithAggregatesFilter<"TicketRatingRequirement"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"TicketRatingRequirement"> | Date | string
  }

  export type PasswordResetTokenWhereInput = {
    AND?: PasswordResetTokenWhereInput | PasswordResetTokenWhereInput[]
    OR?: PasswordResetTokenWhereInput[]
    NOT?: PasswordResetTokenWhereInput | PasswordResetTokenWhereInput[]
    id?: StringFilter<"PasswordResetToken"> | string
    userId?: StringFilter<"PasswordResetToken"> | string
    code?: StringFilter<"PasswordResetToken"> | string
    expiresAt?: DateTimeFilter<"PasswordResetToken"> | Date | string
    usedAt?: DateTimeNullableFilter<"PasswordResetToken"> | Date | string | null
    createdAt?: DateTimeFilter<"PasswordResetToken"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type PasswordResetTokenOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    code?: SortOrder
    expiresAt?: SortOrder
    usedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type PasswordResetTokenWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PasswordResetTokenWhereInput | PasswordResetTokenWhereInput[]
    OR?: PasswordResetTokenWhereInput[]
    NOT?: PasswordResetTokenWhereInput | PasswordResetTokenWhereInput[]
    userId?: StringFilter<"PasswordResetToken"> | string
    code?: StringFilter<"PasswordResetToken"> | string
    expiresAt?: DateTimeFilter<"PasswordResetToken"> | Date | string
    usedAt?: DateTimeNullableFilter<"PasswordResetToken"> | Date | string | null
    createdAt?: DateTimeFilter<"PasswordResetToken"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type PasswordResetTokenOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    code?: SortOrder
    expiresAt?: SortOrder
    usedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: PasswordResetTokenCountOrderByAggregateInput
    _max?: PasswordResetTokenMaxOrderByAggregateInput
    _min?: PasswordResetTokenMinOrderByAggregateInput
  }

  export type PasswordResetTokenScalarWhereWithAggregatesInput = {
    AND?: PasswordResetTokenScalarWhereWithAggregatesInput | PasswordResetTokenScalarWhereWithAggregatesInput[]
    OR?: PasswordResetTokenScalarWhereWithAggregatesInput[]
    NOT?: PasswordResetTokenScalarWhereWithAggregatesInput | PasswordResetTokenScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PasswordResetToken"> | string
    userId?: StringWithAggregatesFilter<"PasswordResetToken"> | string
    code?: StringWithAggregatesFilter<"PasswordResetToken"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"PasswordResetToken"> | Date | string
    usedAt?: DateTimeNullableWithAggregatesFilter<"PasswordResetToken"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"PasswordResetToken"> | Date | string
  }

  export type ProductCreateInput = {
    id?: string
    sku: string
    name: string
    description?: string | null
    priceCents: number
    currency?: string
    durationDays?: number | null
    grantPoints?: number
    grantVipRole?: string | null
    mtaActions?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseItems?: PurchaseItemCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateInput = {
    id?: string
    sku: string
    name: string
    description?: string | null
    priceCents: number
    currency?: string
    durationDays?: number | null
    grantPoints?: number
    grantVipRole?: string | null
    mtaActions?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseItems?: PurchaseItemUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priceCents?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    durationDays?: NullableIntFieldUpdateOperationsInput | number | null
    grantPoints?: IntFieldUpdateOperationsInput | number
    grantVipRole?: NullableStringFieldUpdateOperationsInput | string | null
    mtaActions?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseItems?: PurchaseItemUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priceCents?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    durationDays?: NullableIntFieldUpdateOperationsInput | number | null
    grantPoints?: IntFieldUpdateOperationsInput | number
    grantVipRole?: NullableStringFieldUpdateOperationsInput | string | null
    mtaActions?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseItems?: PurchaseItemUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductCreateManyInput = {
    id?: string
    sku: string
    name: string
    description?: string | null
    priceCents: number
    currency?: string
    durationDays?: number | null
    grantPoints?: number
    grantVipRole?: string | null
    mtaActions?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priceCents?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    durationDays?: NullableIntFieldUpdateOperationsInput | number | null
    grantPoints?: IntFieldUpdateOperationsInput | number
    grantVipRole?: NullableStringFieldUpdateOperationsInput | string | null
    mtaActions?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priceCents?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    durationDays?: NullableIntFieldUpdateOperationsInput | number | null
    grantPoints?: IntFieldUpdateOperationsInput | number
    grantVipRole?: NullableStringFieldUpdateOperationsInput | string | null
    mtaActions?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CouponCreateInput = {
    id?: string
    code: string
    percentOff?: number | null
    amountOffCents?: number | null
    maxUses?: number | null
    uses?: number
    expiresAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
  }

  export type CouponUncheckedCreateInput = {
    id?: string
    code: string
    percentOff?: number | null
    amountOffCents?: number | null
    maxUses?: number | null
    uses?: number
    expiresAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
  }

  export type CouponUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    percentOff?: NullableIntFieldUpdateOperationsInput | number | null
    amountOffCents?: NullableIntFieldUpdateOperationsInput | number | null
    maxUses?: NullableIntFieldUpdateOperationsInput | number | null
    uses?: IntFieldUpdateOperationsInput | number
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CouponUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    percentOff?: NullableIntFieldUpdateOperationsInput | number | null
    amountOffCents?: NullableIntFieldUpdateOperationsInput | number | null
    maxUses?: NullableIntFieldUpdateOperationsInput | number | null
    uses?: IntFieldUpdateOperationsInput | number
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CouponCreateManyInput = {
    id?: string
    code: string
    percentOff?: number | null
    amountOffCents?: number | null
    maxUses?: number | null
    uses?: number
    expiresAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
  }

  export type CouponUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    percentOff?: NullableIntFieldUpdateOperationsInput | number | null
    amountOffCents?: NullableIntFieldUpdateOperationsInput | number | null
    maxUses?: NullableIntFieldUpdateOperationsInput | number | null
    uses?: IntFieldUpdateOperationsInput | number
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CouponUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    percentOff?: NullableIntFieldUpdateOperationsInput | number | null
    amountOffCents?: NullableIntFieldUpdateOperationsInput | number | null
    maxUses?: NullableIntFieldUpdateOperationsInput | number | null
    uses?: IntFieldUpdateOperationsInput | number
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseItemCreateInput = {
    id?: string
    sku: string
    name: string
    priceCents: number
    durationDays?: number | null
    grantPoints?: number
    grantVipRole?: string | null
    mtaActions?: string | null
    purchase: PurchaseCreateNestedOneWithoutItemsInput
    product: ProductCreateNestedOneWithoutPurchaseItemsInput
  }

  export type PurchaseItemUncheckedCreateInput = {
    id?: string
    purchaseId: string
    productId: string
    sku: string
    name: string
    priceCents: number
    durationDays?: number | null
    grantPoints?: number
    grantVipRole?: string | null
    mtaActions?: string | null
  }

  export type PurchaseItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    priceCents?: IntFieldUpdateOperationsInput | number
    durationDays?: NullableIntFieldUpdateOperationsInput | number | null
    grantPoints?: IntFieldUpdateOperationsInput | number
    grantVipRole?: NullableStringFieldUpdateOperationsInput | string | null
    mtaActions?: NullableStringFieldUpdateOperationsInput | string | null
    purchase?: PurchaseUpdateOneRequiredWithoutItemsNestedInput
    product?: ProductUpdateOneRequiredWithoutPurchaseItemsNestedInput
  }

  export type PurchaseItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    purchaseId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    priceCents?: IntFieldUpdateOperationsInput | number
    durationDays?: NullableIntFieldUpdateOperationsInput | number | null
    grantPoints?: IntFieldUpdateOperationsInput | number
    grantVipRole?: NullableStringFieldUpdateOperationsInput | string | null
    mtaActions?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PurchaseItemCreateManyInput = {
    id?: string
    purchaseId: string
    productId: string
    sku: string
    name: string
    priceCents: number
    durationDays?: number | null
    grantPoints?: number
    grantVipRole?: string | null
    mtaActions?: string | null
  }

  export type PurchaseItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    priceCents?: IntFieldUpdateOperationsInput | number
    durationDays?: NullableIntFieldUpdateOperationsInput | number | null
    grantPoints?: IntFieldUpdateOperationsInput | number
    grantVipRole?: NullableStringFieldUpdateOperationsInput | string | null
    mtaActions?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PurchaseItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    purchaseId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    priceCents?: IntFieldUpdateOperationsInput | number
    durationDays?: NullableIntFieldUpdateOperationsInput | number | null
    grantPoints?: IntFieldUpdateOperationsInput | number
    grantVipRole?: NullableStringFieldUpdateOperationsInput | string | null
    mtaActions?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EntitlementCreateInput = {
    id?: string
    roleName: string
    expiresAt: Date | string
    source?: string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutEntitlementsInput
  }

  export type EntitlementUncheckedCreateInput = {
    id?: string
    userId: string
    roleName: string
    expiresAt: Date | string
    source?: string | null
    createdAt?: Date | string
  }

  export type EntitlementUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    roleName?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutEntitlementsNestedInput
  }

  export type EntitlementUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    roleName?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EntitlementCreateManyInput = {
    id?: string
    userId: string
    roleName: string
    expiresAt: Date | string
    source?: string | null
    createdAt?: Date | string
  }

  export type EntitlementUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    roleName?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EntitlementUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    roleName?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateInput = {
    id?: string
    message: string
    href?: string | null
    read?: boolean
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: string
    userId: string
    message: string
    href?: string | null
    read?: boolean
    createdAt?: Date | string
  }

  export type NotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    href?: NullableStringFieldUpdateOperationsInput | string | null
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    href?: NullableStringFieldUpdateOperationsInput | string | null
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateManyInput = {
    id?: string
    userId: string
    message: string
    href?: string | null
    read?: boolean
    createdAt?: Date | string
  }

  export type NotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    href?: NullableStringFieldUpdateOperationsInput | string | null
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    href?: NullableStringFieldUpdateOperationsInput | string | null
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StaffShiftCreateInput = {
    id?: string
    openedAt: Date | string
    closedAt?: Date | string | null
    seconds?: number
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutStaffShiftsInput
  }

  export type StaffShiftUncheckedCreateInput = {
    id?: string
    userId: string
    openedAt: Date | string
    closedAt?: Date | string | null
    seconds?: number
    createdAt?: Date | string
  }

  export type StaffShiftUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    openedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    seconds?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStaffShiftsNestedInput
  }

  export type StaffShiftUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    openedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    seconds?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StaffShiftCreateManyInput = {
    id?: string
    userId: string
    openedAt: Date | string
    closedAt?: Date | string | null
    seconds?: number
    createdAt?: Date | string
  }

  export type StaffShiftUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    openedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    seconds?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StaffShiftUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    openedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    seconds?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StaffWeeklyRewardCreateInput = {
    id?: string
    position: number
    weekKey: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutStaffWeeklyRewardsInput
  }

  export type StaffWeeklyRewardUncheckedCreateInput = {
    id?: string
    userId: string
    position: number
    weekKey: string
    createdAt?: Date | string
  }

  export type StaffWeeklyRewardUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    weekKey?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStaffWeeklyRewardsNestedInput
  }

  export type StaffWeeklyRewardUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    weekKey?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StaffWeeklyRewardCreateManyInput = {
    id?: string
    userId: string
    position: number
    weekKey: string
    createdAt?: Date | string
  }

  export type StaffWeeklyRewardUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    weekKey?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StaffWeeklyRewardUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    weekKey?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminCaseCreateInput = {
    id?: string
    type: string
    reason: string
    expiresAt?: Date | string | null
    active?: boolean
    createdAt?: Date | string
    targetUser: UserCreateNestedOneWithoutAdminCasesTargetInput
    staffUser: UserCreateNestedOneWithoutAdminCasesStaffInput
  }

  export type AdminCaseUncheckedCreateInput = {
    id?: string
    targetUserId: string
    staffUserId: string
    type: string
    reason: string
    expiresAt?: Date | string | null
    active?: boolean
    createdAt?: Date | string
  }

  export type AdminCaseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    targetUser?: UserUpdateOneRequiredWithoutAdminCasesTargetNestedInput
    staffUser?: UserUpdateOneRequiredWithoutAdminCasesStaffNestedInput
  }

  export type AdminCaseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    targetUserId?: StringFieldUpdateOperationsInput | string
    staffUserId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminCaseCreateManyInput = {
    id?: string
    targetUserId: string
    staffUserId: string
    type: string
    reason: string
    expiresAt?: Date | string | null
    active?: boolean
    createdAt?: Date | string
  }

  export type AdminCaseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminCaseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    targetUserId?: StringFieldUpdateOperationsInput | string
    staffUserId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserReputationCreateInput = {
    score?: number
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutReputationInput
  }

  export type UserReputationUncheckedCreateInput = {
    userId: string
    score?: number
    updatedAt?: Date | string
  }

  export type UserReputationUpdateInput = {
    score?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutReputationNestedInput
  }

  export type UserReputationUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserReputationCreateManyInput = {
    userId: string
    score?: number
    updatedAt?: Date | string
  }

  export type UserReputationUpdateManyMutationInput = {
    score?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserReputationUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    emailVerifiedAt?: Date | string | null
    emailVerifyToken?: string | null
    emailVerifyExpiresAt?: Date | string | null
    phone?: string | null
    recoveryEmail?: string | null
    googleId?: string | null
    discordId?: string | null
    discordUsername?: string | null
    avatarKey?: string
    role?: string
    isDeleted?: boolean
    bannedUntil?: Date | string | null
    whitelistStatus?: string
    points?: number
    lastSeenAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    avatarUrl?: string | null
    topics?: TopicCreateNestedManyWithoutAuthorInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    tickets?: TicketCreateNestedManyWithoutAuthorInput
    assignedTickets?: TicketCreateNestedManyWithoutAssignedToInput
    ticketMsgs?: TicketMessageCreateNestedManyWithoutAuthorInput
    ticketParticipants?: TicketParticipantCreateNestedManyWithoutUserInput
    ticketParticipantsAdded?: TicketParticipantCreateNestedManyWithoutAddedByInput
    ticketRatingsGiven?: TicketRatingCreateNestedManyWithoutRaterInput
    ticketRatingsReceived?: TicketRatingCreateNestedManyWithoutTargetInput
    closedTickets?: TicketCreateNestedManyWithoutClosedByInput
    purchases?: PurchaseCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    whitelistApps?: WhitelistApplicationCreateNestedManyWithoutUserInput
    reviewedWhitelists?: WhitelistApplicationCreateNestedManyWithoutReviewerInput
    convoParts?: ConversationParticipantCreateNestedManyWithoutUserInput
    sentMessages?: DirectMessageCreateNestedManyWithoutSenderInput
    receivedMessages?: DirectMessageCreateNestedManyWithoutReceiverInput
    userBadges?: UserBadgeCreateNestedManyWithoutUserInput
    gameAccounts?: GameAccountCreateNestedManyWithoutUserInput
    mtaAccessLogs?: MtaAccessLogCreateNestedManyWithoutUserInput
    ticketRatingReqGiven?: TicketRatingRequirementCreateNestedManyWithoutRaterInput
    ticketRatingReqReceived?: TicketRatingRequirementCreateNestedManyWithoutTargetInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    entitlements?: EntitlementCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    staffShifts?: StaffShiftCreateNestedManyWithoutUserInput
    staffWeeklyRewards?: StaffWeeklyRewardCreateNestedManyWithoutUserInput
    adminCasesTarget?: AdminCaseCreateNestedManyWithoutTargetUserInput
    adminCasesStaff?: AdminCaseCreateNestedManyWithoutStaffUserInput
    reputation?: UserReputationCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    emailVerifiedAt?: Date | string | null
    emailVerifyToken?: string | null
    emailVerifyExpiresAt?: Date | string | null
    phone?: string | null
    recoveryEmail?: string | null
    googleId?: string | null
    discordId?: string | null
    discordUsername?: string | null
    avatarKey?: string
    role?: string
    isDeleted?: boolean
    bannedUntil?: Date | string | null
    whitelistStatus?: string
    points?: number
    lastSeenAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    avatarUrl?: string | null
    topics?: TopicUncheckedCreateNestedManyWithoutAuthorInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    tickets?: TicketUncheckedCreateNestedManyWithoutAuthorInput
    assignedTickets?: TicketUncheckedCreateNestedManyWithoutAssignedToInput
    ticketMsgs?: TicketMessageUncheckedCreateNestedManyWithoutAuthorInput
    ticketParticipants?: TicketParticipantUncheckedCreateNestedManyWithoutUserInput
    ticketParticipantsAdded?: TicketParticipantUncheckedCreateNestedManyWithoutAddedByInput
    ticketRatingsGiven?: TicketRatingUncheckedCreateNestedManyWithoutRaterInput
    ticketRatingsReceived?: TicketRatingUncheckedCreateNestedManyWithoutTargetInput
    closedTickets?: TicketUncheckedCreateNestedManyWithoutClosedByInput
    purchases?: PurchaseUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    whitelistApps?: WhitelistApplicationUncheckedCreateNestedManyWithoutUserInput
    reviewedWhitelists?: WhitelistApplicationUncheckedCreateNestedManyWithoutReviewerInput
    convoParts?: ConversationParticipantUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: DirectMessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: DirectMessageUncheckedCreateNestedManyWithoutReceiverInput
    userBadges?: UserBadgeUncheckedCreateNestedManyWithoutUserInput
    gameAccounts?: GameAccountUncheckedCreateNestedManyWithoutUserInput
    mtaAccessLogs?: MtaAccessLogUncheckedCreateNestedManyWithoutUserInput
    ticketRatingReqGiven?: TicketRatingRequirementUncheckedCreateNestedManyWithoutRaterInput
    ticketRatingReqReceived?: TicketRatingRequirementUncheckedCreateNestedManyWithoutTargetInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    entitlements?: EntitlementUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    staffShifts?: StaffShiftUncheckedCreateNestedManyWithoutUserInput
    staffWeeklyRewards?: StaffWeeklyRewardUncheckedCreateNestedManyWithoutUserInput
    adminCasesTarget?: AdminCaseUncheckedCreateNestedManyWithoutTargetUserInput
    adminCasesStaff?: AdminCaseUncheckedCreateNestedManyWithoutStaffUserInput
    reputation?: UserReputationUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifyToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerifyExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    discordId?: NullableStringFieldUpdateOperationsInput | string | null
    discordUsername?: NullableStringFieldUpdateOperationsInput | string | null
    avatarKey?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    bannedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    whitelistStatus?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    lastSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    topics?: TopicUpdateManyWithoutAuthorNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    tickets?: TicketUpdateManyWithoutAuthorNestedInput
    assignedTickets?: TicketUpdateManyWithoutAssignedToNestedInput
    ticketMsgs?: TicketMessageUpdateManyWithoutAuthorNestedInput
    ticketParticipants?: TicketParticipantUpdateManyWithoutUserNestedInput
    ticketParticipantsAdded?: TicketParticipantUpdateManyWithoutAddedByNestedInput
    ticketRatingsGiven?: TicketRatingUpdateManyWithoutRaterNestedInput
    ticketRatingsReceived?: TicketRatingUpdateManyWithoutTargetNestedInput
    closedTickets?: TicketUpdateManyWithoutClosedByNestedInput
    purchases?: PurchaseUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    whitelistApps?: WhitelistApplicationUpdateManyWithoutUserNestedInput
    reviewedWhitelists?: WhitelistApplicationUpdateManyWithoutReviewerNestedInput
    convoParts?: ConversationParticipantUpdateManyWithoutUserNestedInput
    sentMessages?: DirectMessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: DirectMessageUpdateManyWithoutReceiverNestedInput
    userBadges?: UserBadgeUpdateManyWithoutUserNestedInput
    gameAccounts?: GameAccountUpdateManyWithoutUserNestedInput
    mtaAccessLogs?: MtaAccessLogUpdateManyWithoutUserNestedInput
    ticketRatingReqGiven?: TicketRatingRequirementUpdateManyWithoutRaterNestedInput
    ticketRatingReqReceived?: TicketRatingRequirementUpdateManyWithoutTargetNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    entitlements?: EntitlementUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    staffShifts?: StaffShiftUpdateManyWithoutUserNestedInput
    staffWeeklyRewards?: StaffWeeklyRewardUpdateManyWithoutUserNestedInput
    adminCasesTarget?: AdminCaseUpdateManyWithoutTargetUserNestedInput
    adminCasesStaff?: AdminCaseUpdateManyWithoutStaffUserNestedInput
    reputation?: UserReputationUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifyToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerifyExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    discordId?: NullableStringFieldUpdateOperationsInput | string | null
    discordUsername?: NullableStringFieldUpdateOperationsInput | string | null
    avatarKey?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    bannedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    whitelistStatus?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    lastSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    topics?: TopicUncheckedUpdateManyWithoutAuthorNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutAuthorNestedInput
    assignedTickets?: TicketUncheckedUpdateManyWithoutAssignedToNestedInput
    ticketMsgs?: TicketMessageUncheckedUpdateManyWithoutAuthorNestedInput
    ticketParticipants?: TicketParticipantUncheckedUpdateManyWithoutUserNestedInput
    ticketParticipantsAdded?: TicketParticipantUncheckedUpdateManyWithoutAddedByNestedInput
    ticketRatingsGiven?: TicketRatingUncheckedUpdateManyWithoutRaterNestedInput
    ticketRatingsReceived?: TicketRatingUncheckedUpdateManyWithoutTargetNestedInput
    closedTickets?: TicketUncheckedUpdateManyWithoutClosedByNestedInput
    purchases?: PurchaseUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    whitelistApps?: WhitelistApplicationUncheckedUpdateManyWithoutUserNestedInput
    reviewedWhitelists?: WhitelistApplicationUncheckedUpdateManyWithoutReviewerNestedInput
    convoParts?: ConversationParticipantUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: DirectMessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: DirectMessageUncheckedUpdateManyWithoutReceiverNestedInput
    userBadges?: UserBadgeUncheckedUpdateManyWithoutUserNestedInput
    gameAccounts?: GameAccountUncheckedUpdateManyWithoutUserNestedInput
    mtaAccessLogs?: MtaAccessLogUncheckedUpdateManyWithoutUserNestedInput
    ticketRatingReqGiven?: TicketRatingRequirementUncheckedUpdateManyWithoutRaterNestedInput
    ticketRatingReqReceived?: TicketRatingRequirementUncheckedUpdateManyWithoutTargetNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    entitlements?: EntitlementUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    staffShifts?: StaffShiftUncheckedUpdateManyWithoutUserNestedInput
    staffWeeklyRewards?: StaffWeeklyRewardUncheckedUpdateManyWithoutUserNestedInput
    adminCasesTarget?: AdminCaseUncheckedUpdateManyWithoutTargetUserNestedInput
    adminCasesStaff?: AdminCaseUncheckedUpdateManyWithoutStaffUserNestedInput
    reputation?: UserReputationUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    emailVerifiedAt?: Date | string | null
    emailVerifyToken?: string | null
    emailVerifyExpiresAt?: Date | string | null
    phone?: string | null
    recoveryEmail?: string | null
    googleId?: string | null
    discordId?: string | null
    discordUsername?: string | null
    avatarKey?: string
    role?: string
    isDeleted?: boolean
    bannedUntil?: Date | string | null
    whitelistStatus?: string
    points?: number
    lastSeenAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    avatarUrl?: string | null
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifyToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerifyExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    discordId?: NullableStringFieldUpdateOperationsInput | string | null
    discordUsername?: NullableStringFieldUpdateOperationsInput | string | null
    avatarKey?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    bannedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    whitelistStatus?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    lastSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifyToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerifyExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    discordId?: NullableStringFieldUpdateOperationsInput | string | null
    discordUsername?: NullableStringFieldUpdateOperationsInput | string | null
    avatarKey?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    bannedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    whitelistStatus?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    lastSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ForumCategoryCreateInput = {
    id?: string
    name: string
    description?: string | null
    order?: number
    createdAt?: Date | string
    boards?: ForumBoardCreateNestedManyWithoutCategoryInput
  }

  export type ForumCategoryUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    order?: number
    createdAt?: Date | string
    boards?: ForumBoardUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type ForumCategoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    boards?: ForumBoardUpdateManyWithoutCategoryNestedInput
  }

  export type ForumCategoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    boards?: ForumBoardUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type ForumCategoryCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    order?: number
    createdAt?: Date | string
  }

  export type ForumCategoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ForumCategoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ForumBoardCreateInput = {
    id?: string
    name: string
    description?: string | null
    order?: number
    requireWhitelist?: boolean
    pointsOnTopic?: number
    pointsOnReply?: number
    allowReplies?: boolean
    createdAt?: Date | string
    category: ForumCategoryCreateNestedOneWithoutBoardsInput
    topics?: TopicCreateNestedManyWithoutBoardInput
  }

  export type ForumBoardUncheckedCreateInput = {
    id?: string
    categoryId: string
    name: string
    description?: string | null
    order?: number
    requireWhitelist?: boolean
    pointsOnTopic?: number
    pointsOnReply?: number
    allowReplies?: boolean
    createdAt?: Date | string
    topics?: TopicUncheckedCreateNestedManyWithoutBoardInput
  }

  export type ForumBoardUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    requireWhitelist?: BoolFieldUpdateOperationsInput | boolean
    pointsOnTopic?: IntFieldUpdateOperationsInput | number
    pointsOnReply?: IntFieldUpdateOperationsInput | number
    allowReplies?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: ForumCategoryUpdateOneRequiredWithoutBoardsNestedInput
    topics?: TopicUpdateManyWithoutBoardNestedInput
  }

  export type ForumBoardUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    requireWhitelist?: BoolFieldUpdateOperationsInput | boolean
    pointsOnTopic?: IntFieldUpdateOperationsInput | number
    pointsOnReply?: IntFieldUpdateOperationsInput | number
    allowReplies?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    topics?: TopicUncheckedUpdateManyWithoutBoardNestedInput
  }

  export type ForumBoardCreateManyInput = {
    id?: string
    categoryId: string
    name: string
    description?: string | null
    order?: number
    requireWhitelist?: boolean
    pointsOnTopic?: number
    pointsOnReply?: number
    allowReplies?: boolean
    createdAt?: Date | string
  }

  export type ForumBoardUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    requireWhitelist?: BoolFieldUpdateOperationsInput | boolean
    pointsOnTopic?: IntFieldUpdateOperationsInput | number
    pointsOnReply?: IntFieldUpdateOperationsInput | number
    allowReplies?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ForumBoardUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    requireWhitelist?: BoolFieldUpdateOperationsInput | boolean
    pointsOnTopic?: IntFieldUpdateOperationsInput | number
    pointsOnReply?: IntFieldUpdateOperationsInput | number
    allowReplies?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TopicCreateInput = {
    id?: string
    title: string
    status?: string
    pinned?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastPostAt?: Date | string
    board: ForumBoardCreateNestedOneWithoutTopicsInput
    author: UserCreateNestedOneWithoutTopicsInput
    posts?: PostCreateNestedManyWithoutTopicInput
  }

  export type TopicUncheckedCreateInput = {
    id?: string
    boardId: string
    authorId: string
    title: string
    status?: string
    pinned?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastPostAt?: Date | string
    posts?: PostUncheckedCreateNestedManyWithoutTopicInput
  }

  export type TopicUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    pinned?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastPostAt?: DateTimeFieldUpdateOperationsInput | Date | string
    board?: ForumBoardUpdateOneRequiredWithoutTopicsNestedInput
    author?: UserUpdateOneRequiredWithoutTopicsNestedInput
    posts?: PostUpdateManyWithoutTopicNestedInput
  }

  export type TopicUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    boardId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    pinned?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastPostAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posts?: PostUncheckedUpdateManyWithoutTopicNestedInput
  }

  export type TopicCreateManyInput = {
    id?: string
    boardId: string
    authorId: string
    title: string
    status?: string
    pinned?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastPostAt?: Date | string
  }

  export type TopicUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    pinned?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastPostAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TopicUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    boardId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    pinned?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastPostAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostCreateInput = {
    id?: string
    content: string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    topic: TopicCreateNestedOneWithoutPostsInput
    author: UserCreateNestedOneWithoutPostsInput
    attachments?: PostAttachmentCreateNestedManyWithoutPostInput
  }

  export type PostUncheckedCreateInput = {
    id?: string
    topicId: string
    authorId: string
    content: string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    attachments?: PostAttachmentUncheckedCreateNestedManyWithoutPostInput
  }

  export type PostUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    topic?: TopicUpdateOneRequiredWithoutPostsNestedInput
    author?: UserUpdateOneRequiredWithoutPostsNestedInput
    attachments?: PostAttachmentUpdateManyWithoutPostNestedInput
  }

  export type PostUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    topicId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attachments?: PostAttachmentUncheckedUpdateManyWithoutPostNestedInput
  }

  export type PostCreateManyInput = {
    id?: string
    topicId: string
    authorId: string
    content: string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PostUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    topicId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostAttachmentCreateInput = {
    id?: string
    url: string
    mime?: string | null
    size?: number | null
    createdAt?: Date | string
    post: PostCreateNestedOneWithoutAttachmentsInput
  }

  export type PostAttachmentUncheckedCreateInput = {
    id?: string
    postId: string
    url: string
    mime?: string | null
    size?: number | null
    createdAt?: Date | string
  }

  export type PostAttachmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    mime?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    post?: PostUpdateOneRequiredWithoutAttachmentsNestedInput
  }

  export type PostAttachmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    mime?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostAttachmentCreateManyInput = {
    id?: string
    postId: string
    url: string
    mime?: string | null
    size?: number | null
    createdAt?: Date | string
  }

  export type PostAttachmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    mime?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostAttachmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    mime?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketCategoryCreateInput = {
    id?: string
    slug: string
    name: string
    description?: string | null
    order?: number
    createdAt?: Date | string
    tickets?: TicketCreateNestedManyWithoutCategoryInput
  }

  export type TicketCategoryUncheckedCreateInput = {
    id?: string
    slug: string
    name: string
    description?: string | null
    order?: number
    createdAt?: Date | string
    tickets?: TicketUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type TicketCategoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tickets?: TicketUpdateManyWithoutCategoryNestedInput
  }

  export type TicketCategoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tickets?: TicketUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type TicketCategoryCreateManyInput = {
    id?: string
    slug: string
    name: string
    description?: string | null
    order?: number
    createdAt?: Date | string
  }

  export type TicketCategoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketCategoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketCreateInput = {
    id?: string
    title: string
    status?: string
    priority?: string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    closedAt?: Date | string | null
    category: TicketCategoryCreateNestedOneWithoutTicketsInput
    author: UserCreateNestedOneWithoutTicketsInput
    assignedTo?: UserCreateNestedOneWithoutAssignedTicketsInput
    closedBy?: UserCreateNestedOneWithoutClosedTicketsInput
    messages?: TicketMessageCreateNestedManyWithoutTicketInput
    participants?: TicketParticipantCreateNestedManyWithoutTicketInput
    ratings?: TicketRatingCreateNestedManyWithoutTicketInput
    ratingRequirements?: TicketRatingRequirementCreateNestedManyWithoutTicketInput
  }

  export type TicketUncheckedCreateInput = {
    id?: string
    categoryId: string
    authorId: string
    title: string
    status?: string
    priority?: string
    assignedToId?: string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    closedAt?: Date | string | null
    closedById?: string | null
    messages?: TicketMessageUncheckedCreateNestedManyWithoutTicketInput
    participants?: TicketParticipantUncheckedCreateNestedManyWithoutTicketInput
    ratings?: TicketRatingUncheckedCreateNestedManyWithoutTicketInput
    ratingRequirements?: TicketRatingRequirementUncheckedCreateNestedManyWithoutTicketInput
  }

  export type TicketUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: TicketCategoryUpdateOneRequiredWithoutTicketsNestedInput
    author?: UserUpdateOneRequiredWithoutTicketsNestedInput
    assignedTo?: UserUpdateOneWithoutAssignedTicketsNestedInput
    closedBy?: UserUpdateOneWithoutClosedTicketsNestedInput
    messages?: TicketMessageUpdateManyWithoutTicketNestedInput
    participants?: TicketParticipantUpdateManyWithoutTicketNestedInput
    ratings?: TicketRatingUpdateManyWithoutTicketNestedInput
    ratingRequirements?: TicketRatingRequirementUpdateManyWithoutTicketNestedInput
  }

  export type TicketUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedById?: NullableStringFieldUpdateOperationsInput | string | null
    messages?: TicketMessageUncheckedUpdateManyWithoutTicketNestedInput
    participants?: TicketParticipantUncheckedUpdateManyWithoutTicketNestedInput
    ratings?: TicketRatingUncheckedUpdateManyWithoutTicketNestedInput
    ratingRequirements?: TicketRatingRequirementUncheckedUpdateManyWithoutTicketNestedInput
  }

  export type TicketCreateManyInput = {
    id?: string
    categoryId: string
    authorId: string
    title: string
    status?: string
    priority?: string
    assignedToId?: string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    closedAt?: Date | string | null
    closedById?: string | null
  }

  export type TicketUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TicketUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TicketMessageCreateInput = {
    id?: string
    content: string
    isDeleted?: boolean
    createdAt?: Date | string
    ticket: TicketCreateNestedOneWithoutMessagesInput
    author: UserCreateNestedOneWithoutTicketMsgsInput
  }

  export type TicketMessageUncheckedCreateInput = {
    id?: string
    ticketId: string
    authorId: string
    content: string
    isDeleted?: boolean
    createdAt?: Date | string
  }

  export type TicketMessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ticket?: TicketUpdateOneRequiredWithoutMessagesNestedInput
    author?: UserUpdateOneRequiredWithoutTicketMsgsNestedInput
  }

  export type TicketMessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticketId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketMessageCreateManyInput = {
    id?: string
    ticketId: string
    authorId: string
    content: string
    isDeleted?: boolean
    createdAt?: Date | string
  }

  export type TicketMessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketMessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticketId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseCreateInput = {
    id?: string
    provider: string
    externalId?: string | null
    status?: string
    amountCents: number
    currency?: string
    meta?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPurchasesInput
    items?: PurchaseItemCreateNestedManyWithoutPurchaseInput
  }

  export type PurchaseUncheckedCreateInput = {
    id?: string
    userId: string
    provider: string
    externalId?: string | null
    status?: string
    amountCents: number
    currency?: string
    meta?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: PurchaseItemUncheckedCreateNestedManyWithoutPurchaseInput
  }

  export type PurchaseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    amountCents?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    meta?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPurchasesNestedInput
    items?: PurchaseItemUpdateManyWithoutPurchaseNestedInput
  }

  export type PurchaseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    amountCents?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    meta?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: PurchaseItemUncheckedUpdateManyWithoutPurchaseNestedInput
  }

  export type PurchaseCreateManyInput = {
    id?: string
    userId: string
    provider: string
    externalId?: string | null
    status?: string
    amountCents: number
    currency?: string
    meta?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    amountCents?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    meta?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    amountCents?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    meta?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateInput = {
    id?: string
    action: string
    entityType: string
    entityId?: string | null
    ip?: string | null
    userAgent?: string | null
    meta?: string | null
    createdAt?: Date | string
    actor?: UserCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateInput = {
    id?: string
    actorId?: string | null
    action: string
    entityType: string
    entityId?: string | null
    ip?: string | null
    userAgent?: string | null
    meta?: string | null
    createdAt?: Date | string
  }

  export type AuditLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    meta?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    actor?: UserUpdateOneWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    actorId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    meta?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateManyInput = {
    id?: string
    actorId?: string | null
    action: string
    entityType: string
    entityId?: string | null
    ip?: string | null
    userAgent?: string | null
    meta?: string | null
    createdAt?: Date | string
  }

  export type AuditLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    meta?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    actorId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    meta?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MpWebhookEventCreateInput = {
    id?: string
    eventType?: string | null
    externalId?: string | null
    payload: string
    processed?: boolean
    createdAt?: Date | string
  }

  export type MpWebhookEventUncheckedCreateInput = {
    id?: string
    eventType?: string | null
    externalId?: string | null
    payload: string
    processed?: boolean
    createdAt?: Date | string
  }

  export type MpWebhookEventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: NullableStringFieldUpdateOperationsInput | string | null
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    payload?: StringFieldUpdateOperationsInput | string
    processed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MpWebhookEventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: NullableStringFieldUpdateOperationsInput | string | null
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    payload?: StringFieldUpdateOperationsInput | string
    processed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MpWebhookEventCreateManyInput = {
    id?: string
    eventType?: string | null
    externalId?: string | null
    payload: string
    processed?: boolean
    createdAt?: Date | string
  }

  export type MpWebhookEventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: NullableStringFieldUpdateOperationsInput | string | null
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    payload?: StringFieldUpdateOperationsInput | string
    processed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MpWebhookEventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: NullableStringFieldUpdateOperationsInput | string | null
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    payload?: StringFieldUpdateOperationsInput | string
    processed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleCreateInput = {
    id?: string
    name: string
    rank?: number
    category?: string
    description?: string | null
    createdAt?: Date | string
    colorHex?: string | null
    permissions?: RolePermissionCreateNestedManyWithoutRoleInput
    users?: UserRoleCreateNestedManyWithoutRoleInput
  }

  export type RoleUncheckedCreateInput = {
    id?: string
    name: string
    rank?: number
    category?: string
    description?: string | null
    createdAt?: Date | string
    colorHex?: string | null
    permissions?: RolePermissionUncheckedCreateNestedManyWithoutRoleInput
    users?: UserRoleUncheckedCreateNestedManyWithoutRoleInput
  }

  export type RoleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    rank?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    colorHex?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: RolePermissionUpdateManyWithoutRoleNestedInput
    users?: UserRoleUpdateManyWithoutRoleNestedInput
  }

  export type RoleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    rank?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    colorHex?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: RolePermissionUncheckedUpdateManyWithoutRoleNestedInput
    users?: UserRoleUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type RoleCreateManyInput = {
    id?: string
    name: string
    rank?: number
    category?: string
    description?: string | null
    createdAt?: Date | string
    colorHex?: string | null
  }

  export type RoleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    rank?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    colorHex?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RoleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    rank?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    colorHex?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PermissionCreateInput = {
    id?: string
    key: string
    description?: string | null
    createdAt?: Date | string
    roles?: RolePermissionCreateNestedManyWithoutPermissionInput
  }

  export type PermissionUncheckedCreateInput = {
    id?: string
    key: string
    description?: string | null
    createdAt?: Date | string
    roles?: RolePermissionUncheckedCreateNestedManyWithoutPermissionInput
  }

  export type PermissionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roles?: RolePermissionUpdateManyWithoutPermissionNestedInput
  }

  export type PermissionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roles?: RolePermissionUncheckedUpdateManyWithoutPermissionNestedInput
  }

  export type PermissionCreateManyInput = {
    id?: string
    key: string
    description?: string | null
    createdAt?: Date | string
  }

  export type PermissionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PermissionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RolePermissionCreateInput = {
    role: RoleCreateNestedOneWithoutPermissionsInput
    permission: PermissionCreateNestedOneWithoutRolesInput
  }

  export type RolePermissionUncheckedCreateInput = {
    roleId: string
    permissionId: string
  }

  export type RolePermissionUpdateInput = {
    role?: RoleUpdateOneRequiredWithoutPermissionsNestedInput
    permission?: PermissionUpdateOneRequiredWithoutRolesNestedInput
  }

  export type RolePermissionUncheckedUpdateInput = {
    roleId?: StringFieldUpdateOperationsInput | string
    permissionId?: StringFieldUpdateOperationsInput | string
  }

  export type RolePermissionCreateManyInput = {
    roleId: string
    permissionId: string
  }

  export type RolePermissionUpdateManyMutationInput = {

  }

  export type RolePermissionUncheckedUpdateManyInput = {
    roleId?: StringFieldUpdateOperationsInput | string
    permissionId?: StringFieldUpdateOperationsInput | string
  }

  export type UserRoleCreateInput = {
    user: UserCreateNestedOneWithoutUserRolesInput
    role: RoleCreateNestedOneWithoutUsersInput
  }

  export type UserRoleUncheckedCreateInput = {
    userId: string
    roleId: string
  }

  export type UserRoleUpdateInput = {
    user?: UserUpdateOneRequiredWithoutUserRolesNestedInput
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserRoleUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
  }

  export type UserRoleCreateManyInput = {
    userId: string
    roleId: string
  }

  export type UserRoleUpdateManyMutationInput = {

  }

  export type UserRoleUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
  }

  export type WhitelistConfigCreateInput = {
    id?: string
    enabled?: boolean
    pausedUntil?: Date | string | null
    successTitle?: string
    successBody?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WhitelistConfigUncheckedCreateInput = {
    id?: string
    enabled?: boolean
    pausedUntil?: Date | string | null
    successTitle?: string
    successBody?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WhitelistConfigUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    pausedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    successTitle?: StringFieldUpdateOperationsInput | string
    successBody?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WhitelistConfigUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    pausedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    successTitle?: StringFieldUpdateOperationsInput | string
    successBody?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WhitelistConfigCreateManyInput = {
    id?: string
    enabled?: boolean
    pausedUntil?: Date | string | null
    successTitle?: string
    successBody?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WhitelistConfigUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    pausedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    successTitle?: StringFieldUpdateOperationsInput | string
    successBody?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WhitelistConfigUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    pausedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    successTitle?: StringFieldUpdateOperationsInput | string
    successBody?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WhitelistQuestionCreateInput = {
    id?: string
    prompt: string
    required?: boolean
    order?: number
    createdAt?: Date | string
    answers?: WhitelistAnswerCreateNestedManyWithoutQuestionInput
  }

  export type WhitelistQuestionUncheckedCreateInput = {
    id?: string
    prompt: string
    required?: boolean
    order?: number
    createdAt?: Date | string
    answers?: WhitelistAnswerUncheckedCreateNestedManyWithoutQuestionInput
  }

  export type WhitelistQuestionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    prompt?: StringFieldUpdateOperationsInput | string
    required?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    answers?: WhitelistAnswerUpdateManyWithoutQuestionNestedInput
  }

  export type WhitelistQuestionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    prompt?: StringFieldUpdateOperationsInput | string
    required?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    answers?: WhitelistAnswerUncheckedUpdateManyWithoutQuestionNestedInput
  }

  export type WhitelistQuestionCreateManyInput = {
    id?: string
    prompt: string
    required?: boolean
    order?: number
    createdAt?: Date | string
  }

  export type WhitelistQuestionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    prompt?: StringFieldUpdateOperationsInput | string
    required?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WhitelistQuestionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    prompt?: StringFieldUpdateOperationsInput | string
    required?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WhitelistApplicationCreateInput = {
    id?: string
    status?: string
    rejectReason?: string | null
    createdAt?: Date | string
    reviewedAt?: Date | string | null
    user: UserCreateNestedOneWithoutWhitelistAppsInput
    reviewer?: UserCreateNestedOneWithoutReviewedWhitelistsInput
    answers?: WhitelistAnswerCreateNestedManyWithoutApplicationInput
  }

  export type WhitelistApplicationUncheckedCreateInput = {
    id?: string
    userId: string
    status?: string
    reviewerId?: string | null
    rejectReason?: string | null
    createdAt?: Date | string
    reviewedAt?: Date | string | null
    answers?: WhitelistAnswerUncheckedCreateNestedManyWithoutApplicationInput
  }

  export type WhitelistApplicationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    rejectReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutWhitelistAppsNestedInput
    reviewer?: UserUpdateOneWithoutReviewedWhitelistsNestedInput
    answers?: WhitelistAnswerUpdateManyWithoutApplicationNestedInput
  }

  export type WhitelistApplicationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    reviewerId?: NullableStringFieldUpdateOperationsInput | string | null
    rejectReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    answers?: WhitelistAnswerUncheckedUpdateManyWithoutApplicationNestedInput
  }

  export type WhitelistApplicationCreateManyInput = {
    id?: string
    userId: string
    status?: string
    reviewerId?: string | null
    rejectReason?: string | null
    createdAt?: Date | string
    reviewedAt?: Date | string | null
  }

  export type WhitelistApplicationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    rejectReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WhitelistApplicationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    reviewerId?: NullableStringFieldUpdateOperationsInput | string | null
    rejectReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WhitelistAnswerCreateInput = {
    id?: string
    value: string
    createdAt?: Date | string
    application: WhitelistApplicationCreateNestedOneWithoutAnswersInput
    question: WhitelistQuestionCreateNestedOneWithoutAnswersInput
  }

  export type WhitelistAnswerUncheckedCreateInput = {
    id?: string
    applicationId: string
    questionId: string
    value: string
    createdAt?: Date | string
  }

  export type WhitelistAnswerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    application?: WhitelistApplicationUpdateOneRequiredWithoutAnswersNestedInput
    question?: WhitelistQuestionUpdateOneRequiredWithoutAnswersNestedInput
  }

  export type WhitelistAnswerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    applicationId?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WhitelistAnswerCreateManyInput = {
    id?: string
    applicationId: string
    questionId: string
    value: string
    createdAt?: Date | string
  }

  export type WhitelistAnswerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WhitelistAnswerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    applicationId?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BadgeCreateInput = {
    id?: string
    name: string
    description?: string | null
    icon?: string | null
    createdAt?: Date | string
    users?: UserBadgeCreateNestedManyWithoutBadgeInput
  }

  export type BadgeUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    icon?: string | null
    createdAt?: Date | string
    users?: UserBadgeUncheckedCreateNestedManyWithoutBadgeInput
  }

  export type BadgeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserBadgeUpdateManyWithoutBadgeNestedInput
  }

  export type BadgeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserBadgeUncheckedUpdateManyWithoutBadgeNestedInput
  }

  export type BadgeCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    icon?: string | null
    createdAt?: Date | string
  }

  export type BadgeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BadgeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserBadgeCreateInput = {
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutUserBadgesInput
    badge: BadgeCreateNestedOneWithoutUsersInput
  }

  export type UserBadgeUncheckedCreateInput = {
    userId: string
    badgeId: string
    createdAt?: Date | string
  }

  export type UserBadgeUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutUserBadgesNestedInput
    badge?: BadgeUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserBadgeUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    badgeId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserBadgeCreateManyInput = {
    userId: string
    badgeId: string
    createdAt?: Date | string
  }

  export type UserBadgeUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserBadgeUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    badgeId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    participants?: ConversationParticipantCreateNestedManyWithoutConversationInput
    messages?: DirectMessageCreateNestedManyWithoutConversationInput
  }

  export type ConversationUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    participants?: ConversationParticipantUncheckedCreateNestedManyWithoutConversationInput
    messages?: DirectMessageUncheckedCreateNestedManyWithoutConversationInput
  }

  export type ConversationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participants?: ConversationParticipantUpdateManyWithoutConversationNestedInput
    messages?: DirectMessageUpdateManyWithoutConversationNestedInput
  }

  export type ConversationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participants?: ConversationParticipantUncheckedUpdateManyWithoutConversationNestedInput
    messages?: DirectMessageUncheckedUpdateManyWithoutConversationNestedInput
  }

  export type ConversationCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConversationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationParticipantCreateInput = {
    createdAt?: Date | string
    conversation: ConversationCreateNestedOneWithoutParticipantsInput
    user: UserCreateNestedOneWithoutConvoPartsInput
  }

  export type ConversationParticipantUncheckedCreateInput = {
    conversationId: string
    userId: string
    createdAt?: Date | string
  }

  export type ConversationParticipantUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conversation?: ConversationUpdateOneRequiredWithoutParticipantsNestedInput
    user?: UserUpdateOneRequiredWithoutConvoPartsNestedInput
  }

  export type ConversationParticipantUncheckedUpdateInput = {
    conversationId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationParticipantCreateManyInput = {
    conversationId: string
    userId: string
    createdAt?: Date | string
  }

  export type ConversationParticipantUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationParticipantUncheckedUpdateManyInput = {
    conversationId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DirectMessageCreateInput = {
    id?: string
    content: string
    kind?: string
    isDeleted?: boolean
    createdAt?: Date | string
    conversation: ConversationCreateNestedOneWithoutMessagesInput
    sender: UserCreateNestedOneWithoutSentMessagesInput
    receiver: UserCreateNestedOneWithoutReceivedMessagesInput
  }

  export type DirectMessageUncheckedCreateInput = {
    id?: string
    conversationId: string
    senderId: string
    receiverId: string
    content: string
    kind?: string
    isDeleted?: boolean
    createdAt?: Date | string
  }

  export type DirectMessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    kind?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conversation?: ConversationUpdateOneRequiredWithoutMessagesNestedInput
    sender?: UserUpdateOneRequiredWithoutSentMessagesNestedInput
    receiver?: UserUpdateOneRequiredWithoutReceivedMessagesNestedInput
  }

  export type DirectMessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    receiverId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    kind?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DirectMessageCreateManyInput = {
    id?: string
    conversationId: string
    senderId: string
    receiverId: string
    content: string
    kind?: string
    isDeleted?: boolean
    createdAt?: Date | string
  }

  export type DirectMessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    kind?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DirectMessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    receiverId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    kind?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BankInfoCreateInput = {
    id?: string
    label: string
    holderName?: string | null
    pixKey?: string | null
    bankName?: string | null
    agency?: string | null
    accountNumber?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BankInfoUncheckedCreateInput = {
    id?: string
    label: string
    holderName?: string | null
    pixKey?: string | null
    bankName?: string | null
    agency?: string | null
    accountNumber?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BankInfoUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    holderName?: NullableStringFieldUpdateOperationsInput | string | null
    pixKey?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    agency?: NullableStringFieldUpdateOperationsInput | string | null
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BankInfoUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    holderName?: NullableStringFieldUpdateOperationsInput | string | null
    pixKey?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    agency?: NullableStringFieldUpdateOperationsInput | string | null
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BankInfoCreateManyInput = {
    id?: string
    label: string
    holderName?: string | null
    pixKey?: string | null
    bankName?: string | null
    agency?: string | null
    accountNumber?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BankInfoUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    holderName?: NullableStringFieldUpdateOperationsInput | string | null
    pixKey?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    agency?: NullableStringFieldUpdateOperationsInput | string | null
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BankInfoUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    holderName?: NullableStringFieldUpdateOperationsInput | string | null
    pixKey?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    agency?: NullableStringFieldUpdateOperationsInput | string | null
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SiteSettingCreateInput = {
    key: string
    value: string
    updatedAt?: Date | string
  }

  export type SiteSettingUncheckedCreateInput = {
    key: string
    value: string
    updatedAt?: Date | string
  }

  export type SiteSettingUpdateInput = {
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SiteSettingUncheckedUpdateInput = {
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SiteSettingCreateManyInput = {
    key: string
    value: string
    updatedAt?: Date | string
  }

  export type SiteSettingUpdateManyMutationInput = {
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SiteSettingUncheckedUpdateManyInput = {
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GameAccountCreateInput = {
    id?: string
    mtaSerial: string
    mtaAccount?: string | null
    locked?: boolean
    changedAfterApproved?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutGameAccountsInput
  }

  export type GameAccountUncheckedCreateInput = {
    id?: string
    userId: string
    mtaSerial: string
    mtaAccount?: string | null
    locked?: boolean
    changedAfterApproved?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GameAccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    mtaSerial?: StringFieldUpdateOperationsInput | string
    mtaAccount?: NullableStringFieldUpdateOperationsInput | string | null
    locked?: BoolFieldUpdateOperationsInput | boolean
    changedAfterApproved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutGameAccountsNestedInput
  }

  export type GameAccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    mtaSerial?: StringFieldUpdateOperationsInput | string
    mtaAccount?: NullableStringFieldUpdateOperationsInput | string | null
    locked?: BoolFieldUpdateOperationsInput | boolean
    changedAfterApproved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GameAccountCreateManyInput = {
    id?: string
    userId: string
    mtaSerial: string
    mtaAccount?: string | null
    locked?: boolean
    changedAfterApproved?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GameAccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    mtaSerial?: StringFieldUpdateOperationsInput | string
    mtaAccount?: NullableStringFieldUpdateOperationsInput | string | null
    locked?: BoolFieldUpdateOperationsInput | boolean
    changedAfterApproved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GameAccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    mtaSerial?: StringFieldUpdateOperationsInput | string
    mtaAccount?: NullableStringFieldUpdateOperationsInput | string | null
    locked?: BoolFieldUpdateOperationsInput | boolean
    changedAfterApproved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketParticipantCreateInput = {
    createdAt?: Date | string
    ticket: TicketCreateNestedOneWithoutParticipantsInput
    user: UserCreateNestedOneWithoutTicketParticipantsInput
    addedBy?: UserCreateNestedOneWithoutTicketParticipantsAddedInput
  }

  export type TicketParticipantUncheckedCreateInput = {
    ticketId: string
    userId: string
    addedById?: string | null
    createdAt?: Date | string
  }

  export type TicketParticipantUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ticket?: TicketUpdateOneRequiredWithoutParticipantsNestedInput
    user?: UserUpdateOneRequiredWithoutTicketParticipantsNestedInput
    addedBy?: UserUpdateOneWithoutTicketParticipantsAddedNestedInput
  }

  export type TicketParticipantUncheckedUpdateInput = {
    ticketId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    addedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketParticipantCreateManyInput = {
    ticketId: string
    userId: string
    addedById?: string | null
    createdAt?: Date | string
  }

  export type TicketParticipantUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketParticipantUncheckedUpdateManyInput = {
    ticketId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    addedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketRatingCreateInput = {
    id?: string
    stars: number
    feedback: string
    createdAt?: Date | string
    ticket: TicketCreateNestedOneWithoutRatingsInput
    rater: UserCreateNestedOneWithoutTicketRatingsGivenInput
    target: UserCreateNestedOneWithoutTicketRatingsReceivedInput
  }

  export type TicketRatingUncheckedCreateInput = {
    id?: string
    ticketId: string
    raterUserId: string
    targetUserId: string
    stars: number
    feedback: string
    createdAt?: Date | string
  }

  export type TicketRatingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    stars?: IntFieldUpdateOperationsInput | number
    feedback?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ticket?: TicketUpdateOneRequiredWithoutRatingsNestedInput
    rater?: UserUpdateOneRequiredWithoutTicketRatingsGivenNestedInput
    target?: UserUpdateOneRequiredWithoutTicketRatingsReceivedNestedInput
  }

  export type TicketRatingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticketId?: StringFieldUpdateOperationsInput | string
    raterUserId?: StringFieldUpdateOperationsInput | string
    targetUserId?: StringFieldUpdateOperationsInput | string
    stars?: IntFieldUpdateOperationsInput | number
    feedback?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketRatingCreateManyInput = {
    id?: string
    ticketId: string
    raterUserId: string
    targetUserId: string
    stars: number
    feedback: string
    createdAt?: Date | string
  }

  export type TicketRatingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    stars?: IntFieldUpdateOperationsInput | number
    feedback?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketRatingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticketId?: StringFieldUpdateOperationsInput | string
    raterUserId?: StringFieldUpdateOperationsInput | string
    targetUserId?: StringFieldUpdateOperationsInput | string
    stars?: IntFieldUpdateOperationsInput | number
    feedback?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MtaAccessLogCreateInput = {
    id?: string
    serial: string
    allowed: boolean
    reason?: string | null
    ip?: string | null
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutMtaAccessLogsInput
  }

  export type MtaAccessLogUncheckedCreateInput = {
    id?: string
    serial: string
    userId?: string | null
    allowed: boolean
    reason?: string | null
    ip?: string | null
    createdAt?: Date | string
  }

  export type MtaAccessLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    serial?: StringFieldUpdateOperationsInput | string
    allowed?: BoolFieldUpdateOperationsInput | boolean
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutMtaAccessLogsNestedInput
  }

  export type MtaAccessLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    serial?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    allowed?: BoolFieldUpdateOperationsInput | boolean
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MtaAccessLogCreateManyInput = {
    id?: string
    serial: string
    userId?: string | null
    allowed: boolean
    reason?: string | null
    ip?: string | null
    createdAt?: Date | string
  }

  export type MtaAccessLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    serial?: StringFieldUpdateOperationsInput | string
    allowed?: BoolFieldUpdateOperationsInput | boolean
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MtaAccessLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    serial?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    allowed?: BoolFieldUpdateOperationsInput | boolean
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketRatingRequirementCreateInput = {
    id?: string
    completed?: boolean
    createdAt?: Date | string
    ticket: TicketCreateNestedOneWithoutRatingRequirementsInput
    rater: UserCreateNestedOneWithoutTicketRatingReqGivenInput
    target: UserCreateNestedOneWithoutTicketRatingReqReceivedInput
  }

  export type TicketRatingRequirementUncheckedCreateInput = {
    id?: string
    ticketId: string
    raterId: string
    targetId: string
    completed?: boolean
    createdAt?: Date | string
  }

  export type TicketRatingRequirementUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ticket?: TicketUpdateOneRequiredWithoutRatingRequirementsNestedInput
    rater?: UserUpdateOneRequiredWithoutTicketRatingReqGivenNestedInput
    target?: UserUpdateOneRequiredWithoutTicketRatingReqReceivedNestedInput
  }

  export type TicketRatingRequirementUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticketId?: StringFieldUpdateOperationsInput | string
    raterId?: StringFieldUpdateOperationsInput | string
    targetId?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketRatingRequirementCreateManyInput = {
    id?: string
    ticketId: string
    raterId: string
    targetId: string
    completed?: boolean
    createdAt?: Date | string
  }

  export type TicketRatingRequirementUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketRatingRequirementUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticketId?: StringFieldUpdateOperationsInput | string
    raterId?: StringFieldUpdateOperationsInput | string
    targetId?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetTokenCreateInput = {
    id?: string
    code: string
    expiresAt: Date | string
    usedAt?: Date | string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutPasswordResetTokensInput
  }

  export type PasswordResetTokenUncheckedCreateInput = {
    id?: string
    userId: string
    code: string
    expiresAt: Date | string
    usedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type PasswordResetTokenUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPasswordResetTokensNestedInput
  }

  export type PasswordResetTokenUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetTokenCreateManyInput = {
    id?: string
    userId: string
    code: string
    expiresAt: Date | string
    usedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type PasswordResetTokenUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetTokenUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type PurchaseItemListRelationFilter = {
    every?: PurchaseItemWhereInput
    some?: PurchaseItemWhereInput
    none?: PurchaseItemWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type PurchaseItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductCountOrderByAggregateInput = {
    id?: SortOrder
    sku?: SortOrder
    name?: SortOrder
    description?: SortOrder
    priceCents?: SortOrder
    currency?: SortOrder
    durationDays?: SortOrder
    grantPoints?: SortOrder
    grantVipRole?: SortOrder
    mtaActions?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductAvgOrderByAggregateInput = {
    priceCents?: SortOrder
    durationDays?: SortOrder
    grantPoints?: SortOrder
  }

  export type ProductMaxOrderByAggregateInput = {
    id?: SortOrder
    sku?: SortOrder
    name?: SortOrder
    description?: SortOrder
    priceCents?: SortOrder
    currency?: SortOrder
    durationDays?: SortOrder
    grantPoints?: SortOrder
    grantVipRole?: SortOrder
    mtaActions?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductMinOrderByAggregateInput = {
    id?: SortOrder
    sku?: SortOrder
    name?: SortOrder
    description?: SortOrder
    priceCents?: SortOrder
    currency?: SortOrder
    durationDays?: SortOrder
    grantPoints?: SortOrder
    grantVipRole?: SortOrder
    mtaActions?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductSumOrderByAggregateInput = {
    priceCents?: SortOrder
    durationDays?: SortOrder
    grantPoints?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type CouponCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    percentOff?: SortOrder
    amountOffCents?: SortOrder
    maxUses?: SortOrder
    uses?: SortOrder
    expiresAt?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type CouponAvgOrderByAggregateInput = {
    percentOff?: SortOrder
    amountOffCents?: SortOrder
    maxUses?: SortOrder
    uses?: SortOrder
  }

  export type CouponMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    percentOff?: SortOrder
    amountOffCents?: SortOrder
    maxUses?: SortOrder
    uses?: SortOrder
    expiresAt?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type CouponMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    percentOff?: SortOrder
    amountOffCents?: SortOrder
    maxUses?: SortOrder
    uses?: SortOrder
    expiresAt?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type CouponSumOrderByAggregateInput = {
    percentOff?: SortOrder
    amountOffCents?: SortOrder
    maxUses?: SortOrder
    uses?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type PurchaseRelationFilter = {
    is?: PurchaseWhereInput
    isNot?: PurchaseWhereInput
  }

  export type ProductRelationFilter = {
    is?: ProductWhereInput
    isNot?: ProductWhereInput
  }

  export type PurchaseItemCountOrderByAggregateInput = {
    id?: SortOrder
    purchaseId?: SortOrder
    productId?: SortOrder
    sku?: SortOrder
    name?: SortOrder
    priceCents?: SortOrder
    durationDays?: SortOrder
    grantPoints?: SortOrder
    grantVipRole?: SortOrder
    mtaActions?: SortOrder
  }

  export type PurchaseItemAvgOrderByAggregateInput = {
    priceCents?: SortOrder
    durationDays?: SortOrder
    grantPoints?: SortOrder
  }

  export type PurchaseItemMaxOrderByAggregateInput = {
    id?: SortOrder
    purchaseId?: SortOrder
    productId?: SortOrder
    sku?: SortOrder
    name?: SortOrder
    priceCents?: SortOrder
    durationDays?: SortOrder
    grantPoints?: SortOrder
    grantVipRole?: SortOrder
    mtaActions?: SortOrder
  }

  export type PurchaseItemMinOrderByAggregateInput = {
    id?: SortOrder
    purchaseId?: SortOrder
    productId?: SortOrder
    sku?: SortOrder
    name?: SortOrder
    priceCents?: SortOrder
    durationDays?: SortOrder
    grantPoints?: SortOrder
    grantVipRole?: SortOrder
    mtaActions?: SortOrder
  }

  export type PurchaseItemSumOrderByAggregateInput = {
    priceCents?: SortOrder
    durationDays?: SortOrder
    grantPoints?: SortOrder
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type EntitlementCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    roleName?: SortOrder
    expiresAt?: SortOrder
    source?: SortOrder
    createdAt?: SortOrder
  }

  export type EntitlementMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    roleName?: SortOrder
    expiresAt?: SortOrder
    source?: SortOrder
    createdAt?: SortOrder
  }

  export type EntitlementMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    roleName?: SortOrder
    expiresAt?: SortOrder
    source?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    message?: SortOrder
    href?: SortOrder
    read?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    message?: SortOrder
    href?: SortOrder
    read?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    message?: SortOrder
    href?: SortOrder
    read?: SortOrder
    createdAt?: SortOrder
  }

  export type StaffShiftCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    openedAt?: SortOrder
    closedAt?: SortOrder
    seconds?: SortOrder
    createdAt?: SortOrder
  }

  export type StaffShiftAvgOrderByAggregateInput = {
    seconds?: SortOrder
  }

  export type StaffShiftMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    openedAt?: SortOrder
    closedAt?: SortOrder
    seconds?: SortOrder
    createdAt?: SortOrder
  }

  export type StaffShiftMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    openedAt?: SortOrder
    closedAt?: SortOrder
    seconds?: SortOrder
    createdAt?: SortOrder
  }

  export type StaffShiftSumOrderByAggregateInput = {
    seconds?: SortOrder
  }

  export type StaffWeeklyRewardUserIdWeekKeyCompoundUniqueInput = {
    userId: string
    weekKey: string
  }

  export type StaffWeeklyRewardCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    position?: SortOrder
    weekKey?: SortOrder
    createdAt?: SortOrder
  }

  export type StaffWeeklyRewardAvgOrderByAggregateInput = {
    position?: SortOrder
  }

  export type StaffWeeklyRewardMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    position?: SortOrder
    weekKey?: SortOrder
    createdAt?: SortOrder
  }

  export type StaffWeeklyRewardMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    position?: SortOrder
    weekKey?: SortOrder
    createdAt?: SortOrder
  }

  export type StaffWeeklyRewardSumOrderByAggregateInput = {
    position?: SortOrder
  }

  export type AdminCaseCountOrderByAggregateInput = {
    id?: SortOrder
    targetUserId?: SortOrder
    staffUserId?: SortOrder
    type?: SortOrder
    reason?: SortOrder
    expiresAt?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
  }

  export type AdminCaseMaxOrderByAggregateInput = {
    id?: SortOrder
    targetUserId?: SortOrder
    staffUserId?: SortOrder
    type?: SortOrder
    reason?: SortOrder
    expiresAt?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
  }

  export type AdminCaseMinOrderByAggregateInput = {
    id?: SortOrder
    targetUserId?: SortOrder
    staffUserId?: SortOrder
    type?: SortOrder
    reason?: SortOrder
    expiresAt?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
  }

  export type UserReputationCountOrderByAggregateInput = {
    userId?: SortOrder
    score?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserReputationAvgOrderByAggregateInput = {
    score?: SortOrder
  }

  export type UserReputationMaxOrderByAggregateInput = {
    userId?: SortOrder
    score?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserReputationMinOrderByAggregateInput = {
    userId?: SortOrder
    score?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserReputationSumOrderByAggregateInput = {
    score?: SortOrder
  }

  export type TopicListRelationFilter = {
    every?: TopicWhereInput
    some?: TopicWhereInput
    none?: TopicWhereInput
  }

  export type PostListRelationFilter = {
    every?: PostWhereInput
    some?: PostWhereInput
    none?: PostWhereInput
  }

  export type TicketListRelationFilter = {
    every?: TicketWhereInput
    some?: TicketWhereInput
    none?: TicketWhereInput
  }

  export type TicketMessageListRelationFilter = {
    every?: TicketMessageWhereInput
    some?: TicketMessageWhereInput
    none?: TicketMessageWhereInput
  }

  export type TicketParticipantListRelationFilter = {
    every?: TicketParticipantWhereInput
    some?: TicketParticipantWhereInput
    none?: TicketParticipantWhereInput
  }

  export type TicketRatingListRelationFilter = {
    every?: TicketRatingWhereInput
    some?: TicketRatingWhereInput
    none?: TicketRatingWhereInput
  }

  export type PurchaseListRelationFilter = {
    every?: PurchaseWhereInput
    some?: PurchaseWhereInput
    none?: PurchaseWhereInput
  }

  export type AuditLogListRelationFilter = {
    every?: AuditLogWhereInput
    some?: AuditLogWhereInput
    none?: AuditLogWhereInput
  }

  export type UserRoleListRelationFilter = {
    every?: UserRoleWhereInput
    some?: UserRoleWhereInput
    none?: UserRoleWhereInput
  }

  export type WhitelistApplicationListRelationFilter = {
    every?: WhitelistApplicationWhereInput
    some?: WhitelistApplicationWhereInput
    none?: WhitelistApplicationWhereInput
  }

  export type ConversationParticipantListRelationFilter = {
    every?: ConversationParticipantWhereInput
    some?: ConversationParticipantWhereInput
    none?: ConversationParticipantWhereInput
  }

  export type DirectMessageListRelationFilter = {
    every?: DirectMessageWhereInput
    some?: DirectMessageWhereInput
    none?: DirectMessageWhereInput
  }

  export type UserBadgeListRelationFilter = {
    every?: UserBadgeWhereInput
    some?: UserBadgeWhereInput
    none?: UserBadgeWhereInput
  }

  export type GameAccountListRelationFilter = {
    every?: GameAccountWhereInput
    some?: GameAccountWhereInput
    none?: GameAccountWhereInput
  }

  export type MtaAccessLogListRelationFilter = {
    every?: MtaAccessLogWhereInput
    some?: MtaAccessLogWhereInput
    none?: MtaAccessLogWhereInput
  }

  export type TicketRatingRequirementListRelationFilter = {
    every?: TicketRatingRequirementWhereInput
    some?: TicketRatingRequirementWhereInput
    none?: TicketRatingRequirementWhereInput
  }

  export type PasswordResetTokenListRelationFilter = {
    every?: PasswordResetTokenWhereInput
    some?: PasswordResetTokenWhereInput
    none?: PasswordResetTokenWhereInput
  }

  export type EntitlementListRelationFilter = {
    every?: EntitlementWhereInput
    some?: EntitlementWhereInput
    none?: EntitlementWhereInput
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type StaffShiftListRelationFilter = {
    every?: StaffShiftWhereInput
    some?: StaffShiftWhereInput
    none?: StaffShiftWhereInput
  }

  export type StaffWeeklyRewardListRelationFilter = {
    every?: StaffWeeklyRewardWhereInput
    some?: StaffWeeklyRewardWhereInput
    none?: StaffWeeklyRewardWhereInput
  }

  export type AdminCaseListRelationFilter = {
    every?: AdminCaseWhereInput
    some?: AdminCaseWhereInput
    none?: AdminCaseWhereInput
  }

  export type UserReputationNullableRelationFilter = {
    is?: UserReputationWhereInput | null
    isNot?: UserReputationWhereInput | null
  }

  export type TopicOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PostOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TicketOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TicketMessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TicketParticipantOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TicketRatingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PurchaseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AuditLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserRoleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WhitelistApplicationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ConversationParticipantOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DirectMessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserBadgeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GameAccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MtaAccessLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TicketRatingRequirementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PasswordResetTokenOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EntitlementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StaffShiftOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StaffWeeklyRewardOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AdminCaseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    passwordHash?: SortOrder
    emailVerifiedAt?: SortOrder
    emailVerifyToken?: SortOrder
    emailVerifyExpiresAt?: SortOrder
    phone?: SortOrder
    recoveryEmail?: SortOrder
    googleId?: SortOrder
    discordId?: SortOrder
    discordUsername?: SortOrder
    avatarKey?: SortOrder
    role?: SortOrder
    isDeleted?: SortOrder
    bannedUntil?: SortOrder
    whitelistStatus?: SortOrder
    points?: SortOrder
    lastSeenAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    avatarUrl?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    points?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    passwordHash?: SortOrder
    emailVerifiedAt?: SortOrder
    emailVerifyToken?: SortOrder
    emailVerifyExpiresAt?: SortOrder
    phone?: SortOrder
    recoveryEmail?: SortOrder
    googleId?: SortOrder
    discordId?: SortOrder
    discordUsername?: SortOrder
    avatarKey?: SortOrder
    role?: SortOrder
    isDeleted?: SortOrder
    bannedUntil?: SortOrder
    whitelistStatus?: SortOrder
    points?: SortOrder
    lastSeenAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    avatarUrl?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    passwordHash?: SortOrder
    emailVerifiedAt?: SortOrder
    emailVerifyToken?: SortOrder
    emailVerifyExpiresAt?: SortOrder
    phone?: SortOrder
    recoveryEmail?: SortOrder
    googleId?: SortOrder
    discordId?: SortOrder
    discordUsername?: SortOrder
    avatarKey?: SortOrder
    role?: SortOrder
    isDeleted?: SortOrder
    bannedUntil?: SortOrder
    whitelistStatus?: SortOrder
    points?: SortOrder
    lastSeenAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    avatarUrl?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    points?: SortOrder
  }

  export type ForumBoardListRelationFilter = {
    every?: ForumBoardWhereInput
    some?: ForumBoardWhereInput
    none?: ForumBoardWhereInput
  }

  export type ForumBoardOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ForumCategoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
  }

  export type ForumCategoryAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type ForumCategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
  }

  export type ForumCategoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
  }

  export type ForumCategorySumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type ForumCategoryRelationFilter = {
    is?: ForumCategoryWhereInput
    isNot?: ForumCategoryWhereInput
  }

  export type ForumBoardCountOrderByAggregateInput = {
    id?: SortOrder
    categoryId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    order?: SortOrder
    requireWhitelist?: SortOrder
    pointsOnTopic?: SortOrder
    pointsOnReply?: SortOrder
    allowReplies?: SortOrder
    createdAt?: SortOrder
  }

  export type ForumBoardAvgOrderByAggregateInput = {
    order?: SortOrder
    pointsOnTopic?: SortOrder
    pointsOnReply?: SortOrder
  }

  export type ForumBoardMaxOrderByAggregateInput = {
    id?: SortOrder
    categoryId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    order?: SortOrder
    requireWhitelist?: SortOrder
    pointsOnTopic?: SortOrder
    pointsOnReply?: SortOrder
    allowReplies?: SortOrder
    createdAt?: SortOrder
  }

  export type ForumBoardMinOrderByAggregateInput = {
    id?: SortOrder
    categoryId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    order?: SortOrder
    requireWhitelist?: SortOrder
    pointsOnTopic?: SortOrder
    pointsOnReply?: SortOrder
    allowReplies?: SortOrder
    createdAt?: SortOrder
  }

  export type ForumBoardSumOrderByAggregateInput = {
    order?: SortOrder
    pointsOnTopic?: SortOrder
    pointsOnReply?: SortOrder
  }

  export type ForumBoardRelationFilter = {
    is?: ForumBoardWhereInput
    isNot?: ForumBoardWhereInput
  }

  export type TopicCountOrderByAggregateInput = {
    id?: SortOrder
    boardId?: SortOrder
    authorId?: SortOrder
    title?: SortOrder
    status?: SortOrder
    pinned?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastPostAt?: SortOrder
  }

  export type TopicMaxOrderByAggregateInput = {
    id?: SortOrder
    boardId?: SortOrder
    authorId?: SortOrder
    title?: SortOrder
    status?: SortOrder
    pinned?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastPostAt?: SortOrder
  }

  export type TopicMinOrderByAggregateInput = {
    id?: SortOrder
    boardId?: SortOrder
    authorId?: SortOrder
    title?: SortOrder
    status?: SortOrder
    pinned?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastPostAt?: SortOrder
  }

  export type TopicRelationFilter = {
    is?: TopicWhereInput
    isNot?: TopicWhereInput
  }

  export type PostAttachmentListRelationFilter = {
    every?: PostAttachmentWhereInput
    some?: PostAttachmentWhereInput
    none?: PostAttachmentWhereInput
  }

  export type PostAttachmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PostCountOrderByAggregateInput = {
    id?: SortOrder
    topicId?: SortOrder
    authorId?: SortOrder
    content?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PostMaxOrderByAggregateInput = {
    id?: SortOrder
    topicId?: SortOrder
    authorId?: SortOrder
    content?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PostMinOrderByAggregateInput = {
    id?: SortOrder
    topicId?: SortOrder
    authorId?: SortOrder
    content?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PostRelationFilter = {
    is?: PostWhereInput
    isNot?: PostWhereInput
  }

  export type PostAttachmentCountOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    url?: SortOrder
    mime?: SortOrder
    size?: SortOrder
    createdAt?: SortOrder
  }

  export type PostAttachmentAvgOrderByAggregateInput = {
    size?: SortOrder
  }

  export type PostAttachmentMaxOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    url?: SortOrder
    mime?: SortOrder
    size?: SortOrder
    createdAt?: SortOrder
  }

  export type PostAttachmentMinOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    url?: SortOrder
    mime?: SortOrder
    size?: SortOrder
    createdAt?: SortOrder
  }

  export type PostAttachmentSumOrderByAggregateInput = {
    size?: SortOrder
  }

  export type TicketCategoryCountOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    name?: SortOrder
    description?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
  }

  export type TicketCategoryAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type TicketCategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    name?: SortOrder
    description?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
  }

  export type TicketCategoryMinOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    name?: SortOrder
    description?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
  }

  export type TicketCategorySumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type TicketCategoryRelationFilter = {
    is?: TicketCategoryWhereInput
    isNot?: TicketCategoryWhereInput
  }

  export type UserNullableRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type TicketCountOrderByAggregateInput = {
    id?: SortOrder
    categoryId?: SortOrder
    authorId?: SortOrder
    title?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    assignedToId?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    closedAt?: SortOrder
    closedById?: SortOrder
  }

  export type TicketMaxOrderByAggregateInput = {
    id?: SortOrder
    categoryId?: SortOrder
    authorId?: SortOrder
    title?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    assignedToId?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    closedAt?: SortOrder
    closedById?: SortOrder
  }

  export type TicketMinOrderByAggregateInput = {
    id?: SortOrder
    categoryId?: SortOrder
    authorId?: SortOrder
    title?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    assignedToId?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    closedAt?: SortOrder
    closedById?: SortOrder
  }

  export type TicketRelationFilter = {
    is?: TicketWhereInput
    isNot?: TicketWhereInput
  }

  export type TicketMessageCountOrderByAggregateInput = {
    id?: SortOrder
    ticketId?: SortOrder
    authorId?: SortOrder
    content?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
  }

  export type TicketMessageMaxOrderByAggregateInput = {
    id?: SortOrder
    ticketId?: SortOrder
    authorId?: SortOrder
    content?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
  }

  export type TicketMessageMinOrderByAggregateInput = {
    id?: SortOrder
    ticketId?: SortOrder
    authorId?: SortOrder
    content?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
  }

  export type PurchaseCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    provider?: SortOrder
    externalId?: SortOrder
    status?: SortOrder
    amountCents?: SortOrder
    currency?: SortOrder
    meta?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PurchaseAvgOrderByAggregateInput = {
    amountCents?: SortOrder
  }

  export type PurchaseMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    provider?: SortOrder
    externalId?: SortOrder
    status?: SortOrder
    amountCents?: SortOrder
    currency?: SortOrder
    meta?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PurchaseMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    provider?: SortOrder
    externalId?: SortOrder
    status?: SortOrder
    amountCents?: SortOrder
    currency?: SortOrder
    meta?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PurchaseSumOrderByAggregateInput = {
    amountCents?: SortOrder
  }

  export type AuditLogCountOrderByAggregateInput = {
    id?: SortOrder
    actorId?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    ip?: SortOrder
    userAgent?: SortOrder
    meta?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMaxOrderByAggregateInput = {
    id?: SortOrder
    actorId?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    ip?: SortOrder
    userAgent?: SortOrder
    meta?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMinOrderByAggregateInput = {
    id?: SortOrder
    actorId?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    ip?: SortOrder
    userAgent?: SortOrder
    meta?: SortOrder
    createdAt?: SortOrder
  }

  export type MpWebhookEventCountOrderByAggregateInput = {
    id?: SortOrder
    eventType?: SortOrder
    externalId?: SortOrder
    payload?: SortOrder
    processed?: SortOrder
    createdAt?: SortOrder
  }

  export type MpWebhookEventMaxOrderByAggregateInput = {
    id?: SortOrder
    eventType?: SortOrder
    externalId?: SortOrder
    payload?: SortOrder
    processed?: SortOrder
    createdAt?: SortOrder
  }

  export type MpWebhookEventMinOrderByAggregateInput = {
    id?: SortOrder
    eventType?: SortOrder
    externalId?: SortOrder
    payload?: SortOrder
    processed?: SortOrder
    createdAt?: SortOrder
  }

  export type RolePermissionListRelationFilter = {
    every?: RolePermissionWhereInput
    some?: RolePermissionWhereInput
    none?: RolePermissionWhereInput
  }

  export type RolePermissionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RoleCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    rank?: SortOrder
    category?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    colorHex?: SortOrder
  }

  export type RoleAvgOrderByAggregateInput = {
    rank?: SortOrder
  }

  export type RoleMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    rank?: SortOrder
    category?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    colorHex?: SortOrder
  }

  export type RoleMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    rank?: SortOrder
    category?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    colorHex?: SortOrder
  }

  export type RoleSumOrderByAggregateInput = {
    rank?: SortOrder
  }

  export type PermissionCountOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
  }

  export type PermissionMaxOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
  }

  export type PermissionMinOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
  }

  export type RoleRelationFilter = {
    is?: RoleWhereInput
    isNot?: RoleWhereInput
  }

  export type PermissionRelationFilter = {
    is?: PermissionWhereInput
    isNot?: PermissionWhereInput
  }

  export type RolePermissionRoleIdPermissionIdCompoundUniqueInput = {
    roleId: string
    permissionId: string
  }

  export type RolePermissionCountOrderByAggregateInput = {
    roleId?: SortOrder
    permissionId?: SortOrder
  }

  export type RolePermissionMaxOrderByAggregateInput = {
    roleId?: SortOrder
    permissionId?: SortOrder
  }

  export type RolePermissionMinOrderByAggregateInput = {
    roleId?: SortOrder
    permissionId?: SortOrder
  }

  export type UserRoleUserIdRoleIdCompoundUniqueInput = {
    userId: string
    roleId: string
  }

  export type UserRoleCountOrderByAggregateInput = {
    userId?: SortOrder
    roleId?: SortOrder
  }

  export type UserRoleMaxOrderByAggregateInput = {
    userId?: SortOrder
    roleId?: SortOrder
  }

  export type UserRoleMinOrderByAggregateInput = {
    userId?: SortOrder
    roleId?: SortOrder
  }

  export type WhitelistConfigCountOrderByAggregateInput = {
    id?: SortOrder
    enabled?: SortOrder
    pausedUntil?: SortOrder
    successTitle?: SortOrder
    successBody?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WhitelistConfigMaxOrderByAggregateInput = {
    id?: SortOrder
    enabled?: SortOrder
    pausedUntil?: SortOrder
    successTitle?: SortOrder
    successBody?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WhitelistConfigMinOrderByAggregateInput = {
    id?: SortOrder
    enabled?: SortOrder
    pausedUntil?: SortOrder
    successTitle?: SortOrder
    successBody?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WhitelistAnswerListRelationFilter = {
    every?: WhitelistAnswerWhereInput
    some?: WhitelistAnswerWhereInput
    none?: WhitelistAnswerWhereInput
  }

  export type WhitelistAnswerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WhitelistQuestionCountOrderByAggregateInput = {
    id?: SortOrder
    prompt?: SortOrder
    required?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
  }

  export type WhitelistQuestionAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type WhitelistQuestionMaxOrderByAggregateInput = {
    id?: SortOrder
    prompt?: SortOrder
    required?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
  }

  export type WhitelistQuestionMinOrderByAggregateInput = {
    id?: SortOrder
    prompt?: SortOrder
    required?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
  }

  export type WhitelistQuestionSumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type WhitelistApplicationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    reviewerId?: SortOrder
    rejectReason?: SortOrder
    createdAt?: SortOrder
    reviewedAt?: SortOrder
  }

  export type WhitelistApplicationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    reviewerId?: SortOrder
    rejectReason?: SortOrder
    createdAt?: SortOrder
    reviewedAt?: SortOrder
  }

  export type WhitelistApplicationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    reviewerId?: SortOrder
    rejectReason?: SortOrder
    createdAt?: SortOrder
    reviewedAt?: SortOrder
  }

  export type WhitelistApplicationRelationFilter = {
    is?: WhitelistApplicationWhereInput
    isNot?: WhitelistApplicationWhereInput
  }

  export type WhitelistQuestionRelationFilter = {
    is?: WhitelistQuestionWhereInput
    isNot?: WhitelistQuestionWhereInput
  }

  export type WhitelistAnswerCountOrderByAggregateInput = {
    id?: SortOrder
    applicationId?: SortOrder
    questionId?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
  }

  export type WhitelistAnswerMaxOrderByAggregateInput = {
    id?: SortOrder
    applicationId?: SortOrder
    questionId?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
  }

  export type WhitelistAnswerMinOrderByAggregateInput = {
    id?: SortOrder
    applicationId?: SortOrder
    questionId?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
  }

  export type BadgeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    createdAt?: SortOrder
  }

  export type BadgeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    createdAt?: SortOrder
  }

  export type BadgeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    createdAt?: SortOrder
  }

  export type BadgeRelationFilter = {
    is?: BadgeWhereInput
    isNot?: BadgeWhereInput
  }

  export type UserBadgeUserIdBadgeIdCompoundUniqueInput = {
    userId: string
    badgeId: string
  }

  export type UserBadgeCountOrderByAggregateInput = {
    userId?: SortOrder
    badgeId?: SortOrder
    createdAt?: SortOrder
  }

  export type UserBadgeMaxOrderByAggregateInput = {
    userId?: SortOrder
    badgeId?: SortOrder
    createdAt?: SortOrder
  }

  export type UserBadgeMinOrderByAggregateInput = {
    userId?: SortOrder
    badgeId?: SortOrder
    createdAt?: SortOrder
  }

  export type ConversationCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConversationMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConversationMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConversationRelationFilter = {
    is?: ConversationWhereInput
    isNot?: ConversationWhereInput
  }

  export type ConversationParticipantConversationIdUserIdCompoundUniqueInput = {
    conversationId: string
    userId: string
  }

  export type ConversationParticipantCountOrderByAggregateInput = {
    conversationId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type ConversationParticipantMaxOrderByAggregateInput = {
    conversationId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type ConversationParticipantMinOrderByAggregateInput = {
    conversationId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type DirectMessageCountOrderByAggregateInput = {
    id?: SortOrder
    conversationId?: SortOrder
    senderId?: SortOrder
    receiverId?: SortOrder
    content?: SortOrder
    kind?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
  }

  export type DirectMessageMaxOrderByAggregateInput = {
    id?: SortOrder
    conversationId?: SortOrder
    senderId?: SortOrder
    receiverId?: SortOrder
    content?: SortOrder
    kind?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
  }

  export type DirectMessageMinOrderByAggregateInput = {
    id?: SortOrder
    conversationId?: SortOrder
    senderId?: SortOrder
    receiverId?: SortOrder
    content?: SortOrder
    kind?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
  }

  export type BankInfoCountOrderByAggregateInput = {
    id?: SortOrder
    label?: SortOrder
    holderName?: SortOrder
    pixKey?: SortOrder
    bankName?: SortOrder
    agency?: SortOrder
    accountNumber?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BankInfoMaxOrderByAggregateInput = {
    id?: SortOrder
    label?: SortOrder
    holderName?: SortOrder
    pixKey?: SortOrder
    bankName?: SortOrder
    agency?: SortOrder
    accountNumber?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BankInfoMinOrderByAggregateInput = {
    id?: SortOrder
    label?: SortOrder
    holderName?: SortOrder
    pixKey?: SortOrder
    bankName?: SortOrder
    agency?: SortOrder
    accountNumber?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SiteSettingCountOrderByAggregateInput = {
    key?: SortOrder
    value?: SortOrder
    updatedAt?: SortOrder
  }

  export type SiteSettingMaxOrderByAggregateInput = {
    key?: SortOrder
    value?: SortOrder
    updatedAt?: SortOrder
  }

  export type SiteSettingMinOrderByAggregateInput = {
    key?: SortOrder
    value?: SortOrder
    updatedAt?: SortOrder
  }

  export type GameAccountCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    mtaSerial?: SortOrder
    mtaAccount?: SortOrder
    locked?: SortOrder
    changedAfterApproved?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GameAccountMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    mtaSerial?: SortOrder
    mtaAccount?: SortOrder
    locked?: SortOrder
    changedAfterApproved?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GameAccountMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    mtaSerial?: SortOrder
    mtaAccount?: SortOrder
    locked?: SortOrder
    changedAfterApproved?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TicketParticipantTicketIdUserIdCompoundUniqueInput = {
    ticketId: string
    userId: string
  }

  export type TicketParticipantCountOrderByAggregateInput = {
    ticketId?: SortOrder
    userId?: SortOrder
    addedById?: SortOrder
    createdAt?: SortOrder
  }

  export type TicketParticipantMaxOrderByAggregateInput = {
    ticketId?: SortOrder
    userId?: SortOrder
    addedById?: SortOrder
    createdAt?: SortOrder
  }

  export type TicketParticipantMinOrderByAggregateInput = {
    ticketId?: SortOrder
    userId?: SortOrder
    addedById?: SortOrder
    createdAt?: SortOrder
  }

  export type TicketRatingTicketIdRaterUserIdTargetUserIdCompoundUniqueInput = {
    ticketId: string
    raterUserId: string
    targetUserId: string
  }

  export type TicketRatingCountOrderByAggregateInput = {
    id?: SortOrder
    ticketId?: SortOrder
    raterUserId?: SortOrder
    targetUserId?: SortOrder
    stars?: SortOrder
    feedback?: SortOrder
    createdAt?: SortOrder
  }

  export type TicketRatingAvgOrderByAggregateInput = {
    stars?: SortOrder
  }

  export type TicketRatingMaxOrderByAggregateInput = {
    id?: SortOrder
    ticketId?: SortOrder
    raterUserId?: SortOrder
    targetUserId?: SortOrder
    stars?: SortOrder
    feedback?: SortOrder
    createdAt?: SortOrder
  }

  export type TicketRatingMinOrderByAggregateInput = {
    id?: SortOrder
    ticketId?: SortOrder
    raterUserId?: SortOrder
    targetUserId?: SortOrder
    stars?: SortOrder
    feedback?: SortOrder
    createdAt?: SortOrder
  }

  export type TicketRatingSumOrderByAggregateInput = {
    stars?: SortOrder
  }

  export type MtaAccessLogCountOrderByAggregateInput = {
    id?: SortOrder
    serial?: SortOrder
    userId?: SortOrder
    allowed?: SortOrder
    reason?: SortOrder
    ip?: SortOrder
    createdAt?: SortOrder
  }

  export type MtaAccessLogMaxOrderByAggregateInput = {
    id?: SortOrder
    serial?: SortOrder
    userId?: SortOrder
    allowed?: SortOrder
    reason?: SortOrder
    ip?: SortOrder
    createdAt?: SortOrder
  }

  export type MtaAccessLogMinOrderByAggregateInput = {
    id?: SortOrder
    serial?: SortOrder
    userId?: SortOrder
    allowed?: SortOrder
    reason?: SortOrder
    ip?: SortOrder
    createdAt?: SortOrder
  }

  export type TicketRatingRequirementTicketIdRaterIdTargetIdCompoundUniqueInput = {
    ticketId: string
    raterId: string
    targetId: string
  }

  export type TicketRatingRequirementCountOrderByAggregateInput = {
    id?: SortOrder
    ticketId?: SortOrder
    raterId?: SortOrder
    targetId?: SortOrder
    completed?: SortOrder
    createdAt?: SortOrder
  }

  export type TicketRatingRequirementMaxOrderByAggregateInput = {
    id?: SortOrder
    ticketId?: SortOrder
    raterId?: SortOrder
    targetId?: SortOrder
    completed?: SortOrder
    createdAt?: SortOrder
  }

  export type TicketRatingRequirementMinOrderByAggregateInput = {
    id?: SortOrder
    ticketId?: SortOrder
    raterId?: SortOrder
    targetId?: SortOrder
    completed?: SortOrder
    createdAt?: SortOrder
  }

  export type PasswordResetTokenCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    code?: SortOrder
    expiresAt?: SortOrder
    usedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type PasswordResetTokenMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    code?: SortOrder
    expiresAt?: SortOrder
    usedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type PasswordResetTokenMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    code?: SortOrder
    expiresAt?: SortOrder
    usedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type PurchaseItemCreateNestedManyWithoutProductInput = {
    create?: XOR<PurchaseItemCreateWithoutProductInput, PurchaseItemUncheckedCreateWithoutProductInput> | PurchaseItemCreateWithoutProductInput[] | PurchaseItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: PurchaseItemCreateOrConnectWithoutProductInput | PurchaseItemCreateOrConnectWithoutProductInput[]
    createMany?: PurchaseItemCreateManyProductInputEnvelope
    connect?: PurchaseItemWhereUniqueInput | PurchaseItemWhereUniqueInput[]
  }

  export type PurchaseItemUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<PurchaseItemCreateWithoutProductInput, PurchaseItemUncheckedCreateWithoutProductInput> | PurchaseItemCreateWithoutProductInput[] | PurchaseItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: PurchaseItemCreateOrConnectWithoutProductInput | PurchaseItemCreateOrConnectWithoutProductInput[]
    createMany?: PurchaseItemCreateManyProductInputEnvelope
    connect?: PurchaseItemWhereUniqueInput | PurchaseItemWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type PurchaseItemUpdateManyWithoutProductNestedInput = {
    create?: XOR<PurchaseItemCreateWithoutProductInput, PurchaseItemUncheckedCreateWithoutProductInput> | PurchaseItemCreateWithoutProductInput[] | PurchaseItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: PurchaseItemCreateOrConnectWithoutProductInput | PurchaseItemCreateOrConnectWithoutProductInput[]
    upsert?: PurchaseItemUpsertWithWhereUniqueWithoutProductInput | PurchaseItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: PurchaseItemCreateManyProductInputEnvelope
    set?: PurchaseItemWhereUniqueInput | PurchaseItemWhereUniqueInput[]
    disconnect?: PurchaseItemWhereUniqueInput | PurchaseItemWhereUniqueInput[]
    delete?: PurchaseItemWhereUniqueInput | PurchaseItemWhereUniqueInput[]
    connect?: PurchaseItemWhereUniqueInput | PurchaseItemWhereUniqueInput[]
    update?: PurchaseItemUpdateWithWhereUniqueWithoutProductInput | PurchaseItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: PurchaseItemUpdateManyWithWhereWithoutProductInput | PurchaseItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: PurchaseItemScalarWhereInput | PurchaseItemScalarWhereInput[]
  }

  export type PurchaseItemUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<PurchaseItemCreateWithoutProductInput, PurchaseItemUncheckedCreateWithoutProductInput> | PurchaseItemCreateWithoutProductInput[] | PurchaseItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: PurchaseItemCreateOrConnectWithoutProductInput | PurchaseItemCreateOrConnectWithoutProductInput[]
    upsert?: PurchaseItemUpsertWithWhereUniqueWithoutProductInput | PurchaseItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: PurchaseItemCreateManyProductInputEnvelope
    set?: PurchaseItemWhereUniqueInput | PurchaseItemWhereUniqueInput[]
    disconnect?: PurchaseItemWhereUniqueInput | PurchaseItemWhereUniqueInput[]
    delete?: PurchaseItemWhereUniqueInput | PurchaseItemWhereUniqueInput[]
    connect?: PurchaseItemWhereUniqueInput | PurchaseItemWhereUniqueInput[]
    update?: PurchaseItemUpdateWithWhereUniqueWithoutProductInput | PurchaseItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: PurchaseItemUpdateManyWithWhereWithoutProductInput | PurchaseItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: PurchaseItemScalarWhereInput | PurchaseItemScalarWhereInput[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type PurchaseCreateNestedOneWithoutItemsInput = {
    create?: XOR<PurchaseCreateWithoutItemsInput, PurchaseUncheckedCreateWithoutItemsInput>
    connectOrCreate?: PurchaseCreateOrConnectWithoutItemsInput
    connect?: PurchaseWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutPurchaseItemsInput = {
    create?: XOR<ProductCreateWithoutPurchaseItemsInput, ProductUncheckedCreateWithoutPurchaseItemsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutPurchaseItemsInput
    connect?: ProductWhereUniqueInput
  }

  export type PurchaseUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<PurchaseCreateWithoutItemsInput, PurchaseUncheckedCreateWithoutItemsInput>
    connectOrCreate?: PurchaseCreateOrConnectWithoutItemsInput
    upsert?: PurchaseUpsertWithoutItemsInput
    connect?: PurchaseWhereUniqueInput
    update?: XOR<XOR<PurchaseUpdateToOneWithWhereWithoutItemsInput, PurchaseUpdateWithoutItemsInput>, PurchaseUncheckedUpdateWithoutItemsInput>
  }

  export type ProductUpdateOneRequiredWithoutPurchaseItemsNestedInput = {
    create?: XOR<ProductCreateWithoutPurchaseItemsInput, ProductUncheckedCreateWithoutPurchaseItemsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutPurchaseItemsInput
    upsert?: ProductUpsertWithoutPurchaseItemsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutPurchaseItemsInput, ProductUpdateWithoutPurchaseItemsInput>, ProductUncheckedUpdateWithoutPurchaseItemsInput>
  }

  export type UserCreateNestedOneWithoutEntitlementsInput = {
    create?: XOR<UserCreateWithoutEntitlementsInput, UserUncheckedCreateWithoutEntitlementsInput>
    connectOrCreate?: UserCreateOrConnectWithoutEntitlementsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutEntitlementsNestedInput = {
    create?: XOR<UserCreateWithoutEntitlementsInput, UserUncheckedCreateWithoutEntitlementsInput>
    connectOrCreate?: UserCreateOrConnectWithoutEntitlementsInput
    upsert?: UserUpsertWithoutEntitlementsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutEntitlementsInput, UserUpdateWithoutEntitlementsInput>, UserUncheckedUpdateWithoutEntitlementsInput>
  }

  export type UserCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    upsert?: UserUpsertWithoutNotificationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationsInput, UserUpdateWithoutNotificationsInput>, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserCreateNestedOneWithoutStaffShiftsInput = {
    create?: XOR<UserCreateWithoutStaffShiftsInput, UserUncheckedCreateWithoutStaffShiftsInput>
    connectOrCreate?: UserCreateOrConnectWithoutStaffShiftsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutStaffShiftsNestedInput = {
    create?: XOR<UserCreateWithoutStaffShiftsInput, UserUncheckedCreateWithoutStaffShiftsInput>
    connectOrCreate?: UserCreateOrConnectWithoutStaffShiftsInput
    upsert?: UserUpsertWithoutStaffShiftsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutStaffShiftsInput, UserUpdateWithoutStaffShiftsInput>, UserUncheckedUpdateWithoutStaffShiftsInput>
  }

  export type UserCreateNestedOneWithoutStaffWeeklyRewardsInput = {
    create?: XOR<UserCreateWithoutStaffWeeklyRewardsInput, UserUncheckedCreateWithoutStaffWeeklyRewardsInput>
    connectOrCreate?: UserCreateOrConnectWithoutStaffWeeklyRewardsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutStaffWeeklyRewardsNestedInput = {
    create?: XOR<UserCreateWithoutStaffWeeklyRewardsInput, UserUncheckedCreateWithoutStaffWeeklyRewardsInput>
    connectOrCreate?: UserCreateOrConnectWithoutStaffWeeklyRewardsInput
    upsert?: UserUpsertWithoutStaffWeeklyRewardsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutStaffWeeklyRewardsInput, UserUpdateWithoutStaffWeeklyRewardsInput>, UserUncheckedUpdateWithoutStaffWeeklyRewardsInput>
  }

  export type UserCreateNestedOneWithoutAdminCasesTargetInput = {
    create?: XOR<UserCreateWithoutAdminCasesTargetInput, UserUncheckedCreateWithoutAdminCasesTargetInput>
    connectOrCreate?: UserCreateOrConnectWithoutAdminCasesTargetInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAdminCasesStaffInput = {
    create?: XOR<UserCreateWithoutAdminCasesStaffInput, UserUncheckedCreateWithoutAdminCasesStaffInput>
    connectOrCreate?: UserCreateOrConnectWithoutAdminCasesStaffInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAdminCasesTargetNestedInput = {
    create?: XOR<UserCreateWithoutAdminCasesTargetInput, UserUncheckedCreateWithoutAdminCasesTargetInput>
    connectOrCreate?: UserCreateOrConnectWithoutAdminCasesTargetInput
    upsert?: UserUpsertWithoutAdminCasesTargetInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAdminCasesTargetInput, UserUpdateWithoutAdminCasesTargetInput>, UserUncheckedUpdateWithoutAdminCasesTargetInput>
  }

  export type UserUpdateOneRequiredWithoutAdminCasesStaffNestedInput = {
    create?: XOR<UserCreateWithoutAdminCasesStaffInput, UserUncheckedCreateWithoutAdminCasesStaffInput>
    connectOrCreate?: UserCreateOrConnectWithoutAdminCasesStaffInput
    upsert?: UserUpsertWithoutAdminCasesStaffInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAdminCasesStaffInput, UserUpdateWithoutAdminCasesStaffInput>, UserUncheckedUpdateWithoutAdminCasesStaffInput>
  }

  export type UserCreateNestedOneWithoutReputationInput = {
    create?: XOR<UserCreateWithoutReputationInput, UserUncheckedCreateWithoutReputationInput>
    connectOrCreate?: UserCreateOrConnectWithoutReputationInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutReputationNestedInput = {
    create?: XOR<UserCreateWithoutReputationInput, UserUncheckedCreateWithoutReputationInput>
    connectOrCreate?: UserCreateOrConnectWithoutReputationInput
    upsert?: UserUpsertWithoutReputationInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReputationInput, UserUpdateWithoutReputationInput>, UserUncheckedUpdateWithoutReputationInput>
  }

  export type TopicCreateNestedManyWithoutAuthorInput = {
    create?: XOR<TopicCreateWithoutAuthorInput, TopicUncheckedCreateWithoutAuthorInput> | TopicCreateWithoutAuthorInput[] | TopicUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: TopicCreateOrConnectWithoutAuthorInput | TopicCreateOrConnectWithoutAuthorInput[]
    createMany?: TopicCreateManyAuthorInputEnvelope
    connect?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
  }

  export type PostCreateNestedManyWithoutAuthorInput = {
    create?: XOR<PostCreateWithoutAuthorInput, PostUncheckedCreateWithoutAuthorInput> | PostCreateWithoutAuthorInput[] | PostUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: PostCreateOrConnectWithoutAuthorInput | PostCreateOrConnectWithoutAuthorInput[]
    createMany?: PostCreateManyAuthorInputEnvelope
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
  }

  export type TicketCreateNestedManyWithoutAuthorInput = {
    create?: XOR<TicketCreateWithoutAuthorInput, TicketUncheckedCreateWithoutAuthorInput> | TicketCreateWithoutAuthorInput[] | TicketUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutAuthorInput | TicketCreateOrConnectWithoutAuthorInput[]
    createMany?: TicketCreateManyAuthorInputEnvelope
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
  }

  export type TicketCreateNestedManyWithoutAssignedToInput = {
    create?: XOR<TicketCreateWithoutAssignedToInput, TicketUncheckedCreateWithoutAssignedToInput> | TicketCreateWithoutAssignedToInput[] | TicketUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutAssignedToInput | TicketCreateOrConnectWithoutAssignedToInput[]
    createMany?: TicketCreateManyAssignedToInputEnvelope
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
  }

  export type TicketMessageCreateNestedManyWithoutAuthorInput = {
    create?: XOR<TicketMessageCreateWithoutAuthorInput, TicketMessageUncheckedCreateWithoutAuthorInput> | TicketMessageCreateWithoutAuthorInput[] | TicketMessageUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: TicketMessageCreateOrConnectWithoutAuthorInput | TicketMessageCreateOrConnectWithoutAuthorInput[]
    createMany?: TicketMessageCreateManyAuthorInputEnvelope
    connect?: TicketMessageWhereUniqueInput | TicketMessageWhereUniqueInput[]
  }

  export type TicketParticipantCreateNestedManyWithoutUserInput = {
    create?: XOR<TicketParticipantCreateWithoutUserInput, TicketParticipantUncheckedCreateWithoutUserInput> | TicketParticipantCreateWithoutUserInput[] | TicketParticipantUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TicketParticipantCreateOrConnectWithoutUserInput | TicketParticipantCreateOrConnectWithoutUserInput[]
    createMany?: TicketParticipantCreateManyUserInputEnvelope
    connect?: TicketParticipantWhereUniqueInput | TicketParticipantWhereUniqueInput[]
  }

  export type TicketParticipantCreateNestedManyWithoutAddedByInput = {
    create?: XOR<TicketParticipantCreateWithoutAddedByInput, TicketParticipantUncheckedCreateWithoutAddedByInput> | TicketParticipantCreateWithoutAddedByInput[] | TicketParticipantUncheckedCreateWithoutAddedByInput[]
    connectOrCreate?: TicketParticipantCreateOrConnectWithoutAddedByInput | TicketParticipantCreateOrConnectWithoutAddedByInput[]
    createMany?: TicketParticipantCreateManyAddedByInputEnvelope
    connect?: TicketParticipantWhereUniqueInput | TicketParticipantWhereUniqueInput[]
  }

  export type TicketRatingCreateNestedManyWithoutRaterInput = {
    create?: XOR<TicketRatingCreateWithoutRaterInput, TicketRatingUncheckedCreateWithoutRaterInput> | TicketRatingCreateWithoutRaterInput[] | TicketRatingUncheckedCreateWithoutRaterInput[]
    connectOrCreate?: TicketRatingCreateOrConnectWithoutRaterInput | TicketRatingCreateOrConnectWithoutRaterInput[]
    createMany?: TicketRatingCreateManyRaterInputEnvelope
    connect?: TicketRatingWhereUniqueInput | TicketRatingWhereUniqueInput[]
  }

  export type TicketRatingCreateNestedManyWithoutTargetInput = {
    create?: XOR<TicketRatingCreateWithoutTargetInput, TicketRatingUncheckedCreateWithoutTargetInput> | TicketRatingCreateWithoutTargetInput[] | TicketRatingUncheckedCreateWithoutTargetInput[]
    connectOrCreate?: TicketRatingCreateOrConnectWithoutTargetInput | TicketRatingCreateOrConnectWithoutTargetInput[]
    createMany?: TicketRatingCreateManyTargetInputEnvelope
    connect?: TicketRatingWhereUniqueInput | TicketRatingWhereUniqueInput[]
  }

  export type TicketCreateNestedManyWithoutClosedByInput = {
    create?: XOR<TicketCreateWithoutClosedByInput, TicketUncheckedCreateWithoutClosedByInput> | TicketCreateWithoutClosedByInput[] | TicketUncheckedCreateWithoutClosedByInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutClosedByInput | TicketCreateOrConnectWithoutClosedByInput[]
    createMany?: TicketCreateManyClosedByInputEnvelope
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
  }

  export type PurchaseCreateNestedManyWithoutUserInput = {
    create?: XOR<PurchaseCreateWithoutUserInput, PurchaseUncheckedCreateWithoutUserInput> | PurchaseCreateWithoutUserInput[] | PurchaseUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PurchaseCreateOrConnectWithoutUserInput | PurchaseCreateOrConnectWithoutUserInput[]
    createMany?: PurchaseCreateManyUserInputEnvelope
    connect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
  }

  export type AuditLogCreateNestedManyWithoutActorInput = {
    create?: XOR<AuditLogCreateWithoutActorInput, AuditLogUncheckedCreateWithoutActorInput> | AuditLogCreateWithoutActorInput[] | AuditLogUncheckedCreateWithoutActorInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutActorInput | AuditLogCreateOrConnectWithoutActorInput[]
    createMany?: AuditLogCreateManyActorInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type UserRoleCreateNestedManyWithoutUserInput = {
    create?: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput> | UserRoleCreateWithoutUserInput[] | UserRoleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutUserInput | UserRoleCreateOrConnectWithoutUserInput[]
    createMany?: UserRoleCreateManyUserInputEnvelope
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
  }

  export type WhitelistApplicationCreateNestedManyWithoutUserInput = {
    create?: XOR<WhitelistApplicationCreateWithoutUserInput, WhitelistApplicationUncheckedCreateWithoutUserInput> | WhitelistApplicationCreateWithoutUserInput[] | WhitelistApplicationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WhitelistApplicationCreateOrConnectWithoutUserInput | WhitelistApplicationCreateOrConnectWithoutUserInput[]
    createMany?: WhitelistApplicationCreateManyUserInputEnvelope
    connect?: WhitelistApplicationWhereUniqueInput | WhitelistApplicationWhereUniqueInput[]
  }

  export type WhitelistApplicationCreateNestedManyWithoutReviewerInput = {
    create?: XOR<WhitelistApplicationCreateWithoutReviewerInput, WhitelistApplicationUncheckedCreateWithoutReviewerInput> | WhitelistApplicationCreateWithoutReviewerInput[] | WhitelistApplicationUncheckedCreateWithoutReviewerInput[]
    connectOrCreate?: WhitelistApplicationCreateOrConnectWithoutReviewerInput | WhitelistApplicationCreateOrConnectWithoutReviewerInput[]
    createMany?: WhitelistApplicationCreateManyReviewerInputEnvelope
    connect?: WhitelistApplicationWhereUniqueInput | WhitelistApplicationWhereUniqueInput[]
  }

  export type ConversationParticipantCreateNestedManyWithoutUserInput = {
    create?: XOR<ConversationParticipantCreateWithoutUserInput, ConversationParticipantUncheckedCreateWithoutUserInput> | ConversationParticipantCreateWithoutUserInput[] | ConversationParticipantUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ConversationParticipantCreateOrConnectWithoutUserInput | ConversationParticipantCreateOrConnectWithoutUserInput[]
    createMany?: ConversationParticipantCreateManyUserInputEnvelope
    connect?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
  }

  export type DirectMessageCreateNestedManyWithoutSenderInput = {
    create?: XOR<DirectMessageCreateWithoutSenderInput, DirectMessageUncheckedCreateWithoutSenderInput> | DirectMessageCreateWithoutSenderInput[] | DirectMessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: DirectMessageCreateOrConnectWithoutSenderInput | DirectMessageCreateOrConnectWithoutSenderInput[]
    createMany?: DirectMessageCreateManySenderInputEnvelope
    connect?: DirectMessageWhereUniqueInput | DirectMessageWhereUniqueInput[]
  }

  export type DirectMessageCreateNestedManyWithoutReceiverInput = {
    create?: XOR<DirectMessageCreateWithoutReceiverInput, DirectMessageUncheckedCreateWithoutReceiverInput> | DirectMessageCreateWithoutReceiverInput[] | DirectMessageUncheckedCreateWithoutReceiverInput[]
    connectOrCreate?: DirectMessageCreateOrConnectWithoutReceiverInput | DirectMessageCreateOrConnectWithoutReceiverInput[]
    createMany?: DirectMessageCreateManyReceiverInputEnvelope
    connect?: DirectMessageWhereUniqueInput | DirectMessageWhereUniqueInput[]
  }

  export type UserBadgeCreateNestedManyWithoutUserInput = {
    create?: XOR<UserBadgeCreateWithoutUserInput, UserBadgeUncheckedCreateWithoutUserInput> | UserBadgeCreateWithoutUserInput[] | UserBadgeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserBadgeCreateOrConnectWithoutUserInput | UserBadgeCreateOrConnectWithoutUserInput[]
    createMany?: UserBadgeCreateManyUserInputEnvelope
    connect?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
  }

  export type GameAccountCreateNestedManyWithoutUserInput = {
    create?: XOR<GameAccountCreateWithoutUserInput, GameAccountUncheckedCreateWithoutUserInput> | GameAccountCreateWithoutUserInput[] | GameAccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GameAccountCreateOrConnectWithoutUserInput | GameAccountCreateOrConnectWithoutUserInput[]
    createMany?: GameAccountCreateManyUserInputEnvelope
    connect?: GameAccountWhereUniqueInput | GameAccountWhereUniqueInput[]
  }

  export type MtaAccessLogCreateNestedManyWithoutUserInput = {
    create?: XOR<MtaAccessLogCreateWithoutUserInput, MtaAccessLogUncheckedCreateWithoutUserInput> | MtaAccessLogCreateWithoutUserInput[] | MtaAccessLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MtaAccessLogCreateOrConnectWithoutUserInput | MtaAccessLogCreateOrConnectWithoutUserInput[]
    createMany?: MtaAccessLogCreateManyUserInputEnvelope
    connect?: MtaAccessLogWhereUniqueInput | MtaAccessLogWhereUniqueInput[]
  }

  export type TicketRatingRequirementCreateNestedManyWithoutRaterInput = {
    create?: XOR<TicketRatingRequirementCreateWithoutRaterInput, TicketRatingRequirementUncheckedCreateWithoutRaterInput> | TicketRatingRequirementCreateWithoutRaterInput[] | TicketRatingRequirementUncheckedCreateWithoutRaterInput[]
    connectOrCreate?: TicketRatingRequirementCreateOrConnectWithoutRaterInput | TicketRatingRequirementCreateOrConnectWithoutRaterInput[]
    createMany?: TicketRatingRequirementCreateManyRaterInputEnvelope
    connect?: TicketRatingRequirementWhereUniqueInput | TicketRatingRequirementWhereUniqueInput[]
  }

  export type TicketRatingRequirementCreateNestedManyWithoutTargetInput = {
    create?: XOR<TicketRatingRequirementCreateWithoutTargetInput, TicketRatingRequirementUncheckedCreateWithoutTargetInput> | TicketRatingRequirementCreateWithoutTargetInput[] | TicketRatingRequirementUncheckedCreateWithoutTargetInput[]
    connectOrCreate?: TicketRatingRequirementCreateOrConnectWithoutTargetInput | TicketRatingRequirementCreateOrConnectWithoutTargetInput[]
    createMany?: TicketRatingRequirementCreateManyTargetInputEnvelope
    connect?: TicketRatingRequirementWhereUniqueInput | TicketRatingRequirementWhereUniqueInput[]
  }

  export type PasswordResetTokenCreateNestedManyWithoutUserInput = {
    create?: XOR<PasswordResetTokenCreateWithoutUserInput, PasswordResetTokenUncheckedCreateWithoutUserInput> | PasswordResetTokenCreateWithoutUserInput[] | PasswordResetTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PasswordResetTokenCreateOrConnectWithoutUserInput | PasswordResetTokenCreateOrConnectWithoutUserInput[]
    createMany?: PasswordResetTokenCreateManyUserInputEnvelope
    connect?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
  }

  export type EntitlementCreateNestedManyWithoutUserInput = {
    create?: XOR<EntitlementCreateWithoutUserInput, EntitlementUncheckedCreateWithoutUserInput> | EntitlementCreateWithoutUserInput[] | EntitlementUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EntitlementCreateOrConnectWithoutUserInput | EntitlementCreateOrConnectWithoutUserInput[]
    createMany?: EntitlementCreateManyUserInputEnvelope
    connect?: EntitlementWhereUniqueInput | EntitlementWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type StaffShiftCreateNestedManyWithoutUserInput = {
    create?: XOR<StaffShiftCreateWithoutUserInput, StaffShiftUncheckedCreateWithoutUserInput> | StaffShiftCreateWithoutUserInput[] | StaffShiftUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StaffShiftCreateOrConnectWithoutUserInput | StaffShiftCreateOrConnectWithoutUserInput[]
    createMany?: StaffShiftCreateManyUserInputEnvelope
    connect?: StaffShiftWhereUniqueInput | StaffShiftWhereUniqueInput[]
  }

  export type StaffWeeklyRewardCreateNestedManyWithoutUserInput = {
    create?: XOR<StaffWeeklyRewardCreateWithoutUserInput, StaffWeeklyRewardUncheckedCreateWithoutUserInput> | StaffWeeklyRewardCreateWithoutUserInput[] | StaffWeeklyRewardUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StaffWeeklyRewardCreateOrConnectWithoutUserInput | StaffWeeklyRewardCreateOrConnectWithoutUserInput[]
    createMany?: StaffWeeklyRewardCreateManyUserInputEnvelope
    connect?: StaffWeeklyRewardWhereUniqueInput | StaffWeeklyRewardWhereUniqueInput[]
  }

  export type AdminCaseCreateNestedManyWithoutTargetUserInput = {
    create?: XOR<AdminCaseCreateWithoutTargetUserInput, AdminCaseUncheckedCreateWithoutTargetUserInput> | AdminCaseCreateWithoutTargetUserInput[] | AdminCaseUncheckedCreateWithoutTargetUserInput[]
    connectOrCreate?: AdminCaseCreateOrConnectWithoutTargetUserInput | AdminCaseCreateOrConnectWithoutTargetUserInput[]
    createMany?: AdminCaseCreateManyTargetUserInputEnvelope
    connect?: AdminCaseWhereUniqueInput | AdminCaseWhereUniqueInput[]
  }

  export type AdminCaseCreateNestedManyWithoutStaffUserInput = {
    create?: XOR<AdminCaseCreateWithoutStaffUserInput, AdminCaseUncheckedCreateWithoutStaffUserInput> | AdminCaseCreateWithoutStaffUserInput[] | AdminCaseUncheckedCreateWithoutStaffUserInput[]
    connectOrCreate?: AdminCaseCreateOrConnectWithoutStaffUserInput | AdminCaseCreateOrConnectWithoutStaffUserInput[]
    createMany?: AdminCaseCreateManyStaffUserInputEnvelope
    connect?: AdminCaseWhereUniqueInput | AdminCaseWhereUniqueInput[]
  }

  export type UserReputationCreateNestedOneWithoutUserInput = {
    create?: XOR<UserReputationCreateWithoutUserInput, UserReputationUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserReputationCreateOrConnectWithoutUserInput
    connect?: UserReputationWhereUniqueInput
  }

  export type TopicUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<TopicCreateWithoutAuthorInput, TopicUncheckedCreateWithoutAuthorInput> | TopicCreateWithoutAuthorInput[] | TopicUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: TopicCreateOrConnectWithoutAuthorInput | TopicCreateOrConnectWithoutAuthorInput[]
    createMany?: TopicCreateManyAuthorInputEnvelope
    connect?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
  }

  export type PostUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<PostCreateWithoutAuthorInput, PostUncheckedCreateWithoutAuthorInput> | PostCreateWithoutAuthorInput[] | PostUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: PostCreateOrConnectWithoutAuthorInput | PostCreateOrConnectWithoutAuthorInput[]
    createMany?: PostCreateManyAuthorInputEnvelope
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
  }

  export type TicketUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<TicketCreateWithoutAuthorInput, TicketUncheckedCreateWithoutAuthorInput> | TicketCreateWithoutAuthorInput[] | TicketUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutAuthorInput | TicketCreateOrConnectWithoutAuthorInput[]
    createMany?: TicketCreateManyAuthorInputEnvelope
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
  }

  export type TicketUncheckedCreateNestedManyWithoutAssignedToInput = {
    create?: XOR<TicketCreateWithoutAssignedToInput, TicketUncheckedCreateWithoutAssignedToInput> | TicketCreateWithoutAssignedToInput[] | TicketUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutAssignedToInput | TicketCreateOrConnectWithoutAssignedToInput[]
    createMany?: TicketCreateManyAssignedToInputEnvelope
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
  }

  export type TicketMessageUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<TicketMessageCreateWithoutAuthorInput, TicketMessageUncheckedCreateWithoutAuthorInput> | TicketMessageCreateWithoutAuthorInput[] | TicketMessageUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: TicketMessageCreateOrConnectWithoutAuthorInput | TicketMessageCreateOrConnectWithoutAuthorInput[]
    createMany?: TicketMessageCreateManyAuthorInputEnvelope
    connect?: TicketMessageWhereUniqueInput | TicketMessageWhereUniqueInput[]
  }

  export type TicketParticipantUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TicketParticipantCreateWithoutUserInput, TicketParticipantUncheckedCreateWithoutUserInput> | TicketParticipantCreateWithoutUserInput[] | TicketParticipantUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TicketParticipantCreateOrConnectWithoutUserInput | TicketParticipantCreateOrConnectWithoutUserInput[]
    createMany?: TicketParticipantCreateManyUserInputEnvelope
    connect?: TicketParticipantWhereUniqueInput | TicketParticipantWhereUniqueInput[]
  }

  export type TicketParticipantUncheckedCreateNestedManyWithoutAddedByInput = {
    create?: XOR<TicketParticipantCreateWithoutAddedByInput, TicketParticipantUncheckedCreateWithoutAddedByInput> | TicketParticipantCreateWithoutAddedByInput[] | TicketParticipantUncheckedCreateWithoutAddedByInput[]
    connectOrCreate?: TicketParticipantCreateOrConnectWithoutAddedByInput | TicketParticipantCreateOrConnectWithoutAddedByInput[]
    createMany?: TicketParticipantCreateManyAddedByInputEnvelope
    connect?: TicketParticipantWhereUniqueInput | TicketParticipantWhereUniqueInput[]
  }

  export type TicketRatingUncheckedCreateNestedManyWithoutRaterInput = {
    create?: XOR<TicketRatingCreateWithoutRaterInput, TicketRatingUncheckedCreateWithoutRaterInput> | TicketRatingCreateWithoutRaterInput[] | TicketRatingUncheckedCreateWithoutRaterInput[]
    connectOrCreate?: TicketRatingCreateOrConnectWithoutRaterInput | TicketRatingCreateOrConnectWithoutRaterInput[]
    createMany?: TicketRatingCreateManyRaterInputEnvelope
    connect?: TicketRatingWhereUniqueInput | TicketRatingWhereUniqueInput[]
  }

  export type TicketRatingUncheckedCreateNestedManyWithoutTargetInput = {
    create?: XOR<TicketRatingCreateWithoutTargetInput, TicketRatingUncheckedCreateWithoutTargetInput> | TicketRatingCreateWithoutTargetInput[] | TicketRatingUncheckedCreateWithoutTargetInput[]
    connectOrCreate?: TicketRatingCreateOrConnectWithoutTargetInput | TicketRatingCreateOrConnectWithoutTargetInput[]
    createMany?: TicketRatingCreateManyTargetInputEnvelope
    connect?: TicketRatingWhereUniqueInput | TicketRatingWhereUniqueInput[]
  }

  export type TicketUncheckedCreateNestedManyWithoutClosedByInput = {
    create?: XOR<TicketCreateWithoutClosedByInput, TicketUncheckedCreateWithoutClosedByInput> | TicketCreateWithoutClosedByInput[] | TicketUncheckedCreateWithoutClosedByInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutClosedByInput | TicketCreateOrConnectWithoutClosedByInput[]
    createMany?: TicketCreateManyClosedByInputEnvelope
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
  }

  export type PurchaseUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PurchaseCreateWithoutUserInput, PurchaseUncheckedCreateWithoutUserInput> | PurchaseCreateWithoutUserInput[] | PurchaseUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PurchaseCreateOrConnectWithoutUserInput | PurchaseCreateOrConnectWithoutUserInput[]
    createMany?: PurchaseCreateManyUserInputEnvelope
    connect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
  }

  export type AuditLogUncheckedCreateNestedManyWithoutActorInput = {
    create?: XOR<AuditLogCreateWithoutActorInput, AuditLogUncheckedCreateWithoutActorInput> | AuditLogCreateWithoutActorInput[] | AuditLogUncheckedCreateWithoutActorInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutActorInput | AuditLogCreateOrConnectWithoutActorInput[]
    createMany?: AuditLogCreateManyActorInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type UserRoleUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput> | UserRoleCreateWithoutUserInput[] | UserRoleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutUserInput | UserRoleCreateOrConnectWithoutUserInput[]
    createMany?: UserRoleCreateManyUserInputEnvelope
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
  }

  export type WhitelistApplicationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<WhitelistApplicationCreateWithoutUserInput, WhitelistApplicationUncheckedCreateWithoutUserInput> | WhitelistApplicationCreateWithoutUserInput[] | WhitelistApplicationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WhitelistApplicationCreateOrConnectWithoutUserInput | WhitelistApplicationCreateOrConnectWithoutUserInput[]
    createMany?: WhitelistApplicationCreateManyUserInputEnvelope
    connect?: WhitelistApplicationWhereUniqueInput | WhitelistApplicationWhereUniqueInput[]
  }

  export type WhitelistApplicationUncheckedCreateNestedManyWithoutReviewerInput = {
    create?: XOR<WhitelistApplicationCreateWithoutReviewerInput, WhitelistApplicationUncheckedCreateWithoutReviewerInput> | WhitelistApplicationCreateWithoutReviewerInput[] | WhitelistApplicationUncheckedCreateWithoutReviewerInput[]
    connectOrCreate?: WhitelistApplicationCreateOrConnectWithoutReviewerInput | WhitelistApplicationCreateOrConnectWithoutReviewerInput[]
    createMany?: WhitelistApplicationCreateManyReviewerInputEnvelope
    connect?: WhitelistApplicationWhereUniqueInput | WhitelistApplicationWhereUniqueInput[]
  }

  export type ConversationParticipantUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ConversationParticipantCreateWithoutUserInput, ConversationParticipantUncheckedCreateWithoutUserInput> | ConversationParticipantCreateWithoutUserInput[] | ConversationParticipantUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ConversationParticipantCreateOrConnectWithoutUserInput | ConversationParticipantCreateOrConnectWithoutUserInput[]
    createMany?: ConversationParticipantCreateManyUserInputEnvelope
    connect?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
  }

  export type DirectMessageUncheckedCreateNestedManyWithoutSenderInput = {
    create?: XOR<DirectMessageCreateWithoutSenderInput, DirectMessageUncheckedCreateWithoutSenderInput> | DirectMessageCreateWithoutSenderInput[] | DirectMessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: DirectMessageCreateOrConnectWithoutSenderInput | DirectMessageCreateOrConnectWithoutSenderInput[]
    createMany?: DirectMessageCreateManySenderInputEnvelope
    connect?: DirectMessageWhereUniqueInput | DirectMessageWhereUniqueInput[]
  }

  export type DirectMessageUncheckedCreateNestedManyWithoutReceiverInput = {
    create?: XOR<DirectMessageCreateWithoutReceiverInput, DirectMessageUncheckedCreateWithoutReceiverInput> | DirectMessageCreateWithoutReceiverInput[] | DirectMessageUncheckedCreateWithoutReceiverInput[]
    connectOrCreate?: DirectMessageCreateOrConnectWithoutReceiverInput | DirectMessageCreateOrConnectWithoutReceiverInput[]
    createMany?: DirectMessageCreateManyReceiverInputEnvelope
    connect?: DirectMessageWhereUniqueInput | DirectMessageWhereUniqueInput[]
  }

  export type UserBadgeUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserBadgeCreateWithoutUserInput, UserBadgeUncheckedCreateWithoutUserInput> | UserBadgeCreateWithoutUserInput[] | UserBadgeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserBadgeCreateOrConnectWithoutUserInput | UserBadgeCreateOrConnectWithoutUserInput[]
    createMany?: UserBadgeCreateManyUserInputEnvelope
    connect?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
  }

  export type GameAccountUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<GameAccountCreateWithoutUserInput, GameAccountUncheckedCreateWithoutUserInput> | GameAccountCreateWithoutUserInput[] | GameAccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GameAccountCreateOrConnectWithoutUserInput | GameAccountCreateOrConnectWithoutUserInput[]
    createMany?: GameAccountCreateManyUserInputEnvelope
    connect?: GameAccountWhereUniqueInput | GameAccountWhereUniqueInput[]
  }

  export type MtaAccessLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<MtaAccessLogCreateWithoutUserInput, MtaAccessLogUncheckedCreateWithoutUserInput> | MtaAccessLogCreateWithoutUserInput[] | MtaAccessLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MtaAccessLogCreateOrConnectWithoutUserInput | MtaAccessLogCreateOrConnectWithoutUserInput[]
    createMany?: MtaAccessLogCreateManyUserInputEnvelope
    connect?: MtaAccessLogWhereUniqueInput | MtaAccessLogWhereUniqueInput[]
  }

  export type TicketRatingRequirementUncheckedCreateNestedManyWithoutRaterInput = {
    create?: XOR<TicketRatingRequirementCreateWithoutRaterInput, TicketRatingRequirementUncheckedCreateWithoutRaterInput> | TicketRatingRequirementCreateWithoutRaterInput[] | TicketRatingRequirementUncheckedCreateWithoutRaterInput[]
    connectOrCreate?: TicketRatingRequirementCreateOrConnectWithoutRaterInput | TicketRatingRequirementCreateOrConnectWithoutRaterInput[]
    createMany?: TicketRatingRequirementCreateManyRaterInputEnvelope
    connect?: TicketRatingRequirementWhereUniqueInput | TicketRatingRequirementWhereUniqueInput[]
  }

  export type TicketRatingRequirementUncheckedCreateNestedManyWithoutTargetInput = {
    create?: XOR<TicketRatingRequirementCreateWithoutTargetInput, TicketRatingRequirementUncheckedCreateWithoutTargetInput> | TicketRatingRequirementCreateWithoutTargetInput[] | TicketRatingRequirementUncheckedCreateWithoutTargetInput[]
    connectOrCreate?: TicketRatingRequirementCreateOrConnectWithoutTargetInput | TicketRatingRequirementCreateOrConnectWithoutTargetInput[]
    createMany?: TicketRatingRequirementCreateManyTargetInputEnvelope
    connect?: TicketRatingRequirementWhereUniqueInput | TicketRatingRequirementWhereUniqueInput[]
  }

  export type PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PasswordResetTokenCreateWithoutUserInput, PasswordResetTokenUncheckedCreateWithoutUserInput> | PasswordResetTokenCreateWithoutUserInput[] | PasswordResetTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PasswordResetTokenCreateOrConnectWithoutUserInput | PasswordResetTokenCreateOrConnectWithoutUserInput[]
    createMany?: PasswordResetTokenCreateManyUserInputEnvelope
    connect?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
  }

  export type EntitlementUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<EntitlementCreateWithoutUserInput, EntitlementUncheckedCreateWithoutUserInput> | EntitlementCreateWithoutUserInput[] | EntitlementUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EntitlementCreateOrConnectWithoutUserInput | EntitlementCreateOrConnectWithoutUserInput[]
    createMany?: EntitlementCreateManyUserInputEnvelope
    connect?: EntitlementWhereUniqueInput | EntitlementWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type StaffShiftUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<StaffShiftCreateWithoutUserInput, StaffShiftUncheckedCreateWithoutUserInput> | StaffShiftCreateWithoutUserInput[] | StaffShiftUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StaffShiftCreateOrConnectWithoutUserInput | StaffShiftCreateOrConnectWithoutUserInput[]
    createMany?: StaffShiftCreateManyUserInputEnvelope
    connect?: StaffShiftWhereUniqueInput | StaffShiftWhereUniqueInput[]
  }

  export type StaffWeeklyRewardUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<StaffWeeklyRewardCreateWithoutUserInput, StaffWeeklyRewardUncheckedCreateWithoutUserInput> | StaffWeeklyRewardCreateWithoutUserInput[] | StaffWeeklyRewardUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StaffWeeklyRewardCreateOrConnectWithoutUserInput | StaffWeeklyRewardCreateOrConnectWithoutUserInput[]
    createMany?: StaffWeeklyRewardCreateManyUserInputEnvelope
    connect?: StaffWeeklyRewardWhereUniqueInput | StaffWeeklyRewardWhereUniqueInput[]
  }

  export type AdminCaseUncheckedCreateNestedManyWithoutTargetUserInput = {
    create?: XOR<AdminCaseCreateWithoutTargetUserInput, AdminCaseUncheckedCreateWithoutTargetUserInput> | AdminCaseCreateWithoutTargetUserInput[] | AdminCaseUncheckedCreateWithoutTargetUserInput[]
    connectOrCreate?: AdminCaseCreateOrConnectWithoutTargetUserInput | AdminCaseCreateOrConnectWithoutTargetUserInput[]
    createMany?: AdminCaseCreateManyTargetUserInputEnvelope
    connect?: AdminCaseWhereUniqueInput | AdminCaseWhereUniqueInput[]
  }

  export type AdminCaseUncheckedCreateNestedManyWithoutStaffUserInput = {
    create?: XOR<AdminCaseCreateWithoutStaffUserInput, AdminCaseUncheckedCreateWithoutStaffUserInput> | AdminCaseCreateWithoutStaffUserInput[] | AdminCaseUncheckedCreateWithoutStaffUserInput[]
    connectOrCreate?: AdminCaseCreateOrConnectWithoutStaffUserInput | AdminCaseCreateOrConnectWithoutStaffUserInput[]
    createMany?: AdminCaseCreateManyStaffUserInputEnvelope
    connect?: AdminCaseWhereUniqueInput | AdminCaseWhereUniqueInput[]
  }

  export type UserReputationUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<UserReputationCreateWithoutUserInput, UserReputationUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserReputationCreateOrConnectWithoutUserInput
    connect?: UserReputationWhereUniqueInput
  }

  export type TopicUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<TopicCreateWithoutAuthorInput, TopicUncheckedCreateWithoutAuthorInput> | TopicCreateWithoutAuthorInput[] | TopicUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: TopicCreateOrConnectWithoutAuthorInput | TopicCreateOrConnectWithoutAuthorInput[]
    upsert?: TopicUpsertWithWhereUniqueWithoutAuthorInput | TopicUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: TopicCreateManyAuthorInputEnvelope
    set?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
    disconnect?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
    delete?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
    connect?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
    update?: TopicUpdateWithWhereUniqueWithoutAuthorInput | TopicUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: TopicUpdateManyWithWhereWithoutAuthorInput | TopicUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: TopicScalarWhereInput | TopicScalarWhereInput[]
  }

  export type PostUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<PostCreateWithoutAuthorInput, PostUncheckedCreateWithoutAuthorInput> | PostCreateWithoutAuthorInput[] | PostUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: PostCreateOrConnectWithoutAuthorInput | PostCreateOrConnectWithoutAuthorInput[]
    upsert?: PostUpsertWithWhereUniqueWithoutAuthorInput | PostUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: PostCreateManyAuthorInputEnvelope
    set?: PostWhereUniqueInput | PostWhereUniqueInput[]
    disconnect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    delete?: PostWhereUniqueInput | PostWhereUniqueInput[]
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    update?: PostUpdateWithWhereUniqueWithoutAuthorInput | PostUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: PostUpdateManyWithWhereWithoutAuthorInput | PostUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: PostScalarWhereInput | PostScalarWhereInput[]
  }

  export type TicketUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<TicketCreateWithoutAuthorInput, TicketUncheckedCreateWithoutAuthorInput> | TicketCreateWithoutAuthorInput[] | TicketUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutAuthorInput | TicketCreateOrConnectWithoutAuthorInput[]
    upsert?: TicketUpsertWithWhereUniqueWithoutAuthorInput | TicketUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: TicketCreateManyAuthorInputEnvelope
    set?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    disconnect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    delete?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    update?: TicketUpdateWithWhereUniqueWithoutAuthorInput | TicketUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: TicketUpdateManyWithWhereWithoutAuthorInput | TicketUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: TicketScalarWhereInput | TicketScalarWhereInput[]
  }

  export type TicketUpdateManyWithoutAssignedToNestedInput = {
    create?: XOR<TicketCreateWithoutAssignedToInput, TicketUncheckedCreateWithoutAssignedToInput> | TicketCreateWithoutAssignedToInput[] | TicketUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutAssignedToInput | TicketCreateOrConnectWithoutAssignedToInput[]
    upsert?: TicketUpsertWithWhereUniqueWithoutAssignedToInput | TicketUpsertWithWhereUniqueWithoutAssignedToInput[]
    createMany?: TicketCreateManyAssignedToInputEnvelope
    set?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    disconnect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    delete?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    update?: TicketUpdateWithWhereUniqueWithoutAssignedToInput | TicketUpdateWithWhereUniqueWithoutAssignedToInput[]
    updateMany?: TicketUpdateManyWithWhereWithoutAssignedToInput | TicketUpdateManyWithWhereWithoutAssignedToInput[]
    deleteMany?: TicketScalarWhereInput | TicketScalarWhereInput[]
  }

  export type TicketMessageUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<TicketMessageCreateWithoutAuthorInput, TicketMessageUncheckedCreateWithoutAuthorInput> | TicketMessageCreateWithoutAuthorInput[] | TicketMessageUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: TicketMessageCreateOrConnectWithoutAuthorInput | TicketMessageCreateOrConnectWithoutAuthorInput[]
    upsert?: TicketMessageUpsertWithWhereUniqueWithoutAuthorInput | TicketMessageUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: TicketMessageCreateManyAuthorInputEnvelope
    set?: TicketMessageWhereUniqueInput | TicketMessageWhereUniqueInput[]
    disconnect?: TicketMessageWhereUniqueInput | TicketMessageWhereUniqueInput[]
    delete?: TicketMessageWhereUniqueInput | TicketMessageWhereUniqueInput[]
    connect?: TicketMessageWhereUniqueInput | TicketMessageWhereUniqueInput[]
    update?: TicketMessageUpdateWithWhereUniqueWithoutAuthorInput | TicketMessageUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: TicketMessageUpdateManyWithWhereWithoutAuthorInput | TicketMessageUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: TicketMessageScalarWhereInput | TicketMessageScalarWhereInput[]
  }

  export type TicketParticipantUpdateManyWithoutUserNestedInput = {
    create?: XOR<TicketParticipantCreateWithoutUserInput, TicketParticipantUncheckedCreateWithoutUserInput> | TicketParticipantCreateWithoutUserInput[] | TicketParticipantUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TicketParticipantCreateOrConnectWithoutUserInput | TicketParticipantCreateOrConnectWithoutUserInput[]
    upsert?: TicketParticipantUpsertWithWhereUniqueWithoutUserInput | TicketParticipantUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TicketParticipantCreateManyUserInputEnvelope
    set?: TicketParticipantWhereUniqueInput | TicketParticipantWhereUniqueInput[]
    disconnect?: TicketParticipantWhereUniqueInput | TicketParticipantWhereUniqueInput[]
    delete?: TicketParticipantWhereUniqueInput | TicketParticipantWhereUniqueInput[]
    connect?: TicketParticipantWhereUniqueInput | TicketParticipantWhereUniqueInput[]
    update?: TicketParticipantUpdateWithWhereUniqueWithoutUserInput | TicketParticipantUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TicketParticipantUpdateManyWithWhereWithoutUserInput | TicketParticipantUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TicketParticipantScalarWhereInput | TicketParticipantScalarWhereInput[]
  }

  export type TicketParticipantUpdateManyWithoutAddedByNestedInput = {
    create?: XOR<TicketParticipantCreateWithoutAddedByInput, TicketParticipantUncheckedCreateWithoutAddedByInput> | TicketParticipantCreateWithoutAddedByInput[] | TicketParticipantUncheckedCreateWithoutAddedByInput[]
    connectOrCreate?: TicketParticipantCreateOrConnectWithoutAddedByInput | TicketParticipantCreateOrConnectWithoutAddedByInput[]
    upsert?: TicketParticipantUpsertWithWhereUniqueWithoutAddedByInput | TicketParticipantUpsertWithWhereUniqueWithoutAddedByInput[]
    createMany?: TicketParticipantCreateManyAddedByInputEnvelope
    set?: TicketParticipantWhereUniqueInput | TicketParticipantWhereUniqueInput[]
    disconnect?: TicketParticipantWhereUniqueInput | TicketParticipantWhereUniqueInput[]
    delete?: TicketParticipantWhereUniqueInput | TicketParticipantWhereUniqueInput[]
    connect?: TicketParticipantWhereUniqueInput | TicketParticipantWhereUniqueInput[]
    update?: TicketParticipantUpdateWithWhereUniqueWithoutAddedByInput | TicketParticipantUpdateWithWhereUniqueWithoutAddedByInput[]
    updateMany?: TicketParticipantUpdateManyWithWhereWithoutAddedByInput | TicketParticipantUpdateManyWithWhereWithoutAddedByInput[]
    deleteMany?: TicketParticipantScalarWhereInput | TicketParticipantScalarWhereInput[]
  }

  export type TicketRatingUpdateManyWithoutRaterNestedInput = {
    create?: XOR<TicketRatingCreateWithoutRaterInput, TicketRatingUncheckedCreateWithoutRaterInput> | TicketRatingCreateWithoutRaterInput[] | TicketRatingUncheckedCreateWithoutRaterInput[]
    connectOrCreate?: TicketRatingCreateOrConnectWithoutRaterInput | TicketRatingCreateOrConnectWithoutRaterInput[]
    upsert?: TicketRatingUpsertWithWhereUniqueWithoutRaterInput | TicketRatingUpsertWithWhereUniqueWithoutRaterInput[]
    createMany?: TicketRatingCreateManyRaterInputEnvelope
    set?: TicketRatingWhereUniqueInput | TicketRatingWhereUniqueInput[]
    disconnect?: TicketRatingWhereUniqueInput | TicketRatingWhereUniqueInput[]
    delete?: TicketRatingWhereUniqueInput | TicketRatingWhereUniqueInput[]
    connect?: TicketRatingWhereUniqueInput | TicketRatingWhereUniqueInput[]
    update?: TicketRatingUpdateWithWhereUniqueWithoutRaterInput | TicketRatingUpdateWithWhereUniqueWithoutRaterInput[]
    updateMany?: TicketRatingUpdateManyWithWhereWithoutRaterInput | TicketRatingUpdateManyWithWhereWithoutRaterInput[]
    deleteMany?: TicketRatingScalarWhereInput | TicketRatingScalarWhereInput[]
  }

  export type TicketRatingUpdateManyWithoutTargetNestedInput = {
    create?: XOR<TicketRatingCreateWithoutTargetInput, TicketRatingUncheckedCreateWithoutTargetInput> | TicketRatingCreateWithoutTargetInput[] | TicketRatingUncheckedCreateWithoutTargetInput[]
    connectOrCreate?: TicketRatingCreateOrConnectWithoutTargetInput | TicketRatingCreateOrConnectWithoutTargetInput[]
    upsert?: TicketRatingUpsertWithWhereUniqueWithoutTargetInput | TicketRatingUpsertWithWhereUniqueWithoutTargetInput[]
    createMany?: TicketRatingCreateManyTargetInputEnvelope
    set?: TicketRatingWhereUniqueInput | TicketRatingWhereUniqueInput[]
    disconnect?: TicketRatingWhereUniqueInput | TicketRatingWhereUniqueInput[]
    delete?: TicketRatingWhereUniqueInput | TicketRatingWhereUniqueInput[]
    connect?: TicketRatingWhereUniqueInput | TicketRatingWhereUniqueInput[]
    update?: TicketRatingUpdateWithWhereUniqueWithoutTargetInput | TicketRatingUpdateWithWhereUniqueWithoutTargetInput[]
    updateMany?: TicketRatingUpdateManyWithWhereWithoutTargetInput | TicketRatingUpdateManyWithWhereWithoutTargetInput[]
    deleteMany?: TicketRatingScalarWhereInput | TicketRatingScalarWhereInput[]
  }

  export type TicketUpdateManyWithoutClosedByNestedInput = {
    create?: XOR<TicketCreateWithoutClosedByInput, TicketUncheckedCreateWithoutClosedByInput> | TicketCreateWithoutClosedByInput[] | TicketUncheckedCreateWithoutClosedByInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutClosedByInput | TicketCreateOrConnectWithoutClosedByInput[]
    upsert?: TicketUpsertWithWhereUniqueWithoutClosedByInput | TicketUpsertWithWhereUniqueWithoutClosedByInput[]
    createMany?: TicketCreateManyClosedByInputEnvelope
    set?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    disconnect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    delete?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    update?: TicketUpdateWithWhereUniqueWithoutClosedByInput | TicketUpdateWithWhereUniqueWithoutClosedByInput[]
    updateMany?: TicketUpdateManyWithWhereWithoutClosedByInput | TicketUpdateManyWithWhereWithoutClosedByInput[]
    deleteMany?: TicketScalarWhereInput | TicketScalarWhereInput[]
  }

  export type PurchaseUpdateManyWithoutUserNestedInput = {
    create?: XOR<PurchaseCreateWithoutUserInput, PurchaseUncheckedCreateWithoutUserInput> | PurchaseCreateWithoutUserInput[] | PurchaseUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PurchaseCreateOrConnectWithoutUserInput | PurchaseCreateOrConnectWithoutUserInput[]
    upsert?: PurchaseUpsertWithWhereUniqueWithoutUserInput | PurchaseUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PurchaseCreateManyUserInputEnvelope
    set?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    disconnect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    delete?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    connect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    update?: PurchaseUpdateWithWhereUniqueWithoutUserInput | PurchaseUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PurchaseUpdateManyWithWhereWithoutUserInput | PurchaseUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PurchaseScalarWhereInput | PurchaseScalarWhereInput[]
  }

  export type AuditLogUpdateManyWithoutActorNestedInput = {
    create?: XOR<AuditLogCreateWithoutActorInput, AuditLogUncheckedCreateWithoutActorInput> | AuditLogCreateWithoutActorInput[] | AuditLogUncheckedCreateWithoutActorInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutActorInput | AuditLogCreateOrConnectWithoutActorInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutActorInput | AuditLogUpsertWithWhereUniqueWithoutActorInput[]
    createMany?: AuditLogCreateManyActorInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutActorInput | AuditLogUpdateWithWhereUniqueWithoutActorInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutActorInput | AuditLogUpdateManyWithWhereWithoutActorInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type UserRoleUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput> | UserRoleCreateWithoutUserInput[] | UserRoleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutUserInput | UserRoleCreateOrConnectWithoutUserInput[]
    upsert?: UserRoleUpsertWithWhereUniqueWithoutUserInput | UserRoleUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserRoleCreateManyUserInputEnvelope
    set?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    disconnect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    delete?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    update?: UserRoleUpdateWithWhereUniqueWithoutUserInput | UserRoleUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserRoleUpdateManyWithWhereWithoutUserInput | UserRoleUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
  }

  export type WhitelistApplicationUpdateManyWithoutUserNestedInput = {
    create?: XOR<WhitelistApplicationCreateWithoutUserInput, WhitelistApplicationUncheckedCreateWithoutUserInput> | WhitelistApplicationCreateWithoutUserInput[] | WhitelistApplicationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WhitelistApplicationCreateOrConnectWithoutUserInput | WhitelistApplicationCreateOrConnectWithoutUserInput[]
    upsert?: WhitelistApplicationUpsertWithWhereUniqueWithoutUserInput | WhitelistApplicationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: WhitelistApplicationCreateManyUserInputEnvelope
    set?: WhitelistApplicationWhereUniqueInput | WhitelistApplicationWhereUniqueInput[]
    disconnect?: WhitelistApplicationWhereUniqueInput | WhitelistApplicationWhereUniqueInput[]
    delete?: WhitelistApplicationWhereUniqueInput | WhitelistApplicationWhereUniqueInput[]
    connect?: WhitelistApplicationWhereUniqueInput | WhitelistApplicationWhereUniqueInput[]
    update?: WhitelistApplicationUpdateWithWhereUniqueWithoutUserInput | WhitelistApplicationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: WhitelistApplicationUpdateManyWithWhereWithoutUserInput | WhitelistApplicationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: WhitelistApplicationScalarWhereInput | WhitelistApplicationScalarWhereInput[]
  }

  export type WhitelistApplicationUpdateManyWithoutReviewerNestedInput = {
    create?: XOR<WhitelistApplicationCreateWithoutReviewerInput, WhitelistApplicationUncheckedCreateWithoutReviewerInput> | WhitelistApplicationCreateWithoutReviewerInput[] | WhitelistApplicationUncheckedCreateWithoutReviewerInput[]
    connectOrCreate?: WhitelistApplicationCreateOrConnectWithoutReviewerInput | WhitelistApplicationCreateOrConnectWithoutReviewerInput[]
    upsert?: WhitelistApplicationUpsertWithWhereUniqueWithoutReviewerInput | WhitelistApplicationUpsertWithWhereUniqueWithoutReviewerInput[]
    createMany?: WhitelistApplicationCreateManyReviewerInputEnvelope
    set?: WhitelistApplicationWhereUniqueInput | WhitelistApplicationWhereUniqueInput[]
    disconnect?: WhitelistApplicationWhereUniqueInput | WhitelistApplicationWhereUniqueInput[]
    delete?: WhitelistApplicationWhereUniqueInput | WhitelistApplicationWhereUniqueInput[]
    connect?: WhitelistApplicationWhereUniqueInput | WhitelistApplicationWhereUniqueInput[]
    update?: WhitelistApplicationUpdateWithWhereUniqueWithoutReviewerInput | WhitelistApplicationUpdateWithWhereUniqueWithoutReviewerInput[]
    updateMany?: WhitelistApplicationUpdateManyWithWhereWithoutReviewerInput | WhitelistApplicationUpdateManyWithWhereWithoutReviewerInput[]
    deleteMany?: WhitelistApplicationScalarWhereInput | WhitelistApplicationScalarWhereInput[]
  }

  export type ConversationParticipantUpdateManyWithoutUserNestedInput = {
    create?: XOR<ConversationParticipantCreateWithoutUserInput, ConversationParticipantUncheckedCreateWithoutUserInput> | ConversationParticipantCreateWithoutUserInput[] | ConversationParticipantUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ConversationParticipantCreateOrConnectWithoutUserInput | ConversationParticipantCreateOrConnectWithoutUserInput[]
    upsert?: ConversationParticipantUpsertWithWhereUniqueWithoutUserInput | ConversationParticipantUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ConversationParticipantCreateManyUserInputEnvelope
    set?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
    disconnect?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
    delete?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
    connect?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
    update?: ConversationParticipantUpdateWithWhereUniqueWithoutUserInput | ConversationParticipantUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ConversationParticipantUpdateManyWithWhereWithoutUserInput | ConversationParticipantUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ConversationParticipantScalarWhereInput | ConversationParticipantScalarWhereInput[]
  }

  export type DirectMessageUpdateManyWithoutSenderNestedInput = {
    create?: XOR<DirectMessageCreateWithoutSenderInput, DirectMessageUncheckedCreateWithoutSenderInput> | DirectMessageCreateWithoutSenderInput[] | DirectMessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: DirectMessageCreateOrConnectWithoutSenderInput | DirectMessageCreateOrConnectWithoutSenderInput[]
    upsert?: DirectMessageUpsertWithWhereUniqueWithoutSenderInput | DirectMessageUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: DirectMessageCreateManySenderInputEnvelope
    set?: DirectMessageWhereUniqueInput | DirectMessageWhereUniqueInput[]
    disconnect?: DirectMessageWhereUniqueInput | DirectMessageWhereUniqueInput[]
    delete?: DirectMessageWhereUniqueInput | DirectMessageWhereUniqueInput[]
    connect?: DirectMessageWhereUniqueInput | DirectMessageWhereUniqueInput[]
    update?: DirectMessageUpdateWithWhereUniqueWithoutSenderInput | DirectMessageUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: DirectMessageUpdateManyWithWhereWithoutSenderInput | DirectMessageUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: DirectMessageScalarWhereInput | DirectMessageScalarWhereInput[]
  }

  export type DirectMessageUpdateManyWithoutReceiverNestedInput = {
    create?: XOR<DirectMessageCreateWithoutReceiverInput, DirectMessageUncheckedCreateWithoutReceiverInput> | DirectMessageCreateWithoutReceiverInput[] | DirectMessageUncheckedCreateWithoutReceiverInput[]
    connectOrCreate?: DirectMessageCreateOrConnectWithoutReceiverInput | DirectMessageCreateOrConnectWithoutReceiverInput[]
    upsert?: DirectMessageUpsertWithWhereUniqueWithoutReceiverInput | DirectMessageUpsertWithWhereUniqueWithoutReceiverInput[]
    createMany?: DirectMessageCreateManyReceiverInputEnvelope
    set?: DirectMessageWhereUniqueInput | DirectMessageWhereUniqueInput[]
    disconnect?: DirectMessageWhereUniqueInput | DirectMessageWhereUniqueInput[]
    delete?: DirectMessageWhereUniqueInput | DirectMessageWhereUniqueInput[]
    connect?: DirectMessageWhereUniqueInput | DirectMessageWhereUniqueInput[]
    update?: DirectMessageUpdateWithWhereUniqueWithoutReceiverInput | DirectMessageUpdateWithWhereUniqueWithoutReceiverInput[]
    updateMany?: DirectMessageUpdateManyWithWhereWithoutReceiverInput | DirectMessageUpdateManyWithWhereWithoutReceiverInput[]
    deleteMany?: DirectMessageScalarWhereInput | DirectMessageScalarWhereInput[]
  }

  export type UserBadgeUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserBadgeCreateWithoutUserInput, UserBadgeUncheckedCreateWithoutUserInput> | UserBadgeCreateWithoutUserInput[] | UserBadgeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserBadgeCreateOrConnectWithoutUserInput | UserBadgeCreateOrConnectWithoutUserInput[]
    upsert?: UserBadgeUpsertWithWhereUniqueWithoutUserInput | UserBadgeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserBadgeCreateManyUserInputEnvelope
    set?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
    disconnect?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
    delete?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
    connect?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
    update?: UserBadgeUpdateWithWhereUniqueWithoutUserInput | UserBadgeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserBadgeUpdateManyWithWhereWithoutUserInput | UserBadgeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserBadgeScalarWhereInput | UserBadgeScalarWhereInput[]
  }

  export type GameAccountUpdateManyWithoutUserNestedInput = {
    create?: XOR<GameAccountCreateWithoutUserInput, GameAccountUncheckedCreateWithoutUserInput> | GameAccountCreateWithoutUserInput[] | GameAccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GameAccountCreateOrConnectWithoutUserInput | GameAccountCreateOrConnectWithoutUserInput[]
    upsert?: GameAccountUpsertWithWhereUniqueWithoutUserInput | GameAccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: GameAccountCreateManyUserInputEnvelope
    set?: GameAccountWhereUniqueInput | GameAccountWhereUniqueInput[]
    disconnect?: GameAccountWhereUniqueInput | GameAccountWhereUniqueInput[]
    delete?: GameAccountWhereUniqueInput | GameAccountWhereUniqueInput[]
    connect?: GameAccountWhereUniqueInput | GameAccountWhereUniqueInput[]
    update?: GameAccountUpdateWithWhereUniqueWithoutUserInput | GameAccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: GameAccountUpdateManyWithWhereWithoutUserInput | GameAccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: GameAccountScalarWhereInput | GameAccountScalarWhereInput[]
  }

  export type MtaAccessLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<MtaAccessLogCreateWithoutUserInput, MtaAccessLogUncheckedCreateWithoutUserInput> | MtaAccessLogCreateWithoutUserInput[] | MtaAccessLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MtaAccessLogCreateOrConnectWithoutUserInput | MtaAccessLogCreateOrConnectWithoutUserInput[]
    upsert?: MtaAccessLogUpsertWithWhereUniqueWithoutUserInput | MtaAccessLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MtaAccessLogCreateManyUserInputEnvelope
    set?: MtaAccessLogWhereUniqueInput | MtaAccessLogWhereUniqueInput[]
    disconnect?: MtaAccessLogWhereUniqueInput | MtaAccessLogWhereUniqueInput[]
    delete?: MtaAccessLogWhereUniqueInput | MtaAccessLogWhereUniqueInput[]
    connect?: MtaAccessLogWhereUniqueInput | MtaAccessLogWhereUniqueInput[]
    update?: MtaAccessLogUpdateWithWhereUniqueWithoutUserInput | MtaAccessLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MtaAccessLogUpdateManyWithWhereWithoutUserInput | MtaAccessLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MtaAccessLogScalarWhereInput | MtaAccessLogScalarWhereInput[]
  }

  export type TicketRatingRequirementUpdateManyWithoutRaterNestedInput = {
    create?: XOR<TicketRatingRequirementCreateWithoutRaterInput, TicketRatingRequirementUncheckedCreateWithoutRaterInput> | TicketRatingRequirementCreateWithoutRaterInput[] | TicketRatingRequirementUncheckedCreateWithoutRaterInput[]
    connectOrCreate?: TicketRatingRequirementCreateOrConnectWithoutRaterInput | TicketRatingRequirementCreateOrConnectWithoutRaterInput[]
    upsert?: TicketRatingRequirementUpsertWithWhereUniqueWithoutRaterInput | TicketRatingRequirementUpsertWithWhereUniqueWithoutRaterInput[]
    createMany?: TicketRatingRequirementCreateManyRaterInputEnvelope
    set?: TicketRatingRequirementWhereUniqueInput | TicketRatingRequirementWhereUniqueInput[]
    disconnect?: TicketRatingRequirementWhereUniqueInput | TicketRatingRequirementWhereUniqueInput[]
    delete?: TicketRatingRequirementWhereUniqueInput | TicketRatingRequirementWhereUniqueInput[]
    connect?: TicketRatingRequirementWhereUniqueInput | TicketRatingRequirementWhereUniqueInput[]
    update?: TicketRatingRequirementUpdateWithWhereUniqueWithoutRaterInput | TicketRatingRequirementUpdateWithWhereUniqueWithoutRaterInput[]
    updateMany?: TicketRatingRequirementUpdateManyWithWhereWithoutRaterInput | TicketRatingRequirementUpdateManyWithWhereWithoutRaterInput[]
    deleteMany?: TicketRatingRequirementScalarWhereInput | TicketRatingRequirementScalarWhereInput[]
  }

  export type TicketRatingRequirementUpdateManyWithoutTargetNestedInput = {
    create?: XOR<TicketRatingRequirementCreateWithoutTargetInput, TicketRatingRequirementUncheckedCreateWithoutTargetInput> | TicketRatingRequirementCreateWithoutTargetInput[] | TicketRatingRequirementUncheckedCreateWithoutTargetInput[]
    connectOrCreate?: TicketRatingRequirementCreateOrConnectWithoutTargetInput | TicketRatingRequirementCreateOrConnectWithoutTargetInput[]
    upsert?: TicketRatingRequirementUpsertWithWhereUniqueWithoutTargetInput | TicketRatingRequirementUpsertWithWhereUniqueWithoutTargetInput[]
    createMany?: TicketRatingRequirementCreateManyTargetInputEnvelope
    set?: TicketRatingRequirementWhereUniqueInput | TicketRatingRequirementWhereUniqueInput[]
    disconnect?: TicketRatingRequirementWhereUniqueInput | TicketRatingRequirementWhereUniqueInput[]
    delete?: TicketRatingRequirementWhereUniqueInput | TicketRatingRequirementWhereUniqueInput[]
    connect?: TicketRatingRequirementWhereUniqueInput | TicketRatingRequirementWhereUniqueInput[]
    update?: TicketRatingRequirementUpdateWithWhereUniqueWithoutTargetInput | TicketRatingRequirementUpdateWithWhereUniqueWithoutTargetInput[]
    updateMany?: TicketRatingRequirementUpdateManyWithWhereWithoutTargetInput | TicketRatingRequirementUpdateManyWithWhereWithoutTargetInput[]
    deleteMany?: TicketRatingRequirementScalarWhereInput | TicketRatingRequirementScalarWhereInput[]
  }

  export type PasswordResetTokenUpdateManyWithoutUserNestedInput = {
    create?: XOR<PasswordResetTokenCreateWithoutUserInput, PasswordResetTokenUncheckedCreateWithoutUserInput> | PasswordResetTokenCreateWithoutUserInput[] | PasswordResetTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PasswordResetTokenCreateOrConnectWithoutUserInput | PasswordResetTokenCreateOrConnectWithoutUserInput[]
    upsert?: PasswordResetTokenUpsertWithWhereUniqueWithoutUserInput | PasswordResetTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PasswordResetTokenCreateManyUserInputEnvelope
    set?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
    disconnect?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
    delete?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
    connect?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
    update?: PasswordResetTokenUpdateWithWhereUniqueWithoutUserInput | PasswordResetTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PasswordResetTokenUpdateManyWithWhereWithoutUserInput | PasswordResetTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PasswordResetTokenScalarWhereInput | PasswordResetTokenScalarWhereInput[]
  }

  export type EntitlementUpdateManyWithoutUserNestedInput = {
    create?: XOR<EntitlementCreateWithoutUserInput, EntitlementUncheckedCreateWithoutUserInput> | EntitlementCreateWithoutUserInput[] | EntitlementUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EntitlementCreateOrConnectWithoutUserInput | EntitlementCreateOrConnectWithoutUserInput[]
    upsert?: EntitlementUpsertWithWhereUniqueWithoutUserInput | EntitlementUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: EntitlementCreateManyUserInputEnvelope
    set?: EntitlementWhereUniqueInput | EntitlementWhereUniqueInput[]
    disconnect?: EntitlementWhereUniqueInput | EntitlementWhereUniqueInput[]
    delete?: EntitlementWhereUniqueInput | EntitlementWhereUniqueInput[]
    connect?: EntitlementWhereUniqueInput | EntitlementWhereUniqueInput[]
    update?: EntitlementUpdateWithWhereUniqueWithoutUserInput | EntitlementUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: EntitlementUpdateManyWithWhereWithoutUserInput | EntitlementUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: EntitlementScalarWhereInput | EntitlementScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type StaffShiftUpdateManyWithoutUserNestedInput = {
    create?: XOR<StaffShiftCreateWithoutUserInput, StaffShiftUncheckedCreateWithoutUserInput> | StaffShiftCreateWithoutUserInput[] | StaffShiftUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StaffShiftCreateOrConnectWithoutUserInput | StaffShiftCreateOrConnectWithoutUserInput[]
    upsert?: StaffShiftUpsertWithWhereUniqueWithoutUserInput | StaffShiftUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: StaffShiftCreateManyUserInputEnvelope
    set?: StaffShiftWhereUniqueInput | StaffShiftWhereUniqueInput[]
    disconnect?: StaffShiftWhereUniqueInput | StaffShiftWhereUniqueInput[]
    delete?: StaffShiftWhereUniqueInput | StaffShiftWhereUniqueInput[]
    connect?: StaffShiftWhereUniqueInput | StaffShiftWhereUniqueInput[]
    update?: StaffShiftUpdateWithWhereUniqueWithoutUserInput | StaffShiftUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: StaffShiftUpdateManyWithWhereWithoutUserInput | StaffShiftUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: StaffShiftScalarWhereInput | StaffShiftScalarWhereInput[]
  }

  export type StaffWeeklyRewardUpdateManyWithoutUserNestedInput = {
    create?: XOR<StaffWeeklyRewardCreateWithoutUserInput, StaffWeeklyRewardUncheckedCreateWithoutUserInput> | StaffWeeklyRewardCreateWithoutUserInput[] | StaffWeeklyRewardUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StaffWeeklyRewardCreateOrConnectWithoutUserInput | StaffWeeklyRewardCreateOrConnectWithoutUserInput[]
    upsert?: StaffWeeklyRewardUpsertWithWhereUniqueWithoutUserInput | StaffWeeklyRewardUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: StaffWeeklyRewardCreateManyUserInputEnvelope
    set?: StaffWeeklyRewardWhereUniqueInput | StaffWeeklyRewardWhereUniqueInput[]
    disconnect?: StaffWeeklyRewardWhereUniqueInput | StaffWeeklyRewardWhereUniqueInput[]
    delete?: StaffWeeklyRewardWhereUniqueInput | StaffWeeklyRewardWhereUniqueInput[]
    connect?: StaffWeeklyRewardWhereUniqueInput | StaffWeeklyRewardWhereUniqueInput[]
    update?: StaffWeeklyRewardUpdateWithWhereUniqueWithoutUserInput | StaffWeeklyRewardUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: StaffWeeklyRewardUpdateManyWithWhereWithoutUserInput | StaffWeeklyRewardUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: StaffWeeklyRewardScalarWhereInput | StaffWeeklyRewardScalarWhereInput[]
  }

  export type AdminCaseUpdateManyWithoutTargetUserNestedInput = {
    create?: XOR<AdminCaseCreateWithoutTargetUserInput, AdminCaseUncheckedCreateWithoutTargetUserInput> | AdminCaseCreateWithoutTargetUserInput[] | AdminCaseUncheckedCreateWithoutTargetUserInput[]
    connectOrCreate?: AdminCaseCreateOrConnectWithoutTargetUserInput | AdminCaseCreateOrConnectWithoutTargetUserInput[]
    upsert?: AdminCaseUpsertWithWhereUniqueWithoutTargetUserInput | AdminCaseUpsertWithWhereUniqueWithoutTargetUserInput[]
    createMany?: AdminCaseCreateManyTargetUserInputEnvelope
    set?: AdminCaseWhereUniqueInput | AdminCaseWhereUniqueInput[]
    disconnect?: AdminCaseWhereUniqueInput | AdminCaseWhereUniqueInput[]
    delete?: AdminCaseWhereUniqueInput | AdminCaseWhereUniqueInput[]
    connect?: AdminCaseWhereUniqueInput | AdminCaseWhereUniqueInput[]
    update?: AdminCaseUpdateWithWhereUniqueWithoutTargetUserInput | AdminCaseUpdateWithWhereUniqueWithoutTargetUserInput[]
    updateMany?: AdminCaseUpdateManyWithWhereWithoutTargetUserInput | AdminCaseUpdateManyWithWhereWithoutTargetUserInput[]
    deleteMany?: AdminCaseScalarWhereInput | AdminCaseScalarWhereInput[]
  }

  export type AdminCaseUpdateManyWithoutStaffUserNestedInput = {
    create?: XOR<AdminCaseCreateWithoutStaffUserInput, AdminCaseUncheckedCreateWithoutStaffUserInput> | AdminCaseCreateWithoutStaffUserInput[] | AdminCaseUncheckedCreateWithoutStaffUserInput[]
    connectOrCreate?: AdminCaseCreateOrConnectWithoutStaffUserInput | AdminCaseCreateOrConnectWithoutStaffUserInput[]
    upsert?: AdminCaseUpsertWithWhereUniqueWithoutStaffUserInput | AdminCaseUpsertWithWhereUniqueWithoutStaffUserInput[]
    createMany?: AdminCaseCreateManyStaffUserInputEnvelope
    set?: AdminCaseWhereUniqueInput | AdminCaseWhereUniqueInput[]
    disconnect?: AdminCaseWhereUniqueInput | AdminCaseWhereUniqueInput[]
    delete?: AdminCaseWhereUniqueInput | AdminCaseWhereUniqueInput[]
    connect?: AdminCaseWhereUniqueInput | AdminCaseWhereUniqueInput[]
    update?: AdminCaseUpdateWithWhereUniqueWithoutStaffUserInput | AdminCaseUpdateWithWhereUniqueWithoutStaffUserInput[]
    updateMany?: AdminCaseUpdateManyWithWhereWithoutStaffUserInput | AdminCaseUpdateManyWithWhereWithoutStaffUserInput[]
    deleteMany?: AdminCaseScalarWhereInput | AdminCaseScalarWhereInput[]
  }

  export type UserReputationUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserReputationCreateWithoutUserInput, UserReputationUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserReputationCreateOrConnectWithoutUserInput
    upsert?: UserReputationUpsertWithoutUserInput
    disconnect?: UserReputationWhereInput | boolean
    delete?: UserReputationWhereInput | boolean
    connect?: UserReputationWhereUniqueInput
    update?: XOR<XOR<UserReputationUpdateToOneWithWhereWithoutUserInput, UserReputationUpdateWithoutUserInput>, UserReputationUncheckedUpdateWithoutUserInput>
  }

  export type TopicUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<TopicCreateWithoutAuthorInput, TopicUncheckedCreateWithoutAuthorInput> | TopicCreateWithoutAuthorInput[] | TopicUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: TopicCreateOrConnectWithoutAuthorInput | TopicCreateOrConnectWithoutAuthorInput[]
    upsert?: TopicUpsertWithWhereUniqueWithoutAuthorInput | TopicUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: TopicCreateManyAuthorInputEnvelope
    set?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
    disconnect?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
    delete?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
    connect?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
    update?: TopicUpdateWithWhereUniqueWithoutAuthorInput | TopicUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: TopicUpdateManyWithWhereWithoutAuthorInput | TopicUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: TopicScalarWhereInput | TopicScalarWhereInput[]
  }

  export type PostUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<PostCreateWithoutAuthorInput, PostUncheckedCreateWithoutAuthorInput> | PostCreateWithoutAuthorInput[] | PostUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: PostCreateOrConnectWithoutAuthorInput | PostCreateOrConnectWithoutAuthorInput[]
    upsert?: PostUpsertWithWhereUniqueWithoutAuthorInput | PostUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: PostCreateManyAuthorInputEnvelope
    set?: PostWhereUniqueInput | PostWhereUniqueInput[]
    disconnect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    delete?: PostWhereUniqueInput | PostWhereUniqueInput[]
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    update?: PostUpdateWithWhereUniqueWithoutAuthorInput | PostUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: PostUpdateManyWithWhereWithoutAuthorInput | PostUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: PostScalarWhereInput | PostScalarWhereInput[]
  }

  export type TicketUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<TicketCreateWithoutAuthorInput, TicketUncheckedCreateWithoutAuthorInput> | TicketCreateWithoutAuthorInput[] | TicketUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutAuthorInput | TicketCreateOrConnectWithoutAuthorInput[]
    upsert?: TicketUpsertWithWhereUniqueWithoutAuthorInput | TicketUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: TicketCreateManyAuthorInputEnvelope
    set?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    disconnect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    delete?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    update?: TicketUpdateWithWhereUniqueWithoutAuthorInput | TicketUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: TicketUpdateManyWithWhereWithoutAuthorInput | TicketUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: TicketScalarWhereInput | TicketScalarWhereInput[]
  }

  export type TicketUncheckedUpdateManyWithoutAssignedToNestedInput = {
    create?: XOR<TicketCreateWithoutAssignedToInput, TicketUncheckedCreateWithoutAssignedToInput> | TicketCreateWithoutAssignedToInput[] | TicketUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutAssignedToInput | TicketCreateOrConnectWithoutAssignedToInput[]
    upsert?: TicketUpsertWithWhereUniqueWithoutAssignedToInput | TicketUpsertWithWhereUniqueWithoutAssignedToInput[]
    createMany?: TicketCreateManyAssignedToInputEnvelope
    set?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    disconnect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    delete?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    update?: TicketUpdateWithWhereUniqueWithoutAssignedToInput | TicketUpdateWithWhereUniqueWithoutAssignedToInput[]
    updateMany?: TicketUpdateManyWithWhereWithoutAssignedToInput | TicketUpdateManyWithWhereWithoutAssignedToInput[]
    deleteMany?: TicketScalarWhereInput | TicketScalarWhereInput[]
  }

  export type TicketMessageUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<TicketMessageCreateWithoutAuthorInput, TicketMessageUncheckedCreateWithoutAuthorInput> | TicketMessageCreateWithoutAuthorInput[] | TicketMessageUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: TicketMessageCreateOrConnectWithoutAuthorInput | TicketMessageCreateOrConnectWithoutAuthorInput[]
    upsert?: TicketMessageUpsertWithWhereUniqueWithoutAuthorInput | TicketMessageUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: TicketMessageCreateManyAuthorInputEnvelope
    set?: TicketMessageWhereUniqueInput | TicketMessageWhereUniqueInput[]
    disconnect?: TicketMessageWhereUniqueInput | TicketMessageWhereUniqueInput[]
    delete?: TicketMessageWhereUniqueInput | TicketMessageWhereUniqueInput[]
    connect?: TicketMessageWhereUniqueInput | TicketMessageWhereUniqueInput[]
    update?: TicketMessageUpdateWithWhereUniqueWithoutAuthorInput | TicketMessageUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: TicketMessageUpdateManyWithWhereWithoutAuthorInput | TicketMessageUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: TicketMessageScalarWhereInput | TicketMessageScalarWhereInput[]
  }

  export type TicketParticipantUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TicketParticipantCreateWithoutUserInput, TicketParticipantUncheckedCreateWithoutUserInput> | TicketParticipantCreateWithoutUserInput[] | TicketParticipantUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TicketParticipantCreateOrConnectWithoutUserInput | TicketParticipantCreateOrConnectWithoutUserInput[]
    upsert?: TicketParticipantUpsertWithWhereUniqueWithoutUserInput | TicketParticipantUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TicketParticipantCreateManyUserInputEnvelope
    set?: TicketParticipantWhereUniqueInput | TicketParticipantWhereUniqueInput[]
    disconnect?: TicketParticipantWhereUniqueInput | TicketParticipantWhereUniqueInput[]
    delete?: TicketParticipantWhereUniqueInput | TicketParticipantWhereUniqueInput[]
    connect?: TicketParticipantWhereUniqueInput | TicketParticipantWhereUniqueInput[]
    update?: TicketParticipantUpdateWithWhereUniqueWithoutUserInput | TicketParticipantUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TicketParticipantUpdateManyWithWhereWithoutUserInput | TicketParticipantUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TicketParticipantScalarWhereInput | TicketParticipantScalarWhereInput[]
  }

  export type TicketParticipantUncheckedUpdateManyWithoutAddedByNestedInput = {
    create?: XOR<TicketParticipantCreateWithoutAddedByInput, TicketParticipantUncheckedCreateWithoutAddedByInput> | TicketParticipantCreateWithoutAddedByInput[] | TicketParticipantUncheckedCreateWithoutAddedByInput[]
    connectOrCreate?: TicketParticipantCreateOrConnectWithoutAddedByInput | TicketParticipantCreateOrConnectWithoutAddedByInput[]
    upsert?: TicketParticipantUpsertWithWhereUniqueWithoutAddedByInput | TicketParticipantUpsertWithWhereUniqueWithoutAddedByInput[]
    createMany?: TicketParticipantCreateManyAddedByInputEnvelope
    set?: TicketParticipantWhereUniqueInput | TicketParticipantWhereUniqueInput[]
    disconnect?: TicketParticipantWhereUniqueInput | TicketParticipantWhereUniqueInput[]
    delete?: TicketParticipantWhereUniqueInput | TicketParticipantWhereUniqueInput[]
    connect?: TicketParticipantWhereUniqueInput | TicketParticipantWhereUniqueInput[]
    update?: TicketParticipantUpdateWithWhereUniqueWithoutAddedByInput | TicketParticipantUpdateWithWhereUniqueWithoutAddedByInput[]
    updateMany?: TicketParticipantUpdateManyWithWhereWithoutAddedByInput | TicketParticipantUpdateManyWithWhereWithoutAddedByInput[]
    deleteMany?: TicketParticipantScalarWhereInput | TicketParticipantScalarWhereInput[]
  }

  export type TicketRatingUncheckedUpdateManyWithoutRaterNestedInput = {
    create?: XOR<TicketRatingCreateWithoutRaterInput, TicketRatingUncheckedCreateWithoutRaterInput> | TicketRatingCreateWithoutRaterInput[] | TicketRatingUncheckedCreateWithoutRaterInput[]
    connectOrCreate?: TicketRatingCreateOrConnectWithoutRaterInput | TicketRatingCreateOrConnectWithoutRaterInput[]
    upsert?: TicketRatingUpsertWithWhereUniqueWithoutRaterInput | TicketRatingUpsertWithWhereUniqueWithoutRaterInput[]
    createMany?: TicketRatingCreateManyRaterInputEnvelope
    set?: TicketRatingWhereUniqueInput | TicketRatingWhereUniqueInput[]
    disconnect?: TicketRatingWhereUniqueInput | TicketRatingWhereUniqueInput[]
    delete?: TicketRatingWhereUniqueInput | TicketRatingWhereUniqueInput[]
    connect?: TicketRatingWhereUniqueInput | TicketRatingWhereUniqueInput[]
    update?: TicketRatingUpdateWithWhereUniqueWithoutRaterInput | TicketRatingUpdateWithWhereUniqueWithoutRaterInput[]
    updateMany?: TicketRatingUpdateManyWithWhereWithoutRaterInput | TicketRatingUpdateManyWithWhereWithoutRaterInput[]
    deleteMany?: TicketRatingScalarWhereInput | TicketRatingScalarWhereInput[]
  }

  export type TicketRatingUncheckedUpdateManyWithoutTargetNestedInput = {
    create?: XOR<TicketRatingCreateWithoutTargetInput, TicketRatingUncheckedCreateWithoutTargetInput> | TicketRatingCreateWithoutTargetInput[] | TicketRatingUncheckedCreateWithoutTargetInput[]
    connectOrCreate?: TicketRatingCreateOrConnectWithoutTargetInput | TicketRatingCreateOrConnectWithoutTargetInput[]
    upsert?: TicketRatingUpsertWithWhereUniqueWithoutTargetInput | TicketRatingUpsertWithWhereUniqueWithoutTargetInput[]
    createMany?: TicketRatingCreateManyTargetInputEnvelope
    set?: TicketRatingWhereUniqueInput | TicketRatingWhereUniqueInput[]
    disconnect?: TicketRatingWhereUniqueInput | TicketRatingWhereUniqueInput[]
    delete?: TicketRatingWhereUniqueInput | TicketRatingWhereUniqueInput[]
    connect?: TicketRatingWhereUniqueInput | TicketRatingWhereUniqueInput[]
    update?: TicketRatingUpdateWithWhereUniqueWithoutTargetInput | TicketRatingUpdateWithWhereUniqueWithoutTargetInput[]
    updateMany?: TicketRatingUpdateManyWithWhereWithoutTargetInput | TicketRatingUpdateManyWithWhereWithoutTargetInput[]
    deleteMany?: TicketRatingScalarWhereInput | TicketRatingScalarWhereInput[]
  }

  export type TicketUncheckedUpdateManyWithoutClosedByNestedInput = {
    create?: XOR<TicketCreateWithoutClosedByInput, TicketUncheckedCreateWithoutClosedByInput> | TicketCreateWithoutClosedByInput[] | TicketUncheckedCreateWithoutClosedByInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutClosedByInput | TicketCreateOrConnectWithoutClosedByInput[]
    upsert?: TicketUpsertWithWhereUniqueWithoutClosedByInput | TicketUpsertWithWhereUniqueWithoutClosedByInput[]
    createMany?: TicketCreateManyClosedByInputEnvelope
    set?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    disconnect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    delete?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    update?: TicketUpdateWithWhereUniqueWithoutClosedByInput | TicketUpdateWithWhereUniqueWithoutClosedByInput[]
    updateMany?: TicketUpdateManyWithWhereWithoutClosedByInput | TicketUpdateManyWithWhereWithoutClosedByInput[]
    deleteMany?: TicketScalarWhereInput | TicketScalarWhereInput[]
  }

  export type PurchaseUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PurchaseCreateWithoutUserInput, PurchaseUncheckedCreateWithoutUserInput> | PurchaseCreateWithoutUserInput[] | PurchaseUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PurchaseCreateOrConnectWithoutUserInput | PurchaseCreateOrConnectWithoutUserInput[]
    upsert?: PurchaseUpsertWithWhereUniqueWithoutUserInput | PurchaseUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PurchaseCreateManyUserInputEnvelope
    set?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    disconnect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    delete?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    connect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    update?: PurchaseUpdateWithWhereUniqueWithoutUserInput | PurchaseUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PurchaseUpdateManyWithWhereWithoutUserInput | PurchaseUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PurchaseScalarWhereInput | PurchaseScalarWhereInput[]
  }

  export type AuditLogUncheckedUpdateManyWithoutActorNestedInput = {
    create?: XOR<AuditLogCreateWithoutActorInput, AuditLogUncheckedCreateWithoutActorInput> | AuditLogCreateWithoutActorInput[] | AuditLogUncheckedCreateWithoutActorInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutActorInput | AuditLogCreateOrConnectWithoutActorInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutActorInput | AuditLogUpsertWithWhereUniqueWithoutActorInput[]
    createMany?: AuditLogCreateManyActorInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutActorInput | AuditLogUpdateWithWhereUniqueWithoutActorInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutActorInput | AuditLogUpdateManyWithWhereWithoutActorInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type UserRoleUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput> | UserRoleCreateWithoutUserInput[] | UserRoleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutUserInput | UserRoleCreateOrConnectWithoutUserInput[]
    upsert?: UserRoleUpsertWithWhereUniqueWithoutUserInput | UserRoleUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserRoleCreateManyUserInputEnvelope
    set?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    disconnect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    delete?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    update?: UserRoleUpdateWithWhereUniqueWithoutUserInput | UserRoleUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserRoleUpdateManyWithWhereWithoutUserInput | UserRoleUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
  }

  export type WhitelistApplicationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<WhitelistApplicationCreateWithoutUserInput, WhitelistApplicationUncheckedCreateWithoutUserInput> | WhitelistApplicationCreateWithoutUserInput[] | WhitelistApplicationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WhitelistApplicationCreateOrConnectWithoutUserInput | WhitelistApplicationCreateOrConnectWithoutUserInput[]
    upsert?: WhitelistApplicationUpsertWithWhereUniqueWithoutUserInput | WhitelistApplicationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: WhitelistApplicationCreateManyUserInputEnvelope
    set?: WhitelistApplicationWhereUniqueInput | WhitelistApplicationWhereUniqueInput[]
    disconnect?: WhitelistApplicationWhereUniqueInput | WhitelistApplicationWhereUniqueInput[]
    delete?: WhitelistApplicationWhereUniqueInput | WhitelistApplicationWhereUniqueInput[]
    connect?: WhitelistApplicationWhereUniqueInput | WhitelistApplicationWhereUniqueInput[]
    update?: WhitelistApplicationUpdateWithWhereUniqueWithoutUserInput | WhitelistApplicationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: WhitelistApplicationUpdateManyWithWhereWithoutUserInput | WhitelistApplicationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: WhitelistApplicationScalarWhereInput | WhitelistApplicationScalarWhereInput[]
  }

  export type WhitelistApplicationUncheckedUpdateManyWithoutReviewerNestedInput = {
    create?: XOR<WhitelistApplicationCreateWithoutReviewerInput, WhitelistApplicationUncheckedCreateWithoutReviewerInput> | WhitelistApplicationCreateWithoutReviewerInput[] | WhitelistApplicationUncheckedCreateWithoutReviewerInput[]
    connectOrCreate?: WhitelistApplicationCreateOrConnectWithoutReviewerInput | WhitelistApplicationCreateOrConnectWithoutReviewerInput[]
    upsert?: WhitelistApplicationUpsertWithWhereUniqueWithoutReviewerInput | WhitelistApplicationUpsertWithWhereUniqueWithoutReviewerInput[]
    createMany?: WhitelistApplicationCreateManyReviewerInputEnvelope
    set?: WhitelistApplicationWhereUniqueInput | WhitelistApplicationWhereUniqueInput[]
    disconnect?: WhitelistApplicationWhereUniqueInput | WhitelistApplicationWhereUniqueInput[]
    delete?: WhitelistApplicationWhereUniqueInput | WhitelistApplicationWhereUniqueInput[]
    connect?: WhitelistApplicationWhereUniqueInput | WhitelistApplicationWhereUniqueInput[]
    update?: WhitelistApplicationUpdateWithWhereUniqueWithoutReviewerInput | WhitelistApplicationUpdateWithWhereUniqueWithoutReviewerInput[]
    updateMany?: WhitelistApplicationUpdateManyWithWhereWithoutReviewerInput | WhitelistApplicationUpdateManyWithWhereWithoutReviewerInput[]
    deleteMany?: WhitelistApplicationScalarWhereInput | WhitelistApplicationScalarWhereInput[]
  }

  export type ConversationParticipantUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ConversationParticipantCreateWithoutUserInput, ConversationParticipantUncheckedCreateWithoutUserInput> | ConversationParticipantCreateWithoutUserInput[] | ConversationParticipantUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ConversationParticipantCreateOrConnectWithoutUserInput | ConversationParticipantCreateOrConnectWithoutUserInput[]
    upsert?: ConversationParticipantUpsertWithWhereUniqueWithoutUserInput | ConversationParticipantUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ConversationParticipantCreateManyUserInputEnvelope
    set?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
    disconnect?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
    delete?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
    connect?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
    update?: ConversationParticipantUpdateWithWhereUniqueWithoutUserInput | ConversationParticipantUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ConversationParticipantUpdateManyWithWhereWithoutUserInput | ConversationParticipantUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ConversationParticipantScalarWhereInput | ConversationParticipantScalarWhereInput[]
  }

  export type DirectMessageUncheckedUpdateManyWithoutSenderNestedInput = {
    create?: XOR<DirectMessageCreateWithoutSenderInput, DirectMessageUncheckedCreateWithoutSenderInput> | DirectMessageCreateWithoutSenderInput[] | DirectMessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: DirectMessageCreateOrConnectWithoutSenderInput | DirectMessageCreateOrConnectWithoutSenderInput[]
    upsert?: DirectMessageUpsertWithWhereUniqueWithoutSenderInput | DirectMessageUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: DirectMessageCreateManySenderInputEnvelope
    set?: DirectMessageWhereUniqueInput | DirectMessageWhereUniqueInput[]
    disconnect?: DirectMessageWhereUniqueInput | DirectMessageWhereUniqueInput[]
    delete?: DirectMessageWhereUniqueInput | DirectMessageWhereUniqueInput[]
    connect?: DirectMessageWhereUniqueInput | DirectMessageWhereUniqueInput[]
    update?: DirectMessageUpdateWithWhereUniqueWithoutSenderInput | DirectMessageUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: DirectMessageUpdateManyWithWhereWithoutSenderInput | DirectMessageUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: DirectMessageScalarWhereInput | DirectMessageScalarWhereInput[]
  }

  export type DirectMessageUncheckedUpdateManyWithoutReceiverNestedInput = {
    create?: XOR<DirectMessageCreateWithoutReceiverInput, DirectMessageUncheckedCreateWithoutReceiverInput> | DirectMessageCreateWithoutReceiverInput[] | DirectMessageUncheckedCreateWithoutReceiverInput[]
    connectOrCreate?: DirectMessageCreateOrConnectWithoutReceiverInput | DirectMessageCreateOrConnectWithoutReceiverInput[]
    upsert?: DirectMessageUpsertWithWhereUniqueWithoutReceiverInput | DirectMessageUpsertWithWhereUniqueWithoutReceiverInput[]
    createMany?: DirectMessageCreateManyReceiverInputEnvelope
    set?: DirectMessageWhereUniqueInput | DirectMessageWhereUniqueInput[]
    disconnect?: DirectMessageWhereUniqueInput | DirectMessageWhereUniqueInput[]
    delete?: DirectMessageWhereUniqueInput | DirectMessageWhereUniqueInput[]
    connect?: DirectMessageWhereUniqueInput | DirectMessageWhereUniqueInput[]
    update?: DirectMessageUpdateWithWhereUniqueWithoutReceiverInput | DirectMessageUpdateWithWhereUniqueWithoutReceiverInput[]
    updateMany?: DirectMessageUpdateManyWithWhereWithoutReceiverInput | DirectMessageUpdateManyWithWhereWithoutReceiverInput[]
    deleteMany?: DirectMessageScalarWhereInput | DirectMessageScalarWhereInput[]
  }

  export type UserBadgeUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserBadgeCreateWithoutUserInput, UserBadgeUncheckedCreateWithoutUserInput> | UserBadgeCreateWithoutUserInput[] | UserBadgeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserBadgeCreateOrConnectWithoutUserInput | UserBadgeCreateOrConnectWithoutUserInput[]
    upsert?: UserBadgeUpsertWithWhereUniqueWithoutUserInput | UserBadgeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserBadgeCreateManyUserInputEnvelope
    set?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
    disconnect?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
    delete?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
    connect?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
    update?: UserBadgeUpdateWithWhereUniqueWithoutUserInput | UserBadgeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserBadgeUpdateManyWithWhereWithoutUserInput | UserBadgeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserBadgeScalarWhereInput | UserBadgeScalarWhereInput[]
  }

  export type GameAccountUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<GameAccountCreateWithoutUserInput, GameAccountUncheckedCreateWithoutUserInput> | GameAccountCreateWithoutUserInput[] | GameAccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GameAccountCreateOrConnectWithoutUserInput | GameAccountCreateOrConnectWithoutUserInput[]
    upsert?: GameAccountUpsertWithWhereUniqueWithoutUserInput | GameAccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: GameAccountCreateManyUserInputEnvelope
    set?: GameAccountWhereUniqueInput | GameAccountWhereUniqueInput[]
    disconnect?: GameAccountWhereUniqueInput | GameAccountWhereUniqueInput[]
    delete?: GameAccountWhereUniqueInput | GameAccountWhereUniqueInput[]
    connect?: GameAccountWhereUniqueInput | GameAccountWhereUniqueInput[]
    update?: GameAccountUpdateWithWhereUniqueWithoutUserInput | GameAccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: GameAccountUpdateManyWithWhereWithoutUserInput | GameAccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: GameAccountScalarWhereInput | GameAccountScalarWhereInput[]
  }

  export type MtaAccessLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<MtaAccessLogCreateWithoutUserInput, MtaAccessLogUncheckedCreateWithoutUserInput> | MtaAccessLogCreateWithoutUserInput[] | MtaAccessLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MtaAccessLogCreateOrConnectWithoutUserInput | MtaAccessLogCreateOrConnectWithoutUserInput[]
    upsert?: MtaAccessLogUpsertWithWhereUniqueWithoutUserInput | MtaAccessLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MtaAccessLogCreateManyUserInputEnvelope
    set?: MtaAccessLogWhereUniqueInput | MtaAccessLogWhereUniqueInput[]
    disconnect?: MtaAccessLogWhereUniqueInput | MtaAccessLogWhereUniqueInput[]
    delete?: MtaAccessLogWhereUniqueInput | MtaAccessLogWhereUniqueInput[]
    connect?: MtaAccessLogWhereUniqueInput | MtaAccessLogWhereUniqueInput[]
    update?: MtaAccessLogUpdateWithWhereUniqueWithoutUserInput | MtaAccessLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MtaAccessLogUpdateManyWithWhereWithoutUserInput | MtaAccessLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MtaAccessLogScalarWhereInput | MtaAccessLogScalarWhereInput[]
  }

  export type TicketRatingRequirementUncheckedUpdateManyWithoutRaterNestedInput = {
    create?: XOR<TicketRatingRequirementCreateWithoutRaterInput, TicketRatingRequirementUncheckedCreateWithoutRaterInput> | TicketRatingRequirementCreateWithoutRaterInput[] | TicketRatingRequirementUncheckedCreateWithoutRaterInput[]
    connectOrCreate?: TicketRatingRequirementCreateOrConnectWithoutRaterInput | TicketRatingRequirementCreateOrConnectWithoutRaterInput[]
    upsert?: TicketRatingRequirementUpsertWithWhereUniqueWithoutRaterInput | TicketRatingRequirementUpsertWithWhereUniqueWithoutRaterInput[]
    createMany?: TicketRatingRequirementCreateManyRaterInputEnvelope
    set?: TicketRatingRequirementWhereUniqueInput | TicketRatingRequirementWhereUniqueInput[]
    disconnect?: TicketRatingRequirementWhereUniqueInput | TicketRatingRequirementWhereUniqueInput[]
    delete?: TicketRatingRequirementWhereUniqueInput | TicketRatingRequirementWhereUniqueInput[]
    connect?: TicketRatingRequirementWhereUniqueInput | TicketRatingRequirementWhereUniqueInput[]
    update?: TicketRatingRequirementUpdateWithWhereUniqueWithoutRaterInput | TicketRatingRequirementUpdateWithWhereUniqueWithoutRaterInput[]
    updateMany?: TicketRatingRequirementUpdateManyWithWhereWithoutRaterInput | TicketRatingRequirementUpdateManyWithWhereWithoutRaterInput[]
    deleteMany?: TicketRatingRequirementScalarWhereInput | TicketRatingRequirementScalarWhereInput[]
  }

  export type TicketRatingRequirementUncheckedUpdateManyWithoutTargetNestedInput = {
    create?: XOR<TicketRatingRequirementCreateWithoutTargetInput, TicketRatingRequirementUncheckedCreateWithoutTargetInput> | TicketRatingRequirementCreateWithoutTargetInput[] | TicketRatingRequirementUncheckedCreateWithoutTargetInput[]
    connectOrCreate?: TicketRatingRequirementCreateOrConnectWithoutTargetInput | TicketRatingRequirementCreateOrConnectWithoutTargetInput[]
    upsert?: TicketRatingRequirementUpsertWithWhereUniqueWithoutTargetInput | TicketRatingRequirementUpsertWithWhereUniqueWithoutTargetInput[]
    createMany?: TicketRatingRequirementCreateManyTargetInputEnvelope
    set?: TicketRatingRequirementWhereUniqueInput | TicketRatingRequirementWhereUniqueInput[]
    disconnect?: TicketRatingRequirementWhereUniqueInput | TicketRatingRequirementWhereUniqueInput[]
    delete?: TicketRatingRequirementWhereUniqueInput | TicketRatingRequirementWhereUniqueInput[]
    connect?: TicketRatingRequirementWhereUniqueInput | TicketRatingRequirementWhereUniqueInput[]
    update?: TicketRatingRequirementUpdateWithWhereUniqueWithoutTargetInput | TicketRatingRequirementUpdateWithWhereUniqueWithoutTargetInput[]
    updateMany?: TicketRatingRequirementUpdateManyWithWhereWithoutTargetInput | TicketRatingRequirementUpdateManyWithWhereWithoutTargetInput[]
    deleteMany?: TicketRatingRequirementScalarWhereInput | TicketRatingRequirementScalarWhereInput[]
  }

  export type PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PasswordResetTokenCreateWithoutUserInput, PasswordResetTokenUncheckedCreateWithoutUserInput> | PasswordResetTokenCreateWithoutUserInput[] | PasswordResetTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PasswordResetTokenCreateOrConnectWithoutUserInput | PasswordResetTokenCreateOrConnectWithoutUserInput[]
    upsert?: PasswordResetTokenUpsertWithWhereUniqueWithoutUserInput | PasswordResetTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PasswordResetTokenCreateManyUserInputEnvelope
    set?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
    disconnect?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
    delete?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
    connect?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
    update?: PasswordResetTokenUpdateWithWhereUniqueWithoutUserInput | PasswordResetTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PasswordResetTokenUpdateManyWithWhereWithoutUserInput | PasswordResetTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PasswordResetTokenScalarWhereInput | PasswordResetTokenScalarWhereInput[]
  }

  export type EntitlementUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<EntitlementCreateWithoutUserInput, EntitlementUncheckedCreateWithoutUserInput> | EntitlementCreateWithoutUserInput[] | EntitlementUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EntitlementCreateOrConnectWithoutUserInput | EntitlementCreateOrConnectWithoutUserInput[]
    upsert?: EntitlementUpsertWithWhereUniqueWithoutUserInput | EntitlementUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: EntitlementCreateManyUserInputEnvelope
    set?: EntitlementWhereUniqueInput | EntitlementWhereUniqueInput[]
    disconnect?: EntitlementWhereUniqueInput | EntitlementWhereUniqueInput[]
    delete?: EntitlementWhereUniqueInput | EntitlementWhereUniqueInput[]
    connect?: EntitlementWhereUniqueInput | EntitlementWhereUniqueInput[]
    update?: EntitlementUpdateWithWhereUniqueWithoutUserInput | EntitlementUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: EntitlementUpdateManyWithWhereWithoutUserInput | EntitlementUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: EntitlementScalarWhereInput | EntitlementScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type StaffShiftUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<StaffShiftCreateWithoutUserInput, StaffShiftUncheckedCreateWithoutUserInput> | StaffShiftCreateWithoutUserInput[] | StaffShiftUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StaffShiftCreateOrConnectWithoutUserInput | StaffShiftCreateOrConnectWithoutUserInput[]
    upsert?: StaffShiftUpsertWithWhereUniqueWithoutUserInput | StaffShiftUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: StaffShiftCreateManyUserInputEnvelope
    set?: StaffShiftWhereUniqueInput | StaffShiftWhereUniqueInput[]
    disconnect?: StaffShiftWhereUniqueInput | StaffShiftWhereUniqueInput[]
    delete?: StaffShiftWhereUniqueInput | StaffShiftWhereUniqueInput[]
    connect?: StaffShiftWhereUniqueInput | StaffShiftWhereUniqueInput[]
    update?: StaffShiftUpdateWithWhereUniqueWithoutUserInput | StaffShiftUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: StaffShiftUpdateManyWithWhereWithoutUserInput | StaffShiftUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: StaffShiftScalarWhereInput | StaffShiftScalarWhereInput[]
  }

  export type StaffWeeklyRewardUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<StaffWeeklyRewardCreateWithoutUserInput, StaffWeeklyRewardUncheckedCreateWithoutUserInput> | StaffWeeklyRewardCreateWithoutUserInput[] | StaffWeeklyRewardUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StaffWeeklyRewardCreateOrConnectWithoutUserInput | StaffWeeklyRewardCreateOrConnectWithoutUserInput[]
    upsert?: StaffWeeklyRewardUpsertWithWhereUniqueWithoutUserInput | StaffWeeklyRewardUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: StaffWeeklyRewardCreateManyUserInputEnvelope
    set?: StaffWeeklyRewardWhereUniqueInput | StaffWeeklyRewardWhereUniqueInput[]
    disconnect?: StaffWeeklyRewardWhereUniqueInput | StaffWeeklyRewardWhereUniqueInput[]
    delete?: StaffWeeklyRewardWhereUniqueInput | StaffWeeklyRewardWhereUniqueInput[]
    connect?: StaffWeeklyRewardWhereUniqueInput | StaffWeeklyRewardWhereUniqueInput[]
    update?: StaffWeeklyRewardUpdateWithWhereUniqueWithoutUserInput | StaffWeeklyRewardUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: StaffWeeklyRewardUpdateManyWithWhereWithoutUserInput | StaffWeeklyRewardUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: StaffWeeklyRewardScalarWhereInput | StaffWeeklyRewardScalarWhereInput[]
  }

  export type AdminCaseUncheckedUpdateManyWithoutTargetUserNestedInput = {
    create?: XOR<AdminCaseCreateWithoutTargetUserInput, AdminCaseUncheckedCreateWithoutTargetUserInput> | AdminCaseCreateWithoutTargetUserInput[] | AdminCaseUncheckedCreateWithoutTargetUserInput[]
    connectOrCreate?: AdminCaseCreateOrConnectWithoutTargetUserInput | AdminCaseCreateOrConnectWithoutTargetUserInput[]
    upsert?: AdminCaseUpsertWithWhereUniqueWithoutTargetUserInput | AdminCaseUpsertWithWhereUniqueWithoutTargetUserInput[]
    createMany?: AdminCaseCreateManyTargetUserInputEnvelope
    set?: AdminCaseWhereUniqueInput | AdminCaseWhereUniqueInput[]
    disconnect?: AdminCaseWhereUniqueInput | AdminCaseWhereUniqueInput[]
    delete?: AdminCaseWhereUniqueInput | AdminCaseWhereUniqueInput[]
    connect?: AdminCaseWhereUniqueInput | AdminCaseWhereUniqueInput[]
    update?: AdminCaseUpdateWithWhereUniqueWithoutTargetUserInput | AdminCaseUpdateWithWhereUniqueWithoutTargetUserInput[]
    updateMany?: AdminCaseUpdateManyWithWhereWithoutTargetUserInput | AdminCaseUpdateManyWithWhereWithoutTargetUserInput[]
    deleteMany?: AdminCaseScalarWhereInput | AdminCaseScalarWhereInput[]
  }

  export type AdminCaseUncheckedUpdateManyWithoutStaffUserNestedInput = {
    create?: XOR<AdminCaseCreateWithoutStaffUserInput, AdminCaseUncheckedCreateWithoutStaffUserInput> | AdminCaseCreateWithoutStaffUserInput[] | AdminCaseUncheckedCreateWithoutStaffUserInput[]
    connectOrCreate?: AdminCaseCreateOrConnectWithoutStaffUserInput | AdminCaseCreateOrConnectWithoutStaffUserInput[]
    upsert?: AdminCaseUpsertWithWhereUniqueWithoutStaffUserInput | AdminCaseUpsertWithWhereUniqueWithoutStaffUserInput[]
    createMany?: AdminCaseCreateManyStaffUserInputEnvelope
    set?: AdminCaseWhereUniqueInput | AdminCaseWhereUniqueInput[]
    disconnect?: AdminCaseWhereUniqueInput | AdminCaseWhereUniqueInput[]
    delete?: AdminCaseWhereUniqueInput | AdminCaseWhereUniqueInput[]
    connect?: AdminCaseWhereUniqueInput | AdminCaseWhereUniqueInput[]
    update?: AdminCaseUpdateWithWhereUniqueWithoutStaffUserInput | AdminCaseUpdateWithWhereUniqueWithoutStaffUserInput[]
    updateMany?: AdminCaseUpdateManyWithWhereWithoutStaffUserInput | AdminCaseUpdateManyWithWhereWithoutStaffUserInput[]
    deleteMany?: AdminCaseScalarWhereInput | AdminCaseScalarWhereInput[]
  }

  export type UserReputationUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserReputationCreateWithoutUserInput, UserReputationUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserReputationCreateOrConnectWithoutUserInput
    upsert?: UserReputationUpsertWithoutUserInput
    disconnect?: UserReputationWhereInput | boolean
    delete?: UserReputationWhereInput | boolean
    connect?: UserReputationWhereUniqueInput
    update?: XOR<XOR<UserReputationUpdateToOneWithWhereWithoutUserInput, UserReputationUpdateWithoutUserInput>, UserReputationUncheckedUpdateWithoutUserInput>
  }

  export type ForumBoardCreateNestedManyWithoutCategoryInput = {
    create?: XOR<ForumBoardCreateWithoutCategoryInput, ForumBoardUncheckedCreateWithoutCategoryInput> | ForumBoardCreateWithoutCategoryInput[] | ForumBoardUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ForumBoardCreateOrConnectWithoutCategoryInput | ForumBoardCreateOrConnectWithoutCategoryInput[]
    createMany?: ForumBoardCreateManyCategoryInputEnvelope
    connect?: ForumBoardWhereUniqueInput | ForumBoardWhereUniqueInput[]
  }

  export type ForumBoardUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<ForumBoardCreateWithoutCategoryInput, ForumBoardUncheckedCreateWithoutCategoryInput> | ForumBoardCreateWithoutCategoryInput[] | ForumBoardUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ForumBoardCreateOrConnectWithoutCategoryInput | ForumBoardCreateOrConnectWithoutCategoryInput[]
    createMany?: ForumBoardCreateManyCategoryInputEnvelope
    connect?: ForumBoardWhereUniqueInput | ForumBoardWhereUniqueInput[]
  }

  export type ForumBoardUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<ForumBoardCreateWithoutCategoryInput, ForumBoardUncheckedCreateWithoutCategoryInput> | ForumBoardCreateWithoutCategoryInput[] | ForumBoardUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ForumBoardCreateOrConnectWithoutCategoryInput | ForumBoardCreateOrConnectWithoutCategoryInput[]
    upsert?: ForumBoardUpsertWithWhereUniqueWithoutCategoryInput | ForumBoardUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: ForumBoardCreateManyCategoryInputEnvelope
    set?: ForumBoardWhereUniqueInput | ForumBoardWhereUniqueInput[]
    disconnect?: ForumBoardWhereUniqueInput | ForumBoardWhereUniqueInput[]
    delete?: ForumBoardWhereUniqueInput | ForumBoardWhereUniqueInput[]
    connect?: ForumBoardWhereUniqueInput | ForumBoardWhereUniqueInput[]
    update?: ForumBoardUpdateWithWhereUniqueWithoutCategoryInput | ForumBoardUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: ForumBoardUpdateManyWithWhereWithoutCategoryInput | ForumBoardUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: ForumBoardScalarWhereInput | ForumBoardScalarWhereInput[]
  }

  export type ForumBoardUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<ForumBoardCreateWithoutCategoryInput, ForumBoardUncheckedCreateWithoutCategoryInput> | ForumBoardCreateWithoutCategoryInput[] | ForumBoardUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ForumBoardCreateOrConnectWithoutCategoryInput | ForumBoardCreateOrConnectWithoutCategoryInput[]
    upsert?: ForumBoardUpsertWithWhereUniqueWithoutCategoryInput | ForumBoardUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: ForumBoardCreateManyCategoryInputEnvelope
    set?: ForumBoardWhereUniqueInput | ForumBoardWhereUniqueInput[]
    disconnect?: ForumBoardWhereUniqueInput | ForumBoardWhereUniqueInput[]
    delete?: ForumBoardWhereUniqueInput | ForumBoardWhereUniqueInput[]
    connect?: ForumBoardWhereUniqueInput | ForumBoardWhereUniqueInput[]
    update?: ForumBoardUpdateWithWhereUniqueWithoutCategoryInput | ForumBoardUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: ForumBoardUpdateManyWithWhereWithoutCategoryInput | ForumBoardUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: ForumBoardScalarWhereInput | ForumBoardScalarWhereInput[]
  }

  export type ForumCategoryCreateNestedOneWithoutBoardsInput = {
    create?: XOR<ForumCategoryCreateWithoutBoardsInput, ForumCategoryUncheckedCreateWithoutBoardsInput>
    connectOrCreate?: ForumCategoryCreateOrConnectWithoutBoardsInput
    connect?: ForumCategoryWhereUniqueInput
  }

  export type TopicCreateNestedManyWithoutBoardInput = {
    create?: XOR<TopicCreateWithoutBoardInput, TopicUncheckedCreateWithoutBoardInput> | TopicCreateWithoutBoardInput[] | TopicUncheckedCreateWithoutBoardInput[]
    connectOrCreate?: TopicCreateOrConnectWithoutBoardInput | TopicCreateOrConnectWithoutBoardInput[]
    createMany?: TopicCreateManyBoardInputEnvelope
    connect?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
  }

  export type TopicUncheckedCreateNestedManyWithoutBoardInput = {
    create?: XOR<TopicCreateWithoutBoardInput, TopicUncheckedCreateWithoutBoardInput> | TopicCreateWithoutBoardInput[] | TopicUncheckedCreateWithoutBoardInput[]
    connectOrCreate?: TopicCreateOrConnectWithoutBoardInput | TopicCreateOrConnectWithoutBoardInput[]
    createMany?: TopicCreateManyBoardInputEnvelope
    connect?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
  }

  export type ForumCategoryUpdateOneRequiredWithoutBoardsNestedInput = {
    create?: XOR<ForumCategoryCreateWithoutBoardsInput, ForumCategoryUncheckedCreateWithoutBoardsInput>
    connectOrCreate?: ForumCategoryCreateOrConnectWithoutBoardsInput
    upsert?: ForumCategoryUpsertWithoutBoardsInput
    connect?: ForumCategoryWhereUniqueInput
    update?: XOR<XOR<ForumCategoryUpdateToOneWithWhereWithoutBoardsInput, ForumCategoryUpdateWithoutBoardsInput>, ForumCategoryUncheckedUpdateWithoutBoardsInput>
  }

  export type TopicUpdateManyWithoutBoardNestedInput = {
    create?: XOR<TopicCreateWithoutBoardInput, TopicUncheckedCreateWithoutBoardInput> | TopicCreateWithoutBoardInput[] | TopicUncheckedCreateWithoutBoardInput[]
    connectOrCreate?: TopicCreateOrConnectWithoutBoardInput | TopicCreateOrConnectWithoutBoardInput[]
    upsert?: TopicUpsertWithWhereUniqueWithoutBoardInput | TopicUpsertWithWhereUniqueWithoutBoardInput[]
    createMany?: TopicCreateManyBoardInputEnvelope
    set?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
    disconnect?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
    delete?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
    connect?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
    update?: TopicUpdateWithWhereUniqueWithoutBoardInput | TopicUpdateWithWhereUniqueWithoutBoardInput[]
    updateMany?: TopicUpdateManyWithWhereWithoutBoardInput | TopicUpdateManyWithWhereWithoutBoardInput[]
    deleteMany?: TopicScalarWhereInput | TopicScalarWhereInput[]
  }

  export type TopicUncheckedUpdateManyWithoutBoardNestedInput = {
    create?: XOR<TopicCreateWithoutBoardInput, TopicUncheckedCreateWithoutBoardInput> | TopicCreateWithoutBoardInput[] | TopicUncheckedCreateWithoutBoardInput[]
    connectOrCreate?: TopicCreateOrConnectWithoutBoardInput | TopicCreateOrConnectWithoutBoardInput[]
    upsert?: TopicUpsertWithWhereUniqueWithoutBoardInput | TopicUpsertWithWhereUniqueWithoutBoardInput[]
    createMany?: TopicCreateManyBoardInputEnvelope
    set?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
    disconnect?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
    delete?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
    connect?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
    update?: TopicUpdateWithWhereUniqueWithoutBoardInput | TopicUpdateWithWhereUniqueWithoutBoardInput[]
    updateMany?: TopicUpdateManyWithWhereWithoutBoardInput | TopicUpdateManyWithWhereWithoutBoardInput[]
    deleteMany?: TopicScalarWhereInput | TopicScalarWhereInput[]
  }

  export type ForumBoardCreateNestedOneWithoutTopicsInput = {
    create?: XOR<ForumBoardCreateWithoutTopicsInput, ForumBoardUncheckedCreateWithoutTopicsInput>
    connectOrCreate?: ForumBoardCreateOrConnectWithoutTopicsInput
    connect?: ForumBoardWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutTopicsInput = {
    create?: XOR<UserCreateWithoutTopicsInput, UserUncheckedCreateWithoutTopicsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTopicsInput
    connect?: UserWhereUniqueInput
  }

  export type PostCreateNestedManyWithoutTopicInput = {
    create?: XOR<PostCreateWithoutTopicInput, PostUncheckedCreateWithoutTopicInput> | PostCreateWithoutTopicInput[] | PostUncheckedCreateWithoutTopicInput[]
    connectOrCreate?: PostCreateOrConnectWithoutTopicInput | PostCreateOrConnectWithoutTopicInput[]
    createMany?: PostCreateManyTopicInputEnvelope
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
  }

  export type PostUncheckedCreateNestedManyWithoutTopicInput = {
    create?: XOR<PostCreateWithoutTopicInput, PostUncheckedCreateWithoutTopicInput> | PostCreateWithoutTopicInput[] | PostUncheckedCreateWithoutTopicInput[]
    connectOrCreate?: PostCreateOrConnectWithoutTopicInput | PostCreateOrConnectWithoutTopicInput[]
    createMany?: PostCreateManyTopicInputEnvelope
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
  }

  export type ForumBoardUpdateOneRequiredWithoutTopicsNestedInput = {
    create?: XOR<ForumBoardCreateWithoutTopicsInput, ForumBoardUncheckedCreateWithoutTopicsInput>
    connectOrCreate?: ForumBoardCreateOrConnectWithoutTopicsInput
    upsert?: ForumBoardUpsertWithoutTopicsInput
    connect?: ForumBoardWhereUniqueInput
    update?: XOR<XOR<ForumBoardUpdateToOneWithWhereWithoutTopicsInput, ForumBoardUpdateWithoutTopicsInput>, ForumBoardUncheckedUpdateWithoutTopicsInput>
  }

  export type UserUpdateOneRequiredWithoutTopicsNestedInput = {
    create?: XOR<UserCreateWithoutTopicsInput, UserUncheckedCreateWithoutTopicsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTopicsInput
    upsert?: UserUpsertWithoutTopicsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTopicsInput, UserUpdateWithoutTopicsInput>, UserUncheckedUpdateWithoutTopicsInput>
  }

  export type PostUpdateManyWithoutTopicNestedInput = {
    create?: XOR<PostCreateWithoutTopicInput, PostUncheckedCreateWithoutTopicInput> | PostCreateWithoutTopicInput[] | PostUncheckedCreateWithoutTopicInput[]
    connectOrCreate?: PostCreateOrConnectWithoutTopicInput | PostCreateOrConnectWithoutTopicInput[]
    upsert?: PostUpsertWithWhereUniqueWithoutTopicInput | PostUpsertWithWhereUniqueWithoutTopicInput[]
    createMany?: PostCreateManyTopicInputEnvelope
    set?: PostWhereUniqueInput | PostWhereUniqueInput[]
    disconnect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    delete?: PostWhereUniqueInput | PostWhereUniqueInput[]
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    update?: PostUpdateWithWhereUniqueWithoutTopicInput | PostUpdateWithWhereUniqueWithoutTopicInput[]
    updateMany?: PostUpdateManyWithWhereWithoutTopicInput | PostUpdateManyWithWhereWithoutTopicInput[]
    deleteMany?: PostScalarWhereInput | PostScalarWhereInput[]
  }

  export type PostUncheckedUpdateManyWithoutTopicNestedInput = {
    create?: XOR<PostCreateWithoutTopicInput, PostUncheckedCreateWithoutTopicInput> | PostCreateWithoutTopicInput[] | PostUncheckedCreateWithoutTopicInput[]
    connectOrCreate?: PostCreateOrConnectWithoutTopicInput | PostCreateOrConnectWithoutTopicInput[]
    upsert?: PostUpsertWithWhereUniqueWithoutTopicInput | PostUpsertWithWhereUniqueWithoutTopicInput[]
    createMany?: PostCreateManyTopicInputEnvelope
    set?: PostWhereUniqueInput | PostWhereUniqueInput[]
    disconnect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    delete?: PostWhereUniqueInput | PostWhereUniqueInput[]
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    update?: PostUpdateWithWhereUniqueWithoutTopicInput | PostUpdateWithWhereUniqueWithoutTopicInput[]
    updateMany?: PostUpdateManyWithWhereWithoutTopicInput | PostUpdateManyWithWhereWithoutTopicInput[]
    deleteMany?: PostScalarWhereInput | PostScalarWhereInput[]
  }

  export type TopicCreateNestedOneWithoutPostsInput = {
    create?: XOR<TopicCreateWithoutPostsInput, TopicUncheckedCreateWithoutPostsInput>
    connectOrCreate?: TopicCreateOrConnectWithoutPostsInput
    connect?: TopicWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutPostsInput = {
    create?: XOR<UserCreateWithoutPostsInput, UserUncheckedCreateWithoutPostsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPostsInput
    connect?: UserWhereUniqueInput
  }

  export type PostAttachmentCreateNestedManyWithoutPostInput = {
    create?: XOR<PostAttachmentCreateWithoutPostInput, PostAttachmentUncheckedCreateWithoutPostInput> | PostAttachmentCreateWithoutPostInput[] | PostAttachmentUncheckedCreateWithoutPostInput[]
    connectOrCreate?: PostAttachmentCreateOrConnectWithoutPostInput | PostAttachmentCreateOrConnectWithoutPostInput[]
    createMany?: PostAttachmentCreateManyPostInputEnvelope
    connect?: PostAttachmentWhereUniqueInput | PostAttachmentWhereUniqueInput[]
  }

  export type PostAttachmentUncheckedCreateNestedManyWithoutPostInput = {
    create?: XOR<PostAttachmentCreateWithoutPostInput, PostAttachmentUncheckedCreateWithoutPostInput> | PostAttachmentCreateWithoutPostInput[] | PostAttachmentUncheckedCreateWithoutPostInput[]
    connectOrCreate?: PostAttachmentCreateOrConnectWithoutPostInput | PostAttachmentCreateOrConnectWithoutPostInput[]
    createMany?: PostAttachmentCreateManyPostInputEnvelope
    connect?: PostAttachmentWhereUniqueInput | PostAttachmentWhereUniqueInput[]
  }

  export type TopicUpdateOneRequiredWithoutPostsNestedInput = {
    create?: XOR<TopicCreateWithoutPostsInput, TopicUncheckedCreateWithoutPostsInput>
    connectOrCreate?: TopicCreateOrConnectWithoutPostsInput
    upsert?: TopicUpsertWithoutPostsInput
    connect?: TopicWhereUniqueInput
    update?: XOR<XOR<TopicUpdateToOneWithWhereWithoutPostsInput, TopicUpdateWithoutPostsInput>, TopicUncheckedUpdateWithoutPostsInput>
  }

  export type UserUpdateOneRequiredWithoutPostsNestedInput = {
    create?: XOR<UserCreateWithoutPostsInput, UserUncheckedCreateWithoutPostsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPostsInput
    upsert?: UserUpsertWithoutPostsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPostsInput, UserUpdateWithoutPostsInput>, UserUncheckedUpdateWithoutPostsInput>
  }

  export type PostAttachmentUpdateManyWithoutPostNestedInput = {
    create?: XOR<PostAttachmentCreateWithoutPostInput, PostAttachmentUncheckedCreateWithoutPostInput> | PostAttachmentCreateWithoutPostInput[] | PostAttachmentUncheckedCreateWithoutPostInput[]
    connectOrCreate?: PostAttachmentCreateOrConnectWithoutPostInput | PostAttachmentCreateOrConnectWithoutPostInput[]
    upsert?: PostAttachmentUpsertWithWhereUniqueWithoutPostInput | PostAttachmentUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: PostAttachmentCreateManyPostInputEnvelope
    set?: PostAttachmentWhereUniqueInput | PostAttachmentWhereUniqueInput[]
    disconnect?: PostAttachmentWhereUniqueInput | PostAttachmentWhereUniqueInput[]
    delete?: PostAttachmentWhereUniqueInput | PostAttachmentWhereUniqueInput[]
    connect?: PostAttachmentWhereUniqueInput | PostAttachmentWhereUniqueInput[]
    update?: PostAttachmentUpdateWithWhereUniqueWithoutPostInput | PostAttachmentUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: PostAttachmentUpdateManyWithWhereWithoutPostInput | PostAttachmentUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: PostAttachmentScalarWhereInput | PostAttachmentScalarWhereInput[]
  }

  export type PostAttachmentUncheckedUpdateManyWithoutPostNestedInput = {
    create?: XOR<PostAttachmentCreateWithoutPostInput, PostAttachmentUncheckedCreateWithoutPostInput> | PostAttachmentCreateWithoutPostInput[] | PostAttachmentUncheckedCreateWithoutPostInput[]
    connectOrCreate?: PostAttachmentCreateOrConnectWithoutPostInput | PostAttachmentCreateOrConnectWithoutPostInput[]
    upsert?: PostAttachmentUpsertWithWhereUniqueWithoutPostInput | PostAttachmentUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: PostAttachmentCreateManyPostInputEnvelope
    set?: PostAttachmentWhereUniqueInput | PostAttachmentWhereUniqueInput[]
    disconnect?: PostAttachmentWhereUniqueInput | PostAttachmentWhereUniqueInput[]
    delete?: PostAttachmentWhereUniqueInput | PostAttachmentWhereUniqueInput[]
    connect?: PostAttachmentWhereUniqueInput | PostAttachmentWhereUniqueInput[]
    update?: PostAttachmentUpdateWithWhereUniqueWithoutPostInput | PostAttachmentUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: PostAttachmentUpdateManyWithWhereWithoutPostInput | PostAttachmentUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: PostAttachmentScalarWhereInput | PostAttachmentScalarWhereInput[]
  }

  export type PostCreateNestedOneWithoutAttachmentsInput = {
    create?: XOR<PostCreateWithoutAttachmentsInput, PostUncheckedCreateWithoutAttachmentsInput>
    connectOrCreate?: PostCreateOrConnectWithoutAttachmentsInput
    connect?: PostWhereUniqueInput
  }

  export type PostUpdateOneRequiredWithoutAttachmentsNestedInput = {
    create?: XOR<PostCreateWithoutAttachmentsInput, PostUncheckedCreateWithoutAttachmentsInput>
    connectOrCreate?: PostCreateOrConnectWithoutAttachmentsInput
    upsert?: PostUpsertWithoutAttachmentsInput
    connect?: PostWhereUniqueInput
    update?: XOR<XOR<PostUpdateToOneWithWhereWithoutAttachmentsInput, PostUpdateWithoutAttachmentsInput>, PostUncheckedUpdateWithoutAttachmentsInput>
  }

  export type TicketCreateNestedManyWithoutCategoryInput = {
    create?: XOR<TicketCreateWithoutCategoryInput, TicketUncheckedCreateWithoutCategoryInput> | TicketCreateWithoutCategoryInput[] | TicketUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutCategoryInput | TicketCreateOrConnectWithoutCategoryInput[]
    createMany?: TicketCreateManyCategoryInputEnvelope
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
  }

  export type TicketUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<TicketCreateWithoutCategoryInput, TicketUncheckedCreateWithoutCategoryInput> | TicketCreateWithoutCategoryInput[] | TicketUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutCategoryInput | TicketCreateOrConnectWithoutCategoryInput[]
    createMany?: TicketCreateManyCategoryInputEnvelope
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
  }

  export type TicketUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<TicketCreateWithoutCategoryInput, TicketUncheckedCreateWithoutCategoryInput> | TicketCreateWithoutCategoryInput[] | TicketUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutCategoryInput | TicketCreateOrConnectWithoutCategoryInput[]
    upsert?: TicketUpsertWithWhereUniqueWithoutCategoryInput | TicketUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: TicketCreateManyCategoryInputEnvelope
    set?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    disconnect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    delete?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    update?: TicketUpdateWithWhereUniqueWithoutCategoryInput | TicketUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: TicketUpdateManyWithWhereWithoutCategoryInput | TicketUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: TicketScalarWhereInput | TicketScalarWhereInput[]
  }

  export type TicketUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<TicketCreateWithoutCategoryInput, TicketUncheckedCreateWithoutCategoryInput> | TicketCreateWithoutCategoryInput[] | TicketUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutCategoryInput | TicketCreateOrConnectWithoutCategoryInput[]
    upsert?: TicketUpsertWithWhereUniqueWithoutCategoryInput | TicketUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: TicketCreateManyCategoryInputEnvelope
    set?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    disconnect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    delete?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    update?: TicketUpdateWithWhereUniqueWithoutCategoryInput | TicketUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: TicketUpdateManyWithWhereWithoutCategoryInput | TicketUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: TicketScalarWhereInput | TicketScalarWhereInput[]
  }

  export type TicketCategoryCreateNestedOneWithoutTicketsInput = {
    create?: XOR<TicketCategoryCreateWithoutTicketsInput, TicketCategoryUncheckedCreateWithoutTicketsInput>
    connectOrCreate?: TicketCategoryCreateOrConnectWithoutTicketsInput
    connect?: TicketCategoryWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutTicketsInput = {
    create?: XOR<UserCreateWithoutTicketsInput, UserUncheckedCreateWithoutTicketsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTicketsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAssignedTicketsInput = {
    create?: XOR<UserCreateWithoutAssignedTicketsInput, UserUncheckedCreateWithoutAssignedTicketsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAssignedTicketsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutClosedTicketsInput = {
    create?: XOR<UserCreateWithoutClosedTicketsInput, UserUncheckedCreateWithoutClosedTicketsInput>
    connectOrCreate?: UserCreateOrConnectWithoutClosedTicketsInput
    connect?: UserWhereUniqueInput
  }

  export type TicketMessageCreateNestedManyWithoutTicketInput = {
    create?: XOR<TicketMessageCreateWithoutTicketInput, TicketMessageUncheckedCreateWithoutTicketInput> | TicketMessageCreateWithoutTicketInput[] | TicketMessageUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: TicketMessageCreateOrConnectWithoutTicketInput | TicketMessageCreateOrConnectWithoutTicketInput[]
    createMany?: TicketMessageCreateManyTicketInputEnvelope
    connect?: TicketMessageWhereUniqueInput | TicketMessageWhereUniqueInput[]
  }

  export type TicketParticipantCreateNestedManyWithoutTicketInput = {
    create?: XOR<TicketParticipantCreateWithoutTicketInput, TicketParticipantUncheckedCreateWithoutTicketInput> | TicketParticipantCreateWithoutTicketInput[] | TicketParticipantUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: TicketParticipantCreateOrConnectWithoutTicketInput | TicketParticipantCreateOrConnectWithoutTicketInput[]
    createMany?: TicketParticipantCreateManyTicketInputEnvelope
    connect?: TicketParticipantWhereUniqueInput | TicketParticipantWhereUniqueInput[]
  }

  export type TicketRatingCreateNestedManyWithoutTicketInput = {
    create?: XOR<TicketRatingCreateWithoutTicketInput, TicketRatingUncheckedCreateWithoutTicketInput> | TicketRatingCreateWithoutTicketInput[] | TicketRatingUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: TicketRatingCreateOrConnectWithoutTicketInput | TicketRatingCreateOrConnectWithoutTicketInput[]
    createMany?: TicketRatingCreateManyTicketInputEnvelope
    connect?: TicketRatingWhereUniqueInput | TicketRatingWhereUniqueInput[]
  }

  export type TicketRatingRequirementCreateNestedManyWithoutTicketInput = {
    create?: XOR<TicketRatingRequirementCreateWithoutTicketInput, TicketRatingRequirementUncheckedCreateWithoutTicketInput> | TicketRatingRequirementCreateWithoutTicketInput[] | TicketRatingRequirementUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: TicketRatingRequirementCreateOrConnectWithoutTicketInput | TicketRatingRequirementCreateOrConnectWithoutTicketInput[]
    createMany?: TicketRatingRequirementCreateManyTicketInputEnvelope
    connect?: TicketRatingRequirementWhereUniqueInput | TicketRatingRequirementWhereUniqueInput[]
  }

  export type TicketMessageUncheckedCreateNestedManyWithoutTicketInput = {
    create?: XOR<TicketMessageCreateWithoutTicketInput, TicketMessageUncheckedCreateWithoutTicketInput> | TicketMessageCreateWithoutTicketInput[] | TicketMessageUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: TicketMessageCreateOrConnectWithoutTicketInput | TicketMessageCreateOrConnectWithoutTicketInput[]
    createMany?: TicketMessageCreateManyTicketInputEnvelope
    connect?: TicketMessageWhereUniqueInput | TicketMessageWhereUniqueInput[]
  }

  export type TicketParticipantUncheckedCreateNestedManyWithoutTicketInput = {
    create?: XOR<TicketParticipantCreateWithoutTicketInput, TicketParticipantUncheckedCreateWithoutTicketInput> | TicketParticipantCreateWithoutTicketInput[] | TicketParticipantUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: TicketParticipantCreateOrConnectWithoutTicketInput | TicketParticipantCreateOrConnectWithoutTicketInput[]
    createMany?: TicketParticipantCreateManyTicketInputEnvelope
    connect?: TicketParticipantWhereUniqueInput | TicketParticipantWhereUniqueInput[]
  }

  export type TicketRatingUncheckedCreateNestedManyWithoutTicketInput = {
    create?: XOR<TicketRatingCreateWithoutTicketInput, TicketRatingUncheckedCreateWithoutTicketInput> | TicketRatingCreateWithoutTicketInput[] | TicketRatingUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: TicketRatingCreateOrConnectWithoutTicketInput | TicketRatingCreateOrConnectWithoutTicketInput[]
    createMany?: TicketRatingCreateManyTicketInputEnvelope
    connect?: TicketRatingWhereUniqueInput | TicketRatingWhereUniqueInput[]
  }

  export type TicketRatingRequirementUncheckedCreateNestedManyWithoutTicketInput = {
    create?: XOR<TicketRatingRequirementCreateWithoutTicketInput, TicketRatingRequirementUncheckedCreateWithoutTicketInput> | TicketRatingRequirementCreateWithoutTicketInput[] | TicketRatingRequirementUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: TicketRatingRequirementCreateOrConnectWithoutTicketInput | TicketRatingRequirementCreateOrConnectWithoutTicketInput[]
    createMany?: TicketRatingRequirementCreateManyTicketInputEnvelope
    connect?: TicketRatingRequirementWhereUniqueInput | TicketRatingRequirementWhereUniqueInput[]
  }

  export type TicketCategoryUpdateOneRequiredWithoutTicketsNestedInput = {
    create?: XOR<TicketCategoryCreateWithoutTicketsInput, TicketCategoryUncheckedCreateWithoutTicketsInput>
    connectOrCreate?: TicketCategoryCreateOrConnectWithoutTicketsInput
    upsert?: TicketCategoryUpsertWithoutTicketsInput
    connect?: TicketCategoryWhereUniqueInput
    update?: XOR<XOR<TicketCategoryUpdateToOneWithWhereWithoutTicketsInput, TicketCategoryUpdateWithoutTicketsInput>, TicketCategoryUncheckedUpdateWithoutTicketsInput>
  }

  export type UserUpdateOneRequiredWithoutTicketsNestedInput = {
    create?: XOR<UserCreateWithoutTicketsInput, UserUncheckedCreateWithoutTicketsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTicketsInput
    upsert?: UserUpsertWithoutTicketsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTicketsInput, UserUpdateWithoutTicketsInput>, UserUncheckedUpdateWithoutTicketsInput>
  }

  export type UserUpdateOneWithoutAssignedTicketsNestedInput = {
    create?: XOR<UserCreateWithoutAssignedTicketsInput, UserUncheckedCreateWithoutAssignedTicketsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAssignedTicketsInput
    upsert?: UserUpsertWithoutAssignedTicketsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAssignedTicketsInput, UserUpdateWithoutAssignedTicketsInput>, UserUncheckedUpdateWithoutAssignedTicketsInput>
  }

  export type UserUpdateOneWithoutClosedTicketsNestedInput = {
    create?: XOR<UserCreateWithoutClosedTicketsInput, UserUncheckedCreateWithoutClosedTicketsInput>
    connectOrCreate?: UserCreateOrConnectWithoutClosedTicketsInput
    upsert?: UserUpsertWithoutClosedTicketsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutClosedTicketsInput, UserUpdateWithoutClosedTicketsInput>, UserUncheckedUpdateWithoutClosedTicketsInput>
  }

  export type TicketMessageUpdateManyWithoutTicketNestedInput = {
    create?: XOR<TicketMessageCreateWithoutTicketInput, TicketMessageUncheckedCreateWithoutTicketInput> | TicketMessageCreateWithoutTicketInput[] | TicketMessageUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: TicketMessageCreateOrConnectWithoutTicketInput | TicketMessageCreateOrConnectWithoutTicketInput[]
    upsert?: TicketMessageUpsertWithWhereUniqueWithoutTicketInput | TicketMessageUpsertWithWhereUniqueWithoutTicketInput[]
    createMany?: TicketMessageCreateManyTicketInputEnvelope
    set?: TicketMessageWhereUniqueInput | TicketMessageWhereUniqueInput[]
    disconnect?: TicketMessageWhereUniqueInput | TicketMessageWhereUniqueInput[]
    delete?: TicketMessageWhereUniqueInput | TicketMessageWhereUniqueInput[]
    connect?: TicketMessageWhereUniqueInput | TicketMessageWhereUniqueInput[]
    update?: TicketMessageUpdateWithWhereUniqueWithoutTicketInput | TicketMessageUpdateWithWhereUniqueWithoutTicketInput[]
    updateMany?: TicketMessageUpdateManyWithWhereWithoutTicketInput | TicketMessageUpdateManyWithWhereWithoutTicketInput[]
    deleteMany?: TicketMessageScalarWhereInput | TicketMessageScalarWhereInput[]
  }

  export type TicketParticipantUpdateManyWithoutTicketNestedInput = {
    create?: XOR<TicketParticipantCreateWithoutTicketInput, TicketParticipantUncheckedCreateWithoutTicketInput> | TicketParticipantCreateWithoutTicketInput[] | TicketParticipantUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: TicketParticipantCreateOrConnectWithoutTicketInput | TicketParticipantCreateOrConnectWithoutTicketInput[]
    upsert?: TicketParticipantUpsertWithWhereUniqueWithoutTicketInput | TicketParticipantUpsertWithWhereUniqueWithoutTicketInput[]
    createMany?: TicketParticipantCreateManyTicketInputEnvelope
    set?: TicketParticipantWhereUniqueInput | TicketParticipantWhereUniqueInput[]
    disconnect?: TicketParticipantWhereUniqueInput | TicketParticipantWhereUniqueInput[]
    delete?: TicketParticipantWhereUniqueInput | TicketParticipantWhereUniqueInput[]
    connect?: TicketParticipantWhereUniqueInput | TicketParticipantWhereUniqueInput[]
    update?: TicketParticipantUpdateWithWhereUniqueWithoutTicketInput | TicketParticipantUpdateWithWhereUniqueWithoutTicketInput[]
    updateMany?: TicketParticipantUpdateManyWithWhereWithoutTicketInput | TicketParticipantUpdateManyWithWhereWithoutTicketInput[]
    deleteMany?: TicketParticipantScalarWhereInput | TicketParticipantScalarWhereInput[]
  }

  export type TicketRatingUpdateManyWithoutTicketNestedInput = {
    create?: XOR<TicketRatingCreateWithoutTicketInput, TicketRatingUncheckedCreateWithoutTicketInput> | TicketRatingCreateWithoutTicketInput[] | TicketRatingUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: TicketRatingCreateOrConnectWithoutTicketInput | TicketRatingCreateOrConnectWithoutTicketInput[]
    upsert?: TicketRatingUpsertWithWhereUniqueWithoutTicketInput | TicketRatingUpsertWithWhereUniqueWithoutTicketInput[]
    createMany?: TicketRatingCreateManyTicketInputEnvelope
    set?: TicketRatingWhereUniqueInput | TicketRatingWhereUniqueInput[]
    disconnect?: TicketRatingWhereUniqueInput | TicketRatingWhereUniqueInput[]
    delete?: TicketRatingWhereUniqueInput | TicketRatingWhereUniqueInput[]
    connect?: TicketRatingWhereUniqueInput | TicketRatingWhereUniqueInput[]
    update?: TicketRatingUpdateWithWhereUniqueWithoutTicketInput | TicketRatingUpdateWithWhereUniqueWithoutTicketInput[]
    updateMany?: TicketRatingUpdateManyWithWhereWithoutTicketInput | TicketRatingUpdateManyWithWhereWithoutTicketInput[]
    deleteMany?: TicketRatingScalarWhereInput | TicketRatingScalarWhereInput[]
  }

  export type TicketRatingRequirementUpdateManyWithoutTicketNestedInput = {
    create?: XOR<TicketRatingRequirementCreateWithoutTicketInput, TicketRatingRequirementUncheckedCreateWithoutTicketInput> | TicketRatingRequirementCreateWithoutTicketInput[] | TicketRatingRequirementUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: TicketRatingRequirementCreateOrConnectWithoutTicketInput | TicketRatingRequirementCreateOrConnectWithoutTicketInput[]
    upsert?: TicketRatingRequirementUpsertWithWhereUniqueWithoutTicketInput | TicketRatingRequirementUpsertWithWhereUniqueWithoutTicketInput[]
    createMany?: TicketRatingRequirementCreateManyTicketInputEnvelope
    set?: TicketRatingRequirementWhereUniqueInput | TicketRatingRequirementWhereUniqueInput[]
    disconnect?: TicketRatingRequirementWhereUniqueInput | TicketRatingRequirementWhereUniqueInput[]
    delete?: TicketRatingRequirementWhereUniqueInput | TicketRatingRequirementWhereUniqueInput[]
    connect?: TicketRatingRequirementWhereUniqueInput | TicketRatingRequirementWhereUniqueInput[]
    update?: TicketRatingRequirementUpdateWithWhereUniqueWithoutTicketInput | TicketRatingRequirementUpdateWithWhereUniqueWithoutTicketInput[]
    updateMany?: TicketRatingRequirementUpdateManyWithWhereWithoutTicketInput | TicketRatingRequirementUpdateManyWithWhereWithoutTicketInput[]
    deleteMany?: TicketRatingRequirementScalarWhereInput | TicketRatingRequirementScalarWhereInput[]
  }

  export type TicketMessageUncheckedUpdateManyWithoutTicketNestedInput = {
    create?: XOR<TicketMessageCreateWithoutTicketInput, TicketMessageUncheckedCreateWithoutTicketInput> | TicketMessageCreateWithoutTicketInput[] | TicketMessageUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: TicketMessageCreateOrConnectWithoutTicketInput | TicketMessageCreateOrConnectWithoutTicketInput[]
    upsert?: TicketMessageUpsertWithWhereUniqueWithoutTicketInput | TicketMessageUpsertWithWhereUniqueWithoutTicketInput[]
    createMany?: TicketMessageCreateManyTicketInputEnvelope
    set?: TicketMessageWhereUniqueInput | TicketMessageWhereUniqueInput[]
    disconnect?: TicketMessageWhereUniqueInput | TicketMessageWhereUniqueInput[]
    delete?: TicketMessageWhereUniqueInput | TicketMessageWhereUniqueInput[]
    connect?: TicketMessageWhereUniqueInput | TicketMessageWhereUniqueInput[]
    update?: TicketMessageUpdateWithWhereUniqueWithoutTicketInput | TicketMessageUpdateWithWhereUniqueWithoutTicketInput[]
    updateMany?: TicketMessageUpdateManyWithWhereWithoutTicketInput | TicketMessageUpdateManyWithWhereWithoutTicketInput[]
    deleteMany?: TicketMessageScalarWhereInput | TicketMessageScalarWhereInput[]
  }

  export type TicketParticipantUncheckedUpdateManyWithoutTicketNestedInput = {
    create?: XOR<TicketParticipantCreateWithoutTicketInput, TicketParticipantUncheckedCreateWithoutTicketInput> | TicketParticipantCreateWithoutTicketInput[] | TicketParticipantUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: TicketParticipantCreateOrConnectWithoutTicketInput | TicketParticipantCreateOrConnectWithoutTicketInput[]
    upsert?: TicketParticipantUpsertWithWhereUniqueWithoutTicketInput | TicketParticipantUpsertWithWhereUniqueWithoutTicketInput[]
    createMany?: TicketParticipantCreateManyTicketInputEnvelope
    set?: TicketParticipantWhereUniqueInput | TicketParticipantWhereUniqueInput[]
    disconnect?: TicketParticipantWhereUniqueInput | TicketParticipantWhereUniqueInput[]
    delete?: TicketParticipantWhereUniqueInput | TicketParticipantWhereUniqueInput[]
    connect?: TicketParticipantWhereUniqueInput | TicketParticipantWhereUniqueInput[]
    update?: TicketParticipantUpdateWithWhereUniqueWithoutTicketInput | TicketParticipantUpdateWithWhereUniqueWithoutTicketInput[]
    updateMany?: TicketParticipantUpdateManyWithWhereWithoutTicketInput | TicketParticipantUpdateManyWithWhereWithoutTicketInput[]
    deleteMany?: TicketParticipantScalarWhereInput | TicketParticipantScalarWhereInput[]
  }

  export type TicketRatingUncheckedUpdateManyWithoutTicketNestedInput = {
    create?: XOR<TicketRatingCreateWithoutTicketInput, TicketRatingUncheckedCreateWithoutTicketInput> | TicketRatingCreateWithoutTicketInput[] | TicketRatingUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: TicketRatingCreateOrConnectWithoutTicketInput | TicketRatingCreateOrConnectWithoutTicketInput[]
    upsert?: TicketRatingUpsertWithWhereUniqueWithoutTicketInput | TicketRatingUpsertWithWhereUniqueWithoutTicketInput[]
    createMany?: TicketRatingCreateManyTicketInputEnvelope
    set?: TicketRatingWhereUniqueInput | TicketRatingWhereUniqueInput[]
    disconnect?: TicketRatingWhereUniqueInput | TicketRatingWhereUniqueInput[]
    delete?: TicketRatingWhereUniqueInput | TicketRatingWhereUniqueInput[]
    connect?: TicketRatingWhereUniqueInput | TicketRatingWhereUniqueInput[]
    update?: TicketRatingUpdateWithWhereUniqueWithoutTicketInput | TicketRatingUpdateWithWhereUniqueWithoutTicketInput[]
    updateMany?: TicketRatingUpdateManyWithWhereWithoutTicketInput | TicketRatingUpdateManyWithWhereWithoutTicketInput[]
    deleteMany?: TicketRatingScalarWhereInput | TicketRatingScalarWhereInput[]
  }

  export type TicketRatingRequirementUncheckedUpdateManyWithoutTicketNestedInput = {
    create?: XOR<TicketRatingRequirementCreateWithoutTicketInput, TicketRatingRequirementUncheckedCreateWithoutTicketInput> | TicketRatingRequirementCreateWithoutTicketInput[] | TicketRatingRequirementUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: TicketRatingRequirementCreateOrConnectWithoutTicketInput | TicketRatingRequirementCreateOrConnectWithoutTicketInput[]
    upsert?: TicketRatingRequirementUpsertWithWhereUniqueWithoutTicketInput | TicketRatingRequirementUpsertWithWhereUniqueWithoutTicketInput[]
    createMany?: TicketRatingRequirementCreateManyTicketInputEnvelope
    set?: TicketRatingRequirementWhereUniqueInput | TicketRatingRequirementWhereUniqueInput[]
    disconnect?: TicketRatingRequirementWhereUniqueInput | TicketRatingRequirementWhereUniqueInput[]
    delete?: TicketRatingRequirementWhereUniqueInput | TicketRatingRequirementWhereUniqueInput[]
    connect?: TicketRatingRequirementWhereUniqueInput | TicketRatingRequirementWhereUniqueInput[]
    update?: TicketRatingRequirementUpdateWithWhereUniqueWithoutTicketInput | TicketRatingRequirementUpdateWithWhereUniqueWithoutTicketInput[]
    updateMany?: TicketRatingRequirementUpdateManyWithWhereWithoutTicketInput | TicketRatingRequirementUpdateManyWithWhereWithoutTicketInput[]
    deleteMany?: TicketRatingRequirementScalarWhereInput | TicketRatingRequirementScalarWhereInput[]
  }

  export type TicketCreateNestedOneWithoutMessagesInput = {
    create?: XOR<TicketCreateWithoutMessagesInput, TicketUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: TicketCreateOrConnectWithoutMessagesInput
    connect?: TicketWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutTicketMsgsInput = {
    create?: XOR<UserCreateWithoutTicketMsgsInput, UserUncheckedCreateWithoutTicketMsgsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTicketMsgsInput
    connect?: UserWhereUniqueInput
  }

  export type TicketUpdateOneRequiredWithoutMessagesNestedInput = {
    create?: XOR<TicketCreateWithoutMessagesInput, TicketUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: TicketCreateOrConnectWithoutMessagesInput
    upsert?: TicketUpsertWithoutMessagesInput
    connect?: TicketWhereUniqueInput
    update?: XOR<XOR<TicketUpdateToOneWithWhereWithoutMessagesInput, TicketUpdateWithoutMessagesInput>, TicketUncheckedUpdateWithoutMessagesInput>
  }

  export type UserUpdateOneRequiredWithoutTicketMsgsNestedInput = {
    create?: XOR<UserCreateWithoutTicketMsgsInput, UserUncheckedCreateWithoutTicketMsgsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTicketMsgsInput
    upsert?: UserUpsertWithoutTicketMsgsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTicketMsgsInput, UserUpdateWithoutTicketMsgsInput>, UserUncheckedUpdateWithoutTicketMsgsInput>
  }

  export type UserCreateNestedOneWithoutPurchasesInput = {
    create?: XOR<UserCreateWithoutPurchasesInput, UserUncheckedCreateWithoutPurchasesInput>
    connectOrCreate?: UserCreateOrConnectWithoutPurchasesInput
    connect?: UserWhereUniqueInput
  }

  export type PurchaseItemCreateNestedManyWithoutPurchaseInput = {
    create?: XOR<PurchaseItemCreateWithoutPurchaseInput, PurchaseItemUncheckedCreateWithoutPurchaseInput> | PurchaseItemCreateWithoutPurchaseInput[] | PurchaseItemUncheckedCreateWithoutPurchaseInput[]
    connectOrCreate?: PurchaseItemCreateOrConnectWithoutPurchaseInput | PurchaseItemCreateOrConnectWithoutPurchaseInput[]
    createMany?: PurchaseItemCreateManyPurchaseInputEnvelope
    connect?: PurchaseItemWhereUniqueInput | PurchaseItemWhereUniqueInput[]
  }

  export type PurchaseItemUncheckedCreateNestedManyWithoutPurchaseInput = {
    create?: XOR<PurchaseItemCreateWithoutPurchaseInput, PurchaseItemUncheckedCreateWithoutPurchaseInput> | PurchaseItemCreateWithoutPurchaseInput[] | PurchaseItemUncheckedCreateWithoutPurchaseInput[]
    connectOrCreate?: PurchaseItemCreateOrConnectWithoutPurchaseInput | PurchaseItemCreateOrConnectWithoutPurchaseInput[]
    createMany?: PurchaseItemCreateManyPurchaseInputEnvelope
    connect?: PurchaseItemWhereUniqueInput | PurchaseItemWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutPurchasesNestedInput = {
    create?: XOR<UserCreateWithoutPurchasesInput, UserUncheckedCreateWithoutPurchasesInput>
    connectOrCreate?: UserCreateOrConnectWithoutPurchasesInput
    upsert?: UserUpsertWithoutPurchasesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPurchasesInput, UserUpdateWithoutPurchasesInput>, UserUncheckedUpdateWithoutPurchasesInput>
  }

  export type PurchaseItemUpdateManyWithoutPurchaseNestedInput = {
    create?: XOR<PurchaseItemCreateWithoutPurchaseInput, PurchaseItemUncheckedCreateWithoutPurchaseInput> | PurchaseItemCreateWithoutPurchaseInput[] | PurchaseItemUncheckedCreateWithoutPurchaseInput[]
    connectOrCreate?: PurchaseItemCreateOrConnectWithoutPurchaseInput | PurchaseItemCreateOrConnectWithoutPurchaseInput[]
    upsert?: PurchaseItemUpsertWithWhereUniqueWithoutPurchaseInput | PurchaseItemUpsertWithWhereUniqueWithoutPurchaseInput[]
    createMany?: PurchaseItemCreateManyPurchaseInputEnvelope
    set?: PurchaseItemWhereUniqueInput | PurchaseItemWhereUniqueInput[]
    disconnect?: PurchaseItemWhereUniqueInput | PurchaseItemWhereUniqueInput[]
    delete?: PurchaseItemWhereUniqueInput | PurchaseItemWhereUniqueInput[]
    connect?: PurchaseItemWhereUniqueInput | PurchaseItemWhereUniqueInput[]
    update?: PurchaseItemUpdateWithWhereUniqueWithoutPurchaseInput | PurchaseItemUpdateWithWhereUniqueWithoutPurchaseInput[]
    updateMany?: PurchaseItemUpdateManyWithWhereWithoutPurchaseInput | PurchaseItemUpdateManyWithWhereWithoutPurchaseInput[]
    deleteMany?: PurchaseItemScalarWhereInput | PurchaseItemScalarWhereInput[]
  }

  export type PurchaseItemUncheckedUpdateManyWithoutPurchaseNestedInput = {
    create?: XOR<PurchaseItemCreateWithoutPurchaseInput, PurchaseItemUncheckedCreateWithoutPurchaseInput> | PurchaseItemCreateWithoutPurchaseInput[] | PurchaseItemUncheckedCreateWithoutPurchaseInput[]
    connectOrCreate?: PurchaseItemCreateOrConnectWithoutPurchaseInput | PurchaseItemCreateOrConnectWithoutPurchaseInput[]
    upsert?: PurchaseItemUpsertWithWhereUniqueWithoutPurchaseInput | PurchaseItemUpsertWithWhereUniqueWithoutPurchaseInput[]
    createMany?: PurchaseItemCreateManyPurchaseInputEnvelope
    set?: PurchaseItemWhereUniqueInput | PurchaseItemWhereUniqueInput[]
    disconnect?: PurchaseItemWhereUniqueInput | PurchaseItemWhereUniqueInput[]
    delete?: PurchaseItemWhereUniqueInput | PurchaseItemWhereUniqueInput[]
    connect?: PurchaseItemWhereUniqueInput | PurchaseItemWhereUniqueInput[]
    update?: PurchaseItemUpdateWithWhereUniqueWithoutPurchaseInput | PurchaseItemUpdateWithWhereUniqueWithoutPurchaseInput[]
    updateMany?: PurchaseItemUpdateManyWithWhereWithoutPurchaseInput | PurchaseItemUpdateManyWithWhereWithoutPurchaseInput[]
    deleteMany?: PurchaseItemScalarWhereInput | PurchaseItemScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutAuditLogsInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneWithoutAuditLogsNestedInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    upsert?: UserUpsertWithoutAuditLogsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAuditLogsInput, UserUpdateWithoutAuditLogsInput>, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type RolePermissionCreateNestedManyWithoutRoleInput = {
    create?: XOR<RolePermissionCreateWithoutRoleInput, RolePermissionUncheckedCreateWithoutRoleInput> | RolePermissionCreateWithoutRoleInput[] | RolePermissionUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutRoleInput | RolePermissionCreateOrConnectWithoutRoleInput[]
    createMany?: RolePermissionCreateManyRoleInputEnvelope
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
  }

  export type UserRoleCreateNestedManyWithoutRoleInput = {
    create?: XOR<UserRoleCreateWithoutRoleInput, UserRoleUncheckedCreateWithoutRoleInput> | UserRoleCreateWithoutRoleInput[] | UserRoleUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutRoleInput | UserRoleCreateOrConnectWithoutRoleInput[]
    createMany?: UserRoleCreateManyRoleInputEnvelope
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
  }

  export type RolePermissionUncheckedCreateNestedManyWithoutRoleInput = {
    create?: XOR<RolePermissionCreateWithoutRoleInput, RolePermissionUncheckedCreateWithoutRoleInput> | RolePermissionCreateWithoutRoleInput[] | RolePermissionUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutRoleInput | RolePermissionCreateOrConnectWithoutRoleInput[]
    createMany?: RolePermissionCreateManyRoleInputEnvelope
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
  }

  export type UserRoleUncheckedCreateNestedManyWithoutRoleInput = {
    create?: XOR<UserRoleCreateWithoutRoleInput, UserRoleUncheckedCreateWithoutRoleInput> | UserRoleCreateWithoutRoleInput[] | UserRoleUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutRoleInput | UserRoleCreateOrConnectWithoutRoleInput[]
    createMany?: UserRoleCreateManyRoleInputEnvelope
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
  }

  export type RolePermissionUpdateManyWithoutRoleNestedInput = {
    create?: XOR<RolePermissionCreateWithoutRoleInput, RolePermissionUncheckedCreateWithoutRoleInput> | RolePermissionCreateWithoutRoleInput[] | RolePermissionUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutRoleInput | RolePermissionCreateOrConnectWithoutRoleInput[]
    upsert?: RolePermissionUpsertWithWhereUniqueWithoutRoleInput | RolePermissionUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: RolePermissionCreateManyRoleInputEnvelope
    set?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    disconnect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    delete?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    update?: RolePermissionUpdateWithWhereUniqueWithoutRoleInput | RolePermissionUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: RolePermissionUpdateManyWithWhereWithoutRoleInput | RolePermissionUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: RolePermissionScalarWhereInput | RolePermissionScalarWhereInput[]
  }

  export type UserRoleUpdateManyWithoutRoleNestedInput = {
    create?: XOR<UserRoleCreateWithoutRoleInput, UserRoleUncheckedCreateWithoutRoleInput> | UserRoleCreateWithoutRoleInput[] | UserRoleUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutRoleInput | UserRoleCreateOrConnectWithoutRoleInput[]
    upsert?: UserRoleUpsertWithWhereUniqueWithoutRoleInput | UserRoleUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: UserRoleCreateManyRoleInputEnvelope
    set?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    disconnect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    delete?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    update?: UserRoleUpdateWithWhereUniqueWithoutRoleInput | UserRoleUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: UserRoleUpdateManyWithWhereWithoutRoleInput | UserRoleUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
  }

  export type RolePermissionUncheckedUpdateManyWithoutRoleNestedInput = {
    create?: XOR<RolePermissionCreateWithoutRoleInput, RolePermissionUncheckedCreateWithoutRoleInput> | RolePermissionCreateWithoutRoleInput[] | RolePermissionUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutRoleInput | RolePermissionCreateOrConnectWithoutRoleInput[]
    upsert?: RolePermissionUpsertWithWhereUniqueWithoutRoleInput | RolePermissionUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: RolePermissionCreateManyRoleInputEnvelope
    set?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    disconnect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    delete?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    update?: RolePermissionUpdateWithWhereUniqueWithoutRoleInput | RolePermissionUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: RolePermissionUpdateManyWithWhereWithoutRoleInput | RolePermissionUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: RolePermissionScalarWhereInput | RolePermissionScalarWhereInput[]
  }

  export type UserRoleUncheckedUpdateManyWithoutRoleNestedInput = {
    create?: XOR<UserRoleCreateWithoutRoleInput, UserRoleUncheckedCreateWithoutRoleInput> | UserRoleCreateWithoutRoleInput[] | UserRoleUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutRoleInput | UserRoleCreateOrConnectWithoutRoleInput[]
    upsert?: UserRoleUpsertWithWhereUniqueWithoutRoleInput | UserRoleUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: UserRoleCreateManyRoleInputEnvelope
    set?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    disconnect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    delete?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    update?: UserRoleUpdateWithWhereUniqueWithoutRoleInput | UserRoleUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: UserRoleUpdateManyWithWhereWithoutRoleInput | UserRoleUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
  }

  export type RolePermissionCreateNestedManyWithoutPermissionInput = {
    create?: XOR<RolePermissionCreateWithoutPermissionInput, RolePermissionUncheckedCreateWithoutPermissionInput> | RolePermissionCreateWithoutPermissionInput[] | RolePermissionUncheckedCreateWithoutPermissionInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutPermissionInput | RolePermissionCreateOrConnectWithoutPermissionInput[]
    createMany?: RolePermissionCreateManyPermissionInputEnvelope
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
  }

  export type RolePermissionUncheckedCreateNestedManyWithoutPermissionInput = {
    create?: XOR<RolePermissionCreateWithoutPermissionInput, RolePermissionUncheckedCreateWithoutPermissionInput> | RolePermissionCreateWithoutPermissionInput[] | RolePermissionUncheckedCreateWithoutPermissionInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutPermissionInput | RolePermissionCreateOrConnectWithoutPermissionInput[]
    createMany?: RolePermissionCreateManyPermissionInputEnvelope
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
  }

  export type RolePermissionUpdateManyWithoutPermissionNestedInput = {
    create?: XOR<RolePermissionCreateWithoutPermissionInput, RolePermissionUncheckedCreateWithoutPermissionInput> | RolePermissionCreateWithoutPermissionInput[] | RolePermissionUncheckedCreateWithoutPermissionInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutPermissionInput | RolePermissionCreateOrConnectWithoutPermissionInput[]
    upsert?: RolePermissionUpsertWithWhereUniqueWithoutPermissionInput | RolePermissionUpsertWithWhereUniqueWithoutPermissionInput[]
    createMany?: RolePermissionCreateManyPermissionInputEnvelope
    set?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    disconnect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    delete?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    update?: RolePermissionUpdateWithWhereUniqueWithoutPermissionInput | RolePermissionUpdateWithWhereUniqueWithoutPermissionInput[]
    updateMany?: RolePermissionUpdateManyWithWhereWithoutPermissionInput | RolePermissionUpdateManyWithWhereWithoutPermissionInput[]
    deleteMany?: RolePermissionScalarWhereInput | RolePermissionScalarWhereInput[]
  }

  export type RolePermissionUncheckedUpdateManyWithoutPermissionNestedInput = {
    create?: XOR<RolePermissionCreateWithoutPermissionInput, RolePermissionUncheckedCreateWithoutPermissionInput> | RolePermissionCreateWithoutPermissionInput[] | RolePermissionUncheckedCreateWithoutPermissionInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutPermissionInput | RolePermissionCreateOrConnectWithoutPermissionInput[]
    upsert?: RolePermissionUpsertWithWhereUniqueWithoutPermissionInput | RolePermissionUpsertWithWhereUniqueWithoutPermissionInput[]
    createMany?: RolePermissionCreateManyPermissionInputEnvelope
    set?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    disconnect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    delete?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    update?: RolePermissionUpdateWithWhereUniqueWithoutPermissionInput | RolePermissionUpdateWithWhereUniqueWithoutPermissionInput[]
    updateMany?: RolePermissionUpdateManyWithWhereWithoutPermissionInput | RolePermissionUpdateManyWithWhereWithoutPermissionInput[]
    deleteMany?: RolePermissionScalarWhereInput | RolePermissionScalarWhereInput[]
  }

  export type RoleCreateNestedOneWithoutPermissionsInput = {
    create?: XOR<RoleCreateWithoutPermissionsInput, RoleUncheckedCreateWithoutPermissionsInput>
    connectOrCreate?: RoleCreateOrConnectWithoutPermissionsInput
    connect?: RoleWhereUniqueInput
  }

  export type PermissionCreateNestedOneWithoutRolesInput = {
    create?: XOR<PermissionCreateWithoutRolesInput, PermissionUncheckedCreateWithoutRolesInput>
    connectOrCreate?: PermissionCreateOrConnectWithoutRolesInput
    connect?: PermissionWhereUniqueInput
  }

  export type RoleUpdateOneRequiredWithoutPermissionsNestedInput = {
    create?: XOR<RoleCreateWithoutPermissionsInput, RoleUncheckedCreateWithoutPermissionsInput>
    connectOrCreate?: RoleCreateOrConnectWithoutPermissionsInput
    upsert?: RoleUpsertWithoutPermissionsInput
    connect?: RoleWhereUniqueInput
    update?: XOR<XOR<RoleUpdateToOneWithWhereWithoutPermissionsInput, RoleUpdateWithoutPermissionsInput>, RoleUncheckedUpdateWithoutPermissionsInput>
  }

  export type PermissionUpdateOneRequiredWithoutRolesNestedInput = {
    create?: XOR<PermissionCreateWithoutRolesInput, PermissionUncheckedCreateWithoutRolesInput>
    connectOrCreate?: PermissionCreateOrConnectWithoutRolesInput
    upsert?: PermissionUpsertWithoutRolesInput
    connect?: PermissionWhereUniqueInput
    update?: XOR<XOR<PermissionUpdateToOneWithWhereWithoutRolesInput, PermissionUpdateWithoutRolesInput>, PermissionUncheckedUpdateWithoutRolesInput>
  }

  export type UserCreateNestedOneWithoutUserRolesInput = {
    create?: XOR<UserCreateWithoutUserRolesInput, UserUncheckedCreateWithoutUserRolesInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserRolesInput
    connect?: UserWhereUniqueInput
  }

  export type RoleCreateNestedOneWithoutUsersInput = {
    create?: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
    connectOrCreate?: RoleCreateOrConnectWithoutUsersInput
    connect?: RoleWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutUserRolesNestedInput = {
    create?: XOR<UserCreateWithoutUserRolesInput, UserUncheckedCreateWithoutUserRolesInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserRolesInput
    upsert?: UserUpsertWithoutUserRolesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUserRolesInput, UserUpdateWithoutUserRolesInput>, UserUncheckedUpdateWithoutUserRolesInput>
  }

  export type RoleUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
    connectOrCreate?: RoleCreateOrConnectWithoutUsersInput
    upsert?: RoleUpsertWithoutUsersInput
    connect?: RoleWhereUniqueInput
    update?: XOR<XOR<RoleUpdateToOneWithWhereWithoutUsersInput, RoleUpdateWithoutUsersInput>, RoleUncheckedUpdateWithoutUsersInput>
  }

  export type WhitelistAnswerCreateNestedManyWithoutQuestionInput = {
    create?: XOR<WhitelistAnswerCreateWithoutQuestionInput, WhitelistAnswerUncheckedCreateWithoutQuestionInput> | WhitelistAnswerCreateWithoutQuestionInput[] | WhitelistAnswerUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: WhitelistAnswerCreateOrConnectWithoutQuestionInput | WhitelistAnswerCreateOrConnectWithoutQuestionInput[]
    createMany?: WhitelistAnswerCreateManyQuestionInputEnvelope
    connect?: WhitelistAnswerWhereUniqueInput | WhitelistAnswerWhereUniqueInput[]
  }

  export type WhitelistAnswerUncheckedCreateNestedManyWithoutQuestionInput = {
    create?: XOR<WhitelistAnswerCreateWithoutQuestionInput, WhitelistAnswerUncheckedCreateWithoutQuestionInput> | WhitelistAnswerCreateWithoutQuestionInput[] | WhitelistAnswerUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: WhitelistAnswerCreateOrConnectWithoutQuestionInput | WhitelistAnswerCreateOrConnectWithoutQuestionInput[]
    createMany?: WhitelistAnswerCreateManyQuestionInputEnvelope
    connect?: WhitelistAnswerWhereUniqueInput | WhitelistAnswerWhereUniqueInput[]
  }

  export type WhitelistAnswerUpdateManyWithoutQuestionNestedInput = {
    create?: XOR<WhitelistAnswerCreateWithoutQuestionInput, WhitelistAnswerUncheckedCreateWithoutQuestionInput> | WhitelistAnswerCreateWithoutQuestionInput[] | WhitelistAnswerUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: WhitelistAnswerCreateOrConnectWithoutQuestionInput | WhitelistAnswerCreateOrConnectWithoutQuestionInput[]
    upsert?: WhitelistAnswerUpsertWithWhereUniqueWithoutQuestionInput | WhitelistAnswerUpsertWithWhereUniqueWithoutQuestionInput[]
    createMany?: WhitelistAnswerCreateManyQuestionInputEnvelope
    set?: WhitelistAnswerWhereUniqueInput | WhitelistAnswerWhereUniqueInput[]
    disconnect?: WhitelistAnswerWhereUniqueInput | WhitelistAnswerWhereUniqueInput[]
    delete?: WhitelistAnswerWhereUniqueInput | WhitelistAnswerWhereUniqueInput[]
    connect?: WhitelistAnswerWhereUniqueInput | WhitelistAnswerWhereUniqueInput[]
    update?: WhitelistAnswerUpdateWithWhereUniqueWithoutQuestionInput | WhitelistAnswerUpdateWithWhereUniqueWithoutQuestionInput[]
    updateMany?: WhitelistAnswerUpdateManyWithWhereWithoutQuestionInput | WhitelistAnswerUpdateManyWithWhereWithoutQuestionInput[]
    deleteMany?: WhitelistAnswerScalarWhereInput | WhitelistAnswerScalarWhereInput[]
  }

  export type WhitelistAnswerUncheckedUpdateManyWithoutQuestionNestedInput = {
    create?: XOR<WhitelistAnswerCreateWithoutQuestionInput, WhitelistAnswerUncheckedCreateWithoutQuestionInput> | WhitelistAnswerCreateWithoutQuestionInput[] | WhitelistAnswerUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: WhitelistAnswerCreateOrConnectWithoutQuestionInput | WhitelistAnswerCreateOrConnectWithoutQuestionInput[]
    upsert?: WhitelistAnswerUpsertWithWhereUniqueWithoutQuestionInput | WhitelistAnswerUpsertWithWhereUniqueWithoutQuestionInput[]
    createMany?: WhitelistAnswerCreateManyQuestionInputEnvelope
    set?: WhitelistAnswerWhereUniqueInput | WhitelistAnswerWhereUniqueInput[]
    disconnect?: WhitelistAnswerWhereUniqueInput | WhitelistAnswerWhereUniqueInput[]
    delete?: WhitelistAnswerWhereUniqueInput | WhitelistAnswerWhereUniqueInput[]
    connect?: WhitelistAnswerWhereUniqueInput | WhitelistAnswerWhereUniqueInput[]
    update?: WhitelistAnswerUpdateWithWhereUniqueWithoutQuestionInput | WhitelistAnswerUpdateWithWhereUniqueWithoutQuestionInput[]
    updateMany?: WhitelistAnswerUpdateManyWithWhereWithoutQuestionInput | WhitelistAnswerUpdateManyWithWhereWithoutQuestionInput[]
    deleteMany?: WhitelistAnswerScalarWhereInput | WhitelistAnswerScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutWhitelistAppsInput = {
    create?: XOR<UserCreateWithoutWhitelistAppsInput, UserUncheckedCreateWithoutWhitelistAppsInput>
    connectOrCreate?: UserCreateOrConnectWithoutWhitelistAppsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutReviewedWhitelistsInput = {
    create?: XOR<UserCreateWithoutReviewedWhitelistsInput, UserUncheckedCreateWithoutReviewedWhitelistsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReviewedWhitelistsInput
    connect?: UserWhereUniqueInput
  }

  export type WhitelistAnswerCreateNestedManyWithoutApplicationInput = {
    create?: XOR<WhitelistAnswerCreateWithoutApplicationInput, WhitelistAnswerUncheckedCreateWithoutApplicationInput> | WhitelistAnswerCreateWithoutApplicationInput[] | WhitelistAnswerUncheckedCreateWithoutApplicationInput[]
    connectOrCreate?: WhitelistAnswerCreateOrConnectWithoutApplicationInput | WhitelistAnswerCreateOrConnectWithoutApplicationInput[]
    createMany?: WhitelistAnswerCreateManyApplicationInputEnvelope
    connect?: WhitelistAnswerWhereUniqueInput | WhitelistAnswerWhereUniqueInput[]
  }

  export type WhitelistAnswerUncheckedCreateNestedManyWithoutApplicationInput = {
    create?: XOR<WhitelistAnswerCreateWithoutApplicationInput, WhitelistAnswerUncheckedCreateWithoutApplicationInput> | WhitelistAnswerCreateWithoutApplicationInput[] | WhitelistAnswerUncheckedCreateWithoutApplicationInput[]
    connectOrCreate?: WhitelistAnswerCreateOrConnectWithoutApplicationInput | WhitelistAnswerCreateOrConnectWithoutApplicationInput[]
    createMany?: WhitelistAnswerCreateManyApplicationInputEnvelope
    connect?: WhitelistAnswerWhereUniqueInput | WhitelistAnswerWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutWhitelistAppsNestedInput = {
    create?: XOR<UserCreateWithoutWhitelistAppsInput, UserUncheckedCreateWithoutWhitelistAppsInput>
    connectOrCreate?: UserCreateOrConnectWithoutWhitelistAppsInput
    upsert?: UserUpsertWithoutWhitelistAppsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutWhitelistAppsInput, UserUpdateWithoutWhitelistAppsInput>, UserUncheckedUpdateWithoutWhitelistAppsInput>
  }

  export type UserUpdateOneWithoutReviewedWhitelistsNestedInput = {
    create?: XOR<UserCreateWithoutReviewedWhitelistsInput, UserUncheckedCreateWithoutReviewedWhitelistsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReviewedWhitelistsInput
    upsert?: UserUpsertWithoutReviewedWhitelistsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReviewedWhitelistsInput, UserUpdateWithoutReviewedWhitelistsInput>, UserUncheckedUpdateWithoutReviewedWhitelistsInput>
  }

  export type WhitelistAnswerUpdateManyWithoutApplicationNestedInput = {
    create?: XOR<WhitelistAnswerCreateWithoutApplicationInput, WhitelistAnswerUncheckedCreateWithoutApplicationInput> | WhitelistAnswerCreateWithoutApplicationInput[] | WhitelistAnswerUncheckedCreateWithoutApplicationInput[]
    connectOrCreate?: WhitelistAnswerCreateOrConnectWithoutApplicationInput | WhitelistAnswerCreateOrConnectWithoutApplicationInput[]
    upsert?: WhitelistAnswerUpsertWithWhereUniqueWithoutApplicationInput | WhitelistAnswerUpsertWithWhereUniqueWithoutApplicationInput[]
    createMany?: WhitelistAnswerCreateManyApplicationInputEnvelope
    set?: WhitelistAnswerWhereUniqueInput | WhitelistAnswerWhereUniqueInput[]
    disconnect?: WhitelistAnswerWhereUniqueInput | WhitelistAnswerWhereUniqueInput[]
    delete?: WhitelistAnswerWhereUniqueInput | WhitelistAnswerWhereUniqueInput[]
    connect?: WhitelistAnswerWhereUniqueInput | WhitelistAnswerWhereUniqueInput[]
    update?: WhitelistAnswerUpdateWithWhereUniqueWithoutApplicationInput | WhitelistAnswerUpdateWithWhereUniqueWithoutApplicationInput[]
    updateMany?: WhitelistAnswerUpdateManyWithWhereWithoutApplicationInput | WhitelistAnswerUpdateManyWithWhereWithoutApplicationInput[]
    deleteMany?: WhitelistAnswerScalarWhereInput | WhitelistAnswerScalarWhereInput[]
  }

  export type WhitelistAnswerUncheckedUpdateManyWithoutApplicationNestedInput = {
    create?: XOR<WhitelistAnswerCreateWithoutApplicationInput, WhitelistAnswerUncheckedCreateWithoutApplicationInput> | WhitelistAnswerCreateWithoutApplicationInput[] | WhitelistAnswerUncheckedCreateWithoutApplicationInput[]
    connectOrCreate?: WhitelistAnswerCreateOrConnectWithoutApplicationInput | WhitelistAnswerCreateOrConnectWithoutApplicationInput[]
    upsert?: WhitelistAnswerUpsertWithWhereUniqueWithoutApplicationInput | WhitelistAnswerUpsertWithWhereUniqueWithoutApplicationInput[]
    createMany?: WhitelistAnswerCreateManyApplicationInputEnvelope
    set?: WhitelistAnswerWhereUniqueInput | WhitelistAnswerWhereUniqueInput[]
    disconnect?: WhitelistAnswerWhereUniqueInput | WhitelistAnswerWhereUniqueInput[]
    delete?: WhitelistAnswerWhereUniqueInput | WhitelistAnswerWhereUniqueInput[]
    connect?: WhitelistAnswerWhereUniqueInput | WhitelistAnswerWhereUniqueInput[]
    update?: WhitelistAnswerUpdateWithWhereUniqueWithoutApplicationInput | WhitelistAnswerUpdateWithWhereUniqueWithoutApplicationInput[]
    updateMany?: WhitelistAnswerUpdateManyWithWhereWithoutApplicationInput | WhitelistAnswerUpdateManyWithWhereWithoutApplicationInput[]
    deleteMany?: WhitelistAnswerScalarWhereInput | WhitelistAnswerScalarWhereInput[]
  }

  export type WhitelistApplicationCreateNestedOneWithoutAnswersInput = {
    create?: XOR<WhitelistApplicationCreateWithoutAnswersInput, WhitelistApplicationUncheckedCreateWithoutAnswersInput>
    connectOrCreate?: WhitelistApplicationCreateOrConnectWithoutAnswersInput
    connect?: WhitelistApplicationWhereUniqueInput
  }

  export type WhitelistQuestionCreateNestedOneWithoutAnswersInput = {
    create?: XOR<WhitelistQuestionCreateWithoutAnswersInput, WhitelistQuestionUncheckedCreateWithoutAnswersInput>
    connectOrCreate?: WhitelistQuestionCreateOrConnectWithoutAnswersInput
    connect?: WhitelistQuestionWhereUniqueInput
  }

  export type WhitelistApplicationUpdateOneRequiredWithoutAnswersNestedInput = {
    create?: XOR<WhitelistApplicationCreateWithoutAnswersInput, WhitelistApplicationUncheckedCreateWithoutAnswersInput>
    connectOrCreate?: WhitelistApplicationCreateOrConnectWithoutAnswersInput
    upsert?: WhitelistApplicationUpsertWithoutAnswersInput
    connect?: WhitelistApplicationWhereUniqueInput
    update?: XOR<XOR<WhitelistApplicationUpdateToOneWithWhereWithoutAnswersInput, WhitelistApplicationUpdateWithoutAnswersInput>, WhitelistApplicationUncheckedUpdateWithoutAnswersInput>
  }

  export type WhitelistQuestionUpdateOneRequiredWithoutAnswersNestedInput = {
    create?: XOR<WhitelistQuestionCreateWithoutAnswersInput, WhitelistQuestionUncheckedCreateWithoutAnswersInput>
    connectOrCreate?: WhitelistQuestionCreateOrConnectWithoutAnswersInput
    upsert?: WhitelistQuestionUpsertWithoutAnswersInput
    connect?: WhitelistQuestionWhereUniqueInput
    update?: XOR<XOR<WhitelistQuestionUpdateToOneWithWhereWithoutAnswersInput, WhitelistQuestionUpdateWithoutAnswersInput>, WhitelistQuestionUncheckedUpdateWithoutAnswersInput>
  }

  export type UserBadgeCreateNestedManyWithoutBadgeInput = {
    create?: XOR<UserBadgeCreateWithoutBadgeInput, UserBadgeUncheckedCreateWithoutBadgeInput> | UserBadgeCreateWithoutBadgeInput[] | UserBadgeUncheckedCreateWithoutBadgeInput[]
    connectOrCreate?: UserBadgeCreateOrConnectWithoutBadgeInput | UserBadgeCreateOrConnectWithoutBadgeInput[]
    createMany?: UserBadgeCreateManyBadgeInputEnvelope
    connect?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
  }

  export type UserBadgeUncheckedCreateNestedManyWithoutBadgeInput = {
    create?: XOR<UserBadgeCreateWithoutBadgeInput, UserBadgeUncheckedCreateWithoutBadgeInput> | UserBadgeCreateWithoutBadgeInput[] | UserBadgeUncheckedCreateWithoutBadgeInput[]
    connectOrCreate?: UserBadgeCreateOrConnectWithoutBadgeInput | UserBadgeCreateOrConnectWithoutBadgeInput[]
    createMany?: UserBadgeCreateManyBadgeInputEnvelope
    connect?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
  }

  export type UserBadgeUpdateManyWithoutBadgeNestedInput = {
    create?: XOR<UserBadgeCreateWithoutBadgeInput, UserBadgeUncheckedCreateWithoutBadgeInput> | UserBadgeCreateWithoutBadgeInput[] | UserBadgeUncheckedCreateWithoutBadgeInput[]
    connectOrCreate?: UserBadgeCreateOrConnectWithoutBadgeInput | UserBadgeCreateOrConnectWithoutBadgeInput[]
    upsert?: UserBadgeUpsertWithWhereUniqueWithoutBadgeInput | UserBadgeUpsertWithWhereUniqueWithoutBadgeInput[]
    createMany?: UserBadgeCreateManyBadgeInputEnvelope
    set?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
    disconnect?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
    delete?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
    connect?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
    update?: UserBadgeUpdateWithWhereUniqueWithoutBadgeInput | UserBadgeUpdateWithWhereUniqueWithoutBadgeInput[]
    updateMany?: UserBadgeUpdateManyWithWhereWithoutBadgeInput | UserBadgeUpdateManyWithWhereWithoutBadgeInput[]
    deleteMany?: UserBadgeScalarWhereInput | UserBadgeScalarWhereInput[]
  }

  export type UserBadgeUncheckedUpdateManyWithoutBadgeNestedInput = {
    create?: XOR<UserBadgeCreateWithoutBadgeInput, UserBadgeUncheckedCreateWithoutBadgeInput> | UserBadgeCreateWithoutBadgeInput[] | UserBadgeUncheckedCreateWithoutBadgeInput[]
    connectOrCreate?: UserBadgeCreateOrConnectWithoutBadgeInput | UserBadgeCreateOrConnectWithoutBadgeInput[]
    upsert?: UserBadgeUpsertWithWhereUniqueWithoutBadgeInput | UserBadgeUpsertWithWhereUniqueWithoutBadgeInput[]
    createMany?: UserBadgeCreateManyBadgeInputEnvelope
    set?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
    disconnect?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
    delete?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
    connect?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
    update?: UserBadgeUpdateWithWhereUniqueWithoutBadgeInput | UserBadgeUpdateWithWhereUniqueWithoutBadgeInput[]
    updateMany?: UserBadgeUpdateManyWithWhereWithoutBadgeInput | UserBadgeUpdateManyWithWhereWithoutBadgeInput[]
    deleteMany?: UserBadgeScalarWhereInput | UserBadgeScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutUserBadgesInput = {
    create?: XOR<UserCreateWithoutUserBadgesInput, UserUncheckedCreateWithoutUserBadgesInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserBadgesInput
    connect?: UserWhereUniqueInput
  }

  export type BadgeCreateNestedOneWithoutUsersInput = {
    create?: XOR<BadgeCreateWithoutUsersInput, BadgeUncheckedCreateWithoutUsersInput>
    connectOrCreate?: BadgeCreateOrConnectWithoutUsersInput
    connect?: BadgeWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutUserBadgesNestedInput = {
    create?: XOR<UserCreateWithoutUserBadgesInput, UserUncheckedCreateWithoutUserBadgesInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserBadgesInput
    upsert?: UserUpsertWithoutUserBadgesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUserBadgesInput, UserUpdateWithoutUserBadgesInput>, UserUncheckedUpdateWithoutUserBadgesInput>
  }

  export type BadgeUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<BadgeCreateWithoutUsersInput, BadgeUncheckedCreateWithoutUsersInput>
    connectOrCreate?: BadgeCreateOrConnectWithoutUsersInput
    upsert?: BadgeUpsertWithoutUsersInput
    connect?: BadgeWhereUniqueInput
    update?: XOR<XOR<BadgeUpdateToOneWithWhereWithoutUsersInput, BadgeUpdateWithoutUsersInput>, BadgeUncheckedUpdateWithoutUsersInput>
  }

  export type ConversationParticipantCreateNestedManyWithoutConversationInput = {
    create?: XOR<ConversationParticipantCreateWithoutConversationInput, ConversationParticipantUncheckedCreateWithoutConversationInput> | ConversationParticipantCreateWithoutConversationInput[] | ConversationParticipantUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: ConversationParticipantCreateOrConnectWithoutConversationInput | ConversationParticipantCreateOrConnectWithoutConversationInput[]
    createMany?: ConversationParticipantCreateManyConversationInputEnvelope
    connect?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
  }

  export type DirectMessageCreateNestedManyWithoutConversationInput = {
    create?: XOR<DirectMessageCreateWithoutConversationInput, DirectMessageUncheckedCreateWithoutConversationInput> | DirectMessageCreateWithoutConversationInput[] | DirectMessageUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: DirectMessageCreateOrConnectWithoutConversationInput | DirectMessageCreateOrConnectWithoutConversationInput[]
    createMany?: DirectMessageCreateManyConversationInputEnvelope
    connect?: DirectMessageWhereUniqueInput | DirectMessageWhereUniqueInput[]
  }

  export type ConversationParticipantUncheckedCreateNestedManyWithoutConversationInput = {
    create?: XOR<ConversationParticipantCreateWithoutConversationInput, ConversationParticipantUncheckedCreateWithoutConversationInput> | ConversationParticipantCreateWithoutConversationInput[] | ConversationParticipantUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: ConversationParticipantCreateOrConnectWithoutConversationInput | ConversationParticipantCreateOrConnectWithoutConversationInput[]
    createMany?: ConversationParticipantCreateManyConversationInputEnvelope
    connect?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
  }

  export type DirectMessageUncheckedCreateNestedManyWithoutConversationInput = {
    create?: XOR<DirectMessageCreateWithoutConversationInput, DirectMessageUncheckedCreateWithoutConversationInput> | DirectMessageCreateWithoutConversationInput[] | DirectMessageUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: DirectMessageCreateOrConnectWithoutConversationInput | DirectMessageCreateOrConnectWithoutConversationInput[]
    createMany?: DirectMessageCreateManyConversationInputEnvelope
    connect?: DirectMessageWhereUniqueInput | DirectMessageWhereUniqueInput[]
  }

  export type ConversationParticipantUpdateManyWithoutConversationNestedInput = {
    create?: XOR<ConversationParticipantCreateWithoutConversationInput, ConversationParticipantUncheckedCreateWithoutConversationInput> | ConversationParticipantCreateWithoutConversationInput[] | ConversationParticipantUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: ConversationParticipantCreateOrConnectWithoutConversationInput | ConversationParticipantCreateOrConnectWithoutConversationInput[]
    upsert?: ConversationParticipantUpsertWithWhereUniqueWithoutConversationInput | ConversationParticipantUpsertWithWhereUniqueWithoutConversationInput[]
    createMany?: ConversationParticipantCreateManyConversationInputEnvelope
    set?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
    disconnect?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
    delete?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
    connect?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
    update?: ConversationParticipantUpdateWithWhereUniqueWithoutConversationInput | ConversationParticipantUpdateWithWhereUniqueWithoutConversationInput[]
    updateMany?: ConversationParticipantUpdateManyWithWhereWithoutConversationInput | ConversationParticipantUpdateManyWithWhereWithoutConversationInput[]
    deleteMany?: ConversationParticipantScalarWhereInput | ConversationParticipantScalarWhereInput[]
  }

  export type DirectMessageUpdateManyWithoutConversationNestedInput = {
    create?: XOR<DirectMessageCreateWithoutConversationInput, DirectMessageUncheckedCreateWithoutConversationInput> | DirectMessageCreateWithoutConversationInput[] | DirectMessageUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: DirectMessageCreateOrConnectWithoutConversationInput | DirectMessageCreateOrConnectWithoutConversationInput[]
    upsert?: DirectMessageUpsertWithWhereUniqueWithoutConversationInput | DirectMessageUpsertWithWhereUniqueWithoutConversationInput[]
    createMany?: DirectMessageCreateManyConversationInputEnvelope
    set?: DirectMessageWhereUniqueInput | DirectMessageWhereUniqueInput[]
    disconnect?: DirectMessageWhereUniqueInput | DirectMessageWhereUniqueInput[]
    delete?: DirectMessageWhereUniqueInput | DirectMessageWhereUniqueInput[]
    connect?: DirectMessageWhereUniqueInput | DirectMessageWhereUniqueInput[]
    update?: DirectMessageUpdateWithWhereUniqueWithoutConversationInput | DirectMessageUpdateWithWhereUniqueWithoutConversationInput[]
    updateMany?: DirectMessageUpdateManyWithWhereWithoutConversationInput | DirectMessageUpdateManyWithWhereWithoutConversationInput[]
    deleteMany?: DirectMessageScalarWhereInput | DirectMessageScalarWhereInput[]
  }

  export type ConversationParticipantUncheckedUpdateManyWithoutConversationNestedInput = {
    create?: XOR<ConversationParticipantCreateWithoutConversationInput, ConversationParticipantUncheckedCreateWithoutConversationInput> | ConversationParticipantCreateWithoutConversationInput[] | ConversationParticipantUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: ConversationParticipantCreateOrConnectWithoutConversationInput | ConversationParticipantCreateOrConnectWithoutConversationInput[]
    upsert?: ConversationParticipantUpsertWithWhereUniqueWithoutConversationInput | ConversationParticipantUpsertWithWhereUniqueWithoutConversationInput[]
    createMany?: ConversationParticipantCreateManyConversationInputEnvelope
    set?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
    disconnect?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
    delete?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
    connect?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
    update?: ConversationParticipantUpdateWithWhereUniqueWithoutConversationInput | ConversationParticipantUpdateWithWhereUniqueWithoutConversationInput[]
    updateMany?: ConversationParticipantUpdateManyWithWhereWithoutConversationInput | ConversationParticipantUpdateManyWithWhereWithoutConversationInput[]
    deleteMany?: ConversationParticipantScalarWhereInput | ConversationParticipantScalarWhereInput[]
  }

  export type DirectMessageUncheckedUpdateManyWithoutConversationNestedInput = {
    create?: XOR<DirectMessageCreateWithoutConversationInput, DirectMessageUncheckedCreateWithoutConversationInput> | DirectMessageCreateWithoutConversationInput[] | DirectMessageUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: DirectMessageCreateOrConnectWithoutConversationInput | DirectMessageCreateOrConnectWithoutConversationInput[]
    upsert?: DirectMessageUpsertWithWhereUniqueWithoutConversationInput | DirectMessageUpsertWithWhereUniqueWithoutConversationInput[]
    createMany?: DirectMessageCreateManyConversationInputEnvelope
    set?: DirectMessageWhereUniqueInput | DirectMessageWhereUniqueInput[]
    disconnect?: DirectMessageWhereUniqueInput | DirectMessageWhereUniqueInput[]
    delete?: DirectMessageWhereUniqueInput | DirectMessageWhereUniqueInput[]
    connect?: DirectMessageWhereUniqueInput | DirectMessageWhereUniqueInput[]
    update?: DirectMessageUpdateWithWhereUniqueWithoutConversationInput | DirectMessageUpdateWithWhereUniqueWithoutConversationInput[]
    updateMany?: DirectMessageUpdateManyWithWhereWithoutConversationInput | DirectMessageUpdateManyWithWhereWithoutConversationInput[]
    deleteMany?: DirectMessageScalarWhereInput | DirectMessageScalarWhereInput[]
  }

  export type ConversationCreateNestedOneWithoutParticipantsInput = {
    create?: XOR<ConversationCreateWithoutParticipantsInput, ConversationUncheckedCreateWithoutParticipantsInput>
    connectOrCreate?: ConversationCreateOrConnectWithoutParticipantsInput
    connect?: ConversationWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutConvoPartsInput = {
    create?: XOR<UserCreateWithoutConvoPartsInput, UserUncheckedCreateWithoutConvoPartsInput>
    connectOrCreate?: UserCreateOrConnectWithoutConvoPartsInput
    connect?: UserWhereUniqueInput
  }

  export type ConversationUpdateOneRequiredWithoutParticipantsNestedInput = {
    create?: XOR<ConversationCreateWithoutParticipantsInput, ConversationUncheckedCreateWithoutParticipantsInput>
    connectOrCreate?: ConversationCreateOrConnectWithoutParticipantsInput
    upsert?: ConversationUpsertWithoutParticipantsInput
    connect?: ConversationWhereUniqueInput
    update?: XOR<XOR<ConversationUpdateToOneWithWhereWithoutParticipantsInput, ConversationUpdateWithoutParticipantsInput>, ConversationUncheckedUpdateWithoutParticipantsInput>
  }

  export type UserUpdateOneRequiredWithoutConvoPartsNestedInput = {
    create?: XOR<UserCreateWithoutConvoPartsInput, UserUncheckedCreateWithoutConvoPartsInput>
    connectOrCreate?: UserCreateOrConnectWithoutConvoPartsInput
    upsert?: UserUpsertWithoutConvoPartsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutConvoPartsInput, UserUpdateWithoutConvoPartsInput>, UserUncheckedUpdateWithoutConvoPartsInput>
  }

  export type ConversationCreateNestedOneWithoutMessagesInput = {
    create?: XOR<ConversationCreateWithoutMessagesInput, ConversationUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: ConversationCreateOrConnectWithoutMessagesInput
    connect?: ConversationWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutSentMessagesInput = {
    create?: XOR<UserCreateWithoutSentMessagesInput, UserUncheckedCreateWithoutSentMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSentMessagesInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutReceivedMessagesInput = {
    create?: XOR<UserCreateWithoutReceivedMessagesInput, UserUncheckedCreateWithoutReceivedMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutReceivedMessagesInput
    connect?: UserWhereUniqueInput
  }

  export type ConversationUpdateOneRequiredWithoutMessagesNestedInput = {
    create?: XOR<ConversationCreateWithoutMessagesInput, ConversationUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: ConversationCreateOrConnectWithoutMessagesInput
    upsert?: ConversationUpsertWithoutMessagesInput
    connect?: ConversationWhereUniqueInput
    update?: XOR<XOR<ConversationUpdateToOneWithWhereWithoutMessagesInput, ConversationUpdateWithoutMessagesInput>, ConversationUncheckedUpdateWithoutMessagesInput>
  }

  export type UserUpdateOneRequiredWithoutSentMessagesNestedInput = {
    create?: XOR<UserCreateWithoutSentMessagesInput, UserUncheckedCreateWithoutSentMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSentMessagesInput
    upsert?: UserUpsertWithoutSentMessagesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSentMessagesInput, UserUpdateWithoutSentMessagesInput>, UserUncheckedUpdateWithoutSentMessagesInput>
  }

  export type UserUpdateOneRequiredWithoutReceivedMessagesNestedInput = {
    create?: XOR<UserCreateWithoutReceivedMessagesInput, UserUncheckedCreateWithoutReceivedMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutReceivedMessagesInput
    upsert?: UserUpsertWithoutReceivedMessagesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReceivedMessagesInput, UserUpdateWithoutReceivedMessagesInput>, UserUncheckedUpdateWithoutReceivedMessagesInput>
  }

  export type UserCreateNestedOneWithoutGameAccountsInput = {
    create?: XOR<UserCreateWithoutGameAccountsInput, UserUncheckedCreateWithoutGameAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutGameAccountsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutGameAccountsNestedInput = {
    create?: XOR<UserCreateWithoutGameAccountsInput, UserUncheckedCreateWithoutGameAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutGameAccountsInput
    upsert?: UserUpsertWithoutGameAccountsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutGameAccountsInput, UserUpdateWithoutGameAccountsInput>, UserUncheckedUpdateWithoutGameAccountsInput>
  }

  export type TicketCreateNestedOneWithoutParticipantsInput = {
    create?: XOR<TicketCreateWithoutParticipantsInput, TicketUncheckedCreateWithoutParticipantsInput>
    connectOrCreate?: TicketCreateOrConnectWithoutParticipantsInput
    connect?: TicketWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutTicketParticipantsInput = {
    create?: XOR<UserCreateWithoutTicketParticipantsInput, UserUncheckedCreateWithoutTicketParticipantsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTicketParticipantsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutTicketParticipantsAddedInput = {
    create?: XOR<UserCreateWithoutTicketParticipantsAddedInput, UserUncheckedCreateWithoutTicketParticipantsAddedInput>
    connectOrCreate?: UserCreateOrConnectWithoutTicketParticipantsAddedInput
    connect?: UserWhereUniqueInput
  }

  export type TicketUpdateOneRequiredWithoutParticipantsNestedInput = {
    create?: XOR<TicketCreateWithoutParticipantsInput, TicketUncheckedCreateWithoutParticipantsInput>
    connectOrCreate?: TicketCreateOrConnectWithoutParticipantsInput
    upsert?: TicketUpsertWithoutParticipantsInput
    connect?: TicketWhereUniqueInput
    update?: XOR<XOR<TicketUpdateToOneWithWhereWithoutParticipantsInput, TicketUpdateWithoutParticipantsInput>, TicketUncheckedUpdateWithoutParticipantsInput>
  }

  export type UserUpdateOneRequiredWithoutTicketParticipantsNestedInput = {
    create?: XOR<UserCreateWithoutTicketParticipantsInput, UserUncheckedCreateWithoutTicketParticipantsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTicketParticipantsInput
    upsert?: UserUpsertWithoutTicketParticipantsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTicketParticipantsInput, UserUpdateWithoutTicketParticipantsInput>, UserUncheckedUpdateWithoutTicketParticipantsInput>
  }

  export type UserUpdateOneWithoutTicketParticipantsAddedNestedInput = {
    create?: XOR<UserCreateWithoutTicketParticipantsAddedInput, UserUncheckedCreateWithoutTicketParticipantsAddedInput>
    connectOrCreate?: UserCreateOrConnectWithoutTicketParticipantsAddedInput
    upsert?: UserUpsertWithoutTicketParticipantsAddedInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTicketParticipantsAddedInput, UserUpdateWithoutTicketParticipantsAddedInput>, UserUncheckedUpdateWithoutTicketParticipantsAddedInput>
  }

  export type TicketCreateNestedOneWithoutRatingsInput = {
    create?: XOR<TicketCreateWithoutRatingsInput, TicketUncheckedCreateWithoutRatingsInput>
    connectOrCreate?: TicketCreateOrConnectWithoutRatingsInput
    connect?: TicketWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutTicketRatingsGivenInput = {
    create?: XOR<UserCreateWithoutTicketRatingsGivenInput, UserUncheckedCreateWithoutTicketRatingsGivenInput>
    connectOrCreate?: UserCreateOrConnectWithoutTicketRatingsGivenInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutTicketRatingsReceivedInput = {
    create?: XOR<UserCreateWithoutTicketRatingsReceivedInput, UserUncheckedCreateWithoutTicketRatingsReceivedInput>
    connectOrCreate?: UserCreateOrConnectWithoutTicketRatingsReceivedInput
    connect?: UserWhereUniqueInput
  }

  export type TicketUpdateOneRequiredWithoutRatingsNestedInput = {
    create?: XOR<TicketCreateWithoutRatingsInput, TicketUncheckedCreateWithoutRatingsInput>
    connectOrCreate?: TicketCreateOrConnectWithoutRatingsInput
    upsert?: TicketUpsertWithoutRatingsInput
    connect?: TicketWhereUniqueInput
    update?: XOR<XOR<TicketUpdateToOneWithWhereWithoutRatingsInput, TicketUpdateWithoutRatingsInput>, TicketUncheckedUpdateWithoutRatingsInput>
  }

  export type UserUpdateOneRequiredWithoutTicketRatingsGivenNestedInput = {
    create?: XOR<UserCreateWithoutTicketRatingsGivenInput, UserUncheckedCreateWithoutTicketRatingsGivenInput>
    connectOrCreate?: UserCreateOrConnectWithoutTicketRatingsGivenInput
    upsert?: UserUpsertWithoutTicketRatingsGivenInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTicketRatingsGivenInput, UserUpdateWithoutTicketRatingsGivenInput>, UserUncheckedUpdateWithoutTicketRatingsGivenInput>
  }

  export type UserUpdateOneRequiredWithoutTicketRatingsReceivedNestedInput = {
    create?: XOR<UserCreateWithoutTicketRatingsReceivedInput, UserUncheckedCreateWithoutTicketRatingsReceivedInput>
    connectOrCreate?: UserCreateOrConnectWithoutTicketRatingsReceivedInput
    upsert?: UserUpsertWithoutTicketRatingsReceivedInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTicketRatingsReceivedInput, UserUpdateWithoutTicketRatingsReceivedInput>, UserUncheckedUpdateWithoutTicketRatingsReceivedInput>
  }

  export type UserCreateNestedOneWithoutMtaAccessLogsInput = {
    create?: XOR<UserCreateWithoutMtaAccessLogsInput, UserUncheckedCreateWithoutMtaAccessLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutMtaAccessLogsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneWithoutMtaAccessLogsNestedInput = {
    create?: XOR<UserCreateWithoutMtaAccessLogsInput, UserUncheckedCreateWithoutMtaAccessLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutMtaAccessLogsInput
    upsert?: UserUpsertWithoutMtaAccessLogsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMtaAccessLogsInput, UserUpdateWithoutMtaAccessLogsInput>, UserUncheckedUpdateWithoutMtaAccessLogsInput>
  }

  export type TicketCreateNestedOneWithoutRatingRequirementsInput = {
    create?: XOR<TicketCreateWithoutRatingRequirementsInput, TicketUncheckedCreateWithoutRatingRequirementsInput>
    connectOrCreate?: TicketCreateOrConnectWithoutRatingRequirementsInput
    connect?: TicketWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutTicketRatingReqGivenInput = {
    create?: XOR<UserCreateWithoutTicketRatingReqGivenInput, UserUncheckedCreateWithoutTicketRatingReqGivenInput>
    connectOrCreate?: UserCreateOrConnectWithoutTicketRatingReqGivenInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutTicketRatingReqReceivedInput = {
    create?: XOR<UserCreateWithoutTicketRatingReqReceivedInput, UserUncheckedCreateWithoutTicketRatingReqReceivedInput>
    connectOrCreate?: UserCreateOrConnectWithoutTicketRatingReqReceivedInput
    connect?: UserWhereUniqueInput
  }

  export type TicketUpdateOneRequiredWithoutRatingRequirementsNestedInput = {
    create?: XOR<TicketCreateWithoutRatingRequirementsInput, TicketUncheckedCreateWithoutRatingRequirementsInput>
    connectOrCreate?: TicketCreateOrConnectWithoutRatingRequirementsInput
    upsert?: TicketUpsertWithoutRatingRequirementsInput
    connect?: TicketWhereUniqueInput
    update?: XOR<XOR<TicketUpdateToOneWithWhereWithoutRatingRequirementsInput, TicketUpdateWithoutRatingRequirementsInput>, TicketUncheckedUpdateWithoutRatingRequirementsInput>
  }

  export type UserUpdateOneRequiredWithoutTicketRatingReqGivenNestedInput = {
    create?: XOR<UserCreateWithoutTicketRatingReqGivenInput, UserUncheckedCreateWithoutTicketRatingReqGivenInput>
    connectOrCreate?: UserCreateOrConnectWithoutTicketRatingReqGivenInput
    upsert?: UserUpsertWithoutTicketRatingReqGivenInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTicketRatingReqGivenInput, UserUpdateWithoutTicketRatingReqGivenInput>, UserUncheckedUpdateWithoutTicketRatingReqGivenInput>
  }

  export type UserUpdateOneRequiredWithoutTicketRatingReqReceivedNestedInput = {
    create?: XOR<UserCreateWithoutTicketRatingReqReceivedInput, UserUncheckedCreateWithoutTicketRatingReqReceivedInput>
    connectOrCreate?: UserCreateOrConnectWithoutTicketRatingReqReceivedInput
    upsert?: UserUpsertWithoutTicketRatingReqReceivedInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTicketRatingReqReceivedInput, UserUpdateWithoutTicketRatingReqReceivedInput>, UserUncheckedUpdateWithoutTicketRatingReqReceivedInput>
  }

  export type UserCreateNestedOneWithoutPasswordResetTokensInput = {
    create?: XOR<UserCreateWithoutPasswordResetTokensInput, UserUncheckedCreateWithoutPasswordResetTokensInput>
    connectOrCreate?: UserCreateOrConnectWithoutPasswordResetTokensInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutPasswordResetTokensNestedInput = {
    create?: XOR<UserCreateWithoutPasswordResetTokensInput, UserUncheckedCreateWithoutPasswordResetTokensInput>
    connectOrCreate?: UserCreateOrConnectWithoutPasswordResetTokensInput
    upsert?: UserUpsertWithoutPasswordResetTokensInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPasswordResetTokensInput, UserUpdateWithoutPasswordResetTokensInput>, UserUncheckedUpdateWithoutPasswordResetTokensInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type PurchaseItemCreateWithoutProductInput = {
    id?: string
    sku: string
    name: string
    priceCents: number
    durationDays?: number | null
    grantPoints?: number
    grantVipRole?: string | null
    mtaActions?: string | null
    purchase: PurchaseCreateNestedOneWithoutItemsInput
  }

  export type PurchaseItemUncheckedCreateWithoutProductInput = {
    id?: string
    purchaseId: string
    sku: string
    name: string
    priceCents: number
    durationDays?: number | null
    grantPoints?: number
    grantVipRole?: string | null
    mtaActions?: string | null
  }

  export type PurchaseItemCreateOrConnectWithoutProductInput = {
    where: PurchaseItemWhereUniqueInput
    create: XOR<PurchaseItemCreateWithoutProductInput, PurchaseItemUncheckedCreateWithoutProductInput>
  }

  export type PurchaseItemCreateManyProductInputEnvelope = {
    data: PurchaseItemCreateManyProductInput | PurchaseItemCreateManyProductInput[]
  }

  export type PurchaseItemUpsertWithWhereUniqueWithoutProductInput = {
    where: PurchaseItemWhereUniqueInput
    update: XOR<PurchaseItemUpdateWithoutProductInput, PurchaseItemUncheckedUpdateWithoutProductInput>
    create: XOR<PurchaseItemCreateWithoutProductInput, PurchaseItemUncheckedCreateWithoutProductInput>
  }

  export type PurchaseItemUpdateWithWhereUniqueWithoutProductInput = {
    where: PurchaseItemWhereUniqueInput
    data: XOR<PurchaseItemUpdateWithoutProductInput, PurchaseItemUncheckedUpdateWithoutProductInput>
  }

  export type PurchaseItemUpdateManyWithWhereWithoutProductInput = {
    where: PurchaseItemScalarWhereInput
    data: XOR<PurchaseItemUpdateManyMutationInput, PurchaseItemUncheckedUpdateManyWithoutProductInput>
  }

  export type PurchaseItemScalarWhereInput = {
    AND?: PurchaseItemScalarWhereInput | PurchaseItemScalarWhereInput[]
    OR?: PurchaseItemScalarWhereInput[]
    NOT?: PurchaseItemScalarWhereInput | PurchaseItemScalarWhereInput[]
    id?: StringFilter<"PurchaseItem"> | string
    purchaseId?: StringFilter<"PurchaseItem"> | string
    productId?: StringFilter<"PurchaseItem"> | string
    sku?: StringFilter<"PurchaseItem"> | string
    name?: StringFilter<"PurchaseItem"> | string
    priceCents?: IntFilter<"PurchaseItem"> | number
    durationDays?: IntNullableFilter<"PurchaseItem"> | number | null
    grantPoints?: IntFilter<"PurchaseItem"> | number
    grantVipRole?: StringNullableFilter<"PurchaseItem"> | string | null
    mtaActions?: StringNullableFilter<"PurchaseItem"> | string | null
  }

  export type PurchaseCreateWithoutItemsInput = {
    id?: string
    provider: string
    externalId?: string | null
    status?: string
    amountCents: number
    currency?: string
    meta?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPurchasesInput
  }

  export type PurchaseUncheckedCreateWithoutItemsInput = {
    id?: string
    userId: string
    provider: string
    externalId?: string | null
    status?: string
    amountCents: number
    currency?: string
    meta?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseCreateOrConnectWithoutItemsInput = {
    where: PurchaseWhereUniqueInput
    create: XOR<PurchaseCreateWithoutItemsInput, PurchaseUncheckedCreateWithoutItemsInput>
  }

  export type ProductCreateWithoutPurchaseItemsInput = {
    id?: string
    sku: string
    name: string
    description?: string | null
    priceCents: number
    currency?: string
    durationDays?: number | null
    grantPoints?: number
    grantVipRole?: string | null
    mtaActions?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductUncheckedCreateWithoutPurchaseItemsInput = {
    id?: string
    sku: string
    name: string
    description?: string | null
    priceCents: number
    currency?: string
    durationDays?: number | null
    grantPoints?: number
    grantVipRole?: string | null
    mtaActions?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductCreateOrConnectWithoutPurchaseItemsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutPurchaseItemsInput, ProductUncheckedCreateWithoutPurchaseItemsInput>
  }

  export type PurchaseUpsertWithoutItemsInput = {
    update: XOR<PurchaseUpdateWithoutItemsInput, PurchaseUncheckedUpdateWithoutItemsInput>
    create: XOR<PurchaseCreateWithoutItemsInput, PurchaseUncheckedCreateWithoutItemsInput>
    where?: PurchaseWhereInput
  }

  export type PurchaseUpdateToOneWithWhereWithoutItemsInput = {
    where?: PurchaseWhereInput
    data: XOR<PurchaseUpdateWithoutItemsInput, PurchaseUncheckedUpdateWithoutItemsInput>
  }

  export type PurchaseUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    amountCents?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    meta?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPurchasesNestedInput
  }

  export type PurchaseUncheckedUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    amountCents?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    meta?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUpsertWithoutPurchaseItemsInput = {
    update: XOR<ProductUpdateWithoutPurchaseItemsInput, ProductUncheckedUpdateWithoutPurchaseItemsInput>
    create: XOR<ProductCreateWithoutPurchaseItemsInput, ProductUncheckedCreateWithoutPurchaseItemsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutPurchaseItemsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutPurchaseItemsInput, ProductUncheckedUpdateWithoutPurchaseItemsInput>
  }

  export type ProductUpdateWithoutPurchaseItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priceCents?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    durationDays?: NullableIntFieldUpdateOperationsInput | number | null
    grantPoints?: IntFieldUpdateOperationsInput | number
    grantVipRole?: NullableStringFieldUpdateOperationsInput | string | null
    mtaActions?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUncheckedUpdateWithoutPurchaseItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priceCents?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    durationDays?: NullableIntFieldUpdateOperationsInput | number | null
    grantPoints?: IntFieldUpdateOperationsInput | number
    grantVipRole?: NullableStringFieldUpdateOperationsInput | string | null
    mtaActions?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutEntitlementsInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    emailVerifiedAt?: Date | string | null
    emailVerifyToken?: string | null
    emailVerifyExpiresAt?: Date | string | null
    phone?: string | null
    recoveryEmail?: string | null
    googleId?: string | null
    discordId?: string | null
    discordUsername?: string | null
    avatarKey?: string
    role?: string
    isDeleted?: boolean
    bannedUntil?: Date | string | null
    whitelistStatus?: string
    points?: number
    lastSeenAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    avatarUrl?: string | null
    topics?: TopicCreateNestedManyWithoutAuthorInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    tickets?: TicketCreateNestedManyWithoutAuthorInput
    assignedTickets?: TicketCreateNestedManyWithoutAssignedToInput
    ticketMsgs?: TicketMessageCreateNestedManyWithoutAuthorInput
    ticketParticipants?: TicketParticipantCreateNestedManyWithoutUserInput
    ticketParticipantsAdded?: TicketParticipantCreateNestedManyWithoutAddedByInput
    ticketRatingsGiven?: TicketRatingCreateNestedManyWithoutRaterInput
    ticketRatingsReceived?: TicketRatingCreateNestedManyWithoutTargetInput
    closedTickets?: TicketCreateNestedManyWithoutClosedByInput
    purchases?: PurchaseCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    whitelistApps?: WhitelistApplicationCreateNestedManyWithoutUserInput
    reviewedWhitelists?: WhitelistApplicationCreateNestedManyWithoutReviewerInput
    convoParts?: ConversationParticipantCreateNestedManyWithoutUserInput
    sentMessages?: DirectMessageCreateNestedManyWithoutSenderInput
    receivedMessages?: DirectMessageCreateNestedManyWithoutReceiverInput
    userBadges?: UserBadgeCreateNestedManyWithoutUserInput
    gameAccounts?: GameAccountCreateNestedManyWithoutUserInput
    mtaAccessLogs?: MtaAccessLogCreateNestedManyWithoutUserInput
    ticketRatingReqGiven?: TicketRatingRequirementCreateNestedManyWithoutRaterInput
    ticketRatingReqReceived?: TicketRatingRequirementCreateNestedManyWithoutTargetInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    staffShifts?: StaffShiftCreateNestedManyWithoutUserInput
    staffWeeklyRewards?: StaffWeeklyRewardCreateNestedManyWithoutUserInput
    adminCasesTarget?: AdminCaseCreateNestedManyWithoutTargetUserInput
    adminCasesStaff?: AdminCaseCreateNestedManyWithoutStaffUserInput
    reputation?: UserReputationCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutEntitlementsInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    emailVerifiedAt?: Date | string | null
    emailVerifyToken?: string | null
    emailVerifyExpiresAt?: Date | string | null
    phone?: string | null
    recoveryEmail?: string | null
    googleId?: string | null
    discordId?: string | null
    discordUsername?: string | null
    avatarKey?: string
    role?: string
    isDeleted?: boolean
    bannedUntil?: Date | string | null
    whitelistStatus?: string
    points?: number
    lastSeenAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    avatarUrl?: string | null
    topics?: TopicUncheckedCreateNestedManyWithoutAuthorInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    tickets?: TicketUncheckedCreateNestedManyWithoutAuthorInput
    assignedTickets?: TicketUncheckedCreateNestedManyWithoutAssignedToInput
    ticketMsgs?: TicketMessageUncheckedCreateNestedManyWithoutAuthorInput
    ticketParticipants?: TicketParticipantUncheckedCreateNestedManyWithoutUserInput
    ticketParticipantsAdded?: TicketParticipantUncheckedCreateNestedManyWithoutAddedByInput
    ticketRatingsGiven?: TicketRatingUncheckedCreateNestedManyWithoutRaterInput
    ticketRatingsReceived?: TicketRatingUncheckedCreateNestedManyWithoutTargetInput
    closedTickets?: TicketUncheckedCreateNestedManyWithoutClosedByInput
    purchases?: PurchaseUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    whitelistApps?: WhitelistApplicationUncheckedCreateNestedManyWithoutUserInput
    reviewedWhitelists?: WhitelistApplicationUncheckedCreateNestedManyWithoutReviewerInput
    convoParts?: ConversationParticipantUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: DirectMessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: DirectMessageUncheckedCreateNestedManyWithoutReceiverInput
    userBadges?: UserBadgeUncheckedCreateNestedManyWithoutUserInput
    gameAccounts?: GameAccountUncheckedCreateNestedManyWithoutUserInput
    mtaAccessLogs?: MtaAccessLogUncheckedCreateNestedManyWithoutUserInput
    ticketRatingReqGiven?: TicketRatingRequirementUncheckedCreateNestedManyWithoutRaterInput
    ticketRatingReqReceived?: TicketRatingRequirementUncheckedCreateNestedManyWithoutTargetInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    staffShifts?: StaffShiftUncheckedCreateNestedManyWithoutUserInput
    staffWeeklyRewards?: StaffWeeklyRewardUncheckedCreateNestedManyWithoutUserInput
    adminCasesTarget?: AdminCaseUncheckedCreateNestedManyWithoutTargetUserInput
    adminCasesStaff?: AdminCaseUncheckedCreateNestedManyWithoutStaffUserInput
    reputation?: UserReputationUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutEntitlementsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutEntitlementsInput, UserUncheckedCreateWithoutEntitlementsInput>
  }

  export type UserUpsertWithoutEntitlementsInput = {
    update: XOR<UserUpdateWithoutEntitlementsInput, UserUncheckedUpdateWithoutEntitlementsInput>
    create: XOR<UserCreateWithoutEntitlementsInput, UserUncheckedCreateWithoutEntitlementsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutEntitlementsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutEntitlementsInput, UserUncheckedUpdateWithoutEntitlementsInput>
  }

  export type UserUpdateWithoutEntitlementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifyToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerifyExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    discordId?: NullableStringFieldUpdateOperationsInput | string | null
    discordUsername?: NullableStringFieldUpdateOperationsInput | string | null
    avatarKey?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    bannedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    whitelistStatus?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    lastSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    topics?: TopicUpdateManyWithoutAuthorNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    tickets?: TicketUpdateManyWithoutAuthorNestedInput
    assignedTickets?: TicketUpdateManyWithoutAssignedToNestedInput
    ticketMsgs?: TicketMessageUpdateManyWithoutAuthorNestedInput
    ticketParticipants?: TicketParticipantUpdateManyWithoutUserNestedInput
    ticketParticipantsAdded?: TicketParticipantUpdateManyWithoutAddedByNestedInput
    ticketRatingsGiven?: TicketRatingUpdateManyWithoutRaterNestedInput
    ticketRatingsReceived?: TicketRatingUpdateManyWithoutTargetNestedInput
    closedTickets?: TicketUpdateManyWithoutClosedByNestedInput
    purchases?: PurchaseUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    whitelistApps?: WhitelistApplicationUpdateManyWithoutUserNestedInput
    reviewedWhitelists?: WhitelistApplicationUpdateManyWithoutReviewerNestedInput
    convoParts?: ConversationParticipantUpdateManyWithoutUserNestedInput
    sentMessages?: DirectMessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: DirectMessageUpdateManyWithoutReceiverNestedInput
    userBadges?: UserBadgeUpdateManyWithoutUserNestedInput
    gameAccounts?: GameAccountUpdateManyWithoutUserNestedInput
    mtaAccessLogs?: MtaAccessLogUpdateManyWithoutUserNestedInput
    ticketRatingReqGiven?: TicketRatingRequirementUpdateManyWithoutRaterNestedInput
    ticketRatingReqReceived?: TicketRatingRequirementUpdateManyWithoutTargetNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    staffShifts?: StaffShiftUpdateManyWithoutUserNestedInput
    staffWeeklyRewards?: StaffWeeklyRewardUpdateManyWithoutUserNestedInput
    adminCasesTarget?: AdminCaseUpdateManyWithoutTargetUserNestedInput
    adminCasesStaff?: AdminCaseUpdateManyWithoutStaffUserNestedInput
    reputation?: UserReputationUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutEntitlementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifyToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerifyExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    discordId?: NullableStringFieldUpdateOperationsInput | string | null
    discordUsername?: NullableStringFieldUpdateOperationsInput | string | null
    avatarKey?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    bannedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    whitelistStatus?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    lastSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    topics?: TopicUncheckedUpdateManyWithoutAuthorNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutAuthorNestedInput
    assignedTickets?: TicketUncheckedUpdateManyWithoutAssignedToNestedInput
    ticketMsgs?: TicketMessageUncheckedUpdateManyWithoutAuthorNestedInput
    ticketParticipants?: TicketParticipantUncheckedUpdateManyWithoutUserNestedInput
    ticketParticipantsAdded?: TicketParticipantUncheckedUpdateManyWithoutAddedByNestedInput
    ticketRatingsGiven?: TicketRatingUncheckedUpdateManyWithoutRaterNestedInput
    ticketRatingsReceived?: TicketRatingUncheckedUpdateManyWithoutTargetNestedInput
    closedTickets?: TicketUncheckedUpdateManyWithoutClosedByNestedInput
    purchases?: PurchaseUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    whitelistApps?: WhitelistApplicationUncheckedUpdateManyWithoutUserNestedInput
    reviewedWhitelists?: WhitelistApplicationUncheckedUpdateManyWithoutReviewerNestedInput
    convoParts?: ConversationParticipantUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: DirectMessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: DirectMessageUncheckedUpdateManyWithoutReceiverNestedInput
    userBadges?: UserBadgeUncheckedUpdateManyWithoutUserNestedInput
    gameAccounts?: GameAccountUncheckedUpdateManyWithoutUserNestedInput
    mtaAccessLogs?: MtaAccessLogUncheckedUpdateManyWithoutUserNestedInput
    ticketRatingReqGiven?: TicketRatingRequirementUncheckedUpdateManyWithoutRaterNestedInput
    ticketRatingReqReceived?: TicketRatingRequirementUncheckedUpdateManyWithoutTargetNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    staffShifts?: StaffShiftUncheckedUpdateManyWithoutUserNestedInput
    staffWeeklyRewards?: StaffWeeklyRewardUncheckedUpdateManyWithoutUserNestedInput
    adminCasesTarget?: AdminCaseUncheckedUpdateManyWithoutTargetUserNestedInput
    adminCasesStaff?: AdminCaseUncheckedUpdateManyWithoutStaffUserNestedInput
    reputation?: UserReputationUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserCreateWithoutNotificationsInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    emailVerifiedAt?: Date | string | null
    emailVerifyToken?: string | null
    emailVerifyExpiresAt?: Date | string | null
    phone?: string | null
    recoveryEmail?: string | null
    googleId?: string | null
    discordId?: string | null
    discordUsername?: string | null
    avatarKey?: string
    role?: string
    isDeleted?: boolean
    bannedUntil?: Date | string | null
    whitelistStatus?: string
    points?: number
    lastSeenAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    avatarUrl?: string | null
    topics?: TopicCreateNestedManyWithoutAuthorInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    tickets?: TicketCreateNestedManyWithoutAuthorInput
    assignedTickets?: TicketCreateNestedManyWithoutAssignedToInput
    ticketMsgs?: TicketMessageCreateNestedManyWithoutAuthorInput
    ticketParticipants?: TicketParticipantCreateNestedManyWithoutUserInput
    ticketParticipantsAdded?: TicketParticipantCreateNestedManyWithoutAddedByInput
    ticketRatingsGiven?: TicketRatingCreateNestedManyWithoutRaterInput
    ticketRatingsReceived?: TicketRatingCreateNestedManyWithoutTargetInput
    closedTickets?: TicketCreateNestedManyWithoutClosedByInput
    purchases?: PurchaseCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    whitelistApps?: WhitelistApplicationCreateNestedManyWithoutUserInput
    reviewedWhitelists?: WhitelistApplicationCreateNestedManyWithoutReviewerInput
    convoParts?: ConversationParticipantCreateNestedManyWithoutUserInput
    sentMessages?: DirectMessageCreateNestedManyWithoutSenderInput
    receivedMessages?: DirectMessageCreateNestedManyWithoutReceiverInput
    userBadges?: UserBadgeCreateNestedManyWithoutUserInput
    gameAccounts?: GameAccountCreateNestedManyWithoutUserInput
    mtaAccessLogs?: MtaAccessLogCreateNestedManyWithoutUserInput
    ticketRatingReqGiven?: TicketRatingRequirementCreateNestedManyWithoutRaterInput
    ticketRatingReqReceived?: TicketRatingRequirementCreateNestedManyWithoutTargetInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    entitlements?: EntitlementCreateNestedManyWithoutUserInput
    staffShifts?: StaffShiftCreateNestedManyWithoutUserInput
    staffWeeklyRewards?: StaffWeeklyRewardCreateNestedManyWithoutUserInput
    adminCasesTarget?: AdminCaseCreateNestedManyWithoutTargetUserInput
    adminCasesStaff?: AdminCaseCreateNestedManyWithoutStaffUserInput
    reputation?: UserReputationCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutNotificationsInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    emailVerifiedAt?: Date | string | null
    emailVerifyToken?: string | null
    emailVerifyExpiresAt?: Date | string | null
    phone?: string | null
    recoveryEmail?: string | null
    googleId?: string | null
    discordId?: string | null
    discordUsername?: string | null
    avatarKey?: string
    role?: string
    isDeleted?: boolean
    bannedUntil?: Date | string | null
    whitelistStatus?: string
    points?: number
    lastSeenAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    avatarUrl?: string | null
    topics?: TopicUncheckedCreateNestedManyWithoutAuthorInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    tickets?: TicketUncheckedCreateNestedManyWithoutAuthorInput
    assignedTickets?: TicketUncheckedCreateNestedManyWithoutAssignedToInput
    ticketMsgs?: TicketMessageUncheckedCreateNestedManyWithoutAuthorInput
    ticketParticipants?: TicketParticipantUncheckedCreateNestedManyWithoutUserInput
    ticketParticipantsAdded?: TicketParticipantUncheckedCreateNestedManyWithoutAddedByInput
    ticketRatingsGiven?: TicketRatingUncheckedCreateNestedManyWithoutRaterInput
    ticketRatingsReceived?: TicketRatingUncheckedCreateNestedManyWithoutTargetInput
    closedTickets?: TicketUncheckedCreateNestedManyWithoutClosedByInput
    purchases?: PurchaseUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    whitelistApps?: WhitelistApplicationUncheckedCreateNestedManyWithoutUserInput
    reviewedWhitelists?: WhitelistApplicationUncheckedCreateNestedManyWithoutReviewerInput
    convoParts?: ConversationParticipantUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: DirectMessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: DirectMessageUncheckedCreateNestedManyWithoutReceiverInput
    userBadges?: UserBadgeUncheckedCreateNestedManyWithoutUserInput
    gameAccounts?: GameAccountUncheckedCreateNestedManyWithoutUserInput
    mtaAccessLogs?: MtaAccessLogUncheckedCreateNestedManyWithoutUserInput
    ticketRatingReqGiven?: TicketRatingRequirementUncheckedCreateNestedManyWithoutRaterInput
    ticketRatingReqReceived?: TicketRatingRequirementUncheckedCreateNestedManyWithoutTargetInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    entitlements?: EntitlementUncheckedCreateNestedManyWithoutUserInput
    staffShifts?: StaffShiftUncheckedCreateNestedManyWithoutUserInput
    staffWeeklyRewards?: StaffWeeklyRewardUncheckedCreateNestedManyWithoutUserInput
    adminCasesTarget?: AdminCaseUncheckedCreateNestedManyWithoutTargetUserInput
    adminCasesStaff?: AdminCaseUncheckedCreateNestedManyWithoutStaffUserInput
    reputation?: UserReputationUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutNotificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
  }

  export type UserUpsertWithoutNotificationsInput = {
    update: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifyToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerifyExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    discordId?: NullableStringFieldUpdateOperationsInput | string | null
    discordUsername?: NullableStringFieldUpdateOperationsInput | string | null
    avatarKey?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    bannedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    whitelistStatus?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    lastSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    topics?: TopicUpdateManyWithoutAuthorNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    tickets?: TicketUpdateManyWithoutAuthorNestedInput
    assignedTickets?: TicketUpdateManyWithoutAssignedToNestedInput
    ticketMsgs?: TicketMessageUpdateManyWithoutAuthorNestedInput
    ticketParticipants?: TicketParticipantUpdateManyWithoutUserNestedInput
    ticketParticipantsAdded?: TicketParticipantUpdateManyWithoutAddedByNestedInput
    ticketRatingsGiven?: TicketRatingUpdateManyWithoutRaterNestedInput
    ticketRatingsReceived?: TicketRatingUpdateManyWithoutTargetNestedInput
    closedTickets?: TicketUpdateManyWithoutClosedByNestedInput
    purchases?: PurchaseUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    whitelistApps?: WhitelistApplicationUpdateManyWithoutUserNestedInput
    reviewedWhitelists?: WhitelistApplicationUpdateManyWithoutReviewerNestedInput
    convoParts?: ConversationParticipantUpdateManyWithoutUserNestedInput
    sentMessages?: DirectMessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: DirectMessageUpdateManyWithoutReceiverNestedInput
    userBadges?: UserBadgeUpdateManyWithoutUserNestedInput
    gameAccounts?: GameAccountUpdateManyWithoutUserNestedInput
    mtaAccessLogs?: MtaAccessLogUpdateManyWithoutUserNestedInput
    ticketRatingReqGiven?: TicketRatingRequirementUpdateManyWithoutRaterNestedInput
    ticketRatingReqReceived?: TicketRatingRequirementUpdateManyWithoutTargetNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    entitlements?: EntitlementUpdateManyWithoutUserNestedInput
    staffShifts?: StaffShiftUpdateManyWithoutUserNestedInput
    staffWeeklyRewards?: StaffWeeklyRewardUpdateManyWithoutUserNestedInput
    adminCasesTarget?: AdminCaseUpdateManyWithoutTargetUserNestedInput
    adminCasesStaff?: AdminCaseUpdateManyWithoutStaffUserNestedInput
    reputation?: UserReputationUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifyToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerifyExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    discordId?: NullableStringFieldUpdateOperationsInput | string | null
    discordUsername?: NullableStringFieldUpdateOperationsInput | string | null
    avatarKey?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    bannedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    whitelistStatus?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    lastSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    topics?: TopicUncheckedUpdateManyWithoutAuthorNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutAuthorNestedInput
    assignedTickets?: TicketUncheckedUpdateManyWithoutAssignedToNestedInput
    ticketMsgs?: TicketMessageUncheckedUpdateManyWithoutAuthorNestedInput
    ticketParticipants?: TicketParticipantUncheckedUpdateManyWithoutUserNestedInput
    ticketParticipantsAdded?: TicketParticipantUncheckedUpdateManyWithoutAddedByNestedInput
    ticketRatingsGiven?: TicketRatingUncheckedUpdateManyWithoutRaterNestedInput
    ticketRatingsReceived?: TicketRatingUncheckedUpdateManyWithoutTargetNestedInput
    closedTickets?: TicketUncheckedUpdateManyWithoutClosedByNestedInput
    purchases?: PurchaseUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    whitelistApps?: WhitelistApplicationUncheckedUpdateManyWithoutUserNestedInput
    reviewedWhitelists?: WhitelistApplicationUncheckedUpdateManyWithoutReviewerNestedInput
    convoParts?: ConversationParticipantUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: DirectMessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: DirectMessageUncheckedUpdateManyWithoutReceiverNestedInput
    userBadges?: UserBadgeUncheckedUpdateManyWithoutUserNestedInput
    gameAccounts?: GameAccountUncheckedUpdateManyWithoutUserNestedInput
    mtaAccessLogs?: MtaAccessLogUncheckedUpdateManyWithoutUserNestedInput
    ticketRatingReqGiven?: TicketRatingRequirementUncheckedUpdateManyWithoutRaterNestedInput
    ticketRatingReqReceived?: TicketRatingRequirementUncheckedUpdateManyWithoutTargetNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    entitlements?: EntitlementUncheckedUpdateManyWithoutUserNestedInput
    staffShifts?: StaffShiftUncheckedUpdateManyWithoutUserNestedInput
    staffWeeklyRewards?: StaffWeeklyRewardUncheckedUpdateManyWithoutUserNestedInput
    adminCasesTarget?: AdminCaseUncheckedUpdateManyWithoutTargetUserNestedInput
    adminCasesStaff?: AdminCaseUncheckedUpdateManyWithoutStaffUserNestedInput
    reputation?: UserReputationUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserCreateWithoutStaffShiftsInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    emailVerifiedAt?: Date | string | null
    emailVerifyToken?: string | null
    emailVerifyExpiresAt?: Date | string | null
    phone?: string | null
    recoveryEmail?: string | null
    googleId?: string | null
    discordId?: string | null
    discordUsername?: string | null
    avatarKey?: string
    role?: string
    isDeleted?: boolean
    bannedUntil?: Date | string | null
    whitelistStatus?: string
    points?: number
    lastSeenAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    avatarUrl?: string | null
    topics?: TopicCreateNestedManyWithoutAuthorInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    tickets?: TicketCreateNestedManyWithoutAuthorInput
    assignedTickets?: TicketCreateNestedManyWithoutAssignedToInput
    ticketMsgs?: TicketMessageCreateNestedManyWithoutAuthorInput
    ticketParticipants?: TicketParticipantCreateNestedManyWithoutUserInput
    ticketParticipantsAdded?: TicketParticipantCreateNestedManyWithoutAddedByInput
    ticketRatingsGiven?: TicketRatingCreateNestedManyWithoutRaterInput
    ticketRatingsReceived?: TicketRatingCreateNestedManyWithoutTargetInput
    closedTickets?: TicketCreateNestedManyWithoutClosedByInput
    purchases?: PurchaseCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    whitelistApps?: WhitelistApplicationCreateNestedManyWithoutUserInput
    reviewedWhitelists?: WhitelistApplicationCreateNestedManyWithoutReviewerInput
    convoParts?: ConversationParticipantCreateNestedManyWithoutUserInput
    sentMessages?: DirectMessageCreateNestedManyWithoutSenderInput
    receivedMessages?: DirectMessageCreateNestedManyWithoutReceiverInput
    userBadges?: UserBadgeCreateNestedManyWithoutUserInput
    gameAccounts?: GameAccountCreateNestedManyWithoutUserInput
    mtaAccessLogs?: MtaAccessLogCreateNestedManyWithoutUserInput
    ticketRatingReqGiven?: TicketRatingRequirementCreateNestedManyWithoutRaterInput
    ticketRatingReqReceived?: TicketRatingRequirementCreateNestedManyWithoutTargetInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    entitlements?: EntitlementCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    staffWeeklyRewards?: StaffWeeklyRewardCreateNestedManyWithoutUserInput
    adminCasesTarget?: AdminCaseCreateNestedManyWithoutTargetUserInput
    adminCasesStaff?: AdminCaseCreateNestedManyWithoutStaffUserInput
    reputation?: UserReputationCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutStaffShiftsInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    emailVerifiedAt?: Date | string | null
    emailVerifyToken?: string | null
    emailVerifyExpiresAt?: Date | string | null
    phone?: string | null
    recoveryEmail?: string | null
    googleId?: string | null
    discordId?: string | null
    discordUsername?: string | null
    avatarKey?: string
    role?: string
    isDeleted?: boolean
    bannedUntil?: Date | string | null
    whitelistStatus?: string
    points?: number
    lastSeenAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    avatarUrl?: string | null
    topics?: TopicUncheckedCreateNestedManyWithoutAuthorInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    tickets?: TicketUncheckedCreateNestedManyWithoutAuthorInput
    assignedTickets?: TicketUncheckedCreateNestedManyWithoutAssignedToInput
    ticketMsgs?: TicketMessageUncheckedCreateNestedManyWithoutAuthorInput
    ticketParticipants?: TicketParticipantUncheckedCreateNestedManyWithoutUserInput
    ticketParticipantsAdded?: TicketParticipantUncheckedCreateNestedManyWithoutAddedByInput
    ticketRatingsGiven?: TicketRatingUncheckedCreateNestedManyWithoutRaterInput
    ticketRatingsReceived?: TicketRatingUncheckedCreateNestedManyWithoutTargetInput
    closedTickets?: TicketUncheckedCreateNestedManyWithoutClosedByInput
    purchases?: PurchaseUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    whitelistApps?: WhitelistApplicationUncheckedCreateNestedManyWithoutUserInput
    reviewedWhitelists?: WhitelistApplicationUncheckedCreateNestedManyWithoutReviewerInput
    convoParts?: ConversationParticipantUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: DirectMessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: DirectMessageUncheckedCreateNestedManyWithoutReceiverInput
    userBadges?: UserBadgeUncheckedCreateNestedManyWithoutUserInput
    gameAccounts?: GameAccountUncheckedCreateNestedManyWithoutUserInput
    mtaAccessLogs?: MtaAccessLogUncheckedCreateNestedManyWithoutUserInput
    ticketRatingReqGiven?: TicketRatingRequirementUncheckedCreateNestedManyWithoutRaterInput
    ticketRatingReqReceived?: TicketRatingRequirementUncheckedCreateNestedManyWithoutTargetInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    entitlements?: EntitlementUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    staffWeeklyRewards?: StaffWeeklyRewardUncheckedCreateNestedManyWithoutUserInput
    adminCasesTarget?: AdminCaseUncheckedCreateNestedManyWithoutTargetUserInput
    adminCasesStaff?: AdminCaseUncheckedCreateNestedManyWithoutStaffUserInput
    reputation?: UserReputationUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutStaffShiftsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutStaffShiftsInput, UserUncheckedCreateWithoutStaffShiftsInput>
  }

  export type UserUpsertWithoutStaffShiftsInput = {
    update: XOR<UserUpdateWithoutStaffShiftsInput, UserUncheckedUpdateWithoutStaffShiftsInput>
    create: XOR<UserCreateWithoutStaffShiftsInput, UserUncheckedCreateWithoutStaffShiftsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutStaffShiftsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutStaffShiftsInput, UserUncheckedUpdateWithoutStaffShiftsInput>
  }

  export type UserUpdateWithoutStaffShiftsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifyToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerifyExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    discordId?: NullableStringFieldUpdateOperationsInput | string | null
    discordUsername?: NullableStringFieldUpdateOperationsInput | string | null
    avatarKey?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    bannedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    whitelistStatus?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    lastSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    topics?: TopicUpdateManyWithoutAuthorNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    tickets?: TicketUpdateManyWithoutAuthorNestedInput
    assignedTickets?: TicketUpdateManyWithoutAssignedToNestedInput
    ticketMsgs?: TicketMessageUpdateManyWithoutAuthorNestedInput
    ticketParticipants?: TicketParticipantUpdateManyWithoutUserNestedInput
    ticketParticipantsAdded?: TicketParticipantUpdateManyWithoutAddedByNestedInput
    ticketRatingsGiven?: TicketRatingUpdateManyWithoutRaterNestedInput
    ticketRatingsReceived?: TicketRatingUpdateManyWithoutTargetNestedInput
    closedTickets?: TicketUpdateManyWithoutClosedByNestedInput
    purchases?: PurchaseUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    whitelistApps?: WhitelistApplicationUpdateManyWithoutUserNestedInput
    reviewedWhitelists?: WhitelistApplicationUpdateManyWithoutReviewerNestedInput
    convoParts?: ConversationParticipantUpdateManyWithoutUserNestedInput
    sentMessages?: DirectMessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: DirectMessageUpdateManyWithoutReceiverNestedInput
    userBadges?: UserBadgeUpdateManyWithoutUserNestedInput
    gameAccounts?: GameAccountUpdateManyWithoutUserNestedInput
    mtaAccessLogs?: MtaAccessLogUpdateManyWithoutUserNestedInput
    ticketRatingReqGiven?: TicketRatingRequirementUpdateManyWithoutRaterNestedInput
    ticketRatingReqReceived?: TicketRatingRequirementUpdateManyWithoutTargetNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    entitlements?: EntitlementUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    staffWeeklyRewards?: StaffWeeklyRewardUpdateManyWithoutUserNestedInput
    adminCasesTarget?: AdminCaseUpdateManyWithoutTargetUserNestedInput
    adminCasesStaff?: AdminCaseUpdateManyWithoutStaffUserNestedInput
    reputation?: UserReputationUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutStaffShiftsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifyToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerifyExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    discordId?: NullableStringFieldUpdateOperationsInput | string | null
    discordUsername?: NullableStringFieldUpdateOperationsInput | string | null
    avatarKey?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    bannedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    whitelistStatus?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    lastSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    topics?: TopicUncheckedUpdateManyWithoutAuthorNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutAuthorNestedInput
    assignedTickets?: TicketUncheckedUpdateManyWithoutAssignedToNestedInput
    ticketMsgs?: TicketMessageUncheckedUpdateManyWithoutAuthorNestedInput
    ticketParticipants?: TicketParticipantUncheckedUpdateManyWithoutUserNestedInput
    ticketParticipantsAdded?: TicketParticipantUncheckedUpdateManyWithoutAddedByNestedInput
    ticketRatingsGiven?: TicketRatingUncheckedUpdateManyWithoutRaterNestedInput
    ticketRatingsReceived?: TicketRatingUncheckedUpdateManyWithoutTargetNestedInput
    closedTickets?: TicketUncheckedUpdateManyWithoutClosedByNestedInput
    purchases?: PurchaseUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    whitelistApps?: WhitelistApplicationUncheckedUpdateManyWithoutUserNestedInput
    reviewedWhitelists?: WhitelistApplicationUncheckedUpdateManyWithoutReviewerNestedInput
    convoParts?: ConversationParticipantUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: DirectMessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: DirectMessageUncheckedUpdateManyWithoutReceiverNestedInput
    userBadges?: UserBadgeUncheckedUpdateManyWithoutUserNestedInput
    gameAccounts?: GameAccountUncheckedUpdateManyWithoutUserNestedInput
    mtaAccessLogs?: MtaAccessLogUncheckedUpdateManyWithoutUserNestedInput
    ticketRatingReqGiven?: TicketRatingRequirementUncheckedUpdateManyWithoutRaterNestedInput
    ticketRatingReqReceived?: TicketRatingRequirementUncheckedUpdateManyWithoutTargetNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    entitlements?: EntitlementUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    staffWeeklyRewards?: StaffWeeklyRewardUncheckedUpdateManyWithoutUserNestedInput
    adminCasesTarget?: AdminCaseUncheckedUpdateManyWithoutTargetUserNestedInput
    adminCasesStaff?: AdminCaseUncheckedUpdateManyWithoutStaffUserNestedInput
    reputation?: UserReputationUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserCreateWithoutStaffWeeklyRewardsInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    emailVerifiedAt?: Date | string | null
    emailVerifyToken?: string | null
    emailVerifyExpiresAt?: Date | string | null
    phone?: string | null
    recoveryEmail?: string | null
    googleId?: string | null
    discordId?: string | null
    discordUsername?: string | null
    avatarKey?: string
    role?: string
    isDeleted?: boolean
    bannedUntil?: Date | string | null
    whitelistStatus?: string
    points?: number
    lastSeenAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    avatarUrl?: string | null
    topics?: TopicCreateNestedManyWithoutAuthorInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    tickets?: TicketCreateNestedManyWithoutAuthorInput
    assignedTickets?: TicketCreateNestedManyWithoutAssignedToInput
    ticketMsgs?: TicketMessageCreateNestedManyWithoutAuthorInput
    ticketParticipants?: TicketParticipantCreateNestedManyWithoutUserInput
    ticketParticipantsAdded?: TicketParticipantCreateNestedManyWithoutAddedByInput
    ticketRatingsGiven?: TicketRatingCreateNestedManyWithoutRaterInput
    ticketRatingsReceived?: TicketRatingCreateNestedManyWithoutTargetInput
    closedTickets?: TicketCreateNestedManyWithoutClosedByInput
    purchases?: PurchaseCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    whitelistApps?: WhitelistApplicationCreateNestedManyWithoutUserInput
    reviewedWhitelists?: WhitelistApplicationCreateNestedManyWithoutReviewerInput
    convoParts?: ConversationParticipantCreateNestedManyWithoutUserInput
    sentMessages?: DirectMessageCreateNestedManyWithoutSenderInput
    receivedMessages?: DirectMessageCreateNestedManyWithoutReceiverInput
    userBadges?: UserBadgeCreateNestedManyWithoutUserInput
    gameAccounts?: GameAccountCreateNestedManyWithoutUserInput
    mtaAccessLogs?: MtaAccessLogCreateNestedManyWithoutUserInput
    ticketRatingReqGiven?: TicketRatingRequirementCreateNestedManyWithoutRaterInput
    ticketRatingReqReceived?: TicketRatingRequirementCreateNestedManyWithoutTargetInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    entitlements?: EntitlementCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    staffShifts?: StaffShiftCreateNestedManyWithoutUserInput
    adminCasesTarget?: AdminCaseCreateNestedManyWithoutTargetUserInput
    adminCasesStaff?: AdminCaseCreateNestedManyWithoutStaffUserInput
    reputation?: UserReputationCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutStaffWeeklyRewardsInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    emailVerifiedAt?: Date | string | null
    emailVerifyToken?: string | null
    emailVerifyExpiresAt?: Date | string | null
    phone?: string | null
    recoveryEmail?: string | null
    googleId?: string | null
    discordId?: string | null
    discordUsername?: string | null
    avatarKey?: string
    role?: string
    isDeleted?: boolean
    bannedUntil?: Date | string | null
    whitelistStatus?: string
    points?: number
    lastSeenAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    avatarUrl?: string | null
    topics?: TopicUncheckedCreateNestedManyWithoutAuthorInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    tickets?: TicketUncheckedCreateNestedManyWithoutAuthorInput
    assignedTickets?: TicketUncheckedCreateNestedManyWithoutAssignedToInput
    ticketMsgs?: TicketMessageUncheckedCreateNestedManyWithoutAuthorInput
    ticketParticipants?: TicketParticipantUncheckedCreateNestedManyWithoutUserInput
    ticketParticipantsAdded?: TicketParticipantUncheckedCreateNestedManyWithoutAddedByInput
    ticketRatingsGiven?: TicketRatingUncheckedCreateNestedManyWithoutRaterInput
    ticketRatingsReceived?: TicketRatingUncheckedCreateNestedManyWithoutTargetInput
    closedTickets?: TicketUncheckedCreateNestedManyWithoutClosedByInput
    purchases?: PurchaseUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    whitelistApps?: WhitelistApplicationUncheckedCreateNestedManyWithoutUserInput
    reviewedWhitelists?: WhitelistApplicationUncheckedCreateNestedManyWithoutReviewerInput
    convoParts?: ConversationParticipantUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: DirectMessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: DirectMessageUncheckedCreateNestedManyWithoutReceiverInput
    userBadges?: UserBadgeUncheckedCreateNestedManyWithoutUserInput
    gameAccounts?: GameAccountUncheckedCreateNestedManyWithoutUserInput
    mtaAccessLogs?: MtaAccessLogUncheckedCreateNestedManyWithoutUserInput
    ticketRatingReqGiven?: TicketRatingRequirementUncheckedCreateNestedManyWithoutRaterInput
    ticketRatingReqReceived?: TicketRatingRequirementUncheckedCreateNestedManyWithoutTargetInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    entitlements?: EntitlementUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    staffShifts?: StaffShiftUncheckedCreateNestedManyWithoutUserInput
    adminCasesTarget?: AdminCaseUncheckedCreateNestedManyWithoutTargetUserInput
    adminCasesStaff?: AdminCaseUncheckedCreateNestedManyWithoutStaffUserInput
    reputation?: UserReputationUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutStaffWeeklyRewardsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutStaffWeeklyRewardsInput, UserUncheckedCreateWithoutStaffWeeklyRewardsInput>
  }

  export type UserUpsertWithoutStaffWeeklyRewardsInput = {
    update: XOR<UserUpdateWithoutStaffWeeklyRewardsInput, UserUncheckedUpdateWithoutStaffWeeklyRewardsInput>
    create: XOR<UserCreateWithoutStaffWeeklyRewardsInput, UserUncheckedCreateWithoutStaffWeeklyRewardsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutStaffWeeklyRewardsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutStaffWeeklyRewardsInput, UserUncheckedUpdateWithoutStaffWeeklyRewardsInput>
  }

  export type UserUpdateWithoutStaffWeeklyRewardsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifyToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerifyExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    discordId?: NullableStringFieldUpdateOperationsInput | string | null
    discordUsername?: NullableStringFieldUpdateOperationsInput | string | null
    avatarKey?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    bannedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    whitelistStatus?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    lastSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    topics?: TopicUpdateManyWithoutAuthorNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    tickets?: TicketUpdateManyWithoutAuthorNestedInput
    assignedTickets?: TicketUpdateManyWithoutAssignedToNestedInput
    ticketMsgs?: TicketMessageUpdateManyWithoutAuthorNestedInput
    ticketParticipants?: TicketParticipantUpdateManyWithoutUserNestedInput
    ticketParticipantsAdded?: TicketParticipantUpdateManyWithoutAddedByNestedInput
    ticketRatingsGiven?: TicketRatingUpdateManyWithoutRaterNestedInput
    ticketRatingsReceived?: TicketRatingUpdateManyWithoutTargetNestedInput
    closedTickets?: TicketUpdateManyWithoutClosedByNestedInput
    purchases?: PurchaseUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    whitelistApps?: WhitelistApplicationUpdateManyWithoutUserNestedInput
    reviewedWhitelists?: WhitelistApplicationUpdateManyWithoutReviewerNestedInput
    convoParts?: ConversationParticipantUpdateManyWithoutUserNestedInput
    sentMessages?: DirectMessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: DirectMessageUpdateManyWithoutReceiverNestedInput
    userBadges?: UserBadgeUpdateManyWithoutUserNestedInput
    gameAccounts?: GameAccountUpdateManyWithoutUserNestedInput
    mtaAccessLogs?: MtaAccessLogUpdateManyWithoutUserNestedInput
    ticketRatingReqGiven?: TicketRatingRequirementUpdateManyWithoutRaterNestedInput
    ticketRatingReqReceived?: TicketRatingRequirementUpdateManyWithoutTargetNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    entitlements?: EntitlementUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    staffShifts?: StaffShiftUpdateManyWithoutUserNestedInput
    adminCasesTarget?: AdminCaseUpdateManyWithoutTargetUserNestedInput
    adminCasesStaff?: AdminCaseUpdateManyWithoutStaffUserNestedInput
    reputation?: UserReputationUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutStaffWeeklyRewardsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifyToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerifyExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    discordId?: NullableStringFieldUpdateOperationsInput | string | null
    discordUsername?: NullableStringFieldUpdateOperationsInput | string | null
    avatarKey?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    bannedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    whitelistStatus?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    lastSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    topics?: TopicUncheckedUpdateManyWithoutAuthorNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutAuthorNestedInput
    assignedTickets?: TicketUncheckedUpdateManyWithoutAssignedToNestedInput
    ticketMsgs?: TicketMessageUncheckedUpdateManyWithoutAuthorNestedInput
    ticketParticipants?: TicketParticipantUncheckedUpdateManyWithoutUserNestedInput
    ticketParticipantsAdded?: TicketParticipantUncheckedUpdateManyWithoutAddedByNestedInput
    ticketRatingsGiven?: TicketRatingUncheckedUpdateManyWithoutRaterNestedInput
    ticketRatingsReceived?: TicketRatingUncheckedUpdateManyWithoutTargetNestedInput
    closedTickets?: TicketUncheckedUpdateManyWithoutClosedByNestedInput
    purchases?: PurchaseUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    whitelistApps?: WhitelistApplicationUncheckedUpdateManyWithoutUserNestedInput
    reviewedWhitelists?: WhitelistApplicationUncheckedUpdateManyWithoutReviewerNestedInput
    convoParts?: ConversationParticipantUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: DirectMessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: DirectMessageUncheckedUpdateManyWithoutReceiverNestedInput
    userBadges?: UserBadgeUncheckedUpdateManyWithoutUserNestedInput
    gameAccounts?: GameAccountUncheckedUpdateManyWithoutUserNestedInput
    mtaAccessLogs?: MtaAccessLogUncheckedUpdateManyWithoutUserNestedInput
    ticketRatingReqGiven?: TicketRatingRequirementUncheckedUpdateManyWithoutRaterNestedInput
    ticketRatingReqReceived?: TicketRatingRequirementUncheckedUpdateManyWithoutTargetNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    entitlements?: EntitlementUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    staffShifts?: StaffShiftUncheckedUpdateManyWithoutUserNestedInput
    adminCasesTarget?: AdminCaseUncheckedUpdateManyWithoutTargetUserNestedInput
    adminCasesStaff?: AdminCaseUncheckedUpdateManyWithoutStaffUserNestedInput
    reputation?: UserReputationUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserCreateWithoutAdminCasesTargetInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    emailVerifiedAt?: Date | string | null
    emailVerifyToken?: string | null
    emailVerifyExpiresAt?: Date | string | null
    phone?: string | null
    recoveryEmail?: string | null
    googleId?: string | null
    discordId?: string | null
    discordUsername?: string | null
    avatarKey?: string
    role?: string
    isDeleted?: boolean
    bannedUntil?: Date | string | null
    whitelistStatus?: string
    points?: number
    lastSeenAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    avatarUrl?: string | null
    topics?: TopicCreateNestedManyWithoutAuthorInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    tickets?: TicketCreateNestedManyWithoutAuthorInput
    assignedTickets?: TicketCreateNestedManyWithoutAssignedToInput
    ticketMsgs?: TicketMessageCreateNestedManyWithoutAuthorInput
    ticketParticipants?: TicketParticipantCreateNestedManyWithoutUserInput
    ticketParticipantsAdded?: TicketParticipantCreateNestedManyWithoutAddedByInput
    ticketRatingsGiven?: TicketRatingCreateNestedManyWithoutRaterInput
    ticketRatingsReceived?: TicketRatingCreateNestedManyWithoutTargetInput
    closedTickets?: TicketCreateNestedManyWithoutClosedByInput
    purchases?: PurchaseCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    whitelistApps?: WhitelistApplicationCreateNestedManyWithoutUserInput
    reviewedWhitelists?: WhitelistApplicationCreateNestedManyWithoutReviewerInput
    convoParts?: ConversationParticipantCreateNestedManyWithoutUserInput
    sentMessages?: DirectMessageCreateNestedManyWithoutSenderInput
    receivedMessages?: DirectMessageCreateNestedManyWithoutReceiverInput
    userBadges?: UserBadgeCreateNestedManyWithoutUserInput
    gameAccounts?: GameAccountCreateNestedManyWithoutUserInput
    mtaAccessLogs?: MtaAccessLogCreateNestedManyWithoutUserInput
    ticketRatingReqGiven?: TicketRatingRequirementCreateNestedManyWithoutRaterInput
    ticketRatingReqReceived?: TicketRatingRequirementCreateNestedManyWithoutTargetInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    entitlements?: EntitlementCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    staffShifts?: StaffShiftCreateNestedManyWithoutUserInput
    staffWeeklyRewards?: StaffWeeklyRewardCreateNestedManyWithoutUserInput
    adminCasesStaff?: AdminCaseCreateNestedManyWithoutStaffUserInput
    reputation?: UserReputationCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAdminCasesTargetInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    emailVerifiedAt?: Date | string | null
    emailVerifyToken?: string | null
    emailVerifyExpiresAt?: Date | string | null
    phone?: string | null
    recoveryEmail?: string | null
    googleId?: string | null
    discordId?: string | null
    discordUsername?: string | null
    avatarKey?: string
    role?: string
    isDeleted?: boolean
    bannedUntil?: Date | string | null
    whitelistStatus?: string
    points?: number
    lastSeenAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    avatarUrl?: string | null
    topics?: TopicUncheckedCreateNestedManyWithoutAuthorInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    tickets?: TicketUncheckedCreateNestedManyWithoutAuthorInput
    assignedTickets?: TicketUncheckedCreateNestedManyWithoutAssignedToInput
    ticketMsgs?: TicketMessageUncheckedCreateNestedManyWithoutAuthorInput
    ticketParticipants?: TicketParticipantUncheckedCreateNestedManyWithoutUserInput
    ticketParticipantsAdded?: TicketParticipantUncheckedCreateNestedManyWithoutAddedByInput
    ticketRatingsGiven?: TicketRatingUncheckedCreateNestedManyWithoutRaterInput
    ticketRatingsReceived?: TicketRatingUncheckedCreateNestedManyWithoutTargetInput
    closedTickets?: TicketUncheckedCreateNestedManyWithoutClosedByInput
    purchases?: PurchaseUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    whitelistApps?: WhitelistApplicationUncheckedCreateNestedManyWithoutUserInput
    reviewedWhitelists?: WhitelistApplicationUncheckedCreateNestedManyWithoutReviewerInput
    convoParts?: ConversationParticipantUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: DirectMessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: DirectMessageUncheckedCreateNestedManyWithoutReceiverInput
    userBadges?: UserBadgeUncheckedCreateNestedManyWithoutUserInput
    gameAccounts?: GameAccountUncheckedCreateNestedManyWithoutUserInput
    mtaAccessLogs?: MtaAccessLogUncheckedCreateNestedManyWithoutUserInput
    ticketRatingReqGiven?: TicketRatingRequirementUncheckedCreateNestedManyWithoutRaterInput
    ticketRatingReqReceived?: TicketRatingRequirementUncheckedCreateNestedManyWithoutTargetInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    entitlements?: EntitlementUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    staffShifts?: StaffShiftUncheckedCreateNestedManyWithoutUserInput
    staffWeeklyRewards?: StaffWeeklyRewardUncheckedCreateNestedManyWithoutUserInput
    adminCasesStaff?: AdminCaseUncheckedCreateNestedManyWithoutStaffUserInput
    reputation?: UserReputationUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAdminCasesTargetInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAdminCasesTargetInput, UserUncheckedCreateWithoutAdminCasesTargetInput>
  }

  export type UserCreateWithoutAdminCasesStaffInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    emailVerifiedAt?: Date | string | null
    emailVerifyToken?: string | null
    emailVerifyExpiresAt?: Date | string | null
    phone?: string | null
    recoveryEmail?: string | null
    googleId?: string | null
    discordId?: string | null
    discordUsername?: string | null
    avatarKey?: string
    role?: string
    isDeleted?: boolean
    bannedUntil?: Date | string | null
    whitelistStatus?: string
    points?: number
    lastSeenAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    avatarUrl?: string | null
    topics?: TopicCreateNestedManyWithoutAuthorInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    tickets?: TicketCreateNestedManyWithoutAuthorInput
    assignedTickets?: TicketCreateNestedManyWithoutAssignedToInput
    ticketMsgs?: TicketMessageCreateNestedManyWithoutAuthorInput
    ticketParticipants?: TicketParticipantCreateNestedManyWithoutUserInput
    ticketParticipantsAdded?: TicketParticipantCreateNestedManyWithoutAddedByInput
    ticketRatingsGiven?: TicketRatingCreateNestedManyWithoutRaterInput
    ticketRatingsReceived?: TicketRatingCreateNestedManyWithoutTargetInput
    closedTickets?: TicketCreateNestedManyWithoutClosedByInput
    purchases?: PurchaseCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    whitelistApps?: WhitelistApplicationCreateNestedManyWithoutUserInput
    reviewedWhitelists?: WhitelistApplicationCreateNestedManyWithoutReviewerInput
    convoParts?: ConversationParticipantCreateNestedManyWithoutUserInput
    sentMessages?: DirectMessageCreateNestedManyWithoutSenderInput
    receivedMessages?: DirectMessageCreateNestedManyWithoutReceiverInput
    userBadges?: UserBadgeCreateNestedManyWithoutUserInput
    gameAccounts?: GameAccountCreateNestedManyWithoutUserInput
    mtaAccessLogs?: MtaAccessLogCreateNestedManyWithoutUserInput
    ticketRatingReqGiven?: TicketRatingRequirementCreateNestedManyWithoutRaterInput
    ticketRatingReqReceived?: TicketRatingRequirementCreateNestedManyWithoutTargetInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    entitlements?: EntitlementCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    staffShifts?: StaffShiftCreateNestedManyWithoutUserInput
    staffWeeklyRewards?: StaffWeeklyRewardCreateNestedManyWithoutUserInput
    adminCasesTarget?: AdminCaseCreateNestedManyWithoutTargetUserInput
    reputation?: UserReputationCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAdminCasesStaffInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    emailVerifiedAt?: Date | string | null
    emailVerifyToken?: string | null
    emailVerifyExpiresAt?: Date | string | null
    phone?: string | null
    recoveryEmail?: string | null
    googleId?: string | null
    discordId?: string | null
    discordUsername?: string | null
    avatarKey?: string
    role?: string
    isDeleted?: boolean
    bannedUntil?: Date | string | null
    whitelistStatus?: string
    points?: number
    lastSeenAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    avatarUrl?: string | null
    topics?: TopicUncheckedCreateNestedManyWithoutAuthorInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    tickets?: TicketUncheckedCreateNestedManyWithoutAuthorInput
    assignedTickets?: TicketUncheckedCreateNestedManyWithoutAssignedToInput
    ticketMsgs?: TicketMessageUncheckedCreateNestedManyWithoutAuthorInput
    ticketParticipants?: TicketParticipantUncheckedCreateNestedManyWithoutUserInput
    ticketParticipantsAdded?: TicketParticipantUncheckedCreateNestedManyWithoutAddedByInput
    ticketRatingsGiven?: TicketRatingUncheckedCreateNestedManyWithoutRaterInput
    ticketRatingsReceived?: TicketRatingUncheckedCreateNestedManyWithoutTargetInput
    closedTickets?: TicketUncheckedCreateNestedManyWithoutClosedByInput
    purchases?: PurchaseUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    whitelistApps?: WhitelistApplicationUncheckedCreateNestedManyWithoutUserInput
    reviewedWhitelists?: WhitelistApplicationUncheckedCreateNestedManyWithoutReviewerInput
    convoParts?: ConversationParticipantUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: DirectMessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: DirectMessageUncheckedCreateNestedManyWithoutReceiverInput
    userBadges?: UserBadgeUncheckedCreateNestedManyWithoutUserInput
    gameAccounts?: GameAccountUncheckedCreateNestedManyWithoutUserInput
    mtaAccessLogs?: MtaAccessLogUncheckedCreateNestedManyWithoutUserInput
    ticketRatingReqGiven?: TicketRatingRequirementUncheckedCreateNestedManyWithoutRaterInput
    ticketRatingReqReceived?: TicketRatingRequirementUncheckedCreateNestedManyWithoutTargetInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    entitlements?: EntitlementUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    staffShifts?: StaffShiftUncheckedCreateNestedManyWithoutUserInput
    staffWeeklyRewards?: StaffWeeklyRewardUncheckedCreateNestedManyWithoutUserInput
    adminCasesTarget?: AdminCaseUncheckedCreateNestedManyWithoutTargetUserInput
    reputation?: UserReputationUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAdminCasesStaffInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAdminCasesStaffInput, UserUncheckedCreateWithoutAdminCasesStaffInput>
  }

  export type UserUpsertWithoutAdminCasesTargetInput = {
    update: XOR<UserUpdateWithoutAdminCasesTargetInput, UserUncheckedUpdateWithoutAdminCasesTargetInput>
    create: XOR<UserCreateWithoutAdminCasesTargetInput, UserUncheckedCreateWithoutAdminCasesTargetInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAdminCasesTargetInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAdminCasesTargetInput, UserUncheckedUpdateWithoutAdminCasesTargetInput>
  }

  export type UserUpdateWithoutAdminCasesTargetInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifyToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerifyExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    discordId?: NullableStringFieldUpdateOperationsInput | string | null
    discordUsername?: NullableStringFieldUpdateOperationsInput | string | null
    avatarKey?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    bannedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    whitelistStatus?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    lastSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    topics?: TopicUpdateManyWithoutAuthorNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    tickets?: TicketUpdateManyWithoutAuthorNestedInput
    assignedTickets?: TicketUpdateManyWithoutAssignedToNestedInput
    ticketMsgs?: TicketMessageUpdateManyWithoutAuthorNestedInput
    ticketParticipants?: TicketParticipantUpdateManyWithoutUserNestedInput
    ticketParticipantsAdded?: TicketParticipantUpdateManyWithoutAddedByNestedInput
    ticketRatingsGiven?: TicketRatingUpdateManyWithoutRaterNestedInput
    ticketRatingsReceived?: TicketRatingUpdateManyWithoutTargetNestedInput
    closedTickets?: TicketUpdateManyWithoutClosedByNestedInput
    purchases?: PurchaseUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    whitelistApps?: WhitelistApplicationUpdateManyWithoutUserNestedInput
    reviewedWhitelists?: WhitelistApplicationUpdateManyWithoutReviewerNestedInput
    convoParts?: ConversationParticipantUpdateManyWithoutUserNestedInput
    sentMessages?: DirectMessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: DirectMessageUpdateManyWithoutReceiverNestedInput
    userBadges?: UserBadgeUpdateManyWithoutUserNestedInput
    gameAccounts?: GameAccountUpdateManyWithoutUserNestedInput
    mtaAccessLogs?: MtaAccessLogUpdateManyWithoutUserNestedInput
    ticketRatingReqGiven?: TicketRatingRequirementUpdateManyWithoutRaterNestedInput
    ticketRatingReqReceived?: TicketRatingRequirementUpdateManyWithoutTargetNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    entitlements?: EntitlementUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    staffShifts?: StaffShiftUpdateManyWithoutUserNestedInput
    staffWeeklyRewards?: StaffWeeklyRewardUpdateManyWithoutUserNestedInput
    adminCasesStaff?: AdminCaseUpdateManyWithoutStaffUserNestedInput
    reputation?: UserReputationUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAdminCasesTargetInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifyToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerifyExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    discordId?: NullableStringFieldUpdateOperationsInput | string | null
    discordUsername?: NullableStringFieldUpdateOperationsInput | string | null
    avatarKey?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    bannedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    whitelistStatus?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    lastSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    topics?: TopicUncheckedUpdateManyWithoutAuthorNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutAuthorNestedInput
    assignedTickets?: TicketUncheckedUpdateManyWithoutAssignedToNestedInput
    ticketMsgs?: TicketMessageUncheckedUpdateManyWithoutAuthorNestedInput
    ticketParticipants?: TicketParticipantUncheckedUpdateManyWithoutUserNestedInput
    ticketParticipantsAdded?: TicketParticipantUncheckedUpdateManyWithoutAddedByNestedInput
    ticketRatingsGiven?: TicketRatingUncheckedUpdateManyWithoutRaterNestedInput
    ticketRatingsReceived?: TicketRatingUncheckedUpdateManyWithoutTargetNestedInput
    closedTickets?: TicketUncheckedUpdateManyWithoutClosedByNestedInput
    purchases?: PurchaseUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    whitelistApps?: WhitelistApplicationUncheckedUpdateManyWithoutUserNestedInput
    reviewedWhitelists?: WhitelistApplicationUncheckedUpdateManyWithoutReviewerNestedInput
    convoParts?: ConversationParticipantUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: DirectMessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: DirectMessageUncheckedUpdateManyWithoutReceiverNestedInput
    userBadges?: UserBadgeUncheckedUpdateManyWithoutUserNestedInput
    gameAccounts?: GameAccountUncheckedUpdateManyWithoutUserNestedInput
    mtaAccessLogs?: MtaAccessLogUncheckedUpdateManyWithoutUserNestedInput
    ticketRatingReqGiven?: TicketRatingRequirementUncheckedUpdateManyWithoutRaterNestedInput
    ticketRatingReqReceived?: TicketRatingRequirementUncheckedUpdateManyWithoutTargetNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    entitlements?: EntitlementUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    staffShifts?: StaffShiftUncheckedUpdateManyWithoutUserNestedInput
    staffWeeklyRewards?: StaffWeeklyRewardUncheckedUpdateManyWithoutUserNestedInput
    adminCasesStaff?: AdminCaseUncheckedUpdateManyWithoutStaffUserNestedInput
    reputation?: UserReputationUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserUpsertWithoutAdminCasesStaffInput = {
    update: XOR<UserUpdateWithoutAdminCasesStaffInput, UserUncheckedUpdateWithoutAdminCasesStaffInput>
    create: XOR<UserCreateWithoutAdminCasesStaffInput, UserUncheckedCreateWithoutAdminCasesStaffInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAdminCasesStaffInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAdminCasesStaffInput, UserUncheckedUpdateWithoutAdminCasesStaffInput>
  }

  export type UserUpdateWithoutAdminCasesStaffInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifyToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerifyExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    discordId?: NullableStringFieldUpdateOperationsInput | string | null
    discordUsername?: NullableStringFieldUpdateOperationsInput | string | null
    avatarKey?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    bannedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    whitelistStatus?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    lastSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    topics?: TopicUpdateManyWithoutAuthorNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    tickets?: TicketUpdateManyWithoutAuthorNestedInput
    assignedTickets?: TicketUpdateManyWithoutAssignedToNestedInput
    ticketMsgs?: TicketMessageUpdateManyWithoutAuthorNestedInput
    ticketParticipants?: TicketParticipantUpdateManyWithoutUserNestedInput
    ticketParticipantsAdded?: TicketParticipantUpdateManyWithoutAddedByNestedInput
    ticketRatingsGiven?: TicketRatingUpdateManyWithoutRaterNestedInput
    ticketRatingsReceived?: TicketRatingUpdateManyWithoutTargetNestedInput
    closedTickets?: TicketUpdateManyWithoutClosedByNestedInput
    purchases?: PurchaseUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    whitelistApps?: WhitelistApplicationUpdateManyWithoutUserNestedInput
    reviewedWhitelists?: WhitelistApplicationUpdateManyWithoutReviewerNestedInput
    convoParts?: ConversationParticipantUpdateManyWithoutUserNestedInput
    sentMessages?: DirectMessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: DirectMessageUpdateManyWithoutReceiverNestedInput
    userBadges?: UserBadgeUpdateManyWithoutUserNestedInput
    gameAccounts?: GameAccountUpdateManyWithoutUserNestedInput
    mtaAccessLogs?: MtaAccessLogUpdateManyWithoutUserNestedInput
    ticketRatingReqGiven?: TicketRatingRequirementUpdateManyWithoutRaterNestedInput
    ticketRatingReqReceived?: TicketRatingRequirementUpdateManyWithoutTargetNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    entitlements?: EntitlementUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    staffShifts?: StaffShiftUpdateManyWithoutUserNestedInput
    staffWeeklyRewards?: StaffWeeklyRewardUpdateManyWithoutUserNestedInput
    adminCasesTarget?: AdminCaseUpdateManyWithoutTargetUserNestedInput
    reputation?: UserReputationUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAdminCasesStaffInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifyToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerifyExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    discordId?: NullableStringFieldUpdateOperationsInput | string | null
    discordUsername?: NullableStringFieldUpdateOperationsInput | string | null
    avatarKey?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    bannedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    whitelistStatus?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    lastSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    topics?: TopicUncheckedUpdateManyWithoutAuthorNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutAuthorNestedInput
    assignedTickets?: TicketUncheckedUpdateManyWithoutAssignedToNestedInput
    ticketMsgs?: TicketMessageUncheckedUpdateManyWithoutAuthorNestedInput
    ticketParticipants?: TicketParticipantUncheckedUpdateManyWithoutUserNestedInput
    ticketParticipantsAdded?: TicketParticipantUncheckedUpdateManyWithoutAddedByNestedInput
    ticketRatingsGiven?: TicketRatingUncheckedUpdateManyWithoutRaterNestedInput
    ticketRatingsReceived?: TicketRatingUncheckedUpdateManyWithoutTargetNestedInput
    closedTickets?: TicketUncheckedUpdateManyWithoutClosedByNestedInput
    purchases?: PurchaseUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    whitelistApps?: WhitelistApplicationUncheckedUpdateManyWithoutUserNestedInput
    reviewedWhitelists?: WhitelistApplicationUncheckedUpdateManyWithoutReviewerNestedInput
    convoParts?: ConversationParticipantUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: DirectMessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: DirectMessageUncheckedUpdateManyWithoutReceiverNestedInput
    userBadges?: UserBadgeUncheckedUpdateManyWithoutUserNestedInput
    gameAccounts?: GameAccountUncheckedUpdateManyWithoutUserNestedInput
    mtaAccessLogs?: MtaAccessLogUncheckedUpdateManyWithoutUserNestedInput
    ticketRatingReqGiven?: TicketRatingRequirementUncheckedUpdateManyWithoutRaterNestedInput
    ticketRatingReqReceived?: TicketRatingRequirementUncheckedUpdateManyWithoutTargetNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    entitlements?: EntitlementUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    staffShifts?: StaffShiftUncheckedUpdateManyWithoutUserNestedInput
    staffWeeklyRewards?: StaffWeeklyRewardUncheckedUpdateManyWithoutUserNestedInput
    adminCasesTarget?: AdminCaseUncheckedUpdateManyWithoutTargetUserNestedInput
    reputation?: UserReputationUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserCreateWithoutReputationInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    emailVerifiedAt?: Date | string | null
    emailVerifyToken?: string | null
    emailVerifyExpiresAt?: Date | string | null
    phone?: string | null
    recoveryEmail?: string | null
    googleId?: string | null
    discordId?: string | null
    discordUsername?: string | null
    avatarKey?: string
    role?: string
    isDeleted?: boolean
    bannedUntil?: Date | string | null
    whitelistStatus?: string
    points?: number
    lastSeenAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    avatarUrl?: string | null
    topics?: TopicCreateNestedManyWithoutAuthorInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    tickets?: TicketCreateNestedManyWithoutAuthorInput
    assignedTickets?: TicketCreateNestedManyWithoutAssignedToInput
    ticketMsgs?: TicketMessageCreateNestedManyWithoutAuthorInput
    ticketParticipants?: TicketParticipantCreateNestedManyWithoutUserInput
    ticketParticipantsAdded?: TicketParticipantCreateNestedManyWithoutAddedByInput
    ticketRatingsGiven?: TicketRatingCreateNestedManyWithoutRaterInput
    ticketRatingsReceived?: TicketRatingCreateNestedManyWithoutTargetInput
    closedTickets?: TicketCreateNestedManyWithoutClosedByInput
    purchases?: PurchaseCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    whitelistApps?: WhitelistApplicationCreateNestedManyWithoutUserInput
    reviewedWhitelists?: WhitelistApplicationCreateNestedManyWithoutReviewerInput
    convoParts?: ConversationParticipantCreateNestedManyWithoutUserInput
    sentMessages?: DirectMessageCreateNestedManyWithoutSenderInput
    receivedMessages?: DirectMessageCreateNestedManyWithoutReceiverInput
    userBadges?: UserBadgeCreateNestedManyWithoutUserInput
    gameAccounts?: GameAccountCreateNestedManyWithoutUserInput
    mtaAccessLogs?: MtaAccessLogCreateNestedManyWithoutUserInput
    ticketRatingReqGiven?: TicketRatingRequirementCreateNestedManyWithoutRaterInput
    ticketRatingReqReceived?: TicketRatingRequirementCreateNestedManyWithoutTargetInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    entitlements?: EntitlementCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    staffShifts?: StaffShiftCreateNestedManyWithoutUserInput
    staffWeeklyRewards?: StaffWeeklyRewardCreateNestedManyWithoutUserInput
    adminCasesTarget?: AdminCaseCreateNestedManyWithoutTargetUserInput
    adminCasesStaff?: AdminCaseCreateNestedManyWithoutStaffUserInput
  }

  export type UserUncheckedCreateWithoutReputationInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    emailVerifiedAt?: Date | string | null
    emailVerifyToken?: string | null
    emailVerifyExpiresAt?: Date | string | null
    phone?: string | null
    recoveryEmail?: string | null
    googleId?: string | null
    discordId?: string | null
    discordUsername?: string | null
    avatarKey?: string
    role?: string
    isDeleted?: boolean
    bannedUntil?: Date | string | null
    whitelistStatus?: string
    points?: number
    lastSeenAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    avatarUrl?: string | null
    topics?: TopicUncheckedCreateNestedManyWithoutAuthorInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    tickets?: TicketUncheckedCreateNestedManyWithoutAuthorInput
    assignedTickets?: TicketUncheckedCreateNestedManyWithoutAssignedToInput
    ticketMsgs?: TicketMessageUncheckedCreateNestedManyWithoutAuthorInput
    ticketParticipants?: TicketParticipantUncheckedCreateNestedManyWithoutUserInput
    ticketParticipantsAdded?: TicketParticipantUncheckedCreateNestedManyWithoutAddedByInput
    ticketRatingsGiven?: TicketRatingUncheckedCreateNestedManyWithoutRaterInput
    ticketRatingsReceived?: TicketRatingUncheckedCreateNestedManyWithoutTargetInput
    closedTickets?: TicketUncheckedCreateNestedManyWithoutClosedByInput
    purchases?: PurchaseUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    whitelistApps?: WhitelistApplicationUncheckedCreateNestedManyWithoutUserInput
    reviewedWhitelists?: WhitelistApplicationUncheckedCreateNestedManyWithoutReviewerInput
    convoParts?: ConversationParticipantUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: DirectMessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: DirectMessageUncheckedCreateNestedManyWithoutReceiverInput
    userBadges?: UserBadgeUncheckedCreateNestedManyWithoutUserInput
    gameAccounts?: GameAccountUncheckedCreateNestedManyWithoutUserInput
    mtaAccessLogs?: MtaAccessLogUncheckedCreateNestedManyWithoutUserInput
    ticketRatingReqGiven?: TicketRatingRequirementUncheckedCreateNestedManyWithoutRaterInput
    ticketRatingReqReceived?: TicketRatingRequirementUncheckedCreateNestedManyWithoutTargetInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    entitlements?: EntitlementUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    staffShifts?: StaffShiftUncheckedCreateNestedManyWithoutUserInput
    staffWeeklyRewards?: StaffWeeklyRewardUncheckedCreateNestedManyWithoutUserInput
    adminCasesTarget?: AdminCaseUncheckedCreateNestedManyWithoutTargetUserInput
    adminCasesStaff?: AdminCaseUncheckedCreateNestedManyWithoutStaffUserInput
  }

  export type UserCreateOrConnectWithoutReputationInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReputationInput, UserUncheckedCreateWithoutReputationInput>
  }

  export type UserUpsertWithoutReputationInput = {
    update: XOR<UserUpdateWithoutReputationInput, UserUncheckedUpdateWithoutReputationInput>
    create: XOR<UserCreateWithoutReputationInput, UserUncheckedCreateWithoutReputationInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReputationInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReputationInput, UserUncheckedUpdateWithoutReputationInput>
  }

  export type UserUpdateWithoutReputationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifyToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerifyExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    discordId?: NullableStringFieldUpdateOperationsInput | string | null
    discordUsername?: NullableStringFieldUpdateOperationsInput | string | null
    avatarKey?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    bannedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    whitelistStatus?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    lastSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    topics?: TopicUpdateManyWithoutAuthorNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    tickets?: TicketUpdateManyWithoutAuthorNestedInput
    assignedTickets?: TicketUpdateManyWithoutAssignedToNestedInput
    ticketMsgs?: TicketMessageUpdateManyWithoutAuthorNestedInput
    ticketParticipants?: TicketParticipantUpdateManyWithoutUserNestedInput
    ticketParticipantsAdded?: TicketParticipantUpdateManyWithoutAddedByNestedInput
    ticketRatingsGiven?: TicketRatingUpdateManyWithoutRaterNestedInput
    ticketRatingsReceived?: TicketRatingUpdateManyWithoutTargetNestedInput
    closedTickets?: TicketUpdateManyWithoutClosedByNestedInput
    purchases?: PurchaseUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    whitelistApps?: WhitelistApplicationUpdateManyWithoutUserNestedInput
    reviewedWhitelists?: WhitelistApplicationUpdateManyWithoutReviewerNestedInput
    convoParts?: ConversationParticipantUpdateManyWithoutUserNestedInput
    sentMessages?: DirectMessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: DirectMessageUpdateManyWithoutReceiverNestedInput
    userBadges?: UserBadgeUpdateManyWithoutUserNestedInput
    gameAccounts?: GameAccountUpdateManyWithoutUserNestedInput
    mtaAccessLogs?: MtaAccessLogUpdateManyWithoutUserNestedInput
    ticketRatingReqGiven?: TicketRatingRequirementUpdateManyWithoutRaterNestedInput
    ticketRatingReqReceived?: TicketRatingRequirementUpdateManyWithoutTargetNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    entitlements?: EntitlementUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    staffShifts?: StaffShiftUpdateManyWithoutUserNestedInput
    staffWeeklyRewards?: StaffWeeklyRewardUpdateManyWithoutUserNestedInput
    adminCasesTarget?: AdminCaseUpdateManyWithoutTargetUserNestedInput
    adminCasesStaff?: AdminCaseUpdateManyWithoutStaffUserNestedInput
  }

  export type UserUncheckedUpdateWithoutReputationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifyToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerifyExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    discordId?: NullableStringFieldUpdateOperationsInput | string | null
    discordUsername?: NullableStringFieldUpdateOperationsInput | string | null
    avatarKey?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    bannedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    whitelistStatus?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    lastSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    topics?: TopicUncheckedUpdateManyWithoutAuthorNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutAuthorNestedInput
    assignedTickets?: TicketUncheckedUpdateManyWithoutAssignedToNestedInput
    ticketMsgs?: TicketMessageUncheckedUpdateManyWithoutAuthorNestedInput
    ticketParticipants?: TicketParticipantUncheckedUpdateManyWithoutUserNestedInput
    ticketParticipantsAdded?: TicketParticipantUncheckedUpdateManyWithoutAddedByNestedInput
    ticketRatingsGiven?: TicketRatingUncheckedUpdateManyWithoutRaterNestedInput
    ticketRatingsReceived?: TicketRatingUncheckedUpdateManyWithoutTargetNestedInput
    closedTickets?: TicketUncheckedUpdateManyWithoutClosedByNestedInput
    purchases?: PurchaseUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    whitelistApps?: WhitelistApplicationUncheckedUpdateManyWithoutUserNestedInput
    reviewedWhitelists?: WhitelistApplicationUncheckedUpdateManyWithoutReviewerNestedInput
    convoParts?: ConversationParticipantUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: DirectMessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: DirectMessageUncheckedUpdateManyWithoutReceiverNestedInput
    userBadges?: UserBadgeUncheckedUpdateManyWithoutUserNestedInput
    gameAccounts?: GameAccountUncheckedUpdateManyWithoutUserNestedInput
    mtaAccessLogs?: MtaAccessLogUncheckedUpdateManyWithoutUserNestedInput
    ticketRatingReqGiven?: TicketRatingRequirementUncheckedUpdateManyWithoutRaterNestedInput
    ticketRatingReqReceived?: TicketRatingRequirementUncheckedUpdateManyWithoutTargetNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    entitlements?: EntitlementUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    staffShifts?: StaffShiftUncheckedUpdateManyWithoutUserNestedInput
    staffWeeklyRewards?: StaffWeeklyRewardUncheckedUpdateManyWithoutUserNestedInput
    adminCasesTarget?: AdminCaseUncheckedUpdateManyWithoutTargetUserNestedInput
    adminCasesStaff?: AdminCaseUncheckedUpdateManyWithoutStaffUserNestedInput
  }

  export type TopicCreateWithoutAuthorInput = {
    id?: string
    title: string
    status?: string
    pinned?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastPostAt?: Date | string
    board: ForumBoardCreateNestedOneWithoutTopicsInput
    posts?: PostCreateNestedManyWithoutTopicInput
  }

  export type TopicUncheckedCreateWithoutAuthorInput = {
    id?: string
    boardId: string
    title: string
    status?: string
    pinned?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastPostAt?: Date | string
    posts?: PostUncheckedCreateNestedManyWithoutTopicInput
  }

  export type TopicCreateOrConnectWithoutAuthorInput = {
    where: TopicWhereUniqueInput
    create: XOR<TopicCreateWithoutAuthorInput, TopicUncheckedCreateWithoutAuthorInput>
  }

  export type TopicCreateManyAuthorInputEnvelope = {
    data: TopicCreateManyAuthorInput | TopicCreateManyAuthorInput[]
  }

  export type PostCreateWithoutAuthorInput = {
    id?: string
    content: string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    topic: TopicCreateNestedOneWithoutPostsInput
    attachments?: PostAttachmentCreateNestedManyWithoutPostInput
  }

  export type PostUncheckedCreateWithoutAuthorInput = {
    id?: string
    topicId: string
    content: string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    attachments?: PostAttachmentUncheckedCreateNestedManyWithoutPostInput
  }

  export type PostCreateOrConnectWithoutAuthorInput = {
    where: PostWhereUniqueInput
    create: XOR<PostCreateWithoutAuthorInput, PostUncheckedCreateWithoutAuthorInput>
  }

  export type PostCreateManyAuthorInputEnvelope = {
    data: PostCreateManyAuthorInput | PostCreateManyAuthorInput[]
  }

  export type TicketCreateWithoutAuthorInput = {
    id?: string
    title: string
    status?: string
    priority?: string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    closedAt?: Date | string | null
    category: TicketCategoryCreateNestedOneWithoutTicketsInput
    assignedTo?: UserCreateNestedOneWithoutAssignedTicketsInput
    closedBy?: UserCreateNestedOneWithoutClosedTicketsInput
    messages?: TicketMessageCreateNestedManyWithoutTicketInput
    participants?: TicketParticipantCreateNestedManyWithoutTicketInput
    ratings?: TicketRatingCreateNestedManyWithoutTicketInput
    ratingRequirements?: TicketRatingRequirementCreateNestedManyWithoutTicketInput
  }

  export type TicketUncheckedCreateWithoutAuthorInput = {
    id?: string
    categoryId: string
    title: string
    status?: string
    priority?: string
    assignedToId?: string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    closedAt?: Date | string | null
    closedById?: string | null
    messages?: TicketMessageUncheckedCreateNestedManyWithoutTicketInput
    participants?: TicketParticipantUncheckedCreateNestedManyWithoutTicketInput
    ratings?: TicketRatingUncheckedCreateNestedManyWithoutTicketInput
    ratingRequirements?: TicketRatingRequirementUncheckedCreateNestedManyWithoutTicketInput
  }

  export type TicketCreateOrConnectWithoutAuthorInput = {
    where: TicketWhereUniqueInput
    create: XOR<TicketCreateWithoutAuthorInput, TicketUncheckedCreateWithoutAuthorInput>
  }

  export type TicketCreateManyAuthorInputEnvelope = {
    data: TicketCreateManyAuthorInput | TicketCreateManyAuthorInput[]
  }

  export type TicketCreateWithoutAssignedToInput = {
    id?: string
    title: string
    status?: string
    priority?: string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    closedAt?: Date | string | null
    category: TicketCategoryCreateNestedOneWithoutTicketsInput
    author: UserCreateNestedOneWithoutTicketsInput
    closedBy?: UserCreateNestedOneWithoutClosedTicketsInput
    messages?: TicketMessageCreateNestedManyWithoutTicketInput
    participants?: TicketParticipantCreateNestedManyWithoutTicketInput
    ratings?: TicketRatingCreateNestedManyWithoutTicketInput
    ratingRequirements?: TicketRatingRequirementCreateNestedManyWithoutTicketInput
  }

  export type TicketUncheckedCreateWithoutAssignedToInput = {
    id?: string
    categoryId: string
    authorId: string
    title: string
    status?: string
    priority?: string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    closedAt?: Date | string | null
    closedById?: string | null
    messages?: TicketMessageUncheckedCreateNestedManyWithoutTicketInput
    participants?: TicketParticipantUncheckedCreateNestedManyWithoutTicketInput
    ratings?: TicketRatingUncheckedCreateNestedManyWithoutTicketInput
    ratingRequirements?: TicketRatingRequirementUncheckedCreateNestedManyWithoutTicketInput
  }

  export type TicketCreateOrConnectWithoutAssignedToInput = {
    where: TicketWhereUniqueInput
    create: XOR<TicketCreateWithoutAssignedToInput, TicketUncheckedCreateWithoutAssignedToInput>
  }

  export type TicketCreateManyAssignedToInputEnvelope = {
    data: TicketCreateManyAssignedToInput | TicketCreateManyAssignedToInput[]
  }

  export type TicketMessageCreateWithoutAuthorInput = {
    id?: string
    content: string
    isDeleted?: boolean
    createdAt?: Date | string
    ticket: TicketCreateNestedOneWithoutMessagesInput
  }

  export type TicketMessageUncheckedCreateWithoutAuthorInput = {
    id?: string
    ticketId: string
    content: string
    isDeleted?: boolean
    createdAt?: Date | string
  }

  export type TicketMessageCreateOrConnectWithoutAuthorInput = {
    where: TicketMessageWhereUniqueInput
    create: XOR<TicketMessageCreateWithoutAuthorInput, TicketMessageUncheckedCreateWithoutAuthorInput>
  }

  export type TicketMessageCreateManyAuthorInputEnvelope = {
    data: TicketMessageCreateManyAuthorInput | TicketMessageCreateManyAuthorInput[]
  }

  export type TicketParticipantCreateWithoutUserInput = {
    createdAt?: Date | string
    ticket: TicketCreateNestedOneWithoutParticipantsInput
    addedBy?: UserCreateNestedOneWithoutTicketParticipantsAddedInput
  }

  export type TicketParticipantUncheckedCreateWithoutUserInput = {
    ticketId: string
    addedById?: string | null
    createdAt?: Date | string
  }

  export type TicketParticipantCreateOrConnectWithoutUserInput = {
    where: TicketParticipantWhereUniqueInput
    create: XOR<TicketParticipantCreateWithoutUserInput, TicketParticipantUncheckedCreateWithoutUserInput>
  }

  export type TicketParticipantCreateManyUserInputEnvelope = {
    data: TicketParticipantCreateManyUserInput | TicketParticipantCreateManyUserInput[]
  }

  export type TicketParticipantCreateWithoutAddedByInput = {
    createdAt?: Date | string
    ticket: TicketCreateNestedOneWithoutParticipantsInput
    user: UserCreateNestedOneWithoutTicketParticipantsInput
  }

  export type TicketParticipantUncheckedCreateWithoutAddedByInput = {
    ticketId: string
    userId: string
    createdAt?: Date | string
  }

  export type TicketParticipantCreateOrConnectWithoutAddedByInput = {
    where: TicketParticipantWhereUniqueInput
    create: XOR<TicketParticipantCreateWithoutAddedByInput, TicketParticipantUncheckedCreateWithoutAddedByInput>
  }

  export type TicketParticipantCreateManyAddedByInputEnvelope = {
    data: TicketParticipantCreateManyAddedByInput | TicketParticipantCreateManyAddedByInput[]
  }

  export type TicketRatingCreateWithoutRaterInput = {
    id?: string
    stars: number
    feedback: string
    createdAt?: Date | string
    ticket: TicketCreateNestedOneWithoutRatingsInput
    target: UserCreateNestedOneWithoutTicketRatingsReceivedInput
  }

  export type TicketRatingUncheckedCreateWithoutRaterInput = {
    id?: string
    ticketId: string
    targetUserId: string
    stars: number
    feedback: string
    createdAt?: Date | string
  }

  export type TicketRatingCreateOrConnectWithoutRaterInput = {
    where: TicketRatingWhereUniqueInput
    create: XOR<TicketRatingCreateWithoutRaterInput, TicketRatingUncheckedCreateWithoutRaterInput>
  }

  export type TicketRatingCreateManyRaterInputEnvelope = {
    data: TicketRatingCreateManyRaterInput | TicketRatingCreateManyRaterInput[]
  }

  export type TicketRatingCreateWithoutTargetInput = {
    id?: string
    stars: number
    feedback: string
    createdAt?: Date | string
    ticket: TicketCreateNestedOneWithoutRatingsInput
    rater: UserCreateNestedOneWithoutTicketRatingsGivenInput
  }

  export type TicketRatingUncheckedCreateWithoutTargetInput = {
    id?: string
    ticketId: string
    raterUserId: string
    stars: number
    feedback: string
    createdAt?: Date | string
  }

  export type TicketRatingCreateOrConnectWithoutTargetInput = {
    where: TicketRatingWhereUniqueInput
    create: XOR<TicketRatingCreateWithoutTargetInput, TicketRatingUncheckedCreateWithoutTargetInput>
  }

  export type TicketRatingCreateManyTargetInputEnvelope = {
    data: TicketRatingCreateManyTargetInput | TicketRatingCreateManyTargetInput[]
  }

  export type TicketCreateWithoutClosedByInput = {
    id?: string
    title: string
    status?: string
    priority?: string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    closedAt?: Date | string | null
    category: TicketCategoryCreateNestedOneWithoutTicketsInput
    author: UserCreateNestedOneWithoutTicketsInput
    assignedTo?: UserCreateNestedOneWithoutAssignedTicketsInput
    messages?: TicketMessageCreateNestedManyWithoutTicketInput
    participants?: TicketParticipantCreateNestedManyWithoutTicketInput
    ratings?: TicketRatingCreateNestedManyWithoutTicketInput
    ratingRequirements?: TicketRatingRequirementCreateNestedManyWithoutTicketInput
  }

  export type TicketUncheckedCreateWithoutClosedByInput = {
    id?: string
    categoryId: string
    authorId: string
    title: string
    status?: string
    priority?: string
    assignedToId?: string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    closedAt?: Date | string | null
    messages?: TicketMessageUncheckedCreateNestedManyWithoutTicketInput
    participants?: TicketParticipantUncheckedCreateNestedManyWithoutTicketInput
    ratings?: TicketRatingUncheckedCreateNestedManyWithoutTicketInput
    ratingRequirements?: TicketRatingRequirementUncheckedCreateNestedManyWithoutTicketInput
  }

  export type TicketCreateOrConnectWithoutClosedByInput = {
    where: TicketWhereUniqueInput
    create: XOR<TicketCreateWithoutClosedByInput, TicketUncheckedCreateWithoutClosedByInput>
  }

  export type TicketCreateManyClosedByInputEnvelope = {
    data: TicketCreateManyClosedByInput | TicketCreateManyClosedByInput[]
  }

  export type PurchaseCreateWithoutUserInput = {
    id?: string
    provider: string
    externalId?: string | null
    status?: string
    amountCents: number
    currency?: string
    meta?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: PurchaseItemCreateNestedManyWithoutPurchaseInput
  }

  export type PurchaseUncheckedCreateWithoutUserInput = {
    id?: string
    provider: string
    externalId?: string | null
    status?: string
    amountCents: number
    currency?: string
    meta?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: PurchaseItemUncheckedCreateNestedManyWithoutPurchaseInput
  }

  export type PurchaseCreateOrConnectWithoutUserInput = {
    where: PurchaseWhereUniqueInput
    create: XOR<PurchaseCreateWithoutUserInput, PurchaseUncheckedCreateWithoutUserInput>
  }

  export type PurchaseCreateManyUserInputEnvelope = {
    data: PurchaseCreateManyUserInput | PurchaseCreateManyUserInput[]
  }

  export type AuditLogCreateWithoutActorInput = {
    id?: string
    action: string
    entityType: string
    entityId?: string | null
    ip?: string | null
    userAgent?: string | null
    meta?: string | null
    createdAt?: Date | string
  }

  export type AuditLogUncheckedCreateWithoutActorInput = {
    id?: string
    action: string
    entityType: string
    entityId?: string | null
    ip?: string | null
    userAgent?: string | null
    meta?: string | null
    createdAt?: Date | string
  }

  export type AuditLogCreateOrConnectWithoutActorInput = {
    where: AuditLogWhereUniqueInput
    create: XOR<AuditLogCreateWithoutActorInput, AuditLogUncheckedCreateWithoutActorInput>
  }

  export type AuditLogCreateManyActorInputEnvelope = {
    data: AuditLogCreateManyActorInput | AuditLogCreateManyActorInput[]
  }

  export type UserRoleCreateWithoutUserInput = {
    role: RoleCreateNestedOneWithoutUsersInput
  }

  export type UserRoleUncheckedCreateWithoutUserInput = {
    roleId: string
  }

  export type UserRoleCreateOrConnectWithoutUserInput = {
    where: UserRoleWhereUniqueInput
    create: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput>
  }

  export type UserRoleCreateManyUserInputEnvelope = {
    data: UserRoleCreateManyUserInput | UserRoleCreateManyUserInput[]
  }

  export type WhitelistApplicationCreateWithoutUserInput = {
    id?: string
    status?: string
    rejectReason?: string | null
    createdAt?: Date | string
    reviewedAt?: Date | string | null
    reviewer?: UserCreateNestedOneWithoutReviewedWhitelistsInput
    answers?: WhitelistAnswerCreateNestedManyWithoutApplicationInput
  }

  export type WhitelistApplicationUncheckedCreateWithoutUserInput = {
    id?: string
    status?: string
    reviewerId?: string | null
    rejectReason?: string | null
    createdAt?: Date | string
    reviewedAt?: Date | string | null
    answers?: WhitelistAnswerUncheckedCreateNestedManyWithoutApplicationInput
  }

  export type WhitelistApplicationCreateOrConnectWithoutUserInput = {
    where: WhitelistApplicationWhereUniqueInput
    create: XOR<WhitelistApplicationCreateWithoutUserInput, WhitelistApplicationUncheckedCreateWithoutUserInput>
  }

  export type WhitelistApplicationCreateManyUserInputEnvelope = {
    data: WhitelistApplicationCreateManyUserInput | WhitelistApplicationCreateManyUserInput[]
  }

  export type WhitelistApplicationCreateWithoutReviewerInput = {
    id?: string
    status?: string
    rejectReason?: string | null
    createdAt?: Date | string
    reviewedAt?: Date | string | null
    user: UserCreateNestedOneWithoutWhitelistAppsInput
    answers?: WhitelistAnswerCreateNestedManyWithoutApplicationInput
  }

  export type WhitelistApplicationUncheckedCreateWithoutReviewerInput = {
    id?: string
    userId: string
    status?: string
    rejectReason?: string | null
    createdAt?: Date | string
    reviewedAt?: Date | string | null
    answers?: WhitelistAnswerUncheckedCreateNestedManyWithoutApplicationInput
  }

  export type WhitelistApplicationCreateOrConnectWithoutReviewerInput = {
    where: WhitelistApplicationWhereUniqueInput
    create: XOR<WhitelistApplicationCreateWithoutReviewerInput, WhitelistApplicationUncheckedCreateWithoutReviewerInput>
  }

  export type WhitelistApplicationCreateManyReviewerInputEnvelope = {
    data: WhitelistApplicationCreateManyReviewerInput | WhitelistApplicationCreateManyReviewerInput[]
  }

  export type ConversationParticipantCreateWithoutUserInput = {
    createdAt?: Date | string
    conversation: ConversationCreateNestedOneWithoutParticipantsInput
  }

  export type ConversationParticipantUncheckedCreateWithoutUserInput = {
    conversationId: string
    createdAt?: Date | string
  }

  export type ConversationParticipantCreateOrConnectWithoutUserInput = {
    where: ConversationParticipantWhereUniqueInput
    create: XOR<ConversationParticipantCreateWithoutUserInput, ConversationParticipantUncheckedCreateWithoutUserInput>
  }

  export type ConversationParticipantCreateManyUserInputEnvelope = {
    data: ConversationParticipantCreateManyUserInput | ConversationParticipantCreateManyUserInput[]
  }

  export type DirectMessageCreateWithoutSenderInput = {
    id?: string
    content: string
    kind?: string
    isDeleted?: boolean
    createdAt?: Date | string
    conversation: ConversationCreateNestedOneWithoutMessagesInput
    receiver: UserCreateNestedOneWithoutReceivedMessagesInput
  }

  export type DirectMessageUncheckedCreateWithoutSenderInput = {
    id?: string
    conversationId: string
    receiverId: string
    content: string
    kind?: string
    isDeleted?: boolean
    createdAt?: Date | string
  }

  export type DirectMessageCreateOrConnectWithoutSenderInput = {
    where: DirectMessageWhereUniqueInput
    create: XOR<DirectMessageCreateWithoutSenderInput, DirectMessageUncheckedCreateWithoutSenderInput>
  }

  export type DirectMessageCreateManySenderInputEnvelope = {
    data: DirectMessageCreateManySenderInput | DirectMessageCreateManySenderInput[]
  }

  export type DirectMessageCreateWithoutReceiverInput = {
    id?: string
    content: string
    kind?: string
    isDeleted?: boolean
    createdAt?: Date | string
    conversation: ConversationCreateNestedOneWithoutMessagesInput
    sender: UserCreateNestedOneWithoutSentMessagesInput
  }

  export type DirectMessageUncheckedCreateWithoutReceiverInput = {
    id?: string
    conversationId: string
    senderId: string
    content: string
    kind?: string
    isDeleted?: boolean
    createdAt?: Date | string
  }

  export type DirectMessageCreateOrConnectWithoutReceiverInput = {
    where: DirectMessageWhereUniqueInput
    create: XOR<DirectMessageCreateWithoutReceiverInput, DirectMessageUncheckedCreateWithoutReceiverInput>
  }

  export type DirectMessageCreateManyReceiverInputEnvelope = {
    data: DirectMessageCreateManyReceiverInput | DirectMessageCreateManyReceiverInput[]
  }

  export type UserBadgeCreateWithoutUserInput = {
    createdAt?: Date | string
    badge: BadgeCreateNestedOneWithoutUsersInput
  }

  export type UserBadgeUncheckedCreateWithoutUserInput = {
    badgeId: string
    createdAt?: Date | string
  }

  export type UserBadgeCreateOrConnectWithoutUserInput = {
    where: UserBadgeWhereUniqueInput
    create: XOR<UserBadgeCreateWithoutUserInput, UserBadgeUncheckedCreateWithoutUserInput>
  }

  export type UserBadgeCreateManyUserInputEnvelope = {
    data: UserBadgeCreateManyUserInput | UserBadgeCreateManyUserInput[]
  }

  export type GameAccountCreateWithoutUserInput = {
    id?: string
    mtaSerial: string
    mtaAccount?: string | null
    locked?: boolean
    changedAfterApproved?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GameAccountUncheckedCreateWithoutUserInput = {
    id?: string
    mtaSerial: string
    mtaAccount?: string | null
    locked?: boolean
    changedAfterApproved?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GameAccountCreateOrConnectWithoutUserInput = {
    where: GameAccountWhereUniqueInput
    create: XOR<GameAccountCreateWithoutUserInput, GameAccountUncheckedCreateWithoutUserInput>
  }

  export type GameAccountCreateManyUserInputEnvelope = {
    data: GameAccountCreateManyUserInput | GameAccountCreateManyUserInput[]
  }

  export type MtaAccessLogCreateWithoutUserInput = {
    id?: string
    serial: string
    allowed: boolean
    reason?: string | null
    ip?: string | null
    createdAt?: Date | string
  }

  export type MtaAccessLogUncheckedCreateWithoutUserInput = {
    id?: string
    serial: string
    allowed: boolean
    reason?: string | null
    ip?: string | null
    createdAt?: Date | string
  }

  export type MtaAccessLogCreateOrConnectWithoutUserInput = {
    where: MtaAccessLogWhereUniqueInput
    create: XOR<MtaAccessLogCreateWithoutUserInput, MtaAccessLogUncheckedCreateWithoutUserInput>
  }

  export type MtaAccessLogCreateManyUserInputEnvelope = {
    data: MtaAccessLogCreateManyUserInput | MtaAccessLogCreateManyUserInput[]
  }

  export type TicketRatingRequirementCreateWithoutRaterInput = {
    id?: string
    completed?: boolean
    createdAt?: Date | string
    ticket: TicketCreateNestedOneWithoutRatingRequirementsInput
    target: UserCreateNestedOneWithoutTicketRatingReqReceivedInput
  }

  export type TicketRatingRequirementUncheckedCreateWithoutRaterInput = {
    id?: string
    ticketId: string
    targetId: string
    completed?: boolean
    createdAt?: Date | string
  }

  export type TicketRatingRequirementCreateOrConnectWithoutRaterInput = {
    where: TicketRatingRequirementWhereUniqueInput
    create: XOR<TicketRatingRequirementCreateWithoutRaterInput, TicketRatingRequirementUncheckedCreateWithoutRaterInput>
  }

  export type TicketRatingRequirementCreateManyRaterInputEnvelope = {
    data: TicketRatingRequirementCreateManyRaterInput | TicketRatingRequirementCreateManyRaterInput[]
  }

  export type TicketRatingRequirementCreateWithoutTargetInput = {
    id?: string
    completed?: boolean
    createdAt?: Date | string
    ticket: TicketCreateNestedOneWithoutRatingRequirementsInput
    rater: UserCreateNestedOneWithoutTicketRatingReqGivenInput
  }

  export type TicketRatingRequirementUncheckedCreateWithoutTargetInput = {
    id?: string
    ticketId: string
    raterId: string
    completed?: boolean
    createdAt?: Date | string
  }

  export type TicketRatingRequirementCreateOrConnectWithoutTargetInput = {
    where: TicketRatingRequirementWhereUniqueInput
    create: XOR<TicketRatingRequirementCreateWithoutTargetInput, TicketRatingRequirementUncheckedCreateWithoutTargetInput>
  }

  export type TicketRatingRequirementCreateManyTargetInputEnvelope = {
    data: TicketRatingRequirementCreateManyTargetInput | TicketRatingRequirementCreateManyTargetInput[]
  }

  export type PasswordResetTokenCreateWithoutUserInput = {
    id?: string
    code: string
    expiresAt: Date | string
    usedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type PasswordResetTokenUncheckedCreateWithoutUserInput = {
    id?: string
    code: string
    expiresAt: Date | string
    usedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type PasswordResetTokenCreateOrConnectWithoutUserInput = {
    where: PasswordResetTokenWhereUniqueInput
    create: XOR<PasswordResetTokenCreateWithoutUserInput, PasswordResetTokenUncheckedCreateWithoutUserInput>
  }

  export type PasswordResetTokenCreateManyUserInputEnvelope = {
    data: PasswordResetTokenCreateManyUserInput | PasswordResetTokenCreateManyUserInput[]
  }

  export type EntitlementCreateWithoutUserInput = {
    id?: string
    roleName: string
    expiresAt: Date | string
    source?: string | null
    createdAt?: Date | string
  }

  export type EntitlementUncheckedCreateWithoutUserInput = {
    id?: string
    roleName: string
    expiresAt: Date | string
    source?: string | null
    createdAt?: Date | string
  }

  export type EntitlementCreateOrConnectWithoutUserInput = {
    where: EntitlementWhereUniqueInput
    create: XOR<EntitlementCreateWithoutUserInput, EntitlementUncheckedCreateWithoutUserInput>
  }

  export type EntitlementCreateManyUserInputEnvelope = {
    data: EntitlementCreateManyUserInput | EntitlementCreateManyUserInput[]
  }

  export type NotificationCreateWithoutUserInput = {
    id?: string
    message: string
    href?: string | null
    read?: boolean
    createdAt?: Date | string
  }

  export type NotificationUncheckedCreateWithoutUserInput = {
    id?: string
    message: string
    href?: string | null
    read?: boolean
    createdAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutUserInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationCreateManyUserInputEnvelope = {
    data: NotificationCreateManyUserInput | NotificationCreateManyUserInput[]
  }

  export type StaffShiftCreateWithoutUserInput = {
    id?: string
    openedAt: Date | string
    closedAt?: Date | string | null
    seconds?: number
    createdAt?: Date | string
  }

  export type StaffShiftUncheckedCreateWithoutUserInput = {
    id?: string
    openedAt: Date | string
    closedAt?: Date | string | null
    seconds?: number
    createdAt?: Date | string
  }

  export type StaffShiftCreateOrConnectWithoutUserInput = {
    where: StaffShiftWhereUniqueInput
    create: XOR<StaffShiftCreateWithoutUserInput, StaffShiftUncheckedCreateWithoutUserInput>
  }

  export type StaffShiftCreateManyUserInputEnvelope = {
    data: StaffShiftCreateManyUserInput | StaffShiftCreateManyUserInput[]
  }

  export type StaffWeeklyRewardCreateWithoutUserInput = {
    id?: string
    position: number
    weekKey: string
    createdAt?: Date | string
  }

  export type StaffWeeklyRewardUncheckedCreateWithoutUserInput = {
    id?: string
    position: number
    weekKey: string
    createdAt?: Date | string
  }

  export type StaffWeeklyRewardCreateOrConnectWithoutUserInput = {
    where: StaffWeeklyRewardWhereUniqueInput
    create: XOR<StaffWeeklyRewardCreateWithoutUserInput, StaffWeeklyRewardUncheckedCreateWithoutUserInput>
  }

  export type StaffWeeklyRewardCreateManyUserInputEnvelope = {
    data: StaffWeeklyRewardCreateManyUserInput | StaffWeeklyRewardCreateManyUserInput[]
  }

  export type AdminCaseCreateWithoutTargetUserInput = {
    id?: string
    type: string
    reason: string
    expiresAt?: Date | string | null
    active?: boolean
    createdAt?: Date | string
    staffUser: UserCreateNestedOneWithoutAdminCasesStaffInput
  }

  export type AdminCaseUncheckedCreateWithoutTargetUserInput = {
    id?: string
    staffUserId: string
    type: string
    reason: string
    expiresAt?: Date | string | null
    active?: boolean
    createdAt?: Date | string
  }

  export type AdminCaseCreateOrConnectWithoutTargetUserInput = {
    where: AdminCaseWhereUniqueInput
    create: XOR<AdminCaseCreateWithoutTargetUserInput, AdminCaseUncheckedCreateWithoutTargetUserInput>
  }

  export type AdminCaseCreateManyTargetUserInputEnvelope = {
    data: AdminCaseCreateManyTargetUserInput | AdminCaseCreateManyTargetUserInput[]
  }

  export type AdminCaseCreateWithoutStaffUserInput = {
    id?: string
    type: string
    reason: string
    expiresAt?: Date | string | null
    active?: boolean
    createdAt?: Date | string
    targetUser: UserCreateNestedOneWithoutAdminCasesTargetInput
  }

  export type AdminCaseUncheckedCreateWithoutStaffUserInput = {
    id?: string
    targetUserId: string
    type: string
    reason: string
    expiresAt?: Date | string | null
    active?: boolean
    createdAt?: Date | string
  }

  export type AdminCaseCreateOrConnectWithoutStaffUserInput = {
    where: AdminCaseWhereUniqueInput
    create: XOR<AdminCaseCreateWithoutStaffUserInput, AdminCaseUncheckedCreateWithoutStaffUserInput>
  }

  export type AdminCaseCreateManyStaffUserInputEnvelope = {
    data: AdminCaseCreateManyStaffUserInput | AdminCaseCreateManyStaffUserInput[]
  }

  export type UserReputationCreateWithoutUserInput = {
    score?: number
    updatedAt?: Date | string
  }

  export type UserReputationUncheckedCreateWithoutUserInput = {
    score?: number
    updatedAt?: Date | string
  }

  export type UserReputationCreateOrConnectWithoutUserInput = {
    where: UserReputationWhereUniqueInput
    create: XOR<UserReputationCreateWithoutUserInput, UserReputationUncheckedCreateWithoutUserInput>
  }

  export type TopicUpsertWithWhereUniqueWithoutAuthorInput = {
    where: TopicWhereUniqueInput
    update: XOR<TopicUpdateWithoutAuthorInput, TopicUncheckedUpdateWithoutAuthorInput>
    create: XOR<TopicCreateWithoutAuthorInput, TopicUncheckedCreateWithoutAuthorInput>
  }

  export type TopicUpdateWithWhereUniqueWithoutAuthorInput = {
    where: TopicWhereUniqueInput
    data: XOR<TopicUpdateWithoutAuthorInput, TopicUncheckedUpdateWithoutAuthorInput>
  }

  export type TopicUpdateManyWithWhereWithoutAuthorInput = {
    where: TopicScalarWhereInput
    data: XOR<TopicUpdateManyMutationInput, TopicUncheckedUpdateManyWithoutAuthorInput>
  }

  export type TopicScalarWhereInput = {
    AND?: TopicScalarWhereInput | TopicScalarWhereInput[]
    OR?: TopicScalarWhereInput[]
    NOT?: TopicScalarWhereInput | TopicScalarWhereInput[]
    id?: StringFilter<"Topic"> | string
    boardId?: StringFilter<"Topic"> | string
    authorId?: StringFilter<"Topic"> | string
    title?: StringFilter<"Topic"> | string
    status?: StringFilter<"Topic"> | string
    pinned?: BoolFilter<"Topic"> | boolean
    isDeleted?: BoolFilter<"Topic"> | boolean
    createdAt?: DateTimeFilter<"Topic"> | Date | string
    updatedAt?: DateTimeFilter<"Topic"> | Date | string
    lastPostAt?: DateTimeFilter<"Topic"> | Date | string
  }

  export type PostUpsertWithWhereUniqueWithoutAuthorInput = {
    where: PostWhereUniqueInput
    update: XOR<PostUpdateWithoutAuthorInput, PostUncheckedUpdateWithoutAuthorInput>
    create: XOR<PostCreateWithoutAuthorInput, PostUncheckedCreateWithoutAuthorInput>
  }

  export type PostUpdateWithWhereUniqueWithoutAuthorInput = {
    where: PostWhereUniqueInput
    data: XOR<PostUpdateWithoutAuthorInput, PostUncheckedUpdateWithoutAuthorInput>
  }

  export type PostUpdateManyWithWhereWithoutAuthorInput = {
    where: PostScalarWhereInput
    data: XOR<PostUpdateManyMutationInput, PostUncheckedUpdateManyWithoutAuthorInput>
  }

  export type PostScalarWhereInput = {
    AND?: PostScalarWhereInput | PostScalarWhereInput[]
    OR?: PostScalarWhereInput[]
    NOT?: PostScalarWhereInput | PostScalarWhereInput[]
    id?: StringFilter<"Post"> | string
    topicId?: StringFilter<"Post"> | string
    authorId?: StringFilter<"Post"> | string
    content?: StringFilter<"Post"> | string
    isDeleted?: BoolFilter<"Post"> | boolean
    createdAt?: DateTimeFilter<"Post"> | Date | string
    updatedAt?: DateTimeFilter<"Post"> | Date | string
  }

  export type TicketUpsertWithWhereUniqueWithoutAuthorInput = {
    where: TicketWhereUniqueInput
    update: XOR<TicketUpdateWithoutAuthorInput, TicketUncheckedUpdateWithoutAuthorInput>
    create: XOR<TicketCreateWithoutAuthorInput, TicketUncheckedCreateWithoutAuthorInput>
  }

  export type TicketUpdateWithWhereUniqueWithoutAuthorInput = {
    where: TicketWhereUniqueInput
    data: XOR<TicketUpdateWithoutAuthorInput, TicketUncheckedUpdateWithoutAuthorInput>
  }

  export type TicketUpdateManyWithWhereWithoutAuthorInput = {
    where: TicketScalarWhereInput
    data: XOR<TicketUpdateManyMutationInput, TicketUncheckedUpdateManyWithoutAuthorInput>
  }

  export type TicketScalarWhereInput = {
    AND?: TicketScalarWhereInput | TicketScalarWhereInput[]
    OR?: TicketScalarWhereInput[]
    NOT?: TicketScalarWhereInput | TicketScalarWhereInput[]
    id?: StringFilter<"Ticket"> | string
    categoryId?: StringFilter<"Ticket"> | string
    authorId?: StringFilter<"Ticket"> | string
    title?: StringFilter<"Ticket"> | string
    status?: StringFilter<"Ticket"> | string
    priority?: StringFilter<"Ticket"> | string
    assignedToId?: StringNullableFilter<"Ticket"> | string | null
    isDeleted?: BoolFilter<"Ticket"> | boolean
    createdAt?: DateTimeFilter<"Ticket"> | Date | string
    updatedAt?: DateTimeFilter<"Ticket"> | Date | string
    closedAt?: DateTimeNullableFilter<"Ticket"> | Date | string | null
    closedById?: StringNullableFilter<"Ticket"> | string | null
  }

  export type TicketUpsertWithWhereUniqueWithoutAssignedToInput = {
    where: TicketWhereUniqueInput
    update: XOR<TicketUpdateWithoutAssignedToInput, TicketUncheckedUpdateWithoutAssignedToInput>
    create: XOR<TicketCreateWithoutAssignedToInput, TicketUncheckedCreateWithoutAssignedToInput>
  }

  export type TicketUpdateWithWhereUniqueWithoutAssignedToInput = {
    where: TicketWhereUniqueInput
    data: XOR<TicketUpdateWithoutAssignedToInput, TicketUncheckedUpdateWithoutAssignedToInput>
  }

  export type TicketUpdateManyWithWhereWithoutAssignedToInput = {
    where: TicketScalarWhereInput
    data: XOR<TicketUpdateManyMutationInput, TicketUncheckedUpdateManyWithoutAssignedToInput>
  }

  export type TicketMessageUpsertWithWhereUniqueWithoutAuthorInput = {
    where: TicketMessageWhereUniqueInput
    update: XOR<TicketMessageUpdateWithoutAuthorInput, TicketMessageUncheckedUpdateWithoutAuthorInput>
    create: XOR<TicketMessageCreateWithoutAuthorInput, TicketMessageUncheckedCreateWithoutAuthorInput>
  }

  export type TicketMessageUpdateWithWhereUniqueWithoutAuthorInput = {
    where: TicketMessageWhereUniqueInput
    data: XOR<TicketMessageUpdateWithoutAuthorInput, TicketMessageUncheckedUpdateWithoutAuthorInput>
  }

  export type TicketMessageUpdateManyWithWhereWithoutAuthorInput = {
    where: TicketMessageScalarWhereInput
    data: XOR<TicketMessageUpdateManyMutationInput, TicketMessageUncheckedUpdateManyWithoutAuthorInput>
  }

  export type TicketMessageScalarWhereInput = {
    AND?: TicketMessageScalarWhereInput | TicketMessageScalarWhereInput[]
    OR?: TicketMessageScalarWhereInput[]
    NOT?: TicketMessageScalarWhereInput | TicketMessageScalarWhereInput[]
    id?: StringFilter<"TicketMessage"> | string
    ticketId?: StringFilter<"TicketMessage"> | string
    authorId?: StringFilter<"TicketMessage"> | string
    content?: StringFilter<"TicketMessage"> | string
    isDeleted?: BoolFilter<"TicketMessage"> | boolean
    createdAt?: DateTimeFilter<"TicketMessage"> | Date | string
  }

  export type TicketParticipantUpsertWithWhereUniqueWithoutUserInput = {
    where: TicketParticipantWhereUniqueInput
    update: XOR<TicketParticipantUpdateWithoutUserInput, TicketParticipantUncheckedUpdateWithoutUserInput>
    create: XOR<TicketParticipantCreateWithoutUserInput, TicketParticipantUncheckedCreateWithoutUserInput>
  }

  export type TicketParticipantUpdateWithWhereUniqueWithoutUserInput = {
    where: TicketParticipantWhereUniqueInput
    data: XOR<TicketParticipantUpdateWithoutUserInput, TicketParticipantUncheckedUpdateWithoutUserInput>
  }

  export type TicketParticipantUpdateManyWithWhereWithoutUserInput = {
    where: TicketParticipantScalarWhereInput
    data: XOR<TicketParticipantUpdateManyMutationInput, TicketParticipantUncheckedUpdateManyWithoutUserInput>
  }

  export type TicketParticipantScalarWhereInput = {
    AND?: TicketParticipantScalarWhereInput | TicketParticipantScalarWhereInput[]
    OR?: TicketParticipantScalarWhereInput[]
    NOT?: TicketParticipantScalarWhereInput | TicketParticipantScalarWhereInput[]
    ticketId?: StringFilter<"TicketParticipant"> | string
    userId?: StringFilter<"TicketParticipant"> | string
    addedById?: StringNullableFilter<"TicketParticipant"> | string | null
    createdAt?: DateTimeFilter<"TicketParticipant"> | Date | string
  }

  export type TicketParticipantUpsertWithWhereUniqueWithoutAddedByInput = {
    where: TicketParticipantWhereUniqueInput
    update: XOR<TicketParticipantUpdateWithoutAddedByInput, TicketParticipantUncheckedUpdateWithoutAddedByInput>
    create: XOR<TicketParticipantCreateWithoutAddedByInput, TicketParticipantUncheckedCreateWithoutAddedByInput>
  }

  export type TicketParticipantUpdateWithWhereUniqueWithoutAddedByInput = {
    where: TicketParticipantWhereUniqueInput
    data: XOR<TicketParticipantUpdateWithoutAddedByInput, TicketParticipantUncheckedUpdateWithoutAddedByInput>
  }

  export type TicketParticipantUpdateManyWithWhereWithoutAddedByInput = {
    where: TicketParticipantScalarWhereInput
    data: XOR<TicketParticipantUpdateManyMutationInput, TicketParticipantUncheckedUpdateManyWithoutAddedByInput>
  }

  export type TicketRatingUpsertWithWhereUniqueWithoutRaterInput = {
    where: TicketRatingWhereUniqueInput
    update: XOR<TicketRatingUpdateWithoutRaterInput, TicketRatingUncheckedUpdateWithoutRaterInput>
    create: XOR<TicketRatingCreateWithoutRaterInput, TicketRatingUncheckedCreateWithoutRaterInput>
  }

  export type TicketRatingUpdateWithWhereUniqueWithoutRaterInput = {
    where: TicketRatingWhereUniqueInput
    data: XOR<TicketRatingUpdateWithoutRaterInput, TicketRatingUncheckedUpdateWithoutRaterInput>
  }

  export type TicketRatingUpdateManyWithWhereWithoutRaterInput = {
    where: TicketRatingScalarWhereInput
    data: XOR<TicketRatingUpdateManyMutationInput, TicketRatingUncheckedUpdateManyWithoutRaterInput>
  }

  export type TicketRatingScalarWhereInput = {
    AND?: TicketRatingScalarWhereInput | TicketRatingScalarWhereInput[]
    OR?: TicketRatingScalarWhereInput[]
    NOT?: TicketRatingScalarWhereInput | TicketRatingScalarWhereInput[]
    id?: StringFilter<"TicketRating"> | string
    ticketId?: StringFilter<"TicketRating"> | string
    raterUserId?: StringFilter<"TicketRating"> | string
    targetUserId?: StringFilter<"TicketRating"> | string
    stars?: IntFilter<"TicketRating"> | number
    feedback?: StringFilter<"TicketRating"> | string
    createdAt?: DateTimeFilter<"TicketRating"> | Date | string
  }

  export type TicketRatingUpsertWithWhereUniqueWithoutTargetInput = {
    where: TicketRatingWhereUniqueInput
    update: XOR<TicketRatingUpdateWithoutTargetInput, TicketRatingUncheckedUpdateWithoutTargetInput>
    create: XOR<TicketRatingCreateWithoutTargetInput, TicketRatingUncheckedCreateWithoutTargetInput>
  }

  export type TicketRatingUpdateWithWhereUniqueWithoutTargetInput = {
    where: TicketRatingWhereUniqueInput
    data: XOR<TicketRatingUpdateWithoutTargetInput, TicketRatingUncheckedUpdateWithoutTargetInput>
  }

  export type TicketRatingUpdateManyWithWhereWithoutTargetInput = {
    where: TicketRatingScalarWhereInput
    data: XOR<TicketRatingUpdateManyMutationInput, TicketRatingUncheckedUpdateManyWithoutTargetInput>
  }

  export type TicketUpsertWithWhereUniqueWithoutClosedByInput = {
    where: TicketWhereUniqueInput
    update: XOR<TicketUpdateWithoutClosedByInput, TicketUncheckedUpdateWithoutClosedByInput>
    create: XOR<TicketCreateWithoutClosedByInput, TicketUncheckedCreateWithoutClosedByInput>
  }

  export type TicketUpdateWithWhereUniqueWithoutClosedByInput = {
    where: TicketWhereUniqueInput
    data: XOR<TicketUpdateWithoutClosedByInput, TicketUncheckedUpdateWithoutClosedByInput>
  }

  export type TicketUpdateManyWithWhereWithoutClosedByInput = {
    where: TicketScalarWhereInput
    data: XOR<TicketUpdateManyMutationInput, TicketUncheckedUpdateManyWithoutClosedByInput>
  }

  export type PurchaseUpsertWithWhereUniqueWithoutUserInput = {
    where: PurchaseWhereUniqueInput
    update: XOR<PurchaseUpdateWithoutUserInput, PurchaseUncheckedUpdateWithoutUserInput>
    create: XOR<PurchaseCreateWithoutUserInput, PurchaseUncheckedCreateWithoutUserInput>
  }

  export type PurchaseUpdateWithWhereUniqueWithoutUserInput = {
    where: PurchaseWhereUniqueInput
    data: XOR<PurchaseUpdateWithoutUserInput, PurchaseUncheckedUpdateWithoutUserInput>
  }

  export type PurchaseUpdateManyWithWhereWithoutUserInput = {
    where: PurchaseScalarWhereInput
    data: XOR<PurchaseUpdateManyMutationInput, PurchaseUncheckedUpdateManyWithoutUserInput>
  }

  export type PurchaseScalarWhereInput = {
    AND?: PurchaseScalarWhereInput | PurchaseScalarWhereInput[]
    OR?: PurchaseScalarWhereInput[]
    NOT?: PurchaseScalarWhereInput | PurchaseScalarWhereInput[]
    id?: StringFilter<"Purchase"> | string
    userId?: StringFilter<"Purchase"> | string
    provider?: StringFilter<"Purchase"> | string
    externalId?: StringNullableFilter<"Purchase"> | string | null
    status?: StringFilter<"Purchase"> | string
    amountCents?: IntFilter<"Purchase"> | number
    currency?: StringFilter<"Purchase"> | string
    meta?: StringNullableFilter<"Purchase"> | string | null
    createdAt?: DateTimeFilter<"Purchase"> | Date | string
    updatedAt?: DateTimeFilter<"Purchase"> | Date | string
  }

  export type AuditLogUpsertWithWhereUniqueWithoutActorInput = {
    where: AuditLogWhereUniqueInput
    update: XOR<AuditLogUpdateWithoutActorInput, AuditLogUncheckedUpdateWithoutActorInput>
    create: XOR<AuditLogCreateWithoutActorInput, AuditLogUncheckedCreateWithoutActorInput>
  }

  export type AuditLogUpdateWithWhereUniqueWithoutActorInput = {
    where: AuditLogWhereUniqueInput
    data: XOR<AuditLogUpdateWithoutActorInput, AuditLogUncheckedUpdateWithoutActorInput>
  }

  export type AuditLogUpdateManyWithWhereWithoutActorInput = {
    where: AuditLogScalarWhereInput
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyWithoutActorInput>
  }

  export type AuditLogScalarWhereInput = {
    AND?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    OR?: AuditLogScalarWhereInput[]
    NOT?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    actorId?: StringNullableFilter<"AuditLog"> | string | null
    action?: StringFilter<"AuditLog"> | string
    entityType?: StringFilter<"AuditLog"> | string
    entityId?: StringNullableFilter<"AuditLog"> | string | null
    ip?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    meta?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
  }

  export type UserRoleUpsertWithWhereUniqueWithoutUserInput = {
    where: UserRoleWhereUniqueInput
    update: XOR<UserRoleUpdateWithoutUserInput, UserRoleUncheckedUpdateWithoutUserInput>
    create: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput>
  }

  export type UserRoleUpdateWithWhereUniqueWithoutUserInput = {
    where: UserRoleWhereUniqueInput
    data: XOR<UserRoleUpdateWithoutUserInput, UserRoleUncheckedUpdateWithoutUserInput>
  }

  export type UserRoleUpdateManyWithWhereWithoutUserInput = {
    where: UserRoleScalarWhereInput
    data: XOR<UserRoleUpdateManyMutationInput, UserRoleUncheckedUpdateManyWithoutUserInput>
  }

  export type UserRoleScalarWhereInput = {
    AND?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
    OR?: UserRoleScalarWhereInput[]
    NOT?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
    userId?: StringFilter<"UserRole"> | string
    roleId?: StringFilter<"UserRole"> | string
  }

  export type WhitelistApplicationUpsertWithWhereUniqueWithoutUserInput = {
    where: WhitelistApplicationWhereUniqueInput
    update: XOR<WhitelistApplicationUpdateWithoutUserInput, WhitelistApplicationUncheckedUpdateWithoutUserInput>
    create: XOR<WhitelistApplicationCreateWithoutUserInput, WhitelistApplicationUncheckedCreateWithoutUserInput>
  }

  export type WhitelistApplicationUpdateWithWhereUniqueWithoutUserInput = {
    where: WhitelistApplicationWhereUniqueInput
    data: XOR<WhitelistApplicationUpdateWithoutUserInput, WhitelistApplicationUncheckedUpdateWithoutUserInput>
  }

  export type WhitelistApplicationUpdateManyWithWhereWithoutUserInput = {
    where: WhitelistApplicationScalarWhereInput
    data: XOR<WhitelistApplicationUpdateManyMutationInput, WhitelistApplicationUncheckedUpdateManyWithoutUserInput>
  }

  export type WhitelistApplicationScalarWhereInput = {
    AND?: WhitelistApplicationScalarWhereInput | WhitelistApplicationScalarWhereInput[]
    OR?: WhitelistApplicationScalarWhereInput[]
    NOT?: WhitelistApplicationScalarWhereInput | WhitelistApplicationScalarWhereInput[]
    id?: StringFilter<"WhitelistApplication"> | string
    userId?: StringFilter<"WhitelistApplication"> | string
    status?: StringFilter<"WhitelistApplication"> | string
    reviewerId?: StringNullableFilter<"WhitelistApplication"> | string | null
    rejectReason?: StringNullableFilter<"WhitelistApplication"> | string | null
    createdAt?: DateTimeFilter<"WhitelistApplication"> | Date | string
    reviewedAt?: DateTimeNullableFilter<"WhitelistApplication"> | Date | string | null
  }

  export type WhitelistApplicationUpsertWithWhereUniqueWithoutReviewerInput = {
    where: WhitelistApplicationWhereUniqueInput
    update: XOR<WhitelistApplicationUpdateWithoutReviewerInput, WhitelistApplicationUncheckedUpdateWithoutReviewerInput>
    create: XOR<WhitelistApplicationCreateWithoutReviewerInput, WhitelistApplicationUncheckedCreateWithoutReviewerInput>
  }

  export type WhitelistApplicationUpdateWithWhereUniqueWithoutReviewerInput = {
    where: WhitelistApplicationWhereUniqueInput
    data: XOR<WhitelistApplicationUpdateWithoutReviewerInput, WhitelistApplicationUncheckedUpdateWithoutReviewerInput>
  }

  export type WhitelistApplicationUpdateManyWithWhereWithoutReviewerInput = {
    where: WhitelistApplicationScalarWhereInput
    data: XOR<WhitelistApplicationUpdateManyMutationInput, WhitelistApplicationUncheckedUpdateManyWithoutReviewerInput>
  }

  export type ConversationParticipantUpsertWithWhereUniqueWithoutUserInput = {
    where: ConversationParticipantWhereUniqueInput
    update: XOR<ConversationParticipantUpdateWithoutUserInput, ConversationParticipantUncheckedUpdateWithoutUserInput>
    create: XOR<ConversationParticipantCreateWithoutUserInput, ConversationParticipantUncheckedCreateWithoutUserInput>
  }

  export type ConversationParticipantUpdateWithWhereUniqueWithoutUserInput = {
    where: ConversationParticipantWhereUniqueInput
    data: XOR<ConversationParticipantUpdateWithoutUserInput, ConversationParticipantUncheckedUpdateWithoutUserInput>
  }

  export type ConversationParticipantUpdateManyWithWhereWithoutUserInput = {
    where: ConversationParticipantScalarWhereInput
    data: XOR<ConversationParticipantUpdateManyMutationInput, ConversationParticipantUncheckedUpdateManyWithoutUserInput>
  }

  export type ConversationParticipantScalarWhereInput = {
    AND?: ConversationParticipantScalarWhereInput | ConversationParticipantScalarWhereInput[]
    OR?: ConversationParticipantScalarWhereInput[]
    NOT?: ConversationParticipantScalarWhereInput | ConversationParticipantScalarWhereInput[]
    conversationId?: StringFilter<"ConversationParticipant"> | string
    userId?: StringFilter<"ConversationParticipant"> | string
    createdAt?: DateTimeFilter<"ConversationParticipant"> | Date | string
  }

  export type DirectMessageUpsertWithWhereUniqueWithoutSenderInput = {
    where: DirectMessageWhereUniqueInput
    update: XOR<DirectMessageUpdateWithoutSenderInput, DirectMessageUncheckedUpdateWithoutSenderInput>
    create: XOR<DirectMessageCreateWithoutSenderInput, DirectMessageUncheckedCreateWithoutSenderInput>
  }

  export type DirectMessageUpdateWithWhereUniqueWithoutSenderInput = {
    where: DirectMessageWhereUniqueInput
    data: XOR<DirectMessageUpdateWithoutSenderInput, DirectMessageUncheckedUpdateWithoutSenderInput>
  }

  export type DirectMessageUpdateManyWithWhereWithoutSenderInput = {
    where: DirectMessageScalarWhereInput
    data: XOR<DirectMessageUpdateManyMutationInput, DirectMessageUncheckedUpdateManyWithoutSenderInput>
  }

  export type DirectMessageScalarWhereInput = {
    AND?: DirectMessageScalarWhereInput | DirectMessageScalarWhereInput[]
    OR?: DirectMessageScalarWhereInput[]
    NOT?: DirectMessageScalarWhereInput | DirectMessageScalarWhereInput[]
    id?: StringFilter<"DirectMessage"> | string
    conversationId?: StringFilter<"DirectMessage"> | string
    senderId?: StringFilter<"DirectMessage"> | string
    receiverId?: StringFilter<"DirectMessage"> | string
    content?: StringFilter<"DirectMessage"> | string
    kind?: StringFilter<"DirectMessage"> | string
    isDeleted?: BoolFilter<"DirectMessage"> | boolean
    createdAt?: DateTimeFilter<"DirectMessage"> | Date | string
  }

  export type DirectMessageUpsertWithWhereUniqueWithoutReceiverInput = {
    where: DirectMessageWhereUniqueInput
    update: XOR<DirectMessageUpdateWithoutReceiverInput, DirectMessageUncheckedUpdateWithoutReceiverInput>
    create: XOR<DirectMessageCreateWithoutReceiverInput, DirectMessageUncheckedCreateWithoutReceiverInput>
  }

  export type DirectMessageUpdateWithWhereUniqueWithoutReceiverInput = {
    where: DirectMessageWhereUniqueInput
    data: XOR<DirectMessageUpdateWithoutReceiverInput, DirectMessageUncheckedUpdateWithoutReceiverInput>
  }

  export type DirectMessageUpdateManyWithWhereWithoutReceiverInput = {
    where: DirectMessageScalarWhereInput
    data: XOR<DirectMessageUpdateManyMutationInput, DirectMessageUncheckedUpdateManyWithoutReceiverInput>
  }

  export type UserBadgeUpsertWithWhereUniqueWithoutUserInput = {
    where: UserBadgeWhereUniqueInput
    update: XOR<UserBadgeUpdateWithoutUserInput, UserBadgeUncheckedUpdateWithoutUserInput>
    create: XOR<UserBadgeCreateWithoutUserInput, UserBadgeUncheckedCreateWithoutUserInput>
  }

  export type UserBadgeUpdateWithWhereUniqueWithoutUserInput = {
    where: UserBadgeWhereUniqueInput
    data: XOR<UserBadgeUpdateWithoutUserInput, UserBadgeUncheckedUpdateWithoutUserInput>
  }

  export type UserBadgeUpdateManyWithWhereWithoutUserInput = {
    where: UserBadgeScalarWhereInput
    data: XOR<UserBadgeUpdateManyMutationInput, UserBadgeUncheckedUpdateManyWithoutUserInput>
  }

  export type UserBadgeScalarWhereInput = {
    AND?: UserBadgeScalarWhereInput | UserBadgeScalarWhereInput[]
    OR?: UserBadgeScalarWhereInput[]
    NOT?: UserBadgeScalarWhereInput | UserBadgeScalarWhereInput[]
    userId?: StringFilter<"UserBadge"> | string
    badgeId?: StringFilter<"UserBadge"> | string
    createdAt?: DateTimeFilter<"UserBadge"> | Date | string
  }

  export type GameAccountUpsertWithWhereUniqueWithoutUserInput = {
    where: GameAccountWhereUniqueInput
    update: XOR<GameAccountUpdateWithoutUserInput, GameAccountUncheckedUpdateWithoutUserInput>
    create: XOR<GameAccountCreateWithoutUserInput, GameAccountUncheckedCreateWithoutUserInput>
  }

  export type GameAccountUpdateWithWhereUniqueWithoutUserInput = {
    where: GameAccountWhereUniqueInput
    data: XOR<GameAccountUpdateWithoutUserInput, GameAccountUncheckedUpdateWithoutUserInput>
  }

  export type GameAccountUpdateManyWithWhereWithoutUserInput = {
    where: GameAccountScalarWhereInput
    data: XOR<GameAccountUpdateManyMutationInput, GameAccountUncheckedUpdateManyWithoutUserInput>
  }

  export type GameAccountScalarWhereInput = {
    AND?: GameAccountScalarWhereInput | GameAccountScalarWhereInput[]
    OR?: GameAccountScalarWhereInput[]
    NOT?: GameAccountScalarWhereInput | GameAccountScalarWhereInput[]
    id?: StringFilter<"GameAccount"> | string
    userId?: StringFilter<"GameAccount"> | string
    mtaSerial?: StringFilter<"GameAccount"> | string
    mtaAccount?: StringNullableFilter<"GameAccount"> | string | null
    locked?: BoolFilter<"GameAccount"> | boolean
    changedAfterApproved?: BoolFilter<"GameAccount"> | boolean
    createdAt?: DateTimeFilter<"GameAccount"> | Date | string
    updatedAt?: DateTimeFilter<"GameAccount"> | Date | string
  }

  export type MtaAccessLogUpsertWithWhereUniqueWithoutUserInput = {
    where: MtaAccessLogWhereUniqueInput
    update: XOR<MtaAccessLogUpdateWithoutUserInput, MtaAccessLogUncheckedUpdateWithoutUserInput>
    create: XOR<MtaAccessLogCreateWithoutUserInput, MtaAccessLogUncheckedCreateWithoutUserInput>
  }

  export type MtaAccessLogUpdateWithWhereUniqueWithoutUserInput = {
    where: MtaAccessLogWhereUniqueInput
    data: XOR<MtaAccessLogUpdateWithoutUserInput, MtaAccessLogUncheckedUpdateWithoutUserInput>
  }

  export type MtaAccessLogUpdateManyWithWhereWithoutUserInput = {
    where: MtaAccessLogScalarWhereInput
    data: XOR<MtaAccessLogUpdateManyMutationInput, MtaAccessLogUncheckedUpdateManyWithoutUserInput>
  }

  export type MtaAccessLogScalarWhereInput = {
    AND?: MtaAccessLogScalarWhereInput | MtaAccessLogScalarWhereInput[]
    OR?: MtaAccessLogScalarWhereInput[]
    NOT?: MtaAccessLogScalarWhereInput | MtaAccessLogScalarWhereInput[]
    id?: StringFilter<"MtaAccessLog"> | string
    serial?: StringFilter<"MtaAccessLog"> | string
    userId?: StringNullableFilter<"MtaAccessLog"> | string | null
    allowed?: BoolFilter<"MtaAccessLog"> | boolean
    reason?: StringNullableFilter<"MtaAccessLog"> | string | null
    ip?: StringNullableFilter<"MtaAccessLog"> | string | null
    createdAt?: DateTimeFilter<"MtaAccessLog"> | Date | string
  }

  export type TicketRatingRequirementUpsertWithWhereUniqueWithoutRaterInput = {
    where: TicketRatingRequirementWhereUniqueInput
    update: XOR<TicketRatingRequirementUpdateWithoutRaterInput, TicketRatingRequirementUncheckedUpdateWithoutRaterInput>
    create: XOR<TicketRatingRequirementCreateWithoutRaterInput, TicketRatingRequirementUncheckedCreateWithoutRaterInput>
  }

  export type TicketRatingRequirementUpdateWithWhereUniqueWithoutRaterInput = {
    where: TicketRatingRequirementWhereUniqueInput
    data: XOR<TicketRatingRequirementUpdateWithoutRaterInput, TicketRatingRequirementUncheckedUpdateWithoutRaterInput>
  }

  export type TicketRatingRequirementUpdateManyWithWhereWithoutRaterInput = {
    where: TicketRatingRequirementScalarWhereInput
    data: XOR<TicketRatingRequirementUpdateManyMutationInput, TicketRatingRequirementUncheckedUpdateManyWithoutRaterInput>
  }

  export type TicketRatingRequirementScalarWhereInput = {
    AND?: TicketRatingRequirementScalarWhereInput | TicketRatingRequirementScalarWhereInput[]
    OR?: TicketRatingRequirementScalarWhereInput[]
    NOT?: TicketRatingRequirementScalarWhereInput | TicketRatingRequirementScalarWhereInput[]
    id?: StringFilter<"TicketRatingRequirement"> | string
    ticketId?: StringFilter<"TicketRatingRequirement"> | string
    raterId?: StringFilter<"TicketRatingRequirement"> | string
    targetId?: StringFilter<"TicketRatingRequirement"> | string
    completed?: BoolFilter<"TicketRatingRequirement"> | boolean
    createdAt?: DateTimeFilter<"TicketRatingRequirement"> | Date | string
  }

  export type TicketRatingRequirementUpsertWithWhereUniqueWithoutTargetInput = {
    where: TicketRatingRequirementWhereUniqueInput
    update: XOR<TicketRatingRequirementUpdateWithoutTargetInput, TicketRatingRequirementUncheckedUpdateWithoutTargetInput>
    create: XOR<TicketRatingRequirementCreateWithoutTargetInput, TicketRatingRequirementUncheckedCreateWithoutTargetInput>
  }

  export type TicketRatingRequirementUpdateWithWhereUniqueWithoutTargetInput = {
    where: TicketRatingRequirementWhereUniqueInput
    data: XOR<TicketRatingRequirementUpdateWithoutTargetInput, TicketRatingRequirementUncheckedUpdateWithoutTargetInput>
  }

  export type TicketRatingRequirementUpdateManyWithWhereWithoutTargetInput = {
    where: TicketRatingRequirementScalarWhereInput
    data: XOR<TicketRatingRequirementUpdateManyMutationInput, TicketRatingRequirementUncheckedUpdateManyWithoutTargetInput>
  }

  export type PasswordResetTokenUpsertWithWhereUniqueWithoutUserInput = {
    where: PasswordResetTokenWhereUniqueInput
    update: XOR<PasswordResetTokenUpdateWithoutUserInput, PasswordResetTokenUncheckedUpdateWithoutUserInput>
    create: XOR<PasswordResetTokenCreateWithoutUserInput, PasswordResetTokenUncheckedCreateWithoutUserInput>
  }

  export type PasswordResetTokenUpdateWithWhereUniqueWithoutUserInput = {
    where: PasswordResetTokenWhereUniqueInput
    data: XOR<PasswordResetTokenUpdateWithoutUserInput, PasswordResetTokenUncheckedUpdateWithoutUserInput>
  }

  export type PasswordResetTokenUpdateManyWithWhereWithoutUserInput = {
    where: PasswordResetTokenScalarWhereInput
    data: XOR<PasswordResetTokenUpdateManyMutationInput, PasswordResetTokenUncheckedUpdateManyWithoutUserInput>
  }

  export type PasswordResetTokenScalarWhereInput = {
    AND?: PasswordResetTokenScalarWhereInput | PasswordResetTokenScalarWhereInput[]
    OR?: PasswordResetTokenScalarWhereInput[]
    NOT?: PasswordResetTokenScalarWhereInput | PasswordResetTokenScalarWhereInput[]
    id?: StringFilter<"PasswordResetToken"> | string
    userId?: StringFilter<"PasswordResetToken"> | string
    code?: StringFilter<"PasswordResetToken"> | string
    expiresAt?: DateTimeFilter<"PasswordResetToken"> | Date | string
    usedAt?: DateTimeNullableFilter<"PasswordResetToken"> | Date | string | null
    createdAt?: DateTimeFilter<"PasswordResetToken"> | Date | string
  }

  export type EntitlementUpsertWithWhereUniqueWithoutUserInput = {
    where: EntitlementWhereUniqueInput
    update: XOR<EntitlementUpdateWithoutUserInput, EntitlementUncheckedUpdateWithoutUserInput>
    create: XOR<EntitlementCreateWithoutUserInput, EntitlementUncheckedCreateWithoutUserInput>
  }

  export type EntitlementUpdateWithWhereUniqueWithoutUserInput = {
    where: EntitlementWhereUniqueInput
    data: XOR<EntitlementUpdateWithoutUserInput, EntitlementUncheckedUpdateWithoutUserInput>
  }

  export type EntitlementUpdateManyWithWhereWithoutUserInput = {
    where: EntitlementScalarWhereInput
    data: XOR<EntitlementUpdateManyMutationInput, EntitlementUncheckedUpdateManyWithoutUserInput>
  }

  export type EntitlementScalarWhereInput = {
    AND?: EntitlementScalarWhereInput | EntitlementScalarWhereInput[]
    OR?: EntitlementScalarWhereInput[]
    NOT?: EntitlementScalarWhereInput | EntitlementScalarWhereInput[]
    id?: StringFilter<"Entitlement"> | string
    userId?: StringFilter<"Entitlement"> | string
    roleName?: StringFilter<"Entitlement"> | string
    expiresAt?: DateTimeFilter<"Entitlement"> | Date | string
    source?: StringNullableFilter<"Entitlement"> | string | null
    createdAt?: DateTimeFilter<"Entitlement"> | Date | string
  }

  export type NotificationUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
  }

  export type NotificationUpdateManyWithWhereWithoutUserInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutUserInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: StringFilter<"Notification"> | string
    userId?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    href?: StringNullableFilter<"Notification"> | string | null
    read?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
  }

  export type StaffShiftUpsertWithWhereUniqueWithoutUserInput = {
    where: StaffShiftWhereUniqueInput
    update: XOR<StaffShiftUpdateWithoutUserInput, StaffShiftUncheckedUpdateWithoutUserInput>
    create: XOR<StaffShiftCreateWithoutUserInput, StaffShiftUncheckedCreateWithoutUserInput>
  }

  export type StaffShiftUpdateWithWhereUniqueWithoutUserInput = {
    where: StaffShiftWhereUniqueInput
    data: XOR<StaffShiftUpdateWithoutUserInput, StaffShiftUncheckedUpdateWithoutUserInput>
  }

  export type StaffShiftUpdateManyWithWhereWithoutUserInput = {
    where: StaffShiftScalarWhereInput
    data: XOR<StaffShiftUpdateManyMutationInput, StaffShiftUncheckedUpdateManyWithoutUserInput>
  }

  export type StaffShiftScalarWhereInput = {
    AND?: StaffShiftScalarWhereInput | StaffShiftScalarWhereInput[]
    OR?: StaffShiftScalarWhereInput[]
    NOT?: StaffShiftScalarWhereInput | StaffShiftScalarWhereInput[]
    id?: StringFilter<"StaffShift"> | string
    userId?: StringFilter<"StaffShift"> | string
    openedAt?: DateTimeFilter<"StaffShift"> | Date | string
    closedAt?: DateTimeNullableFilter<"StaffShift"> | Date | string | null
    seconds?: IntFilter<"StaffShift"> | number
    createdAt?: DateTimeFilter<"StaffShift"> | Date | string
  }

  export type StaffWeeklyRewardUpsertWithWhereUniqueWithoutUserInput = {
    where: StaffWeeklyRewardWhereUniqueInput
    update: XOR<StaffWeeklyRewardUpdateWithoutUserInput, StaffWeeklyRewardUncheckedUpdateWithoutUserInput>
    create: XOR<StaffWeeklyRewardCreateWithoutUserInput, StaffWeeklyRewardUncheckedCreateWithoutUserInput>
  }

  export type StaffWeeklyRewardUpdateWithWhereUniqueWithoutUserInput = {
    where: StaffWeeklyRewardWhereUniqueInput
    data: XOR<StaffWeeklyRewardUpdateWithoutUserInput, StaffWeeklyRewardUncheckedUpdateWithoutUserInput>
  }

  export type StaffWeeklyRewardUpdateManyWithWhereWithoutUserInput = {
    where: StaffWeeklyRewardScalarWhereInput
    data: XOR<StaffWeeklyRewardUpdateManyMutationInput, StaffWeeklyRewardUncheckedUpdateManyWithoutUserInput>
  }

  export type StaffWeeklyRewardScalarWhereInput = {
    AND?: StaffWeeklyRewardScalarWhereInput | StaffWeeklyRewardScalarWhereInput[]
    OR?: StaffWeeklyRewardScalarWhereInput[]
    NOT?: StaffWeeklyRewardScalarWhereInput | StaffWeeklyRewardScalarWhereInput[]
    id?: StringFilter<"StaffWeeklyReward"> | string
    userId?: StringFilter<"StaffWeeklyReward"> | string
    position?: IntFilter<"StaffWeeklyReward"> | number
    weekKey?: StringFilter<"StaffWeeklyReward"> | string
    createdAt?: DateTimeFilter<"StaffWeeklyReward"> | Date | string
  }

  export type AdminCaseUpsertWithWhereUniqueWithoutTargetUserInput = {
    where: AdminCaseWhereUniqueInput
    update: XOR<AdminCaseUpdateWithoutTargetUserInput, AdminCaseUncheckedUpdateWithoutTargetUserInput>
    create: XOR<AdminCaseCreateWithoutTargetUserInput, AdminCaseUncheckedCreateWithoutTargetUserInput>
  }

  export type AdminCaseUpdateWithWhereUniqueWithoutTargetUserInput = {
    where: AdminCaseWhereUniqueInput
    data: XOR<AdminCaseUpdateWithoutTargetUserInput, AdminCaseUncheckedUpdateWithoutTargetUserInput>
  }

  export type AdminCaseUpdateManyWithWhereWithoutTargetUserInput = {
    where: AdminCaseScalarWhereInput
    data: XOR<AdminCaseUpdateManyMutationInput, AdminCaseUncheckedUpdateManyWithoutTargetUserInput>
  }

  export type AdminCaseScalarWhereInput = {
    AND?: AdminCaseScalarWhereInput | AdminCaseScalarWhereInput[]
    OR?: AdminCaseScalarWhereInput[]
    NOT?: AdminCaseScalarWhereInput | AdminCaseScalarWhereInput[]
    id?: StringFilter<"AdminCase"> | string
    targetUserId?: StringFilter<"AdminCase"> | string
    staffUserId?: StringFilter<"AdminCase"> | string
    type?: StringFilter<"AdminCase"> | string
    reason?: StringFilter<"AdminCase"> | string
    expiresAt?: DateTimeNullableFilter<"AdminCase"> | Date | string | null
    active?: BoolFilter<"AdminCase"> | boolean
    createdAt?: DateTimeFilter<"AdminCase"> | Date | string
  }

  export type AdminCaseUpsertWithWhereUniqueWithoutStaffUserInput = {
    where: AdminCaseWhereUniqueInput
    update: XOR<AdminCaseUpdateWithoutStaffUserInput, AdminCaseUncheckedUpdateWithoutStaffUserInput>
    create: XOR<AdminCaseCreateWithoutStaffUserInput, AdminCaseUncheckedCreateWithoutStaffUserInput>
  }

  export type AdminCaseUpdateWithWhereUniqueWithoutStaffUserInput = {
    where: AdminCaseWhereUniqueInput
    data: XOR<AdminCaseUpdateWithoutStaffUserInput, AdminCaseUncheckedUpdateWithoutStaffUserInput>
  }

  export type AdminCaseUpdateManyWithWhereWithoutStaffUserInput = {
    where: AdminCaseScalarWhereInput
    data: XOR<AdminCaseUpdateManyMutationInput, AdminCaseUncheckedUpdateManyWithoutStaffUserInput>
  }

  export type UserReputationUpsertWithoutUserInput = {
    update: XOR<UserReputationUpdateWithoutUserInput, UserReputationUncheckedUpdateWithoutUserInput>
    create: XOR<UserReputationCreateWithoutUserInput, UserReputationUncheckedCreateWithoutUserInput>
    where?: UserReputationWhereInput
  }

  export type UserReputationUpdateToOneWithWhereWithoutUserInput = {
    where?: UserReputationWhereInput
    data: XOR<UserReputationUpdateWithoutUserInput, UserReputationUncheckedUpdateWithoutUserInput>
  }

  export type UserReputationUpdateWithoutUserInput = {
    score?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserReputationUncheckedUpdateWithoutUserInput = {
    score?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ForumBoardCreateWithoutCategoryInput = {
    id?: string
    name: string
    description?: string | null
    order?: number
    requireWhitelist?: boolean
    pointsOnTopic?: number
    pointsOnReply?: number
    allowReplies?: boolean
    createdAt?: Date | string
    topics?: TopicCreateNestedManyWithoutBoardInput
  }

  export type ForumBoardUncheckedCreateWithoutCategoryInput = {
    id?: string
    name: string
    description?: string | null
    order?: number
    requireWhitelist?: boolean
    pointsOnTopic?: number
    pointsOnReply?: number
    allowReplies?: boolean
    createdAt?: Date | string
    topics?: TopicUncheckedCreateNestedManyWithoutBoardInput
  }

  export type ForumBoardCreateOrConnectWithoutCategoryInput = {
    where: ForumBoardWhereUniqueInput
    create: XOR<ForumBoardCreateWithoutCategoryInput, ForumBoardUncheckedCreateWithoutCategoryInput>
  }

  export type ForumBoardCreateManyCategoryInputEnvelope = {
    data: ForumBoardCreateManyCategoryInput | ForumBoardCreateManyCategoryInput[]
  }

  export type ForumBoardUpsertWithWhereUniqueWithoutCategoryInput = {
    where: ForumBoardWhereUniqueInput
    update: XOR<ForumBoardUpdateWithoutCategoryInput, ForumBoardUncheckedUpdateWithoutCategoryInput>
    create: XOR<ForumBoardCreateWithoutCategoryInput, ForumBoardUncheckedCreateWithoutCategoryInput>
  }

  export type ForumBoardUpdateWithWhereUniqueWithoutCategoryInput = {
    where: ForumBoardWhereUniqueInput
    data: XOR<ForumBoardUpdateWithoutCategoryInput, ForumBoardUncheckedUpdateWithoutCategoryInput>
  }

  export type ForumBoardUpdateManyWithWhereWithoutCategoryInput = {
    where: ForumBoardScalarWhereInput
    data: XOR<ForumBoardUpdateManyMutationInput, ForumBoardUncheckedUpdateManyWithoutCategoryInput>
  }

  export type ForumBoardScalarWhereInput = {
    AND?: ForumBoardScalarWhereInput | ForumBoardScalarWhereInput[]
    OR?: ForumBoardScalarWhereInput[]
    NOT?: ForumBoardScalarWhereInput | ForumBoardScalarWhereInput[]
    id?: StringFilter<"ForumBoard"> | string
    categoryId?: StringFilter<"ForumBoard"> | string
    name?: StringFilter<"ForumBoard"> | string
    description?: StringNullableFilter<"ForumBoard"> | string | null
    order?: IntFilter<"ForumBoard"> | number
    requireWhitelist?: BoolFilter<"ForumBoard"> | boolean
    pointsOnTopic?: IntFilter<"ForumBoard"> | number
    pointsOnReply?: IntFilter<"ForumBoard"> | number
    allowReplies?: BoolFilter<"ForumBoard"> | boolean
    createdAt?: DateTimeFilter<"ForumBoard"> | Date | string
  }

  export type ForumCategoryCreateWithoutBoardsInput = {
    id?: string
    name: string
    description?: string | null
    order?: number
    createdAt?: Date | string
  }

  export type ForumCategoryUncheckedCreateWithoutBoardsInput = {
    id?: string
    name: string
    description?: string | null
    order?: number
    createdAt?: Date | string
  }

  export type ForumCategoryCreateOrConnectWithoutBoardsInput = {
    where: ForumCategoryWhereUniqueInput
    create: XOR<ForumCategoryCreateWithoutBoardsInput, ForumCategoryUncheckedCreateWithoutBoardsInput>
  }

  export type TopicCreateWithoutBoardInput = {
    id?: string
    title: string
    status?: string
    pinned?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastPostAt?: Date | string
    author: UserCreateNestedOneWithoutTopicsInput
    posts?: PostCreateNestedManyWithoutTopicInput
  }

  export type TopicUncheckedCreateWithoutBoardInput = {
    id?: string
    authorId: string
    title: string
    status?: string
    pinned?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastPostAt?: Date | string
    posts?: PostUncheckedCreateNestedManyWithoutTopicInput
  }

  export type TopicCreateOrConnectWithoutBoardInput = {
    where: TopicWhereUniqueInput
    create: XOR<TopicCreateWithoutBoardInput, TopicUncheckedCreateWithoutBoardInput>
  }

  export type TopicCreateManyBoardInputEnvelope = {
    data: TopicCreateManyBoardInput | TopicCreateManyBoardInput[]
  }

  export type ForumCategoryUpsertWithoutBoardsInput = {
    update: XOR<ForumCategoryUpdateWithoutBoardsInput, ForumCategoryUncheckedUpdateWithoutBoardsInput>
    create: XOR<ForumCategoryCreateWithoutBoardsInput, ForumCategoryUncheckedCreateWithoutBoardsInput>
    where?: ForumCategoryWhereInput
  }

  export type ForumCategoryUpdateToOneWithWhereWithoutBoardsInput = {
    where?: ForumCategoryWhereInput
    data: XOR<ForumCategoryUpdateWithoutBoardsInput, ForumCategoryUncheckedUpdateWithoutBoardsInput>
  }

  export type ForumCategoryUpdateWithoutBoardsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ForumCategoryUncheckedUpdateWithoutBoardsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TopicUpsertWithWhereUniqueWithoutBoardInput = {
    where: TopicWhereUniqueInput
    update: XOR<TopicUpdateWithoutBoardInput, TopicUncheckedUpdateWithoutBoardInput>
    create: XOR<TopicCreateWithoutBoardInput, TopicUncheckedCreateWithoutBoardInput>
  }

  export type TopicUpdateWithWhereUniqueWithoutBoardInput = {
    where: TopicWhereUniqueInput
    data: XOR<TopicUpdateWithoutBoardInput, TopicUncheckedUpdateWithoutBoardInput>
  }

  export type TopicUpdateManyWithWhereWithoutBoardInput = {
    where: TopicScalarWhereInput
    data: XOR<TopicUpdateManyMutationInput, TopicUncheckedUpdateManyWithoutBoardInput>
  }

  export type ForumBoardCreateWithoutTopicsInput = {
    id?: string
    name: string
    description?: string | null
    order?: number
    requireWhitelist?: boolean
    pointsOnTopic?: number
    pointsOnReply?: number
    allowReplies?: boolean
    createdAt?: Date | string
    category: ForumCategoryCreateNestedOneWithoutBoardsInput
  }

  export type ForumBoardUncheckedCreateWithoutTopicsInput = {
    id?: string
    categoryId: string
    name: string
    description?: string | null
    order?: number
    requireWhitelist?: boolean
    pointsOnTopic?: number
    pointsOnReply?: number
    allowReplies?: boolean
    createdAt?: Date | string
  }

  export type ForumBoardCreateOrConnectWithoutTopicsInput = {
    where: ForumBoardWhereUniqueInput
    create: XOR<ForumBoardCreateWithoutTopicsInput, ForumBoardUncheckedCreateWithoutTopicsInput>
  }

  export type UserCreateWithoutTopicsInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    emailVerifiedAt?: Date | string | null
    emailVerifyToken?: string | null
    emailVerifyExpiresAt?: Date | string | null
    phone?: string | null
    recoveryEmail?: string | null
    googleId?: string | null
    discordId?: string | null
    discordUsername?: string | null
    avatarKey?: string
    role?: string
    isDeleted?: boolean
    bannedUntil?: Date | string | null
    whitelistStatus?: string
    points?: number
    lastSeenAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    avatarUrl?: string | null
    posts?: PostCreateNestedManyWithoutAuthorInput
    tickets?: TicketCreateNestedManyWithoutAuthorInput
    assignedTickets?: TicketCreateNestedManyWithoutAssignedToInput
    ticketMsgs?: TicketMessageCreateNestedManyWithoutAuthorInput
    ticketParticipants?: TicketParticipantCreateNestedManyWithoutUserInput
    ticketParticipantsAdded?: TicketParticipantCreateNestedManyWithoutAddedByInput
    ticketRatingsGiven?: TicketRatingCreateNestedManyWithoutRaterInput
    ticketRatingsReceived?: TicketRatingCreateNestedManyWithoutTargetInput
    closedTickets?: TicketCreateNestedManyWithoutClosedByInput
    purchases?: PurchaseCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    whitelistApps?: WhitelistApplicationCreateNestedManyWithoutUserInput
    reviewedWhitelists?: WhitelistApplicationCreateNestedManyWithoutReviewerInput
    convoParts?: ConversationParticipantCreateNestedManyWithoutUserInput
    sentMessages?: DirectMessageCreateNestedManyWithoutSenderInput
    receivedMessages?: DirectMessageCreateNestedManyWithoutReceiverInput
    userBadges?: UserBadgeCreateNestedManyWithoutUserInput
    gameAccounts?: GameAccountCreateNestedManyWithoutUserInput
    mtaAccessLogs?: MtaAccessLogCreateNestedManyWithoutUserInput
    ticketRatingReqGiven?: TicketRatingRequirementCreateNestedManyWithoutRaterInput
    ticketRatingReqReceived?: TicketRatingRequirementCreateNestedManyWithoutTargetInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    entitlements?: EntitlementCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    staffShifts?: StaffShiftCreateNestedManyWithoutUserInput
    staffWeeklyRewards?: StaffWeeklyRewardCreateNestedManyWithoutUserInput
    adminCasesTarget?: AdminCaseCreateNestedManyWithoutTargetUserInput
    adminCasesStaff?: AdminCaseCreateNestedManyWithoutStaffUserInput
    reputation?: UserReputationCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTopicsInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    emailVerifiedAt?: Date | string | null
    emailVerifyToken?: string | null
    emailVerifyExpiresAt?: Date | string | null
    phone?: string | null
    recoveryEmail?: string | null
    googleId?: string | null
    discordId?: string | null
    discordUsername?: string | null
    avatarKey?: string
    role?: string
    isDeleted?: boolean
    bannedUntil?: Date | string | null
    whitelistStatus?: string
    points?: number
    lastSeenAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    avatarUrl?: string | null
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    tickets?: TicketUncheckedCreateNestedManyWithoutAuthorInput
    assignedTickets?: TicketUncheckedCreateNestedManyWithoutAssignedToInput
    ticketMsgs?: TicketMessageUncheckedCreateNestedManyWithoutAuthorInput
    ticketParticipants?: TicketParticipantUncheckedCreateNestedManyWithoutUserInput
    ticketParticipantsAdded?: TicketParticipantUncheckedCreateNestedManyWithoutAddedByInput
    ticketRatingsGiven?: TicketRatingUncheckedCreateNestedManyWithoutRaterInput
    ticketRatingsReceived?: TicketRatingUncheckedCreateNestedManyWithoutTargetInput
    closedTickets?: TicketUncheckedCreateNestedManyWithoutClosedByInput
    purchases?: PurchaseUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    whitelistApps?: WhitelistApplicationUncheckedCreateNestedManyWithoutUserInput
    reviewedWhitelists?: WhitelistApplicationUncheckedCreateNestedManyWithoutReviewerInput
    convoParts?: ConversationParticipantUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: DirectMessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: DirectMessageUncheckedCreateNestedManyWithoutReceiverInput
    userBadges?: UserBadgeUncheckedCreateNestedManyWithoutUserInput
    gameAccounts?: GameAccountUncheckedCreateNestedManyWithoutUserInput
    mtaAccessLogs?: MtaAccessLogUncheckedCreateNestedManyWithoutUserInput
    ticketRatingReqGiven?: TicketRatingRequirementUncheckedCreateNestedManyWithoutRaterInput
    ticketRatingReqReceived?: TicketRatingRequirementUncheckedCreateNestedManyWithoutTargetInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    entitlements?: EntitlementUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    staffShifts?: StaffShiftUncheckedCreateNestedManyWithoutUserInput
    staffWeeklyRewards?: StaffWeeklyRewardUncheckedCreateNestedManyWithoutUserInput
    adminCasesTarget?: AdminCaseUncheckedCreateNestedManyWithoutTargetUserInput
    adminCasesStaff?: AdminCaseUncheckedCreateNestedManyWithoutStaffUserInput
    reputation?: UserReputationUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTopicsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTopicsInput, UserUncheckedCreateWithoutTopicsInput>
  }

  export type PostCreateWithoutTopicInput = {
    id?: string
    content: string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    author: UserCreateNestedOneWithoutPostsInput
    attachments?: PostAttachmentCreateNestedManyWithoutPostInput
  }

  export type PostUncheckedCreateWithoutTopicInput = {
    id?: string
    authorId: string
    content: string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    attachments?: PostAttachmentUncheckedCreateNestedManyWithoutPostInput
  }

  export type PostCreateOrConnectWithoutTopicInput = {
    where: PostWhereUniqueInput
    create: XOR<PostCreateWithoutTopicInput, PostUncheckedCreateWithoutTopicInput>
  }

  export type PostCreateManyTopicInputEnvelope = {
    data: PostCreateManyTopicInput | PostCreateManyTopicInput[]
  }

  export type ForumBoardUpsertWithoutTopicsInput = {
    update: XOR<ForumBoardUpdateWithoutTopicsInput, ForumBoardUncheckedUpdateWithoutTopicsInput>
    create: XOR<ForumBoardCreateWithoutTopicsInput, ForumBoardUncheckedCreateWithoutTopicsInput>
    where?: ForumBoardWhereInput
  }

  export type ForumBoardUpdateToOneWithWhereWithoutTopicsInput = {
    where?: ForumBoardWhereInput
    data: XOR<ForumBoardUpdateWithoutTopicsInput, ForumBoardUncheckedUpdateWithoutTopicsInput>
  }

  export type ForumBoardUpdateWithoutTopicsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    requireWhitelist?: BoolFieldUpdateOperationsInput | boolean
    pointsOnTopic?: IntFieldUpdateOperationsInput | number
    pointsOnReply?: IntFieldUpdateOperationsInput | number
    allowReplies?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: ForumCategoryUpdateOneRequiredWithoutBoardsNestedInput
  }

  export type ForumBoardUncheckedUpdateWithoutTopicsInput = {
    id?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    requireWhitelist?: BoolFieldUpdateOperationsInput | boolean
    pointsOnTopic?: IntFieldUpdateOperationsInput | number
    pointsOnReply?: IntFieldUpdateOperationsInput | number
    allowReplies?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutTopicsInput = {
    update: XOR<UserUpdateWithoutTopicsInput, UserUncheckedUpdateWithoutTopicsInput>
    create: XOR<UserCreateWithoutTopicsInput, UserUncheckedCreateWithoutTopicsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTopicsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTopicsInput, UserUncheckedUpdateWithoutTopicsInput>
  }

  export type UserUpdateWithoutTopicsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifyToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerifyExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    discordId?: NullableStringFieldUpdateOperationsInput | string | null
    discordUsername?: NullableStringFieldUpdateOperationsInput | string | null
    avatarKey?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    bannedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    whitelistStatus?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    lastSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    posts?: PostUpdateManyWithoutAuthorNestedInput
    tickets?: TicketUpdateManyWithoutAuthorNestedInput
    assignedTickets?: TicketUpdateManyWithoutAssignedToNestedInput
    ticketMsgs?: TicketMessageUpdateManyWithoutAuthorNestedInput
    ticketParticipants?: TicketParticipantUpdateManyWithoutUserNestedInput
    ticketParticipantsAdded?: TicketParticipantUpdateManyWithoutAddedByNestedInput
    ticketRatingsGiven?: TicketRatingUpdateManyWithoutRaterNestedInput
    ticketRatingsReceived?: TicketRatingUpdateManyWithoutTargetNestedInput
    closedTickets?: TicketUpdateManyWithoutClosedByNestedInput
    purchases?: PurchaseUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    whitelistApps?: WhitelistApplicationUpdateManyWithoutUserNestedInput
    reviewedWhitelists?: WhitelistApplicationUpdateManyWithoutReviewerNestedInput
    convoParts?: ConversationParticipantUpdateManyWithoutUserNestedInput
    sentMessages?: DirectMessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: DirectMessageUpdateManyWithoutReceiverNestedInput
    userBadges?: UserBadgeUpdateManyWithoutUserNestedInput
    gameAccounts?: GameAccountUpdateManyWithoutUserNestedInput
    mtaAccessLogs?: MtaAccessLogUpdateManyWithoutUserNestedInput
    ticketRatingReqGiven?: TicketRatingRequirementUpdateManyWithoutRaterNestedInput
    ticketRatingReqReceived?: TicketRatingRequirementUpdateManyWithoutTargetNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    entitlements?: EntitlementUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    staffShifts?: StaffShiftUpdateManyWithoutUserNestedInput
    staffWeeklyRewards?: StaffWeeklyRewardUpdateManyWithoutUserNestedInput
    adminCasesTarget?: AdminCaseUpdateManyWithoutTargetUserNestedInput
    adminCasesStaff?: AdminCaseUpdateManyWithoutStaffUserNestedInput
    reputation?: UserReputationUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTopicsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifyToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerifyExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    discordId?: NullableStringFieldUpdateOperationsInput | string | null
    discordUsername?: NullableStringFieldUpdateOperationsInput | string | null
    avatarKey?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    bannedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    whitelistStatus?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    lastSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutAuthorNestedInput
    assignedTickets?: TicketUncheckedUpdateManyWithoutAssignedToNestedInput
    ticketMsgs?: TicketMessageUncheckedUpdateManyWithoutAuthorNestedInput
    ticketParticipants?: TicketParticipantUncheckedUpdateManyWithoutUserNestedInput
    ticketParticipantsAdded?: TicketParticipantUncheckedUpdateManyWithoutAddedByNestedInput
    ticketRatingsGiven?: TicketRatingUncheckedUpdateManyWithoutRaterNestedInput
    ticketRatingsReceived?: TicketRatingUncheckedUpdateManyWithoutTargetNestedInput
    closedTickets?: TicketUncheckedUpdateManyWithoutClosedByNestedInput
    purchases?: PurchaseUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    whitelistApps?: WhitelistApplicationUncheckedUpdateManyWithoutUserNestedInput
    reviewedWhitelists?: WhitelistApplicationUncheckedUpdateManyWithoutReviewerNestedInput
    convoParts?: ConversationParticipantUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: DirectMessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: DirectMessageUncheckedUpdateManyWithoutReceiverNestedInput
    userBadges?: UserBadgeUncheckedUpdateManyWithoutUserNestedInput
    gameAccounts?: GameAccountUncheckedUpdateManyWithoutUserNestedInput
    mtaAccessLogs?: MtaAccessLogUncheckedUpdateManyWithoutUserNestedInput
    ticketRatingReqGiven?: TicketRatingRequirementUncheckedUpdateManyWithoutRaterNestedInput
    ticketRatingReqReceived?: TicketRatingRequirementUncheckedUpdateManyWithoutTargetNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    entitlements?: EntitlementUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    staffShifts?: StaffShiftUncheckedUpdateManyWithoutUserNestedInput
    staffWeeklyRewards?: StaffWeeklyRewardUncheckedUpdateManyWithoutUserNestedInput
    adminCasesTarget?: AdminCaseUncheckedUpdateManyWithoutTargetUserNestedInput
    adminCasesStaff?: AdminCaseUncheckedUpdateManyWithoutStaffUserNestedInput
    reputation?: UserReputationUncheckedUpdateOneWithoutUserNestedInput
  }

  export type PostUpsertWithWhereUniqueWithoutTopicInput = {
    where: PostWhereUniqueInput
    update: XOR<PostUpdateWithoutTopicInput, PostUncheckedUpdateWithoutTopicInput>
    create: XOR<PostCreateWithoutTopicInput, PostUncheckedCreateWithoutTopicInput>
  }

  export type PostUpdateWithWhereUniqueWithoutTopicInput = {
    where: PostWhereUniqueInput
    data: XOR<PostUpdateWithoutTopicInput, PostUncheckedUpdateWithoutTopicInput>
  }

  export type PostUpdateManyWithWhereWithoutTopicInput = {
    where: PostScalarWhereInput
    data: XOR<PostUpdateManyMutationInput, PostUncheckedUpdateManyWithoutTopicInput>
  }

  export type TopicCreateWithoutPostsInput = {
    id?: string
    title: string
    status?: string
    pinned?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastPostAt?: Date | string
    board: ForumBoardCreateNestedOneWithoutTopicsInput
    author: UserCreateNestedOneWithoutTopicsInput
  }

  export type TopicUncheckedCreateWithoutPostsInput = {
    id?: string
    boardId: string
    authorId: string
    title: string
    status?: string
    pinned?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastPostAt?: Date | string
  }

  export type TopicCreateOrConnectWithoutPostsInput = {
    where: TopicWhereUniqueInput
    create: XOR<TopicCreateWithoutPostsInput, TopicUncheckedCreateWithoutPostsInput>
  }

  export type UserCreateWithoutPostsInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    emailVerifiedAt?: Date | string | null
    emailVerifyToken?: string | null
    emailVerifyExpiresAt?: Date | string | null
    phone?: string | null
    recoveryEmail?: string | null
    googleId?: string | null
    discordId?: string | null
    discordUsername?: string | null
    avatarKey?: string
    role?: string
    isDeleted?: boolean
    bannedUntil?: Date | string | null
    whitelistStatus?: string
    points?: number
    lastSeenAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    avatarUrl?: string | null
    topics?: TopicCreateNestedManyWithoutAuthorInput
    tickets?: TicketCreateNestedManyWithoutAuthorInput
    assignedTickets?: TicketCreateNestedManyWithoutAssignedToInput
    ticketMsgs?: TicketMessageCreateNestedManyWithoutAuthorInput
    ticketParticipants?: TicketParticipantCreateNestedManyWithoutUserInput
    ticketParticipantsAdded?: TicketParticipantCreateNestedManyWithoutAddedByInput
    ticketRatingsGiven?: TicketRatingCreateNestedManyWithoutRaterInput
    ticketRatingsReceived?: TicketRatingCreateNestedManyWithoutTargetInput
    closedTickets?: TicketCreateNestedManyWithoutClosedByInput
    purchases?: PurchaseCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    whitelistApps?: WhitelistApplicationCreateNestedManyWithoutUserInput
    reviewedWhitelists?: WhitelistApplicationCreateNestedManyWithoutReviewerInput
    convoParts?: ConversationParticipantCreateNestedManyWithoutUserInput
    sentMessages?: DirectMessageCreateNestedManyWithoutSenderInput
    receivedMessages?: DirectMessageCreateNestedManyWithoutReceiverInput
    userBadges?: UserBadgeCreateNestedManyWithoutUserInput
    gameAccounts?: GameAccountCreateNestedManyWithoutUserInput
    mtaAccessLogs?: MtaAccessLogCreateNestedManyWithoutUserInput
    ticketRatingReqGiven?: TicketRatingRequirementCreateNestedManyWithoutRaterInput
    ticketRatingReqReceived?: TicketRatingRequirementCreateNestedManyWithoutTargetInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    entitlements?: EntitlementCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    staffShifts?: StaffShiftCreateNestedManyWithoutUserInput
    staffWeeklyRewards?: StaffWeeklyRewardCreateNestedManyWithoutUserInput
    adminCasesTarget?: AdminCaseCreateNestedManyWithoutTargetUserInput
    adminCasesStaff?: AdminCaseCreateNestedManyWithoutStaffUserInput
    reputation?: UserReputationCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPostsInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    emailVerifiedAt?: Date | string | null
    emailVerifyToken?: string | null
    emailVerifyExpiresAt?: Date | string | null
    phone?: string | null
    recoveryEmail?: string | null
    googleId?: string | null
    discordId?: string | null
    discordUsername?: string | null
    avatarKey?: string
    role?: string
    isDeleted?: boolean
    bannedUntil?: Date | string | null
    whitelistStatus?: string
    points?: number
    lastSeenAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    avatarUrl?: string | null
    topics?: TopicUncheckedCreateNestedManyWithoutAuthorInput
    tickets?: TicketUncheckedCreateNestedManyWithoutAuthorInput
    assignedTickets?: TicketUncheckedCreateNestedManyWithoutAssignedToInput
    ticketMsgs?: TicketMessageUncheckedCreateNestedManyWithoutAuthorInput
    ticketParticipants?: TicketParticipantUncheckedCreateNestedManyWithoutUserInput
    ticketParticipantsAdded?: TicketParticipantUncheckedCreateNestedManyWithoutAddedByInput
    ticketRatingsGiven?: TicketRatingUncheckedCreateNestedManyWithoutRaterInput
    ticketRatingsReceived?: TicketRatingUncheckedCreateNestedManyWithoutTargetInput
    closedTickets?: TicketUncheckedCreateNestedManyWithoutClosedByInput
    purchases?: PurchaseUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    whitelistApps?: WhitelistApplicationUncheckedCreateNestedManyWithoutUserInput
    reviewedWhitelists?: WhitelistApplicationUncheckedCreateNestedManyWithoutReviewerInput
    convoParts?: ConversationParticipantUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: DirectMessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: DirectMessageUncheckedCreateNestedManyWithoutReceiverInput
    userBadges?: UserBadgeUncheckedCreateNestedManyWithoutUserInput
    gameAccounts?: GameAccountUncheckedCreateNestedManyWithoutUserInput
    mtaAccessLogs?: MtaAccessLogUncheckedCreateNestedManyWithoutUserInput
    ticketRatingReqGiven?: TicketRatingRequirementUncheckedCreateNestedManyWithoutRaterInput
    ticketRatingReqReceived?: TicketRatingRequirementUncheckedCreateNestedManyWithoutTargetInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    entitlements?: EntitlementUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    staffShifts?: StaffShiftUncheckedCreateNestedManyWithoutUserInput
    staffWeeklyRewards?: StaffWeeklyRewardUncheckedCreateNestedManyWithoutUserInput
    adminCasesTarget?: AdminCaseUncheckedCreateNestedManyWithoutTargetUserInput
    adminCasesStaff?: AdminCaseUncheckedCreateNestedManyWithoutStaffUserInput
    reputation?: UserReputationUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPostsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPostsInput, UserUncheckedCreateWithoutPostsInput>
  }

  export type PostAttachmentCreateWithoutPostInput = {
    id?: string
    url: string
    mime?: string | null
    size?: number | null
    createdAt?: Date | string
  }

  export type PostAttachmentUncheckedCreateWithoutPostInput = {
    id?: string
    url: string
    mime?: string | null
    size?: number | null
    createdAt?: Date | string
  }

  export type PostAttachmentCreateOrConnectWithoutPostInput = {
    where: PostAttachmentWhereUniqueInput
    create: XOR<PostAttachmentCreateWithoutPostInput, PostAttachmentUncheckedCreateWithoutPostInput>
  }

  export type PostAttachmentCreateManyPostInputEnvelope = {
    data: PostAttachmentCreateManyPostInput | PostAttachmentCreateManyPostInput[]
  }

  export type TopicUpsertWithoutPostsInput = {
    update: XOR<TopicUpdateWithoutPostsInput, TopicUncheckedUpdateWithoutPostsInput>
    create: XOR<TopicCreateWithoutPostsInput, TopicUncheckedCreateWithoutPostsInput>
    where?: TopicWhereInput
  }

  export type TopicUpdateToOneWithWhereWithoutPostsInput = {
    where?: TopicWhereInput
    data: XOR<TopicUpdateWithoutPostsInput, TopicUncheckedUpdateWithoutPostsInput>
  }

  export type TopicUpdateWithoutPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    pinned?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastPostAt?: DateTimeFieldUpdateOperationsInput | Date | string
    board?: ForumBoardUpdateOneRequiredWithoutTopicsNestedInput
    author?: UserUpdateOneRequiredWithoutTopicsNestedInput
  }

  export type TopicUncheckedUpdateWithoutPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    boardId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    pinned?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastPostAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutPostsInput = {
    update: XOR<UserUpdateWithoutPostsInput, UserUncheckedUpdateWithoutPostsInput>
    create: XOR<UserCreateWithoutPostsInput, UserUncheckedCreateWithoutPostsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPostsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPostsInput, UserUncheckedUpdateWithoutPostsInput>
  }

  export type UserUpdateWithoutPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifyToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerifyExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    discordId?: NullableStringFieldUpdateOperationsInput | string | null
    discordUsername?: NullableStringFieldUpdateOperationsInput | string | null
    avatarKey?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    bannedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    whitelistStatus?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    lastSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    topics?: TopicUpdateManyWithoutAuthorNestedInput
    tickets?: TicketUpdateManyWithoutAuthorNestedInput
    assignedTickets?: TicketUpdateManyWithoutAssignedToNestedInput
    ticketMsgs?: TicketMessageUpdateManyWithoutAuthorNestedInput
    ticketParticipants?: TicketParticipantUpdateManyWithoutUserNestedInput
    ticketParticipantsAdded?: TicketParticipantUpdateManyWithoutAddedByNestedInput
    ticketRatingsGiven?: TicketRatingUpdateManyWithoutRaterNestedInput
    ticketRatingsReceived?: TicketRatingUpdateManyWithoutTargetNestedInput
    closedTickets?: TicketUpdateManyWithoutClosedByNestedInput
    purchases?: PurchaseUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    whitelistApps?: WhitelistApplicationUpdateManyWithoutUserNestedInput
    reviewedWhitelists?: WhitelistApplicationUpdateManyWithoutReviewerNestedInput
    convoParts?: ConversationParticipantUpdateManyWithoutUserNestedInput
    sentMessages?: DirectMessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: DirectMessageUpdateManyWithoutReceiverNestedInput
    userBadges?: UserBadgeUpdateManyWithoutUserNestedInput
    gameAccounts?: GameAccountUpdateManyWithoutUserNestedInput
    mtaAccessLogs?: MtaAccessLogUpdateManyWithoutUserNestedInput
    ticketRatingReqGiven?: TicketRatingRequirementUpdateManyWithoutRaterNestedInput
    ticketRatingReqReceived?: TicketRatingRequirementUpdateManyWithoutTargetNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    entitlements?: EntitlementUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    staffShifts?: StaffShiftUpdateManyWithoutUserNestedInput
    staffWeeklyRewards?: StaffWeeklyRewardUpdateManyWithoutUserNestedInput
    adminCasesTarget?: AdminCaseUpdateManyWithoutTargetUserNestedInput
    adminCasesStaff?: AdminCaseUpdateManyWithoutStaffUserNestedInput
    reputation?: UserReputationUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifyToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerifyExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    discordId?: NullableStringFieldUpdateOperationsInput | string | null
    discordUsername?: NullableStringFieldUpdateOperationsInput | string | null
    avatarKey?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    bannedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    whitelistStatus?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    lastSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    topics?: TopicUncheckedUpdateManyWithoutAuthorNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutAuthorNestedInput
    assignedTickets?: TicketUncheckedUpdateManyWithoutAssignedToNestedInput
    ticketMsgs?: TicketMessageUncheckedUpdateManyWithoutAuthorNestedInput
    ticketParticipants?: TicketParticipantUncheckedUpdateManyWithoutUserNestedInput
    ticketParticipantsAdded?: TicketParticipantUncheckedUpdateManyWithoutAddedByNestedInput
    ticketRatingsGiven?: TicketRatingUncheckedUpdateManyWithoutRaterNestedInput
    ticketRatingsReceived?: TicketRatingUncheckedUpdateManyWithoutTargetNestedInput
    closedTickets?: TicketUncheckedUpdateManyWithoutClosedByNestedInput
    purchases?: PurchaseUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    whitelistApps?: WhitelistApplicationUncheckedUpdateManyWithoutUserNestedInput
    reviewedWhitelists?: WhitelistApplicationUncheckedUpdateManyWithoutReviewerNestedInput
    convoParts?: ConversationParticipantUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: DirectMessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: DirectMessageUncheckedUpdateManyWithoutReceiverNestedInput
    userBadges?: UserBadgeUncheckedUpdateManyWithoutUserNestedInput
    gameAccounts?: GameAccountUncheckedUpdateManyWithoutUserNestedInput
    mtaAccessLogs?: MtaAccessLogUncheckedUpdateManyWithoutUserNestedInput
    ticketRatingReqGiven?: TicketRatingRequirementUncheckedUpdateManyWithoutRaterNestedInput
    ticketRatingReqReceived?: TicketRatingRequirementUncheckedUpdateManyWithoutTargetNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    entitlements?: EntitlementUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    staffShifts?: StaffShiftUncheckedUpdateManyWithoutUserNestedInput
    staffWeeklyRewards?: StaffWeeklyRewardUncheckedUpdateManyWithoutUserNestedInput
    adminCasesTarget?: AdminCaseUncheckedUpdateManyWithoutTargetUserNestedInput
    adminCasesStaff?: AdminCaseUncheckedUpdateManyWithoutStaffUserNestedInput
    reputation?: UserReputationUncheckedUpdateOneWithoutUserNestedInput
  }

  export type PostAttachmentUpsertWithWhereUniqueWithoutPostInput = {
    where: PostAttachmentWhereUniqueInput
    update: XOR<PostAttachmentUpdateWithoutPostInput, PostAttachmentUncheckedUpdateWithoutPostInput>
    create: XOR<PostAttachmentCreateWithoutPostInput, PostAttachmentUncheckedCreateWithoutPostInput>
  }

  export type PostAttachmentUpdateWithWhereUniqueWithoutPostInput = {
    where: PostAttachmentWhereUniqueInput
    data: XOR<PostAttachmentUpdateWithoutPostInput, PostAttachmentUncheckedUpdateWithoutPostInput>
  }

  export type PostAttachmentUpdateManyWithWhereWithoutPostInput = {
    where: PostAttachmentScalarWhereInput
    data: XOR<PostAttachmentUpdateManyMutationInput, PostAttachmentUncheckedUpdateManyWithoutPostInput>
  }

  export type PostAttachmentScalarWhereInput = {
    AND?: PostAttachmentScalarWhereInput | PostAttachmentScalarWhereInput[]
    OR?: PostAttachmentScalarWhereInput[]
    NOT?: PostAttachmentScalarWhereInput | PostAttachmentScalarWhereInput[]
    id?: StringFilter<"PostAttachment"> | string
    postId?: StringFilter<"PostAttachment"> | string
    url?: StringFilter<"PostAttachment"> | string
    mime?: StringNullableFilter<"PostAttachment"> | string | null
    size?: IntNullableFilter<"PostAttachment"> | number | null
    createdAt?: DateTimeFilter<"PostAttachment"> | Date | string
  }

  export type PostCreateWithoutAttachmentsInput = {
    id?: string
    content: string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    topic: TopicCreateNestedOneWithoutPostsInput
    author: UserCreateNestedOneWithoutPostsInput
  }

  export type PostUncheckedCreateWithoutAttachmentsInput = {
    id?: string
    topicId: string
    authorId: string
    content: string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PostCreateOrConnectWithoutAttachmentsInput = {
    where: PostWhereUniqueInput
    create: XOR<PostCreateWithoutAttachmentsInput, PostUncheckedCreateWithoutAttachmentsInput>
  }

  export type PostUpsertWithoutAttachmentsInput = {
    update: XOR<PostUpdateWithoutAttachmentsInput, PostUncheckedUpdateWithoutAttachmentsInput>
    create: XOR<PostCreateWithoutAttachmentsInput, PostUncheckedCreateWithoutAttachmentsInput>
    where?: PostWhereInput
  }

  export type PostUpdateToOneWithWhereWithoutAttachmentsInput = {
    where?: PostWhereInput
    data: XOR<PostUpdateWithoutAttachmentsInput, PostUncheckedUpdateWithoutAttachmentsInput>
  }

  export type PostUpdateWithoutAttachmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    topic?: TopicUpdateOneRequiredWithoutPostsNestedInput
    author?: UserUpdateOneRequiredWithoutPostsNestedInput
  }

  export type PostUncheckedUpdateWithoutAttachmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    topicId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketCreateWithoutCategoryInput = {
    id?: string
    title: string
    status?: string
    priority?: string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    closedAt?: Date | string | null
    author: UserCreateNestedOneWithoutTicketsInput
    assignedTo?: UserCreateNestedOneWithoutAssignedTicketsInput
    closedBy?: UserCreateNestedOneWithoutClosedTicketsInput
    messages?: TicketMessageCreateNestedManyWithoutTicketInput
    participants?: TicketParticipantCreateNestedManyWithoutTicketInput
    ratings?: TicketRatingCreateNestedManyWithoutTicketInput
    ratingRequirements?: TicketRatingRequirementCreateNestedManyWithoutTicketInput
  }

  export type TicketUncheckedCreateWithoutCategoryInput = {
    id?: string
    authorId: string
    title: string
    status?: string
    priority?: string
    assignedToId?: string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    closedAt?: Date | string | null
    closedById?: string | null
    messages?: TicketMessageUncheckedCreateNestedManyWithoutTicketInput
    participants?: TicketParticipantUncheckedCreateNestedManyWithoutTicketInput
    ratings?: TicketRatingUncheckedCreateNestedManyWithoutTicketInput
    ratingRequirements?: TicketRatingRequirementUncheckedCreateNestedManyWithoutTicketInput
  }

  export type TicketCreateOrConnectWithoutCategoryInput = {
    where: TicketWhereUniqueInput
    create: XOR<TicketCreateWithoutCategoryInput, TicketUncheckedCreateWithoutCategoryInput>
  }

  export type TicketCreateManyCategoryInputEnvelope = {
    data: TicketCreateManyCategoryInput | TicketCreateManyCategoryInput[]
  }

  export type TicketUpsertWithWhereUniqueWithoutCategoryInput = {
    where: TicketWhereUniqueInput
    update: XOR<TicketUpdateWithoutCategoryInput, TicketUncheckedUpdateWithoutCategoryInput>
    create: XOR<TicketCreateWithoutCategoryInput, TicketUncheckedCreateWithoutCategoryInput>
  }

  export type TicketUpdateWithWhereUniqueWithoutCategoryInput = {
    where: TicketWhereUniqueInput
    data: XOR<TicketUpdateWithoutCategoryInput, TicketUncheckedUpdateWithoutCategoryInput>
  }

  export type TicketUpdateManyWithWhereWithoutCategoryInput = {
    where: TicketScalarWhereInput
    data: XOR<TicketUpdateManyMutationInput, TicketUncheckedUpdateManyWithoutCategoryInput>
  }

  export type TicketCategoryCreateWithoutTicketsInput = {
    id?: string
    slug: string
    name: string
    description?: string | null
    order?: number
    createdAt?: Date | string
  }

  export type TicketCategoryUncheckedCreateWithoutTicketsInput = {
    id?: string
    slug: string
    name: string
    description?: string | null
    order?: number
    createdAt?: Date | string
  }

  export type TicketCategoryCreateOrConnectWithoutTicketsInput = {
    where: TicketCategoryWhereUniqueInput
    create: XOR<TicketCategoryCreateWithoutTicketsInput, TicketCategoryUncheckedCreateWithoutTicketsInput>
  }

  export type UserCreateWithoutTicketsInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    emailVerifiedAt?: Date | string | null
    emailVerifyToken?: string | null
    emailVerifyExpiresAt?: Date | string | null
    phone?: string | null
    recoveryEmail?: string | null
    googleId?: string | null
    discordId?: string | null
    discordUsername?: string | null
    avatarKey?: string
    role?: string
    isDeleted?: boolean
    bannedUntil?: Date | string | null
    whitelistStatus?: string
    points?: number
    lastSeenAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    avatarUrl?: string | null
    topics?: TopicCreateNestedManyWithoutAuthorInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    assignedTickets?: TicketCreateNestedManyWithoutAssignedToInput
    ticketMsgs?: TicketMessageCreateNestedManyWithoutAuthorInput
    ticketParticipants?: TicketParticipantCreateNestedManyWithoutUserInput
    ticketParticipantsAdded?: TicketParticipantCreateNestedManyWithoutAddedByInput
    ticketRatingsGiven?: TicketRatingCreateNestedManyWithoutRaterInput
    ticketRatingsReceived?: TicketRatingCreateNestedManyWithoutTargetInput
    closedTickets?: TicketCreateNestedManyWithoutClosedByInput
    purchases?: PurchaseCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    whitelistApps?: WhitelistApplicationCreateNestedManyWithoutUserInput
    reviewedWhitelists?: WhitelistApplicationCreateNestedManyWithoutReviewerInput
    convoParts?: ConversationParticipantCreateNestedManyWithoutUserInput
    sentMessages?: DirectMessageCreateNestedManyWithoutSenderInput
    receivedMessages?: DirectMessageCreateNestedManyWithoutReceiverInput
    userBadges?: UserBadgeCreateNestedManyWithoutUserInput
    gameAccounts?: GameAccountCreateNestedManyWithoutUserInput
    mtaAccessLogs?: MtaAccessLogCreateNestedManyWithoutUserInput
    ticketRatingReqGiven?: TicketRatingRequirementCreateNestedManyWithoutRaterInput
    ticketRatingReqReceived?: TicketRatingRequirementCreateNestedManyWithoutTargetInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    entitlements?: EntitlementCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    staffShifts?: StaffShiftCreateNestedManyWithoutUserInput
    staffWeeklyRewards?: StaffWeeklyRewardCreateNestedManyWithoutUserInput
    adminCasesTarget?: AdminCaseCreateNestedManyWithoutTargetUserInput
    adminCasesStaff?: AdminCaseCreateNestedManyWithoutStaffUserInput
    reputation?: UserReputationCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTicketsInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    emailVerifiedAt?: Date | string | null
    emailVerifyToken?: string | null
    emailVerifyExpiresAt?: Date | string | null
    phone?: string | null
    recoveryEmail?: string | null
    googleId?: string | null
    discordId?: string | null
    discordUsername?: string | null
    avatarKey?: string
    role?: string
    isDeleted?: boolean
    bannedUntil?: Date | string | null
    whitelistStatus?: string
    points?: number
    lastSeenAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    avatarUrl?: string | null
    topics?: TopicUncheckedCreateNestedManyWithoutAuthorInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    assignedTickets?: TicketUncheckedCreateNestedManyWithoutAssignedToInput
    ticketMsgs?: TicketMessageUncheckedCreateNestedManyWithoutAuthorInput
    ticketParticipants?: TicketParticipantUncheckedCreateNestedManyWithoutUserInput
    ticketParticipantsAdded?: TicketParticipantUncheckedCreateNestedManyWithoutAddedByInput
    ticketRatingsGiven?: TicketRatingUncheckedCreateNestedManyWithoutRaterInput
    ticketRatingsReceived?: TicketRatingUncheckedCreateNestedManyWithoutTargetInput
    closedTickets?: TicketUncheckedCreateNestedManyWithoutClosedByInput
    purchases?: PurchaseUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    whitelistApps?: WhitelistApplicationUncheckedCreateNestedManyWithoutUserInput
    reviewedWhitelists?: WhitelistApplicationUncheckedCreateNestedManyWithoutReviewerInput
    convoParts?: ConversationParticipantUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: DirectMessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: DirectMessageUncheckedCreateNestedManyWithoutReceiverInput
    userBadges?: UserBadgeUncheckedCreateNestedManyWithoutUserInput
    gameAccounts?: GameAccountUncheckedCreateNestedManyWithoutUserInput
    mtaAccessLogs?: MtaAccessLogUncheckedCreateNestedManyWithoutUserInput
    ticketRatingReqGiven?: TicketRatingRequirementUncheckedCreateNestedManyWithoutRaterInput
    ticketRatingReqReceived?: TicketRatingRequirementUncheckedCreateNestedManyWithoutTargetInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    entitlements?: EntitlementUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    staffShifts?: StaffShiftUncheckedCreateNestedManyWithoutUserInput
    staffWeeklyRewards?: StaffWeeklyRewardUncheckedCreateNestedManyWithoutUserInput
    adminCasesTarget?: AdminCaseUncheckedCreateNestedManyWithoutTargetUserInput
    adminCasesStaff?: AdminCaseUncheckedCreateNestedManyWithoutStaffUserInput
    reputation?: UserReputationUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTicketsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTicketsInput, UserUncheckedCreateWithoutTicketsInput>
  }

  export type UserCreateWithoutAssignedTicketsInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    emailVerifiedAt?: Date | string | null
    emailVerifyToken?: string | null
    emailVerifyExpiresAt?: Date | string | null
    phone?: string | null
    recoveryEmail?: string | null
    googleId?: string | null
    discordId?: string | null
    discordUsername?: string | null
    avatarKey?: string
    role?: string
    isDeleted?: boolean
    bannedUntil?: Date | string | null
    whitelistStatus?: string
    points?: number
    lastSeenAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    avatarUrl?: string | null
    topics?: TopicCreateNestedManyWithoutAuthorInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    tickets?: TicketCreateNestedManyWithoutAuthorInput
    ticketMsgs?: TicketMessageCreateNestedManyWithoutAuthorInput
    ticketParticipants?: TicketParticipantCreateNestedManyWithoutUserInput
    ticketParticipantsAdded?: TicketParticipantCreateNestedManyWithoutAddedByInput
    ticketRatingsGiven?: TicketRatingCreateNestedManyWithoutRaterInput
    ticketRatingsReceived?: TicketRatingCreateNestedManyWithoutTargetInput
    closedTickets?: TicketCreateNestedManyWithoutClosedByInput
    purchases?: PurchaseCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    whitelistApps?: WhitelistApplicationCreateNestedManyWithoutUserInput
    reviewedWhitelists?: WhitelistApplicationCreateNestedManyWithoutReviewerInput
    convoParts?: ConversationParticipantCreateNestedManyWithoutUserInput
    sentMessages?: DirectMessageCreateNestedManyWithoutSenderInput
    receivedMessages?: DirectMessageCreateNestedManyWithoutReceiverInput
    userBadges?: UserBadgeCreateNestedManyWithoutUserInput
    gameAccounts?: GameAccountCreateNestedManyWithoutUserInput
    mtaAccessLogs?: MtaAccessLogCreateNestedManyWithoutUserInput
    ticketRatingReqGiven?: TicketRatingRequirementCreateNestedManyWithoutRaterInput
    ticketRatingReqReceived?: TicketRatingRequirementCreateNestedManyWithoutTargetInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    entitlements?: EntitlementCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    staffShifts?: StaffShiftCreateNestedManyWithoutUserInput
    staffWeeklyRewards?: StaffWeeklyRewardCreateNestedManyWithoutUserInput
    adminCasesTarget?: AdminCaseCreateNestedManyWithoutTargetUserInput
    adminCasesStaff?: AdminCaseCreateNestedManyWithoutStaffUserInput
    reputation?: UserReputationCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAssignedTicketsInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    emailVerifiedAt?: Date | string | null
    emailVerifyToken?: string | null
    emailVerifyExpiresAt?: Date | string | null
    phone?: string | null
    recoveryEmail?: string | null
    googleId?: string | null
    discordId?: string | null
    discordUsername?: string | null
    avatarKey?: string
    role?: string
    isDeleted?: boolean
    bannedUntil?: Date | string | null
    whitelistStatus?: string
    points?: number
    lastSeenAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    avatarUrl?: string | null
    topics?: TopicUncheckedCreateNestedManyWithoutAuthorInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    tickets?: TicketUncheckedCreateNestedManyWithoutAuthorInput
    ticketMsgs?: TicketMessageUncheckedCreateNestedManyWithoutAuthorInput
    ticketParticipants?: TicketParticipantUncheckedCreateNestedManyWithoutUserInput
    ticketParticipantsAdded?: TicketParticipantUncheckedCreateNestedManyWithoutAddedByInput
    ticketRatingsGiven?: TicketRatingUncheckedCreateNestedManyWithoutRaterInput
    ticketRatingsReceived?: TicketRatingUncheckedCreateNestedManyWithoutTargetInput
    closedTickets?: TicketUncheckedCreateNestedManyWithoutClosedByInput
    purchases?: PurchaseUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    whitelistApps?: WhitelistApplicationUncheckedCreateNestedManyWithoutUserInput
    reviewedWhitelists?: WhitelistApplicationUncheckedCreateNestedManyWithoutReviewerInput
    convoParts?: ConversationParticipantUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: DirectMessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: DirectMessageUncheckedCreateNestedManyWithoutReceiverInput
    userBadges?: UserBadgeUncheckedCreateNestedManyWithoutUserInput
    gameAccounts?: GameAccountUncheckedCreateNestedManyWithoutUserInput
    mtaAccessLogs?: MtaAccessLogUncheckedCreateNestedManyWithoutUserInput
    ticketRatingReqGiven?: TicketRatingRequirementUncheckedCreateNestedManyWithoutRaterInput
    ticketRatingReqReceived?: TicketRatingRequirementUncheckedCreateNestedManyWithoutTargetInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    entitlements?: EntitlementUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    staffShifts?: StaffShiftUncheckedCreateNestedManyWithoutUserInput
    staffWeeklyRewards?: StaffWeeklyRewardUncheckedCreateNestedManyWithoutUserInput
    adminCasesTarget?: AdminCaseUncheckedCreateNestedManyWithoutTargetUserInput
    adminCasesStaff?: AdminCaseUncheckedCreateNestedManyWithoutStaffUserInput
    reputation?: UserReputationUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAssignedTicketsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAssignedTicketsInput, UserUncheckedCreateWithoutAssignedTicketsInput>
  }

  export type UserCreateWithoutClosedTicketsInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    emailVerifiedAt?: Date | string | null
    emailVerifyToken?: string | null
    emailVerifyExpiresAt?: Date | string | null
    phone?: string | null
    recoveryEmail?: string | null
    googleId?: string | null
    discordId?: string | null
    discordUsername?: string | null
    avatarKey?: string
    role?: string
    isDeleted?: boolean
    bannedUntil?: Date | string | null
    whitelistStatus?: string
    points?: number
    lastSeenAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    avatarUrl?: string | null
    topics?: TopicCreateNestedManyWithoutAuthorInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    tickets?: TicketCreateNestedManyWithoutAuthorInput
    assignedTickets?: TicketCreateNestedManyWithoutAssignedToInput
    ticketMsgs?: TicketMessageCreateNestedManyWithoutAuthorInput
    ticketParticipants?: TicketParticipantCreateNestedManyWithoutUserInput
    ticketParticipantsAdded?: TicketParticipantCreateNestedManyWithoutAddedByInput
    ticketRatingsGiven?: TicketRatingCreateNestedManyWithoutRaterInput
    ticketRatingsReceived?: TicketRatingCreateNestedManyWithoutTargetInput
    purchases?: PurchaseCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    whitelistApps?: WhitelistApplicationCreateNestedManyWithoutUserInput
    reviewedWhitelists?: WhitelistApplicationCreateNestedManyWithoutReviewerInput
    convoParts?: ConversationParticipantCreateNestedManyWithoutUserInput
    sentMessages?: DirectMessageCreateNestedManyWithoutSenderInput
    receivedMessages?: DirectMessageCreateNestedManyWithoutReceiverInput
    userBadges?: UserBadgeCreateNestedManyWithoutUserInput
    gameAccounts?: GameAccountCreateNestedManyWithoutUserInput
    mtaAccessLogs?: MtaAccessLogCreateNestedManyWithoutUserInput
    ticketRatingReqGiven?: TicketRatingRequirementCreateNestedManyWithoutRaterInput
    ticketRatingReqReceived?: TicketRatingRequirementCreateNestedManyWithoutTargetInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    entitlements?: EntitlementCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    staffShifts?: StaffShiftCreateNestedManyWithoutUserInput
    staffWeeklyRewards?: StaffWeeklyRewardCreateNestedManyWithoutUserInput
    adminCasesTarget?: AdminCaseCreateNestedManyWithoutTargetUserInput
    adminCasesStaff?: AdminCaseCreateNestedManyWithoutStaffUserInput
    reputation?: UserReputationCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutClosedTicketsInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    emailVerifiedAt?: Date | string | null
    emailVerifyToken?: string | null
    emailVerifyExpiresAt?: Date | string | null
    phone?: string | null
    recoveryEmail?: string | null
    googleId?: string | null
    discordId?: string | null
    discordUsername?: string | null
    avatarKey?: string
    role?: string
    isDeleted?: boolean
    bannedUntil?: Date | string | null
    whitelistStatus?: string
    points?: number
    lastSeenAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    avatarUrl?: string | null
    topics?: TopicUncheckedCreateNestedManyWithoutAuthorInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    tickets?: TicketUncheckedCreateNestedManyWithoutAuthorInput
    assignedTickets?: TicketUncheckedCreateNestedManyWithoutAssignedToInput
    ticketMsgs?: TicketMessageUncheckedCreateNestedManyWithoutAuthorInput
    ticketParticipants?: TicketParticipantUncheckedCreateNestedManyWithoutUserInput
    ticketParticipantsAdded?: TicketParticipantUncheckedCreateNestedManyWithoutAddedByInput
    ticketRatingsGiven?: TicketRatingUncheckedCreateNestedManyWithoutRaterInput
    ticketRatingsReceived?: TicketRatingUncheckedCreateNestedManyWithoutTargetInput
    purchases?: PurchaseUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    whitelistApps?: WhitelistApplicationUncheckedCreateNestedManyWithoutUserInput
    reviewedWhitelists?: WhitelistApplicationUncheckedCreateNestedManyWithoutReviewerInput
    convoParts?: ConversationParticipantUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: DirectMessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: DirectMessageUncheckedCreateNestedManyWithoutReceiverInput
    userBadges?: UserBadgeUncheckedCreateNestedManyWithoutUserInput
    gameAccounts?: GameAccountUncheckedCreateNestedManyWithoutUserInput
    mtaAccessLogs?: MtaAccessLogUncheckedCreateNestedManyWithoutUserInput
    ticketRatingReqGiven?: TicketRatingRequirementUncheckedCreateNestedManyWithoutRaterInput
    ticketRatingReqReceived?: TicketRatingRequirementUncheckedCreateNestedManyWithoutTargetInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    entitlements?: EntitlementUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    staffShifts?: StaffShiftUncheckedCreateNestedManyWithoutUserInput
    staffWeeklyRewards?: StaffWeeklyRewardUncheckedCreateNestedManyWithoutUserInput
    adminCasesTarget?: AdminCaseUncheckedCreateNestedManyWithoutTargetUserInput
    adminCasesStaff?: AdminCaseUncheckedCreateNestedManyWithoutStaffUserInput
    reputation?: UserReputationUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutClosedTicketsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutClosedTicketsInput, UserUncheckedCreateWithoutClosedTicketsInput>
  }

  export type TicketMessageCreateWithoutTicketInput = {
    id?: string
    content: string
    isDeleted?: boolean
    createdAt?: Date | string
    author: UserCreateNestedOneWithoutTicketMsgsInput
  }

  export type TicketMessageUncheckedCreateWithoutTicketInput = {
    id?: string
    authorId: string
    content: string
    isDeleted?: boolean
    createdAt?: Date | string
  }

  export type TicketMessageCreateOrConnectWithoutTicketInput = {
    where: TicketMessageWhereUniqueInput
    create: XOR<TicketMessageCreateWithoutTicketInput, TicketMessageUncheckedCreateWithoutTicketInput>
  }

  export type TicketMessageCreateManyTicketInputEnvelope = {
    data: TicketMessageCreateManyTicketInput | TicketMessageCreateManyTicketInput[]
  }

  export type TicketParticipantCreateWithoutTicketInput = {
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutTicketParticipantsInput
    addedBy?: UserCreateNestedOneWithoutTicketParticipantsAddedInput
  }

  export type TicketParticipantUncheckedCreateWithoutTicketInput = {
    userId: string
    addedById?: string | null
    createdAt?: Date | string
  }

  export type TicketParticipantCreateOrConnectWithoutTicketInput = {
    where: TicketParticipantWhereUniqueInput
    create: XOR<TicketParticipantCreateWithoutTicketInput, TicketParticipantUncheckedCreateWithoutTicketInput>
  }

  export type TicketParticipantCreateManyTicketInputEnvelope = {
    data: TicketParticipantCreateManyTicketInput | TicketParticipantCreateManyTicketInput[]
  }

  export type TicketRatingCreateWithoutTicketInput = {
    id?: string
    stars: number
    feedback: string
    createdAt?: Date | string
    rater: UserCreateNestedOneWithoutTicketRatingsGivenInput
    target: UserCreateNestedOneWithoutTicketRatingsReceivedInput
  }

  export type TicketRatingUncheckedCreateWithoutTicketInput = {
    id?: string
    raterUserId: string
    targetUserId: string
    stars: number
    feedback: string
    createdAt?: Date | string
  }

  export type TicketRatingCreateOrConnectWithoutTicketInput = {
    where: TicketRatingWhereUniqueInput
    create: XOR<TicketRatingCreateWithoutTicketInput, TicketRatingUncheckedCreateWithoutTicketInput>
  }

  export type TicketRatingCreateManyTicketInputEnvelope = {
    data: TicketRatingCreateManyTicketInput | TicketRatingCreateManyTicketInput[]
  }

  export type TicketRatingRequirementCreateWithoutTicketInput = {
    id?: string
    completed?: boolean
    createdAt?: Date | string
    rater: UserCreateNestedOneWithoutTicketRatingReqGivenInput
    target: UserCreateNestedOneWithoutTicketRatingReqReceivedInput
  }

  export type TicketRatingRequirementUncheckedCreateWithoutTicketInput = {
    id?: string
    raterId: string
    targetId: string
    completed?: boolean
    createdAt?: Date | string
  }

  export type TicketRatingRequirementCreateOrConnectWithoutTicketInput = {
    where: TicketRatingRequirementWhereUniqueInput
    create: XOR<TicketRatingRequirementCreateWithoutTicketInput, TicketRatingRequirementUncheckedCreateWithoutTicketInput>
  }

  export type TicketRatingRequirementCreateManyTicketInputEnvelope = {
    data: TicketRatingRequirementCreateManyTicketInput | TicketRatingRequirementCreateManyTicketInput[]
  }

  export type TicketCategoryUpsertWithoutTicketsInput = {
    update: XOR<TicketCategoryUpdateWithoutTicketsInput, TicketCategoryUncheckedUpdateWithoutTicketsInput>
    create: XOR<TicketCategoryCreateWithoutTicketsInput, TicketCategoryUncheckedCreateWithoutTicketsInput>
    where?: TicketCategoryWhereInput
  }

  export type TicketCategoryUpdateToOneWithWhereWithoutTicketsInput = {
    where?: TicketCategoryWhereInput
    data: XOR<TicketCategoryUpdateWithoutTicketsInput, TicketCategoryUncheckedUpdateWithoutTicketsInput>
  }

  export type TicketCategoryUpdateWithoutTicketsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketCategoryUncheckedUpdateWithoutTicketsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutTicketsInput = {
    update: XOR<UserUpdateWithoutTicketsInput, UserUncheckedUpdateWithoutTicketsInput>
    create: XOR<UserCreateWithoutTicketsInput, UserUncheckedCreateWithoutTicketsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTicketsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTicketsInput, UserUncheckedUpdateWithoutTicketsInput>
  }

  export type UserUpdateWithoutTicketsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifyToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerifyExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    discordId?: NullableStringFieldUpdateOperationsInput | string | null
    discordUsername?: NullableStringFieldUpdateOperationsInput | string | null
    avatarKey?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    bannedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    whitelistStatus?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    lastSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    topics?: TopicUpdateManyWithoutAuthorNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    assignedTickets?: TicketUpdateManyWithoutAssignedToNestedInput
    ticketMsgs?: TicketMessageUpdateManyWithoutAuthorNestedInput
    ticketParticipants?: TicketParticipantUpdateManyWithoutUserNestedInput
    ticketParticipantsAdded?: TicketParticipantUpdateManyWithoutAddedByNestedInput
    ticketRatingsGiven?: TicketRatingUpdateManyWithoutRaterNestedInput
    ticketRatingsReceived?: TicketRatingUpdateManyWithoutTargetNestedInput
    closedTickets?: TicketUpdateManyWithoutClosedByNestedInput
    purchases?: PurchaseUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    whitelistApps?: WhitelistApplicationUpdateManyWithoutUserNestedInput
    reviewedWhitelists?: WhitelistApplicationUpdateManyWithoutReviewerNestedInput
    convoParts?: ConversationParticipantUpdateManyWithoutUserNestedInput
    sentMessages?: DirectMessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: DirectMessageUpdateManyWithoutReceiverNestedInput
    userBadges?: UserBadgeUpdateManyWithoutUserNestedInput
    gameAccounts?: GameAccountUpdateManyWithoutUserNestedInput
    mtaAccessLogs?: MtaAccessLogUpdateManyWithoutUserNestedInput
    ticketRatingReqGiven?: TicketRatingRequirementUpdateManyWithoutRaterNestedInput
    ticketRatingReqReceived?: TicketRatingRequirementUpdateManyWithoutTargetNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    entitlements?: EntitlementUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    staffShifts?: StaffShiftUpdateManyWithoutUserNestedInput
    staffWeeklyRewards?: StaffWeeklyRewardUpdateManyWithoutUserNestedInput
    adminCasesTarget?: AdminCaseUpdateManyWithoutTargetUserNestedInput
    adminCasesStaff?: AdminCaseUpdateManyWithoutStaffUserNestedInput
    reputation?: UserReputationUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTicketsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifyToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerifyExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    discordId?: NullableStringFieldUpdateOperationsInput | string | null
    discordUsername?: NullableStringFieldUpdateOperationsInput | string | null
    avatarKey?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    bannedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    whitelistStatus?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    lastSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    topics?: TopicUncheckedUpdateManyWithoutAuthorNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    assignedTickets?: TicketUncheckedUpdateManyWithoutAssignedToNestedInput
    ticketMsgs?: TicketMessageUncheckedUpdateManyWithoutAuthorNestedInput
    ticketParticipants?: TicketParticipantUncheckedUpdateManyWithoutUserNestedInput
    ticketParticipantsAdded?: TicketParticipantUncheckedUpdateManyWithoutAddedByNestedInput
    ticketRatingsGiven?: TicketRatingUncheckedUpdateManyWithoutRaterNestedInput
    ticketRatingsReceived?: TicketRatingUncheckedUpdateManyWithoutTargetNestedInput
    closedTickets?: TicketUncheckedUpdateManyWithoutClosedByNestedInput
    purchases?: PurchaseUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    whitelistApps?: WhitelistApplicationUncheckedUpdateManyWithoutUserNestedInput
    reviewedWhitelists?: WhitelistApplicationUncheckedUpdateManyWithoutReviewerNestedInput
    convoParts?: ConversationParticipantUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: DirectMessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: DirectMessageUncheckedUpdateManyWithoutReceiverNestedInput
    userBadges?: UserBadgeUncheckedUpdateManyWithoutUserNestedInput
    gameAccounts?: GameAccountUncheckedUpdateManyWithoutUserNestedInput
    mtaAccessLogs?: MtaAccessLogUncheckedUpdateManyWithoutUserNestedInput
    ticketRatingReqGiven?: TicketRatingRequirementUncheckedUpdateManyWithoutRaterNestedInput
    ticketRatingReqReceived?: TicketRatingRequirementUncheckedUpdateManyWithoutTargetNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    entitlements?: EntitlementUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    staffShifts?: StaffShiftUncheckedUpdateManyWithoutUserNestedInput
    staffWeeklyRewards?: StaffWeeklyRewardUncheckedUpdateManyWithoutUserNestedInput
    adminCasesTarget?: AdminCaseUncheckedUpdateManyWithoutTargetUserNestedInput
    adminCasesStaff?: AdminCaseUncheckedUpdateManyWithoutStaffUserNestedInput
    reputation?: UserReputationUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserUpsertWithoutAssignedTicketsInput = {
    update: XOR<UserUpdateWithoutAssignedTicketsInput, UserUncheckedUpdateWithoutAssignedTicketsInput>
    create: XOR<UserCreateWithoutAssignedTicketsInput, UserUncheckedCreateWithoutAssignedTicketsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAssignedTicketsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAssignedTicketsInput, UserUncheckedUpdateWithoutAssignedTicketsInput>
  }

  export type UserUpdateWithoutAssignedTicketsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifyToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerifyExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    discordId?: NullableStringFieldUpdateOperationsInput | string | null
    discordUsername?: NullableStringFieldUpdateOperationsInput | string | null
    avatarKey?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    bannedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    whitelistStatus?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    lastSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    topics?: TopicUpdateManyWithoutAuthorNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    tickets?: TicketUpdateManyWithoutAuthorNestedInput
    ticketMsgs?: TicketMessageUpdateManyWithoutAuthorNestedInput
    ticketParticipants?: TicketParticipantUpdateManyWithoutUserNestedInput
    ticketParticipantsAdded?: TicketParticipantUpdateManyWithoutAddedByNestedInput
    ticketRatingsGiven?: TicketRatingUpdateManyWithoutRaterNestedInput
    ticketRatingsReceived?: TicketRatingUpdateManyWithoutTargetNestedInput
    closedTickets?: TicketUpdateManyWithoutClosedByNestedInput
    purchases?: PurchaseUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    whitelistApps?: WhitelistApplicationUpdateManyWithoutUserNestedInput
    reviewedWhitelists?: WhitelistApplicationUpdateManyWithoutReviewerNestedInput
    convoParts?: ConversationParticipantUpdateManyWithoutUserNestedInput
    sentMessages?: DirectMessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: DirectMessageUpdateManyWithoutReceiverNestedInput
    userBadges?: UserBadgeUpdateManyWithoutUserNestedInput
    gameAccounts?: GameAccountUpdateManyWithoutUserNestedInput
    mtaAccessLogs?: MtaAccessLogUpdateManyWithoutUserNestedInput
    ticketRatingReqGiven?: TicketRatingRequirementUpdateManyWithoutRaterNestedInput
    ticketRatingReqReceived?: TicketRatingRequirementUpdateManyWithoutTargetNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    entitlements?: EntitlementUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    staffShifts?: StaffShiftUpdateManyWithoutUserNestedInput
    staffWeeklyRewards?: StaffWeeklyRewardUpdateManyWithoutUserNestedInput
    adminCasesTarget?: AdminCaseUpdateManyWithoutTargetUserNestedInput
    adminCasesStaff?: AdminCaseUpdateManyWithoutStaffUserNestedInput
    reputation?: UserReputationUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAssignedTicketsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifyToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerifyExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    discordId?: NullableStringFieldUpdateOperationsInput | string | null
    discordUsername?: NullableStringFieldUpdateOperationsInput | string | null
    avatarKey?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    bannedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    whitelistStatus?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    lastSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    topics?: TopicUncheckedUpdateManyWithoutAuthorNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutAuthorNestedInput
    ticketMsgs?: TicketMessageUncheckedUpdateManyWithoutAuthorNestedInput
    ticketParticipants?: TicketParticipantUncheckedUpdateManyWithoutUserNestedInput
    ticketParticipantsAdded?: TicketParticipantUncheckedUpdateManyWithoutAddedByNestedInput
    ticketRatingsGiven?: TicketRatingUncheckedUpdateManyWithoutRaterNestedInput
    ticketRatingsReceived?: TicketRatingUncheckedUpdateManyWithoutTargetNestedInput
    closedTickets?: TicketUncheckedUpdateManyWithoutClosedByNestedInput
    purchases?: PurchaseUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    whitelistApps?: WhitelistApplicationUncheckedUpdateManyWithoutUserNestedInput
    reviewedWhitelists?: WhitelistApplicationUncheckedUpdateManyWithoutReviewerNestedInput
    convoParts?: ConversationParticipantUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: DirectMessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: DirectMessageUncheckedUpdateManyWithoutReceiverNestedInput
    userBadges?: UserBadgeUncheckedUpdateManyWithoutUserNestedInput
    gameAccounts?: GameAccountUncheckedUpdateManyWithoutUserNestedInput
    mtaAccessLogs?: MtaAccessLogUncheckedUpdateManyWithoutUserNestedInput
    ticketRatingReqGiven?: TicketRatingRequirementUncheckedUpdateManyWithoutRaterNestedInput
    ticketRatingReqReceived?: TicketRatingRequirementUncheckedUpdateManyWithoutTargetNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    entitlements?: EntitlementUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    staffShifts?: StaffShiftUncheckedUpdateManyWithoutUserNestedInput
    staffWeeklyRewards?: StaffWeeklyRewardUncheckedUpdateManyWithoutUserNestedInput
    adminCasesTarget?: AdminCaseUncheckedUpdateManyWithoutTargetUserNestedInput
    adminCasesStaff?: AdminCaseUncheckedUpdateManyWithoutStaffUserNestedInput
    reputation?: UserReputationUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserUpsertWithoutClosedTicketsInput = {
    update: XOR<UserUpdateWithoutClosedTicketsInput, UserUncheckedUpdateWithoutClosedTicketsInput>
    create: XOR<UserCreateWithoutClosedTicketsInput, UserUncheckedCreateWithoutClosedTicketsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutClosedTicketsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutClosedTicketsInput, UserUncheckedUpdateWithoutClosedTicketsInput>
  }

  export type UserUpdateWithoutClosedTicketsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifyToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerifyExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    discordId?: NullableStringFieldUpdateOperationsInput | string | null
    discordUsername?: NullableStringFieldUpdateOperationsInput | string | null
    avatarKey?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    bannedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    whitelistStatus?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    lastSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    topics?: TopicUpdateManyWithoutAuthorNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    tickets?: TicketUpdateManyWithoutAuthorNestedInput
    assignedTickets?: TicketUpdateManyWithoutAssignedToNestedInput
    ticketMsgs?: TicketMessageUpdateManyWithoutAuthorNestedInput
    ticketParticipants?: TicketParticipantUpdateManyWithoutUserNestedInput
    ticketParticipantsAdded?: TicketParticipantUpdateManyWithoutAddedByNestedInput
    ticketRatingsGiven?: TicketRatingUpdateManyWithoutRaterNestedInput
    ticketRatingsReceived?: TicketRatingUpdateManyWithoutTargetNestedInput
    purchases?: PurchaseUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    whitelistApps?: WhitelistApplicationUpdateManyWithoutUserNestedInput
    reviewedWhitelists?: WhitelistApplicationUpdateManyWithoutReviewerNestedInput
    convoParts?: ConversationParticipantUpdateManyWithoutUserNestedInput
    sentMessages?: DirectMessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: DirectMessageUpdateManyWithoutReceiverNestedInput
    userBadges?: UserBadgeUpdateManyWithoutUserNestedInput
    gameAccounts?: GameAccountUpdateManyWithoutUserNestedInput
    mtaAccessLogs?: MtaAccessLogUpdateManyWithoutUserNestedInput
    ticketRatingReqGiven?: TicketRatingRequirementUpdateManyWithoutRaterNestedInput
    ticketRatingReqReceived?: TicketRatingRequirementUpdateManyWithoutTargetNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    entitlements?: EntitlementUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    staffShifts?: StaffShiftUpdateManyWithoutUserNestedInput
    staffWeeklyRewards?: StaffWeeklyRewardUpdateManyWithoutUserNestedInput
    adminCasesTarget?: AdminCaseUpdateManyWithoutTargetUserNestedInput
    adminCasesStaff?: AdminCaseUpdateManyWithoutStaffUserNestedInput
    reputation?: UserReputationUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutClosedTicketsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifyToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerifyExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    discordId?: NullableStringFieldUpdateOperationsInput | string | null
    discordUsername?: NullableStringFieldUpdateOperationsInput | string | null
    avatarKey?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    bannedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    whitelistStatus?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    lastSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    topics?: TopicUncheckedUpdateManyWithoutAuthorNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutAuthorNestedInput
    assignedTickets?: TicketUncheckedUpdateManyWithoutAssignedToNestedInput
    ticketMsgs?: TicketMessageUncheckedUpdateManyWithoutAuthorNestedInput
    ticketParticipants?: TicketParticipantUncheckedUpdateManyWithoutUserNestedInput
    ticketParticipantsAdded?: TicketParticipantUncheckedUpdateManyWithoutAddedByNestedInput
    ticketRatingsGiven?: TicketRatingUncheckedUpdateManyWithoutRaterNestedInput
    ticketRatingsReceived?: TicketRatingUncheckedUpdateManyWithoutTargetNestedInput
    purchases?: PurchaseUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    whitelistApps?: WhitelistApplicationUncheckedUpdateManyWithoutUserNestedInput
    reviewedWhitelists?: WhitelistApplicationUncheckedUpdateManyWithoutReviewerNestedInput
    convoParts?: ConversationParticipantUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: DirectMessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: DirectMessageUncheckedUpdateManyWithoutReceiverNestedInput
    userBadges?: UserBadgeUncheckedUpdateManyWithoutUserNestedInput
    gameAccounts?: GameAccountUncheckedUpdateManyWithoutUserNestedInput
    mtaAccessLogs?: MtaAccessLogUncheckedUpdateManyWithoutUserNestedInput
    ticketRatingReqGiven?: TicketRatingRequirementUncheckedUpdateManyWithoutRaterNestedInput
    ticketRatingReqReceived?: TicketRatingRequirementUncheckedUpdateManyWithoutTargetNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    entitlements?: EntitlementUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    staffShifts?: StaffShiftUncheckedUpdateManyWithoutUserNestedInput
    staffWeeklyRewards?: StaffWeeklyRewardUncheckedUpdateManyWithoutUserNestedInput
    adminCasesTarget?: AdminCaseUncheckedUpdateManyWithoutTargetUserNestedInput
    adminCasesStaff?: AdminCaseUncheckedUpdateManyWithoutStaffUserNestedInput
    reputation?: UserReputationUncheckedUpdateOneWithoutUserNestedInput
  }

  export type TicketMessageUpsertWithWhereUniqueWithoutTicketInput = {
    where: TicketMessageWhereUniqueInput
    update: XOR<TicketMessageUpdateWithoutTicketInput, TicketMessageUncheckedUpdateWithoutTicketInput>
    create: XOR<TicketMessageCreateWithoutTicketInput, TicketMessageUncheckedCreateWithoutTicketInput>
  }

  export type TicketMessageUpdateWithWhereUniqueWithoutTicketInput = {
    where: TicketMessageWhereUniqueInput
    data: XOR<TicketMessageUpdateWithoutTicketInput, TicketMessageUncheckedUpdateWithoutTicketInput>
  }

  export type TicketMessageUpdateManyWithWhereWithoutTicketInput = {
    where: TicketMessageScalarWhereInput
    data: XOR<TicketMessageUpdateManyMutationInput, TicketMessageUncheckedUpdateManyWithoutTicketInput>
  }

  export type TicketParticipantUpsertWithWhereUniqueWithoutTicketInput = {
    where: TicketParticipantWhereUniqueInput
    update: XOR<TicketParticipantUpdateWithoutTicketInput, TicketParticipantUncheckedUpdateWithoutTicketInput>
    create: XOR<TicketParticipantCreateWithoutTicketInput, TicketParticipantUncheckedCreateWithoutTicketInput>
  }

  export type TicketParticipantUpdateWithWhereUniqueWithoutTicketInput = {
    where: TicketParticipantWhereUniqueInput
    data: XOR<TicketParticipantUpdateWithoutTicketInput, TicketParticipantUncheckedUpdateWithoutTicketInput>
  }

  export type TicketParticipantUpdateManyWithWhereWithoutTicketInput = {
    where: TicketParticipantScalarWhereInput
    data: XOR<TicketParticipantUpdateManyMutationInput, TicketParticipantUncheckedUpdateManyWithoutTicketInput>
  }

  export type TicketRatingUpsertWithWhereUniqueWithoutTicketInput = {
    where: TicketRatingWhereUniqueInput
    update: XOR<TicketRatingUpdateWithoutTicketInput, TicketRatingUncheckedUpdateWithoutTicketInput>
    create: XOR<TicketRatingCreateWithoutTicketInput, TicketRatingUncheckedCreateWithoutTicketInput>
  }

  export type TicketRatingUpdateWithWhereUniqueWithoutTicketInput = {
    where: TicketRatingWhereUniqueInput
    data: XOR<TicketRatingUpdateWithoutTicketInput, TicketRatingUncheckedUpdateWithoutTicketInput>
  }

  export type TicketRatingUpdateManyWithWhereWithoutTicketInput = {
    where: TicketRatingScalarWhereInput
    data: XOR<TicketRatingUpdateManyMutationInput, TicketRatingUncheckedUpdateManyWithoutTicketInput>
  }

  export type TicketRatingRequirementUpsertWithWhereUniqueWithoutTicketInput = {
    where: TicketRatingRequirementWhereUniqueInput
    update: XOR<TicketRatingRequirementUpdateWithoutTicketInput, TicketRatingRequirementUncheckedUpdateWithoutTicketInput>
    create: XOR<TicketRatingRequirementCreateWithoutTicketInput, TicketRatingRequirementUncheckedCreateWithoutTicketInput>
  }

  export type TicketRatingRequirementUpdateWithWhereUniqueWithoutTicketInput = {
    where: TicketRatingRequirementWhereUniqueInput
    data: XOR<TicketRatingRequirementUpdateWithoutTicketInput, TicketRatingRequirementUncheckedUpdateWithoutTicketInput>
  }

  export type TicketRatingRequirementUpdateManyWithWhereWithoutTicketInput = {
    where: TicketRatingRequirementScalarWhereInput
    data: XOR<TicketRatingRequirementUpdateManyMutationInput, TicketRatingRequirementUncheckedUpdateManyWithoutTicketInput>
  }

  export type TicketCreateWithoutMessagesInput = {
    id?: string
    title: string
    status?: string
    priority?: string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    closedAt?: Date | string | null
    category: TicketCategoryCreateNestedOneWithoutTicketsInput
    author: UserCreateNestedOneWithoutTicketsInput
    assignedTo?: UserCreateNestedOneWithoutAssignedTicketsInput
    closedBy?: UserCreateNestedOneWithoutClosedTicketsInput
    participants?: TicketParticipantCreateNestedManyWithoutTicketInput
    ratings?: TicketRatingCreateNestedManyWithoutTicketInput
    ratingRequirements?: TicketRatingRequirementCreateNestedManyWithoutTicketInput
  }

  export type TicketUncheckedCreateWithoutMessagesInput = {
    id?: string
    categoryId: string
    authorId: string
    title: string
    status?: string
    priority?: string
    assignedToId?: string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    closedAt?: Date | string | null
    closedById?: string | null
    participants?: TicketParticipantUncheckedCreateNestedManyWithoutTicketInput
    ratings?: TicketRatingUncheckedCreateNestedManyWithoutTicketInput
    ratingRequirements?: TicketRatingRequirementUncheckedCreateNestedManyWithoutTicketInput
  }

  export type TicketCreateOrConnectWithoutMessagesInput = {
    where: TicketWhereUniqueInput
    create: XOR<TicketCreateWithoutMessagesInput, TicketUncheckedCreateWithoutMessagesInput>
  }

  export type UserCreateWithoutTicketMsgsInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    emailVerifiedAt?: Date | string | null
    emailVerifyToken?: string | null
    emailVerifyExpiresAt?: Date | string | null
    phone?: string | null
    recoveryEmail?: string | null
    googleId?: string | null
    discordId?: string | null
    discordUsername?: string | null
    avatarKey?: string
    role?: string
    isDeleted?: boolean
    bannedUntil?: Date | string | null
    whitelistStatus?: string
    points?: number
    lastSeenAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    avatarUrl?: string | null
    topics?: TopicCreateNestedManyWithoutAuthorInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    tickets?: TicketCreateNestedManyWithoutAuthorInput
    assignedTickets?: TicketCreateNestedManyWithoutAssignedToInput
    ticketParticipants?: TicketParticipantCreateNestedManyWithoutUserInput
    ticketParticipantsAdded?: TicketParticipantCreateNestedManyWithoutAddedByInput
    ticketRatingsGiven?: TicketRatingCreateNestedManyWithoutRaterInput
    ticketRatingsReceived?: TicketRatingCreateNestedManyWithoutTargetInput
    closedTickets?: TicketCreateNestedManyWithoutClosedByInput
    purchases?: PurchaseCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    whitelistApps?: WhitelistApplicationCreateNestedManyWithoutUserInput
    reviewedWhitelists?: WhitelistApplicationCreateNestedManyWithoutReviewerInput
    convoParts?: ConversationParticipantCreateNestedManyWithoutUserInput
    sentMessages?: DirectMessageCreateNestedManyWithoutSenderInput
    receivedMessages?: DirectMessageCreateNestedManyWithoutReceiverInput
    userBadges?: UserBadgeCreateNestedManyWithoutUserInput
    gameAccounts?: GameAccountCreateNestedManyWithoutUserInput
    mtaAccessLogs?: MtaAccessLogCreateNestedManyWithoutUserInput
    ticketRatingReqGiven?: TicketRatingRequirementCreateNestedManyWithoutRaterInput
    ticketRatingReqReceived?: TicketRatingRequirementCreateNestedManyWithoutTargetInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    entitlements?: EntitlementCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    staffShifts?: StaffShiftCreateNestedManyWithoutUserInput
    staffWeeklyRewards?: StaffWeeklyRewardCreateNestedManyWithoutUserInput
    adminCasesTarget?: AdminCaseCreateNestedManyWithoutTargetUserInput
    adminCasesStaff?: AdminCaseCreateNestedManyWithoutStaffUserInput
    reputation?: UserReputationCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTicketMsgsInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    emailVerifiedAt?: Date | string | null
    emailVerifyToken?: string | null
    emailVerifyExpiresAt?: Date | string | null
    phone?: string | null
    recoveryEmail?: string | null
    googleId?: string | null
    discordId?: string | null
    discordUsername?: string | null
    avatarKey?: string
    role?: string
    isDeleted?: boolean
    bannedUntil?: Date | string | null
    whitelistStatus?: string
    points?: number
    lastSeenAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    avatarUrl?: string | null
    topics?: TopicUncheckedCreateNestedManyWithoutAuthorInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    tickets?: TicketUncheckedCreateNestedManyWithoutAuthorInput
    assignedTickets?: TicketUncheckedCreateNestedManyWithoutAssignedToInput
    ticketParticipants?: TicketParticipantUncheckedCreateNestedManyWithoutUserInput
    ticketParticipantsAdded?: TicketParticipantUncheckedCreateNestedManyWithoutAddedByInput
    ticketRatingsGiven?: TicketRatingUncheckedCreateNestedManyWithoutRaterInput
    ticketRatingsReceived?: TicketRatingUncheckedCreateNestedManyWithoutTargetInput
    closedTickets?: TicketUncheckedCreateNestedManyWithoutClosedByInput
    purchases?: PurchaseUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    whitelistApps?: WhitelistApplicationUncheckedCreateNestedManyWithoutUserInput
    reviewedWhitelists?: WhitelistApplicationUncheckedCreateNestedManyWithoutReviewerInput
    convoParts?: ConversationParticipantUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: DirectMessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: DirectMessageUncheckedCreateNestedManyWithoutReceiverInput
    userBadges?: UserBadgeUncheckedCreateNestedManyWithoutUserInput
    gameAccounts?: GameAccountUncheckedCreateNestedManyWithoutUserInput
    mtaAccessLogs?: MtaAccessLogUncheckedCreateNestedManyWithoutUserInput
    ticketRatingReqGiven?: TicketRatingRequirementUncheckedCreateNestedManyWithoutRaterInput
    ticketRatingReqReceived?: TicketRatingRequirementUncheckedCreateNestedManyWithoutTargetInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    entitlements?: EntitlementUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    staffShifts?: StaffShiftUncheckedCreateNestedManyWithoutUserInput
    staffWeeklyRewards?: StaffWeeklyRewardUncheckedCreateNestedManyWithoutUserInput
    adminCasesTarget?: AdminCaseUncheckedCreateNestedManyWithoutTargetUserInput
    adminCasesStaff?: AdminCaseUncheckedCreateNestedManyWithoutStaffUserInput
    reputation?: UserReputationUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTicketMsgsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTicketMsgsInput, UserUncheckedCreateWithoutTicketMsgsInput>
  }

  export type TicketUpsertWithoutMessagesInput = {
    update: XOR<TicketUpdateWithoutMessagesInput, TicketUncheckedUpdateWithoutMessagesInput>
    create: XOR<TicketCreateWithoutMessagesInput, TicketUncheckedCreateWithoutMessagesInput>
    where?: TicketWhereInput
  }

  export type TicketUpdateToOneWithWhereWithoutMessagesInput = {
    where?: TicketWhereInput
    data: XOR<TicketUpdateWithoutMessagesInput, TicketUncheckedUpdateWithoutMessagesInput>
  }

  export type TicketUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: TicketCategoryUpdateOneRequiredWithoutTicketsNestedInput
    author?: UserUpdateOneRequiredWithoutTicketsNestedInput
    assignedTo?: UserUpdateOneWithoutAssignedTicketsNestedInput
    closedBy?: UserUpdateOneWithoutClosedTicketsNestedInput
    participants?: TicketParticipantUpdateManyWithoutTicketNestedInput
    ratings?: TicketRatingUpdateManyWithoutTicketNestedInput
    ratingRequirements?: TicketRatingRequirementUpdateManyWithoutTicketNestedInput
  }

  export type TicketUncheckedUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedById?: NullableStringFieldUpdateOperationsInput | string | null
    participants?: TicketParticipantUncheckedUpdateManyWithoutTicketNestedInput
    ratings?: TicketRatingUncheckedUpdateManyWithoutTicketNestedInput
    ratingRequirements?: TicketRatingRequirementUncheckedUpdateManyWithoutTicketNestedInput
  }

  export type UserUpsertWithoutTicketMsgsInput = {
    update: XOR<UserUpdateWithoutTicketMsgsInput, UserUncheckedUpdateWithoutTicketMsgsInput>
    create: XOR<UserCreateWithoutTicketMsgsInput, UserUncheckedCreateWithoutTicketMsgsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTicketMsgsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTicketMsgsInput, UserUncheckedUpdateWithoutTicketMsgsInput>
  }

  export type UserUpdateWithoutTicketMsgsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifyToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerifyExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    discordId?: NullableStringFieldUpdateOperationsInput | string | null
    discordUsername?: NullableStringFieldUpdateOperationsInput | string | null
    avatarKey?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    bannedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    whitelistStatus?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    lastSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    topics?: TopicUpdateManyWithoutAuthorNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    tickets?: TicketUpdateManyWithoutAuthorNestedInput
    assignedTickets?: TicketUpdateManyWithoutAssignedToNestedInput
    ticketParticipants?: TicketParticipantUpdateManyWithoutUserNestedInput
    ticketParticipantsAdded?: TicketParticipantUpdateManyWithoutAddedByNestedInput
    ticketRatingsGiven?: TicketRatingUpdateManyWithoutRaterNestedInput
    ticketRatingsReceived?: TicketRatingUpdateManyWithoutTargetNestedInput
    closedTickets?: TicketUpdateManyWithoutClosedByNestedInput
    purchases?: PurchaseUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    whitelistApps?: WhitelistApplicationUpdateManyWithoutUserNestedInput
    reviewedWhitelists?: WhitelistApplicationUpdateManyWithoutReviewerNestedInput
    convoParts?: ConversationParticipantUpdateManyWithoutUserNestedInput
    sentMessages?: DirectMessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: DirectMessageUpdateManyWithoutReceiverNestedInput
    userBadges?: UserBadgeUpdateManyWithoutUserNestedInput
    gameAccounts?: GameAccountUpdateManyWithoutUserNestedInput
    mtaAccessLogs?: MtaAccessLogUpdateManyWithoutUserNestedInput
    ticketRatingReqGiven?: TicketRatingRequirementUpdateManyWithoutRaterNestedInput
    ticketRatingReqReceived?: TicketRatingRequirementUpdateManyWithoutTargetNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    entitlements?: EntitlementUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    staffShifts?: StaffShiftUpdateManyWithoutUserNestedInput
    staffWeeklyRewards?: StaffWeeklyRewardUpdateManyWithoutUserNestedInput
    adminCasesTarget?: AdminCaseUpdateManyWithoutTargetUserNestedInput
    adminCasesStaff?: AdminCaseUpdateManyWithoutStaffUserNestedInput
    reputation?: UserReputationUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTicketMsgsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifyToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerifyExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    discordId?: NullableStringFieldUpdateOperationsInput | string | null
    discordUsername?: NullableStringFieldUpdateOperationsInput | string | null
    avatarKey?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    bannedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    whitelistStatus?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    lastSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    topics?: TopicUncheckedUpdateManyWithoutAuthorNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutAuthorNestedInput
    assignedTickets?: TicketUncheckedUpdateManyWithoutAssignedToNestedInput
    ticketParticipants?: TicketParticipantUncheckedUpdateManyWithoutUserNestedInput
    ticketParticipantsAdded?: TicketParticipantUncheckedUpdateManyWithoutAddedByNestedInput
    ticketRatingsGiven?: TicketRatingUncheckedUpdateManyWithoutRaterNestedInput
    ticketRatingsReceived?: TicketRatingUncheckedUpdateManyWithoutTargetNestedInput
    closedTickets?: TicketUncheckedUpdateManyWithoutClosedByNestedInput
    purchases?: PurchaseUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    whitelistApps?: WhitelistApplicationUncheckedUpdateManyWithoutUserNestedInput
    reviewedWhitelists?: WhitelistApplicationUncheckedUpdateManyWithoutReviewerNestedInput
    convoParts?: ConversationParticipantUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: DirectMessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: DirectMessageUncheckedUpdateManyWithoutReceiverNestedInput
    userBadges?: UserBadgeUncheckedUpdateManyWithoutUserNestedInput
    gameAccounts?: GameAccountUncheckedUpdateManyWithoutUserNestedInput
    mtaAccessLogs?: MtaAccessLogUncheckedUpdateManyWithoutUserNestedInput
    ticketRatingReqGiven?: TicketRatingRequirementUncheckedUpdateManyWithoutRaterNestedInput
    ticketRatingReqReceived?: TicketRatingRequirementUncheckedUpdateManyWithoutTargetNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    entitlements?: EntitlementUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    staffShifts?: StaffShiftUncheckedUpdateManyWithoutUserNestedInput
    staffWeeklyRewards?: StaffWeeklyRewardUncheckedUpdateManyWithoutUserNestedInput
    adminCasesTarget?: AdminCaseUncheckedUpdateManyWithoutTargetUserNestedInput
    adminCasesStaff?: AdminCaseUncheckedUpdateManyWithoutStaffUserNestedInput
    reputation?: UserReputationUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserCreateWithoutPurchasesInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    emailVerifiedAt?: Date | string | null
    emailVerifyToken?: string | null
    emailVerifyExpiresAt?: Date | string | null
    phone?: string | null
    recoveryEmail?: string | null
    googleId?: string | null
    discordId?: string | null
    discordUsername?: string | null
    avatarKey?: string
    role?: string
    isDeleted?: boolean
    bannedUntil?: Date | string | null
    whitelistStatus?: string
    points?: number
    lastSeenAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    avatarUrl?: string | null
    topics?: TopicCreateNestedManyWithoutAuthorInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    tickets?: TicketCreateNestedManyWithoutAuthorInput
    assignedTickets?: TicketCreateNestedManyWithoutAssignedToInput
    ticketMsgs?: TicketMessageCreateNestedManyWithoutAuthorInput
    ticketParticipants?: TicketParticipantCreateNestedManyWithoutUserInput
    ticketParticipantsAdded?: TicketParticipantCreateNestedManyWithoutAddedByInput
    ticketRatingsGiven?: TicketRatingCreateNestedManyWithoutRaterInput
    ticketRatingsReceived?: TicketRatingCreateNestedManyWithoutTargetInput
    closedTickets?: TicketCreateNestedManyWithoutClosedByInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    whitelistApps?: WhitelistApplicationCreateNestedManyWithoutUserInput
    reviewedWhitelists?: WhitelistApplicationCreateNestedManyWithoutReviewerInput
    convoParts?: ConversationParticipantCreateNestedManyWithoutUserInput
    sentMessages?: DirectMessageCreateNestedManyWithoutSenderInput
    receivedMessages?: DirectMessageCreateNestedManyWithoutReceiverInput
    userBadges?: UserBadgeCreateNestedManyWithoutUserInput
    gameAccounts?: GameAccountCreateNestedManyWithoutUserInput
    mtaAccessLogs?: MtaAccessLogCreateNestedManyWithoutUserInput
    ticketRatingReqGiven?: TicketRatingRequirementCreateNestedManyWithoutRaterInput
    ticketRatingReqReceived?: TicketRatingRequirementCreateNestedManyWithoutTargetInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    entitlements?: EntitlementCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    staffShifts?: StaffShiftCreateNestedManyWithoutUserInput
    staffWeeklyRewards?: StaffWeeklyRewardCreateNestedManyWithoutUserInput
    adminCasesTarget?: AdminCaseCreateNestedManyWithoutTargetUserInput
    adminCasesStaff?: AdminCaseCreateNestedManyWithoutStaffUserInput
    reputation?: UserReputationCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPurchasesInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    emailVerifiedAt?: Date | string | null
    emailVerifyToken?: string | null
    emailVerifyExpiresAt?: Date | string | null
    phone?: string | null
    recoveryEmail?: string | null
    googleId?: string | null
    discordId?: string | null
    discordUsername?: string | null
    avatarKey?: string
    role?: string
    isDeleted?: boolean
    bannedUntil?: Date | string | null
    whitelistStatus?: string
    points?: number
    lastSeenAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    avatarUrl?: string | null
    topics?: TopicUncheckedCreateNestedManyWithoutAuthorInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    tickets?: TicketUncheckedCreateNestedManyWithoutAuthorInput
    assignedTickets?: TicketUncheckedCreateNestedManyWithoutAssignedToInput
    ticketMsgs?: TicketMessageUncheckedCreateNestedManyWithoutAuthorInput
    ticketParticipants?: TicketParticipantUncheckedCreateNestedManyWithoutUserInput
    ticketParticipantsAdded?: TicketParticipantUncheckedCreateNestedManyWithoutAddedByInput
    ticketRatingsGiven?: TicketRatingUncheckedCreateNestedManyWithoutRaterInput
    ticketRatingsReceived?: TicketRatingUncheckedCreateNestedManyWithoutTargetInput
    closedTickets?: TicketUncheckedCreateNestedManyWithoutClosedByInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    whitelistApps?: WhitelistApplicationUncheckedCreateNestedManyWithoutUserInput
    reviewedWhitelists?: WhitelistApplicationUncheckedCreateNestedManyWithoutReviewerInput
    convoParts?: ConversationParticipantUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: DirectMessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: DirectMessageUncheckedCreateNestedManyWithoutReceiverInput
    userBadges?: UserBadgeUncheckedCreateNestedManyWithoutUserInput
    gameAccounts?: GameAccountUncheckedCreateNestedManyWithoutUserInput
    mtaAccessLogs?: MtaAccessLogUncheckedCreateNestedManyWithoutUserInput
    ticketRatingReqGiven?: TicketRatingRequirementUncheckedCreateNestedManyWithoutRaterInput
    ticketRatingReqReceived?: TicketRatingRequirementUncheckedCreateNestedManyWithoutTargetInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    entitlements?: EntitlementUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    staffShifts?: StaffShiftUncheckedCreateNestedManyWithoutUserInput
    staffWeeklyRewards?: StaffWeeklyRewardUncheckedCreateNestedManyWithoutUserInput
    adminCasesTarget?: AdminCaseUncheckedCreateNestedManyWithoutTargetUserInput
    adminCasesStaff?: AdminCaseUncheckedCreateNestedManyWithoutStaffUserInput
    reputation?: UserReputationUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPurchasesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPurchasesInput, UserUncheckedCreateWithoutPurchasesInput>
  }

  export type PurchaseItemCreateWithoutPurchaseInput = {
    id?: string
    sku: string
    name: string
    priceCents: number
    durationDays?: number | null
    grantPoints?: number
    grantVipRole?: string | null
    mtaActions?: string | null
    product: ProductCreateNestedOneWithoutPurchaseItemsInput
  }

  export type PurchaseItemUncheckedCreateWithoutPurchaseInput = {
    id?: string
    productId: string
    sku: string
    name: string
    priceCents: number
    durationDays?: number | null
    grantPoints?: number
    grantVipRole?: string | null
    mtaActions?: string | null
  }

  export type PurchaseItemCreateOrConnectWithoutPurchaseInput = {
    where: PurchaseItemWhereUniqueInput
    create: XOR<PurchaseItemCreateWithoutPurchaseInput, PurchaseItemUncheckedCreateWithoutPurchaseInput>
  }

  export type PurchaseItemCreateManyPurchaseInputEnvelope = {
    data: PurchaseItemCreateManyPurchaseInput | PurchaseItemCreateManyPurchaseInput[]
  }

  export type UserUpsertWithoutPurchasesInput = {
    update: XOR<UserUpdateWithoutPurchasesInput, UserUncheckedUpdateWithoutPurchasesInput>
    create: XOR<UserCreateWithoutPurchasesInput, UserUncheckedCreateWithoutPurchasesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPurchasesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPurchasesInput, UserUncheckedUpdateWithoutPurchasesInput>
  }

  export type UserUpdateWithoutPurchasesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifyToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerifyExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    discordId?: NullableStringFieldUpdateOperationsInput | string | null
    discordUsername?: NullableStringFieldUpdateOperationsInput | string | null
    avatarKey?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    bannedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    whitelistStatus?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    lastSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    topics?: TopicUpdateManyWithoutAuthorNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    tickets?: TicketUpdateManyWithoutAuthorNestedInput
    assignedTickets?: TicketUpdateManyWithoutAssignedToNestedInput
    ticketMsgs?: TicketMessageUpdateManyWithoutAuthorNestedInput
    ticketParticipants?: TicketParticipantUpdateManyWithoutUserNestedInput
    ticketParticipantsAdded?: TicketParticipantUpdateManyWithoutAddedByNestedInput
    ticketRatingsGiven?: TicketRatingUpdateManyWithoutRaterNestedInput
    ticketRatingsReceived?: TicketRatingUpdateManyWithoutTargetNestedInput
    closedTickets?: TicketUpdateManyWithoutClosedByNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    whitelistApps?: WhitelistApplicationUpdateManyWithoutUserNestedInput
    reviewedWhitelists?: WhitelistApplicationUpdateManyWithoutReviewerNestedInput
    convoParts?: ConversationParticipantUpdateManyWithoutUserNestedInput
    sentMessages?: DirectMessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: DirectMessageUpdateManyWithoutReceiverNestedInput
    userBadges?: UserBadgeUpdateManyWithoutUserNestedInput
    gameAccounts?: GameAccountUpdateManyWithoutUserNestedInput
    mtaAccessLogs?: MtaAccessLogUpdateManyWithoutUserNestedInput
    ticketRatingReqGiven?: TicketRatingRequirementUpdateManyWithoutRaterNestedInput
    ticketRatingReqReceived?: TicketRatingRequirementUpdateManyWithoutTargetNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    entitlements?: EntitlementUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    staffShifts?: StaffShiftUpdateManyWithoutUserNestedInput
    staffWeeklyRewards?: StaffWeeklyRewardUpdateManyWithoutUserNestedInput
    adminCasesTarget?: AdminCaseUpdateManyWithoutTargetUserNestedInput
    adminCasesStaff?: AdminCaseUpdateManyWithoutStaffUserNestedInput
    reputation?: UserReputationUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPurchasesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifyToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerifyExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    discordId?: NullableStringFieldUpdateOperationsInput | string | null
    discordUsername?: NullableStringFieldUpdateOperationsInput | string | null
    avatarKey?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    bannedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    whitelistStatus?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    lastSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    topics?: TopicUncheckedUpdateManyWithoutAuthorNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutAuthorNestedInput
    assignedTickets?: TicketUncheckedUpdateManyWithoutAssignedToNestedInput
    ticketMsgs?: TicketMessageUncheckedUpdateManyWithoutAuthorNestedInput
    ticketParticipants?: TicketParticipantUncheckedUpdateManyWithoutUserNestedInput
    ticketParticipantsAdded?: TicketParticipantUncheckedUpdateManyWithoutAddedByNestedInput
    ticketRatingsGiven?: TicketRatingUncheckedUpdateManyWithoutRaterNestedInput
    ticketRatingsReceived?: TicketRatingUncheckedUpdateManyWithoutTargetNestedInput
    closedTickets?: TicketUncheckedUpdateManyWithoutClosedByNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    whitelistApps?: WhitelistApplicationUncheckedUpdateManyWithoutUserNestedInput
    reviewedWhitelists?: WhitelistApplicationUncheckedUpdateManyWithoutReviewerNestedInput
    convoParts?: ConversationParticipantUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: DirectMessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: DirectMessageUncheckedUpdateManyWithoutReceiverNestedInput
    userBadges?: UserBadgeUncheckedUpdateManyWithoutUserNestedInput
    gameAccounts?: GameAccountUncheckedUpdateManyWithoutUserNestedInput
    mtaAccessLogs?: MtaAccessLogUncheckedUpdateManyWithoutUserNestedInput
    ticketRatingReqGiven?: TicketRatingRequirementUncheckedUpdateManyWithoutRaterNestedInput
    ticketRatingReqReceived?: TicketRatingRequirementUncheckedUpdateManyWithoutTargetNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    entitlements?: EntitlementUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    staffShifts?: StaffShiftUncheckedUpdateManyWithoutUserNestedInput
    staffWeeklyRewards?: StaffWeeklyRewardUncheckedUpdateManyWithoutUserNestedInput
    adminCasesTarget?: AdminCaseUncheckedUpdateManyWithoutTargetUserNestedInput
    adminCasesStaff?: AdminCaseUncheckedUpdateManyWithoutStaffUserNestedInput
    reputation?: UserReputationUncheckedUpdateOneWithoutUserNestedInput
  }

  export type PurchaseItemUpsertWithWhereUniqueWithoutPurchaseInput = {
    where: PurchaseItemWhereUniqueInput
    update: XOR<PurchaseItemUpdateWithoutPurchaseInput, PurchaseItemUncheckedUpdateWithoutPurchaseInput>
    create: XOR<PurchaseItemCreateWithoutPurchaseInput, PurchaseItemUncheckedCreateWithoutPurchaseInput>
  }

  export type PurchaseItemUpdateWithWhereUniqueWithoutPurchaseInput = {
    where: PurchaseItemWhereUniqueInput
    data: XOR<PurchaseItemUpdateWithoutPurchaseInput, PurchaseItemUncheckedUpdateWithoutPurchaseInput>
  }

  export type PurchaseItemUpdateManyWithWhereWithoutPurchaseInput = {
    where: PurchaseItemScalarWhereInput
    data: XOR<PurchaseItemUpdateManyMutationInput, PurchaseItemUncheckedUpdateManyWithoutPurchaseInput>
  }

  export type UserCreateWithoutAuditLogsInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    emailVerifiedAt?: Date | string | null
    emailVerifyToken?: string | null
    emailVerifyExpiresAt?: Date | string | null
    phone?: string | null
    recoveryEmail?: string | null
    googleId?: string | null
    discordId?: string | null
    discordUsername?: string | null
    avatarKey?: string
    role?: string
    isDeleted?: boolean
    bannedUntil?: Date | string | null
    whitelistStatus?: string
    points?: number
    lastSeenAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    avatarUrl?: string | null
    topics?: TopicCreateNestedManyWithoutAuthorInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    tickets?: TicketCreateNestedManyWithoutAuthorInput
    assignedTickets?: TicketCreateNestedManyWithoutAssignedToInput
    ticketMsgs?: TicketMessageCreateNestedManyWithoutAuthorInput
    ticketParticipants?: TicketParticipantCreateNestedManyWithoutUserInput
    ticketParticipantsAdded?: TicketParticipantCreateNestedManyWithoutAddedByInput
    ticketRatingsGiven?: TicketRatingCreateNestedManyWithoutRaterInput
    ticketRatingsReceived?: TicketRatingCreateNestedManyWithoutTargetInput
    closedTickets?: TicketCreateNestedManyWithoutClosedByInput
    purchases?: PurchaseCreateNestedManyWithoutUserInput
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    whitelistApps?: WhitelistApplicationCreateNestedManyWithoutUserInput
    reviewedWhitelists?: WhitelistApplicationCreateNestedManyWithoutReviewerInput
    convoParts?: ConversationParticipantCreateNestedManyWithoutUserInput
    sentMessages?: DirectMessageCreateNestedManyWithoutSenderInput
    receivedMessages?: DirectMessageCreateNestedManyWithoutReceiverInput
    userBadges?: UserBadgeCreateNestedManyWithoutUserInput
    gameAccounts?: GameAccountCreateNestedManyWithoutUserInput
    mtaAccessLogs?: MtaAccessLogCreateNestedManyWithoutUserInput
    ticketRatingReqGiven?: TicketRatingRequirementCreateNestedManyWithoutRaterInput
    ticketRatingReqReceived?: TicketRatingRequirementCreateNestedManyWithoutTargetInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    entitlements?: EntitlementCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    staffShifts?: StaffShiftCreateNestedManyWithoutUserInput
    staffWeeklyRewards?: StaffWeeklyRewardCreateNestedManyWithoutUserInput
    adminCasesTarget?: AdminCaseCreateNestedManyWithoutTargetUserInput
    adminCasesStaff?: AdminCaseCreateNestedManyWithoutStaffUserInput
    reputation?: UserReputationCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAuditLogsInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    emailVerifiedAt?: Date | string | null
    emailVerifyToken?: string | null
    emailVerifyExpiresAt?: Date | string | null
    phone?: string | null
    recoveryEmail?: string | null
    googleId?: string | null
    discordId?: string | null
    discordUsername?: string | null
    avatarKey?: string
    role?: string
    isDeleted?: boolean
    bannedUntil?: Date | string | null
    whitelistStatus?: string
    points?: number
    lastSeenAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    avatarUrl?: string | null
    topics?: TopicUncheckedCreateNestedManyWithoutAuthorInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    tickets?: TicketUncheckedCreateNestedManyWithoutAuthorInput
    assignedTickets?: TicketUncheckedCreateNestedManyWithoutAssignedToInput
    ticketMsgs?: TicketMessageUncheckedCreateNestedManyWithoutAuthorInput
    ticketParticipants?: TicketParticipantUncheckedCreateNestedManyWithoutUserInput
    ticketParticipantsAdded?: TicketParticipantUncheckedCreateNestedManyWithoutAddedByInput
    ticketRatingsGiven?: TicketRatingUncheckedCreateNestedManyWithoutRaterInput
    ticketRatingsReceived?: TicketRatingUncheckedCreateNestedManyWithoutTargetInput
    closedTickets?: TicketUncheckedCreateNestedManyWithoutClosedByInput
    purchases?: PurchaseUncheckedCreateNestedManyWithoutUserInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    whitelistApps?: WhitelistApplicationUncheckedCreateNestedManyWithoutUserInput
    reviewedWhitelists?: WhitelistApplicationUncheckedCreateNestedManyWithoutReviewerInput
    convoParts?: ConversationParticipantUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: DirectMessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: DirectMessageUncheckedCreateNestedManyWithoutReceiverInput
    userBadges?: UserBadgeUncheckedCreateNestedManyWithoutUserInput
    gameAccounts?: GameAccountUncheckedCreateNestedManyWithoutUserInput
    mtaAccessLogs?: MtaAccessLogUncheckedCreateNestedManyWithoutUserInput
    ticketRatingReqGiven?: TicketRatingRequirementUncheckedCreateNestedManyWithoutRaterInput
    ticketRatingReqReceived?: TicketRatingRequirementUncheckedCreateNestedManyWithoutTargetInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    entitlements?: EntitlementUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    staffShifts?: StaffShiftUncheckedCreateNestedManyWithoutUserInput
    staffWeeklyRewards?: StaffWeeklyRewardUncheckedCreateNestedManyWithoutUserInput
    adminCasesTarget?: AdminCaseUncheckedCreateNestedManyWithoutTargetUserInput
    adminCasesStaff?: AdminCaseUncheckedCreateNestedManyWithoutStaffUserInput
    reputation?: UserReputationUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAuditLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
  }

  export type UserUpsertWithoutAuditLogsInput = {
    update: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAuditLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type UserUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifyToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerifyExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    discordId?: NullableStringFieldUpdateOperationsInput | string | null
    discordUsername?: NullableStringFieldUpdateOperationsInput | string | null
    avatarKey?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    bannedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    whitelistStatus?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    lastSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    topics?: TopicUpdateManyWithoutAuthorNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    tickets?: TicketUpdateManyWithoutAuthorNestedInput
    assignedTickets?: TicketUpdateManyWithoutAssignedToNestedInput
    ticketMsgs?: TicketMessageUpdateManyWithoutAuthorNestedInput
    ticketParticipants?: TicketParticipantUpdateManyWithoutUserNestedInput
    ticketParticipantsAdded?: TicketParticipantUpdateManyWithoutAddedByNestedInput
    ticketRatingsGiven?: TicketRatingUpdateManyWithoutRaterNestedInput
    ticketRatingsReceived?: TicketRatingUpdateManyWithoutTargetNestedInput
    closedTickets?: TicketUpdateManyWithoutClosedByNestedInput
    purchases?: PurchaseUpdateManyWithoutUserNestedInput
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    whitelistApps?: WhitelistApplicationUpdateManyWithoutUserNestedInput
    reviewedWhitelists?: WhitelistApplicationUpdateManyWithoutReviewerNestedInput
    convoParts?: ConversationParticipantUpdateManyWithoutUserNestedInput
    sentMessages?: DirectMessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: DirectMessageUpdateManyWithoutReceiverNestedInput
    userBadges?: UserBadgeUpdateManyWithoutUserNestedInput
    gameAccounts?: GameAccountUpdateManyWithoutUserNestedInput
    mtaAccessLogs?: MtaAccessLogUpdateManyWithoutUserNestedInput
    ticketRatingReqGiven?: TicketRatingRequirementUpdateManyWithoutRaterNestedInput
    ticketRatingReqReceived?: TicketRatingRequirementUpdateManyWithoutTargetNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    entitlements?: EntitlementUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    staffShifts?: StaffShiftUpdateManyWithoutUserNestedInput
    staffWeeklyRewards?: StaffWeeklyRewardUpdateManyWithoutUserNestedInput
    adminCasesTarget?: AdminCaseUpdateManyWithoutTargetUserNestedInput
    adminCasesStaff?: AdminCaseUpdateManyWithoutStaffUserNestedInput
    reputation?: UserReputationUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifyToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerifyExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    discordId?: NullableStringFieldUpdateOperationsInput | string | null
    discordUsername?: NullableStringFieldUpdateOperationsInput | string | null
    avatarKey?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    bannedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    whitelistStatus?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    lastSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    topics?: TopicUncheckedUpdateManyWithoutAuthorNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutAuthorNestedInput
    assignedTickets?: TicketUncheckedUpdateManyWithoutAssignedToNestedInput
    ticketMsgs?: TicketMessageUncheckedUpdateManyWithoutAuthorNestedInput
    ticketParticipants?: TicketParticipantUncheckedUpdateManyWithoutUserNestedInput
    ticketParticipantsAdded?: TicketParticipantUncheckedUpdateManyWithoutAddedByNestedInput
    ticketRatingsGiven?: TicketRatingUncheckedUpdateManyWithoutRaterNestedInput
    ticketRatingsReceived?: TicketRatingUncheckedUpdateManyWithoutTargetNestedInput
    closedTickets?: TicketUncheckedUpdateManyWithoutClosedByNestedInput
    purchases?: PurchaseUncheckedUpdateManyWithoutUserNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    whitelistApps?: WhitelistApplicationUncheckedUpdateManyWithoutUserNestedInput
    reviewedWhitelists?: WhitelistApplicationUncheckedUpdateManyWithoutReviewerNestedInput
    convoParts?: ConversationParticipantUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: DirectMessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: DirectMessageUncheckedUpdateManyWithoutReceiverNestedInput
    userBadges?: UserBadgeUncheckedUpdateManyWithoutUserNestedInput
    gameAccounts?: GameAccountUncheckedUpdateManyWithoutUserNestedInput
    mtaAccessLogs?: MtaAccessLogUncheckedUpdateManyWithoutUserNestedInput
    ticketRatingReqGiven?: TicketRatingRequirementUncheckedUpdateManyWithoutRaterNestedInput
    ticketRatingReqReceived?: TicketRatingRequirementUncheckedUpdateManyWithoutTargetNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    entitlements?: EntitlementUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    staffShifts?: StaffShiftUncheckedUpdateManyWithoutUserNestedInput
    staffWeeklyRewards?: StaffWeeklyRewardUncheckedUpdateManyWithoutUserNestedInput
    adminCasesTarget?: AdminCaseUncheckedUpdateManyWithoutTargetUserNestedInput
    adminCasesStaff?: AdminCaseUncheckedUpdateManyWithoutStaffUserNestedInput
    reputation?: UserReputationUncheckedUpdateOneWithoutUserNestedInput
  }

  export type RolePermissionCreateWithoutRoleInput = {
    permission: PermissionCreateNestedOneWithoutRolesInput
  }

  export type RolePermissionUncheckedCreateWithoutRoleInput = {
    permissionId: string
  }

  export type RolePermissionCreateOrConnectWithoutRoleInput = {
    where: RolePermissionWhereUniqueInput
    create: XOR<RolePermissionCreateWithoutRoleInput, RolePermissionUncheckedCreateWithoutRoleInput>
  }

  export type RolePermissionCreateManyRoleInputEnvelope = {
    data: RolePermissionCreateManyRoleInput | RolePermissionCreateManyRoleInput[]
  }

  export type UserRoleCreateWithoutRoleInput = {
    user: UserCreateNestedOneWithoutUserRolesInput
  }

  export type UserRoleUncheckedCreateWithoutRoleInput = {
    userId: string
  }

  export type UserRoleCreateOrConnectWithoutRoleInput = {
    where: UserRoleWhereUniqueInput
    create: XOR<UserRoleCreateWithoutRoleInput, UserRoleUncheckedCreateWithoutRoleInput>
  }

  export type UserRoleCreateManyRoleInputEnvelope = {
    data: UserRoleCreateManyRoleInput | UserRoleCreateManyRoleInput[]
  }

  export type RolePermissionUpsertWithWhereUniqueWithoutRoleInput = {
    where: RolePermissionWhereUniqueInput
    update: XOR<RolePermissionUpdateWithoutRoleInput, RolePermissionUncheckedUpdateWithoutRoleInput>
    create: XOR<RolePermissionCreateWithoutRoleInput, RolePermissionUncheckedCreateWithoutRoleInput>
  }

  export type RolePermissionUpdateWithWhereUniqueWithoutRoleInput = {
    where: RolePermissionWhereUniqueInput
    data: XOR<RolePermissionUpdateWithoutRoleInput, RolePermissionUncheckedUpdateWithoutRoleInput>
  }

  export type RolePermissionUpdateManyWithWhereWithoutRoleInput = {
    where: RolePermissionScalarWhereInput
    data: XOR<RolePermissionUpdateManyMutationInput, RolePermissionUncheckedUpdateManyWithoutRoleInput>
  }

  export type RolePermissionScalarWhereInput = {
    AND?: RolePermissionScalarWhereInput | RolePermissionScalarWhereInput[]
    OR?: RolePermissionScalarWhereInput[]
    NOT?: RolePermissionScalarWhereInput | RolePermissionScalarWhereInput[]
    roleId?: StringFilter<"RolePermission"> | string
    permissionId?: StringFilter<"RolePermission"> | string
  }

  export type UserRoleUpsertWithWhereUniqueWithoutRoleInput = {
    where: UserRoleWhereUniqueInput
    update: XOR<UserRoleUpdateWithoutRoleInput, UserRoleUncheckedUpdateWithoutRoleInput>
    create: XOR<UserRoleCreateWithoutRoleInput, UserRoleUncheckedCreateWithoutRoleInput>
  }

  export type UserRoleUpdateWithWhereUniqueWithoutRoleInput = {
    where: UserRoleWhereUniqueInput
    data: XOR<UserRoleUpdateWithoutRoleInput, UserRoleUncheckedUpdateWithoutRoleInput>
  }

  export type UserRoleUpdateManyWithWhereWithoutRoleInput = {
    where: UserRoleScalarWhereInput
    data: XOR<UserRoleUpdateManyMutationInput, UserRoleUncheckedUpdateManyWithoutRoleInput>
  }

  export type RolePermissionCreateWithoutPermissionInput = {
    role: RoleCreateNestedOneWithoutPermissionsInput
  }

  export type RolePermissionUncheckedCreateWithoutPermissionInput = {
    roleId: string
  }

  export type RolePermissionCreateOrConnectWithoutPermissionInput = {
    where: RolePermissionWhereUniqueInput
    create: XOR<RolePermissionCreateWithoutPermissionInput, RolePermissionUncheckedCreateWithoutPermissionInput>
  }

  export type RolePermissionCreateManyPermissionInputEnvelope = {
    data: RolePermissionCreateManyPermissionInput | RolePermissionCreateManyPermissionInput[]
  }

  export type RolePermissionUpsertWithWhereUniqueWithoutPermissionInput = {
    where: RolePermissionWhereUniqueInput
    update: XOR<RolePermissionUpdateWithoutPermissionInput, RolePermissionUncheckedUpdateWithoutPermissionInput>
    create: XOR<RolePermissionCreateWithoutPermissionInput, RolePermissionUncheckedCreateWithoutPermissionInput>
  }

  export type RolePermissionUpdateWithWhereUniqueWithoutPermissionInput = {
    where: RolePermissionWhereUniqueInput
    data: XOR<RolePermissionUpdateWithoutPermissionInput, RolePermissionUncheckedUpdateWithoutPermissionInput>
  }

  export type RolePermissionUpdateManyWithWhereWithoutPermissionInput = {
    where: RolePermissionScalarWhereInput
    data: XOR<RolePermissionUpdateManyMutationInput, RolePermissionUncheckedUpdateManyWithoutPermissionInput>
  }

  export type RoleCreateWithoutPermissionsInput = {
    id?: string
    name: string
    rank?: number
    category?: string
    description?: string | null
    createdAt?: Date | string
    colorHex?: string | null
    users?: UserRoleCreateNestedManyWithoutRoleInput
  }

  export type RoleUncheckedCreateWithoutPermissionsInput = {
    id?: string
    name: string
    rank?: number
    category?: string
    description?: string | null
    createdAt?: Date | string
    colorHex?: string | null
    users?: UserRoleUncheckedCreateNestedManyWithoutRoleInput
  }

  export type RoleCreateOrConnectWithoutPermissionsInput = {
    where: RoleWhereUniqueInput
    create: XOR<RoleCreateWithoutPermissionsInput, RoleUncheckedCreateWithoutPermissionsInput>
  }

  export type PermissionCreateWithoutRolesInput = {
    id?: string
    key: string
    description?: string | null
    createdAt?: Date | string
  }

  export type PermissionUncheckedCreateWithoutRolesInput = {
    id?: string
    key: string
    description?: string | null
    createdAt?: Date | string
  }

  export type PermissionCreateOrConnectWithoutRolesInput = {
    where: PermissionWhereUniqueInput
    create: XOR<PermissionCreateWithoutRolesInput, PermissionUncheckedCreateWithoutRolesInput>
  }

  export type RoleUpsertWithoutPermissionsInput = {
    update: XOR<RoleUpdateWithoutPermissionsInput, RoleUncheckedUpdateWithoutPermissionsInput>
    create: XOR<RoleCreateWithoutPermissionsInput, RoleUncheckedCreateWithoutPermissionsInput>
    where?: RoleWhereInput
  }

  export type RoleUpdateToOneWithWhereWithoutPermissionsInput = {
    where?: RoleWhereInput
    data: XOR<RoleUpdateWithoutPermissionsInput, RoleUncheckedUpdateWithoutPermissionsInput>
  }

  export type RoleUpdateWithoutPermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    rank?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    colorHex?: NullableStringFieldUpdateOperationsInput | string | null
    users?: UserRoleUpdateManyWithoutRoleNestedInput
  }

  export type RoleUncheckedUpdateWithoutPermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    rank?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    colorHex?: NullableStringFieldUpdateOperationsInput | string | null
    users?: UserRoleUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type PermissionUpsertWithoutRolesInput = {
    update: XOR<PermissionUpdateWithoutRolesInput, PermissionUncheckedUpdateWithoutRolesInput>
    create: XOR<PermissionCreateWithoutRolesInput, PermissionUncheckedCreateWithoutRolesInput>
    where?: PermissionWhereInput
  }

  export type PermissionUpdateToOneWithWhereWithoutRolesInput = {
    where?: PermissionWhereInput
    data: XOR<PermissionUpdateWithoutRolesInput, PermissionUncheckedUpdateWithoutRolesInput>
  }

  export type PermissionUpdateWithoutRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PermissionUncheckedUpdateWithoutRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutUserRolesInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    emailVerifiedAt?: Date | string | null
    emailVerifyToken?: string | null
    emailVerifyExpiresAt?: Date | string | null
    phone?: string | null
    recoveryEmail?: string | null
    googleId?: string | null
    discordId?: string | null
    discordUsername?: string | null
    avatarKey?: string
    role?: string
    isDeleted?: boolean
    bannedUntil?: Date | string | null
    whitelistStatus?: string
    points?: number
    lastSeenAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    avatarUrl?: string | null
    topics?: TopicCreateNestedManyWithoutAuthorInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    tickets?: TicketCreateNestedManyWithoutAuthorInput
    assignedTickets?: TicketCreateNestedManyWithoutAssignedToInput
    ticketMsgs?: TicketMessageCreateNestedManyWithoutAuthorInput
    ticketParticipants?: TicketParticipantCreateNestedManyWithoutUserInput
    ticketParticipantsAdded?: TicketParticipantCreateNestedManyWithoutAddedByInput
    ticketRatingsGiven?: TicketRatingCreateNestedManyWithoutRaterInput
    ticketRatingsReceived?: TicketRatingCreateNestedManyWithoutTargetInput
    closedTickets?: TicketCreateNestedManyWithoutClosedByInput
    purchases?: PurchaseCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    whitelistApps?: WhitelistApplicationCreateNestedManyWithoutUserInput
    reviewedWhitelists?: WhitelistApplicationCreateNestedManyWithoutReviewerInput
    convoParts?: ConversationParticipantCreateNestedManyWithoutUserInput
    sentMessages?: DirectMessageCreateNestedManyWithoutSenderInput
    receivedMessages?: DirectMessageCreateNestedManyWithoutReceiverInput
    userBadges?: UserBadgeCreateNestedManyWithoutUserInput
    gameAccounts?: GameAccountCreateNestedManyWithoutUserInput
    mtaAccessLogs?: MtaAccessLogCreateNestedManyWithoutUserInput
    ticketRatingReqGiven?: TicketRatingRequirementCreateNestedManyWithoutRaterInput
    ticketRatingReqReceived?: TicketRatingRequirementCreateNestedManyWithoutTargetInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    entitlements?: EntitlementCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    staffShifts?: StaffShiftCreateNestedManyWithoutUserInput
    staffWeeklyRewards?: StaffWeeklyRewardCreateNestedManyWithoutUserInput
    adminCasesTarget?: AdminCaseCreateNestedManyWithoutTargetUserInput
    adminCasesStaff?: AdminCaseCreateNestedManyWithoutStaffUserInput
    reputation?: UserReputationCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUserRolesInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    emailVerifiedAt?: Date | string | null
    emailVerifyToken?: string | null
    emailVerifyExpiresAt?: Date | string | null
    phone?: string | null
    recoveryEmail?: string | null
    googleId?: string | null
    discordId?: string | null
    discordUsername?: string | null
    avatarKey?: string
    role?: string
    isDeleted?: boolean
    bannedUntil?: Date | string | null
    whitelistStatus?: string
    points?: number
    lastSeenAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    avatarUrl?: string | null
    topics?: TopicUncheckedCreateNestedManyWithoutAuthorInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    tickets?: TicketUncheckedCreateNestedManyWithoutAuthorInput
    assignedTickets?: TicketUncheckedCreateNestedManyWithoutAssignedToInput
    ticketMsgs?: TicketMessageUncheckedCreateNestedManyWithoutAuthorInput
    ticketParticipants?: TicketParticipantUncheckedCreateNestedManyWithoutUserInput
    ticketParticipantsAdded?: TicketParticipantUncheckedCreateNestedManyWithoutAddedByInput
    ticketRatingsGiven?: TicketRatingUncheckedCreateNestedManyWithoutRaterInput
    ticketRatingsReceived?: TicketRatingUncheckedCreateNestedManyWithoutTargetInput
    closedTickets?: TicketUncheckedCreateNestedManyWithoutClosedByInput
    purchases?: PurchaseUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    whitelistApps?: WhitelistApplicationUncheckedCreateNestedManyWithoutUserInput
    reviewedWhitelists?: WhitelistApplicationUncheckedCreateNestedManyWithoutReviewerInput
    convoParts?: ConversationParticipantUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: DirectMessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: DirectMessageUncheckedCreateNestedManyWithoutReceiverInput
    userBadges?: UserBadgeUncheckedCreateNestedManyWithoutUserInput
    gameAccounts?: GameAccountUncheckedCreateNestedManyWithoutUserInput
    mtaAccessLogs?: MtaAccessLogUncheckedCreateNestedManyWithoutUserInput
    ticketRatingReqGiven?: TicketRatingRequirementUncheckedCreateNestedManyWithoutRaterInput
    ticketRatingReqReceived?: TicketRatingRequirementUncheckedCreateNestedManyWithoutTargetInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    entitlements?: EntitlementUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    staffShifts?: StaffShiftUncheckedCreateNestedManyWithoutUserInput
    staffWeeklyRewards?: StaffWeeklyRewardUncheckedCreateNestedManyWithoutUserInput
    adminCasesTarget?: AdminCaseUncheckedCreateNestedManyWithoutTargetUserInput
    adminCasesStaff?: AdminCaseUncheckedCreateNestedManyWithoutStaffUserInput
    reputation?: UserReputationUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUserRolesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserRolesInput, UserUncheckedCreateWithoutUserRolesInput>
  }

  export type RoleCreateWithoutUsersInput = {
    id?: string
    name: string
    rank?: number
    category?: string
    description?: string | null
    createdAt?: Date | string
    colorHex?: string | null
    permissions?: RolePermissionCreateNestedManyWithoutRoleInput
  }

  export type RoleUncheckedCreateWithoutUsersInput = {
    id?: string
    name: string
    rank?: number
    category?: string
    description?: string | null
    createdAt?: Date | string
    colorHex?: string | null
    permissions?: RolePermissionUncheckedCreateNestedManyWithoutRoleInput
  }

  export type RoleCreateOrConnectWithoutUsersInput = {
    where: RoleWhereUniqueInput
    create: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
  }

  export type UserUpsertWithoutUserRolesInput = {
    update: XOR<UserUpdateWithoutUserRolesInput, UserUncheckedUpdateWithoutUserRolesInput>
    create: XOR<UserCreateWithoutUserRolesInput, UserUncheckedCreateWithoutUserRolesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUserRolesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUserRolesInput, UserUncheckedUpdateWithoutUserRolesInput>
  }

  export type UserUpdateWithoutUserRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifyToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerifyExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    discordId?: NullableStringFieldUpdateOperationsInput | string | null
    discordUsername?: NullableStringFieldUpdateOperationsInput | string | null
    avatarKey?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    bannedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    whitelistStatus?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    lastSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    topics?: TopicUpdateManyWithoutAuthorNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    tickets?: TicketUpdateManyWithoutAuthorNestedInput
    assignedTickets?: TicketUpdateManyWithoutAssignedToNestedInput
    ticketMsgs?: TicketMessageUpdateManyWithoutAuthorNestedInput
    ticketParticipants?: TicketParticipantUpdateManyWithoutUserNestedInput
    ticketParticipantsAdded?: TicketParticipantUpdateManyWithoutAddedByNestedInput
    ticketRatingsGiven?: TicketRatingUpdateManyWithoutRaterNestedInput
    ticketRatingsReceived?: TicketRatingUpdateManyWithoutTargetNestedInput
    closedTickets?: TicketUpdateManyWithoutClosedByNestedInput
    purchases?: PurchaseUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    whitelistApps?: WhitelistApplicationUpdateManyWithoutUserNestedInput
    reviewedWhitelists?: WhitelistApplicationUpdateManyWithoutReviewerNestedInput
    convoParts?: ConversationParticipantUpdateManyWithoutUserNestedInput
    sentMessages?: DirectMessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: DirectMessageUpdateManyWithoutReceiverNestedInput
    userBadges?: UserBadgeUpdateManyWithoutUserNestedInput
    gameAccounts?: GameAccountUpdateManyWithoutUserNestedInput
    mtaAccessLogs?: MtaAccessLogUpdateManyWithoutUserNestedInput
    ticketRatingReqGiven?: TicketRatingRequirementUpdateManyWithoutRaterNestedInput
    ticketRatingReqReceived?: TicketRatingRequirementUpdateManyWithoutTargetNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    entitlements?: EntitlementUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    staffShifts?: StaffShiftUpdateManyWithoutUserNestedInput
    staffWeeklyRewards?: StaffWeeklyRewardUpdateManyWithoutUserNestedInput
    adminCasesTarget?: AdminCaseUpdateManyWithoutTargetUserNestedInput
    adminCasesStaff?: AdminCaseUpdateManyWithoutStaffUserNestedInput
    reputation?: UserReputationUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUserRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifyToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerifyExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    discordId?: NullableStringFieldUpdateOperationsInput | string | null
    discordUsername?: NullableStringFieldUpdateOperationsInput | string | null
    avatarKey?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    bannedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    whitelistStatus?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    lastSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    topics?: TopicUncheckedUpdateManyWithoutAuthorNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutAuthorNestedInput
    assignedTickets?: TicketUncheckedUpdateManyWithoutAssignedToNestedInput
    ticketMsgs?: TicketMessageUncheckedUpdateManyWithoutAuthorNestedInput
    ticketParticipants?: TicketParticipantUncheckedUpdateManyWithoutUserNestedInput
    ticketParticipantsAdded?: TicketParticipantUncheckedUpdateManyWithoutAddedByNestedInput
    ticketRatingsGiven?: TicketRatingUncheckedUpdateManyWithoutRaterNestedInput
    ticketRatingsReceived?: TicketRatingUncheckedUpdateManyWithoutTargetNestedInput
    closedTickets?: TicketUncheckedUpdateManyWithoutClosedByNestedInput
    purchases?: PurchaseUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    whitelistApps?: WhitelistApplicationUncheckedUpdateManyWithoutUserNestedInput
    reviewedWhitelists?: WhitelistApplicationUncheckedUpdateManyWithoutReviewerNestedInput
    convoParts?: ConversationParticipantUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: DirectMessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: DirectMessageUncheckedUpdateManyWithoutReceiverNestedInput
    userBadges?: UserBadgeUncheckedUpdateManyWithoutUserNestedInput
    gameAccounts?: GameAccountUncheckedUpdateManyWithoutUserNestedInput
    mtaAccessLogs?: MtaAccessLogUncheckedUpdateManyWithoutUserNestedInput
    ticketRatingReqGiven?: TicketRatingRequirementUncheckedUpdateManyWithoutRaterNestedInput
    ticketRatingReqReceived?: TicketRatingRequirementUncheckedUpdateManyWithoutTargetNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    entitlements?: EntitlementUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    staffShifts?: StaffShiftUncheckedUpdateManyWithoutUserNestedInput
    staffWeeklyRewards?: StaffWeeklyRewardUncheckedUpdateManyWithoutUserNestedInput
    adminCasesTarget?: AdminCaseUncheckedUpdateManyWithoutTargetUserNestedInput
    adminCasesStaff?: AdminCaseUncheckedUpdateManyWithoutStaffUserNestedInput
    reputation?: UserReputationUncheckedUpdateOneWithoutUserNestedInput
  }

  export type RoleUpsertWithoutUsersInput = {
    update: XOR<RoleUpdateWithoutUsersInput, RoleUncheckedUpdateWithoutUsersInput>
    create: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
    where?: RoleWhereInput
  }

  export type RoleUpdateToOneWithWhereWithoutUsersInput = {
    where?: RoleWhereInput
    data: XOR<RoleUpdateWithoutUsersInput, RoleUncheckedUpdateWithoutUsersInput>
  }

  export type RoleUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    rank?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    colorHex?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: RolePermissionUpdateManyWithoutRoleNestedInput
  }

  export type RoleUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    rank?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    colorHex?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: RolePermissionUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type WhitelistAnswerCreateWithoutQuestionInput = {
    id?: string
    value: string
    createdAt?: Date | string
    application: WhitelistApplicationCreateNestedOneWithoutAnswersInput
  }

  export type WhitelistAnswerUncheckedCreateWithoutQuestionInput = {
    id?: string
    applicationId: string
    value: string
    createdAt?: Date | string
  }

  export type WhitelistAnswerCreateOrConnectWithoutQuestionInput = {
    where: WhitelistAnswerWhereUniqueInput
    create: XOR<WhitelistAnswerCreateWithoutQuestionInput, WhitelistAnswerUncheckedCreateWithoutQuestionInput>
  }

  export type WhitelistAnswerCreateManyQuestionInputEnvelope = {
    data: WhitelistAnswerCreateManyQuestionInput | WhitelistAnswerCreateManyQuestionInput[]
  }

  export type WhitelistAnswerUpsertWithWhereUniqueWithoutQuestionInput = {
    where: WhitelistAnswerWhereUniqueInput
    update: XOR<WhitelistAnswerUpdateWithoutQuestionInput, WhitelistAnswerUncheckedUpdateWithoutQuestionInput>
    create: XOR<WhitelistAnswerCreateWithoutQuestionInput, WhitelistAnswerUncheckedCreateWithoutQuestionInput>
  }

  export type WhitelistAnswerUpdateWithWhereUniqueWithoutQuestionInput = {
    where: WhitelistAnswerWhereUniqueInput
    data: XOR<WhitelistAnswerUpdateWithoutQuestionInput, WhitelistAnswerUncheckedUpdateWithoutQuestionInput>
  }

  export type WhitelistAnswerUpdateManyWithWhereWithoutQuestionInput = {
    where: WhitelistAnswerScalarWhereInput
    data: XOR<WhitelistAnswerUpdateManyMutationInput, WhitelistAnswerUncheckedUpdateManyWithoutQuestionInput>
  }

  export type WhitelistAnswerScalarWhereInput = {
    AND?: WhitelistAnswerScalarWhereInput | WhitelistAnswerScalarWhereInput[]
    OR?: WhitelistAnswerScalarWhereInput[]
    NOT?: WhitelistAnswerScalarWhereInput | WhitelistAnswerScalarWhereInput[]
    id?: StringFilter<"WhitelistAnswer"> | string
    applicationId?: StringFilter<"WhitelistAnswer"> | string
    questionId?: StringFilter<"WhitelistAnswer"> | string
    value?: StringFilter<"WhitelistAnswer"> | string
    createdAt?: DateTimeFilter<"WhitelistAnswer"> | Date | string
  }

  export type UserCreateWithoutWhitelistAppsInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    emailVerifiedAt?: Date | string | null
    emailVerifyToken?: string | null
    emailVerifyExpiresAt?: Date | string | null
    phone?: string | null
    recoveryEmail?: string | null
    googleId?: string | null
    discordId?: string | null
    discordUsername?: string | null
    avatarKey?: string
    role?: string
    isDeleted?: boolean
    bannedUntil?: Date | string | null
    whitelistStatus?: string
    points?: number
    lastSeenAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    avatarUrl?: string | null
    topics?: TopicCreateNestedManyWithoutAuthorInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    tickets?: TicketCreateNestedManyWithoutAuthorInput
    assignedTickets?: TicketCreateNestedManyWithoutAssignedToInput
    ticketMsgs?: TicketMessageCreateNestedManyWithoutAuthorInput
    ticketParticipants?: TicketParticipantCreateNestedManyWithoutUserInput
    ticketParticipantsAdded?: TicketParticipantCreateNestedManyWithoutAddedByInput
    ticketRatingsGiven?: TicketRatingCreateNestedManyWithoutRaterInput
    ticketRatingsReceived?: TicketRatingCreateNestedManyWithoutTargetInput
    closedTickets?: TicketCreateNestedManyWithoutClosedByInput
    purchases?: PurchaseCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    reviewedWhitelists?: WhitelistApplicationCreateNestedManyWithoutReviewerInput
    convoParts?: ConversationParticipantCreateNestedManyWithoutUserInput
    sentMessages?: DirectMessageCreateNestedManyWithoutSenderInput
    receivedMessages?: DirectMessageCreateNestedManyWithoutReceiverInput
    userBadges?: UserBadgeCreateNestedManyWithoutUserInput
    gameAccounts?: GameAccountCreateNestedManyWithoutUserInput
    mtaAccessLogs?: MtaAccessLogCreateNestedManyWithoutUserInput
    ticketRatingReqGiven?: TicketRatingRequirementCreateNestedManyWithoutRaterInput
    ticketRatingReqReceived?: TicketRatingRequirementCreateNestedManyWithoutTargetInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    entitlements?: EntitlementCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    staffShifts?: StaffShiftCreateNestedManyWithoutUserInput
    staffWeeklyRewards?: StaffWeeklyRewardCreateNestedManyWithoutUserInput
    adminCasesTarget?: AdminCaseCreateNestedManyWithoutTargetUserInput
    adminCasesStaff?: AdminCaseCreateNestedManyWithoutStaffUserInput
    reputation?: UserReputationCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutWhitelistAppsInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    emailVerifiedAt?: Date | string | null
    emailVerifyToken?: string | null
    emailVerifyExpiresAt?: Date | string | null
    phone?: string | null
    recoveryEmail?: string | null
    googleId?: string | null
    discordId?: string | null
    discordUsername?: string | null
    avatarKey?: string
    role?: string
    isDeleted?: boolean
    bannedUntil?: Date | string | null
    whitelistStatus?: string
    points?: number
    lastSeenAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    avatarUrl?: string | null
    topics?: TopicUncheckedCreateNestedManyWithoutAuthorInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    tickets?: TicketUncheckedCreateNestedManyWithoutAuthorInput
    assignedTickets?: TicketUncheckedCreateNestedManyWithoutAssignedToInput
    ticketMsgs?: TicketMessageUncheckedCreateNestedManyWithoutAuthorInput
    ticketParticipants?: TicketParticipantUncheckedCreateNestedManyWithoutUserInput
    ticketParticipantsAdded?: TicketParticipantUncheckedCreateNestedManyWithoutAddedByInput
    ticketRatingsGiven?: TicketRatingUncheckedCreateNestedManyWithoutRaterInput
    ticketRatingsReceived?: TicketRatingUncheckedCreateNestedManyWithoutTargetInput
    closedTickets?: TicketUncheckedCreateNestedManyWithoutClosedByInput
    purchases?: PurchaseUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    reviewedWhitelists?: WhitelistApplicationUncheckedCreateNestedManyWithoutReviewerInput
    convoParts?: ConversationParticipantUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: DirectMessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: DirectMessageUncheckedCreateNestedManyWithoutReceiverInput
    userBadges?: UserBadgeUncheckedCreateNestedManyWithoutUserInput
    gameAccounts?: GameAccountUncheckedCreateNestedManyWithoutUserInput
    mtaAccessLogs?: MtaAccessLogUncheckedCreateNestedManyWithoutUserInput
    ticketRatingReqGiven?: TicketRatingRequirementUncheckedCreateNestedManyWithoutRaterInput
    ticketRatingReqReceived?: TicketRatingRequirementUncheckedCreateNestedManyWithoutTargetInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    entitlements?: EntitlementUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    staffShifts?: StaffShiftUncheckedCreateNestedManyWithoutUserInput
    staffWeeklyRewards?: StaffWeeklyRewardUncheckedCreateNestedManyWithoutUserInput
    adminCasesTarget?: AdminCaseUncheckedCreateNestedManyWithoutTargetUserInput
    adminCasesStaff?: AdminCaseUncheckedCreateNestedManyWithoutStaffUserInput
    reputation?: UserReputationUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutWhitelistAppsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutWhitelistAppsInput, UserUncheckedCreateWithoutWhitelistAppsInput>
  }

  export type UserCreateWithoutReviewedWhitelistsInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    emailVerifiedAt?: Date | string | null
    emailVerifyToken?: string | null
    emailVerifyExpiresAt?: Date | string | null
    phone?: string | null
    recoveryEmail?: string | null
    googleId?: string | null
    discordId?: string | null
    discordUsername?: string | null
    avatarKey?: string
    role?: string
    isDeleted?: boolean
    bannedUntil?: Date | string | null
    whitelistStatus?: string
    points?: number
    lastSeenAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    avatarUrl?: string | null
    topics?: TopicCreateNestedManyWithoutAuthorInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    tickets?: TicketCreateNestedManyWithoutAuthorInput
    assignedTickets?: TicketCreateNestedManyWithoutAssignedToInput
    ticketMsgs?: TicketMessageCreateNestedManyWithoutAuthorInput
    ticketParticipants?: TicketParticipantCreateNestedManyWithoutUserInput
    ticketParticipantsAdded?: TicketParticipantCreateNestedManyWithoutAddedByInput
    ticketRatingsGiven?: TicketRatingCreateNestedManyWithoutRaterInput
    ticketRatingsReceived?: TicketRatingCreateNestedManyWithoutTargetInput
    closedTickets?: TicketCreateNestedManyWithoutClosedByInput
    purchases?: PurchaseCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    whitelistApps?: WhitelistApplicationCreateNestedManyWithoutUserInput
    convoParts?: ConversationParticipantCreateNestedManyWithoutUserInput
    sentMessages?: DirectMessageCreateNestedManyWithoutSenderInput
    receivedMessages?: DirectMessageCreateNestedManyWithoutReceiverInput
    userBadges?: UserBadgeCreateNestedManyWithoutUserInput
    gameAccounts?: GameAccountCreateNestedManyWithoutUserInput
    mtaAccessLogs?: MtaAccessLogCreateNestedManyWithoutUserInput
    ticketRatingReqGiven?: TicketRatingRequirementCreateNestedManyWithoutRaterInput
    ticketRatingReqReceived?: TicketRatingRequirementCreateNestedManyWithoutTargetInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    entitlements?: EntitlementCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    staffShifts?: StaffShiftCreateNestedManyWithoutUserInput
    staffWeeklyRewards?: StaffWeeklyRewardCreateNestedManyWithoutUserInput
    adminCasesTarget?: AdminCaseCreateNestedManyWithoutTargetUserInput
    adminCasesStaff?: AdminCaseCreateNestedManyWithoutStaffUserInput
    reputation?: UserReputationCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutReviewedWhitelistsInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    emailVerifiedAt?: Date | string | null
    emailVerifyToken?: string | null
    emailVerifyExpiresAt?: Date | string | null
    phone?: string | null
    recoveryEmail?: string | null
    googleId?: string | null
    discordId?: string | null
    discordUsername?: string | null
    avatarKey?: string
    role?: string
    isDeleted?: boolean
    bannedUntil?: Date | string | null
    whitelistStatus?: string
    points?: number
    lastSeenAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    avatarUrl?: string | null
    topics?: TopicUncheckedCreateNestedManyWithoutAuthorInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    tickets?: TicketUncheckedCreateNestedManyWithoutAuthorInput
    assignedTickets?: TicketUncheckedCreateNestedManyWithoutAssignedToInput
    ticketMsgs?: TicketMessageUncheckedCreateNestedManyWithoutAuthorInput
    ticketParticipants?: TicketParticipantUncheckedCreateNestedManyWithoutUserInput
    ticketParticipantsAdded?: TicketParticipantUncheckedCreateNestedManyWithoutAddedByInput
    ticketRatingsGiven?: TicketRatingUncheckedCreateNestedManyWithoutRaterInput
    ticketRatingsReceived?: TicketRatingUncheckedCreateNestedManyWithoutTargetInput
    closedTickets?: TicketUncheckedCreateNestedManyWithoutClosedByInput
    purchases?: PurchaseUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    whitelistApps?: WhitelistApplicationUncheckedCreateNestedManyWithoutUserInput
    convoParts?: ConversationParticipantUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: DirectMessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: DirectMessageUncheckedCreateNestedManyWithoutReceiverInput
    userBadges?: UserBadgeUncheckedCreateNestedManyWithoutUserInput
    gameAccounts?: GameAccountUncheckedCreateNestedManyWithoutUserInput
    mtaAccessLogs?: MtaAccessLogUncheckedCreateNestedManyWithoutUserInput
    ticketRatingReqGiven?: TicketRatingRequirementUncheckedCreateNestedManyWithoutRaterInput
    ticketRatingReqReceived?: TicketRatingRequirementUncheckedCreateNestedManyWithoutTargetInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    entitlements?: EntitlementUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    staffShifts?: StaffShiftUncheckedCreateNestedManyWithoutUserInput
    staffWeeklyRewards?: StaffWeeklyRewardUncheckedCreateNestedManyWithoutUserInput
    adminCasesTarget?: AdminCaseUncheckedCreateNestedManyWithoutTargetUserInput
    adminCasesStaff?: AdminCaseUncheckedCreateNestedManyWithoutStaffUserInput
    reputation?: UserReputationUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutReviewedWhitelistsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReviewedWhitelistsInput, UserUncheckedCreateWithoutReviewedWhitelistsInput>
  }

  export type WhitelistAnswerCreateWithoutApplicationInput = {
    id?: string
    value: string
    createdAt?: Date | string
    question: WhitelistQuestionCreateNestedOneWithoutAnswersInput
  }

  export type WhitelistAnswerUncheckedCreateWithoutApplicationInput = {
    id?: string
    questionId: string
    value: string
    createdAt?: Date | string
  }

  export type WhitelistAnswerCreateOrConnectWithoutApplicationInput = {
    where: WhitelistAnswerWhereUniqueInput
    create: XOR<WhitelistAnswerCreateWithoutApplicationInput, WhitelistAnswerUncheckedCreateWithoutApplicationInput>
  }

  export type WhitelistAnswerCreateManyApplicationInputEnvelope = {
    data: WhitelistAnswerCreateManyApplicationInput | WhitelistAnswerCreateManyApplicationInput[]
  }

  export type UserUpsertWithoutWhitelistAppsInput = {
    update: XOR<UserUpdateWithoutWhitelistAppsInput, UserUncheckedUpdateWithoutWhitelistAppsInput>
    create: XOR<UserCreateWithoutWhitelistAppsInput, UserUncheckedCreateWithoutWhitelistAppsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutWhitelistAppsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutWhitelistAppsInput, UserUncheckedUpdateWithoutWhitelistAppsInput>
  }

  export type UserUpdateWithoutWhitelistAppsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifyToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerifyExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    discordId?: NullableStringFieldUpdateOperationsInput | string | null
    discordUsername?: NullableStringFieldUpdateOperationsInput | string | null
    avatarKey?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    bannedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    whitelistStatus?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    lastSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    topics?: TopicUpdateManyWithoutAuthorNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    tickets?: TicketUpdateManyWithoutAuthorNestedInput
    assignedTickets?: TicketUpdateManyWithoutAssignedToNestedInput
    ticketMsgs?: TicketMessageUpdateManyWithoutAuthorNestedInput
    ticketParticipants?: TicketParticipantUpdateManyWithoutUserNestedInput
    ticketParticipantsAdded?: TicketParticipantUpdateManyWithoutAddedByNestedInput
    ticketRatingsGiven?: TicketRatingUpdateManyWithoutRaterNestedInput
    ticketRatingsReceived?: TicketRatingUpdateManyWithoutTargetNestedInput
    closedTickets?: TicketUpdateManyWithoutClosedByNestedInput
    purchases?: PurchaseUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    reviewedWhitelists?: WhitelistApplicationUpdateManyWithoutReviewerNestedInput
    convoParts?: ConversationParticipantUpdateManyWithoutUserNestedInput
    sentMessages?: DirectMessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: DirectMessageUpdateManyWithoutReceiverNestedInput
    userBadges?: UserBadgeUpdateManyWithoutUserNestedInput
    gameAccounts?: GameAccountUpdateManyWithoutUserNestedInput
    mtaAccessLogs?: MtaAccessLogUpdateManyWithoutUserNestedInput
    ticketRatingReqGiven?: TicketRatingRequirementUpdateManyWithoutRaterNestedInput
    ticketRatingReqReceived?: TicketRatingRequirementUpdateManyWithoutTargetNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    entitlements?: EntitlementUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    staffShifts?: StaffShiftUpdateManyWithoutUserNestedInput
    staffWeeklyRewards?: StaffWeeklyRewardUpdateManyWithoutUserNestedInput
    adminCasesTarget?: AdminCaseUpdateManyWithoutTargetUserNestedInput
    adminCasesStaff?: AdminCaseUpdateManyWithoutStaffUserNestedInput
    reputation?: UserReputationUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutWhitelistAppsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifyToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerifyExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    discordId?: NullableStringFieldUpdateOperationsInput | string | null
    discordUsername?: NullableStringFieldUpdateOperationsInput | string | null
    avatarKey?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    bannedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    whitelistStatus?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    lastSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    topics?: TopicUncheckedUpdateManyWithoutAuthorNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutAuthorNestedInput
    assignedTickets?: TicketUncheckedUpdateManyWithoutAssignedToNestedInput
    ticketMsgs?: TicketMessageUncheckedUpdateManyWithoutAuthorNestedInput
    ticketParticipants?: TicketParticipantUncheckedUpdateManyWithoutUserNestedInput
    ticketParticipantsAdded?: TicketParticipantUncheckedUpdateManyWithoutAddedByNestedInput
    ticketRatingsGiven?: TicketRatingUncheckedUpdateManyWithoutRaterNestedInput
    ticketRatingsReceived?: TicketRatingUncheckedUpdateManyWithoutTargetNestedInput
    closedTickets?: TicketUncheckedUpdateManyWithoutClosedByNestedInput
    purchases?: PurchaseUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    reviewedWhitelists?: WhitelistApplicationUncheckedUpdateManyWithoutReviewerNestedInput
    convoParts?: ConversationParticipantUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: DirectMessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: DirectMessageUncheckedUpdateManyWithoutReceiverNestedInput
    userBadges?: UserBadgeUncheckedUpdateManyWithoutUserNestedInput
    gameAccounts?: GameAccountUncheckedUpdateManyWithoutUserNestedInput
    mtaAccessLogs?: MtaAccessLogUncheckedUpdateManyWithoutUserNestedInput
    ticketRatingReqGiven?: TicketRatingRequirementUncheckedUpdateManyWithoutRaterNestedInput
    ticketRatingReqReceived?: TicketRatingRequirementUncheckedUpdateManyWithoutTargetNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    entitlements?: EntitlementUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    staffShifts?: StaffShiftUncheckedUpdateManyWithoutUserNestedInput
    staffWeeklyRewards?: StaffWeeklyRewardUncheckedUpdateManyWithoutUserNestedInput
    adminCasesTarget?: AdminCaseUncheckedUpdateManyWithoutTargetUserNestedInput
    adminCasesStaff?: AdminCaseUncheckedUpdateManyWithoutStaffUserNestedInput
    reputation?: UserReputationUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserUpsertWithoutReviewedWhitelistsInput = {
    update: XOR<UserUpdateWithoutReviewedWhitelistsInput, UserUncheckedUpdateWithoutReviewedWhitelistsInput>
    create: XOR<UserCreateWithoutReviewedWhitelistsInput, UserUncheckedCreateWithoutReviewedWhitelistsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReviewedWhitelistsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReviewedWhitelistsInput, UserUncheckedUpdateWithoutReviewedWhitelistsInput>
  }

  export type UserUpdateWithoutReviewedWhitelistsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifyToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerifyExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    discordId?: NullableStringFieldUpdateOperationsInput | string | null
    discordUsername?: NullableStringFieldUpdateOperationsInput | string | null
    avatarKey?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    bannedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    whitelistStatus?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    lastSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    topics?: TopicUpdateManyWithoutAuthorNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    tickets?: TicketUpdateManyWithoutAuthorNestedInput
    assignedTickets?: TicketUpdateManyWithoutAssignedToNestedInput
    ticketMsgs?: TicketMessageUpdateManyWithoutAuthorNestedInput
    ticketParticipants?: TicketParticipantUpdateManyWithoutUserNestedInput
    ticketParticipantsAdded?: TicketParticipantUpdateManyWithoutAddedByNestedInput
    ticketRatingsGiven?: TicketRatingUpdateManyWithoutRaterNestedInput
    ticketRatingsReceived?: TicketRatingUpdateManyWithoutTargetNestedInput
    closedTickets?: TicketUpdateManyWithoutClosedByNestedInput
    purchases?: PurchaseUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    whitelistApps?: WhitelistApplicationUpdateManyWithoutUserNestedInput
    convoParts?: ConversationParticipantUpdateManyWithoutUserNestedInput
    sentMessages?: DirectMessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: DirectMessageUpdateManyWithoutReceiverNestedInput
    userBadges?: UserBadgeUpdateManyWithoutUserNestedInput
    gameAccounts?: GameAccountUpdateManyWithoutUserNestedInput
    mtaAccessLogs?: MtaAccessLogUpdateManyWithoutUserNestedInput
    ticketRatingReqGiven?: TicketRatingRequirementUpdateManyWithoutRaterNestedInput
    ticketRatingReqReceived?: TicketRatingRequirementUpdateManyWithoutTargetNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    entitlements?: EntitlementUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    staffShifts?: StaffShiftUpdateManyWithoutUserNestedInput
    staffWeeklyRewards?: StaffWeeklyRewardUpdateManyWithoutUserNestedInput
    adminCasesTarget?: AdminCaseUpdateManyWithoutTargetUserNestedInput
    adminCasesStaff?: AdminCaseUpdateManyWithoutStaffUserNestedInput
    reputation?: UserReputationUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutReviewedWhitelistsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifyToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerifyExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    discordId?: NullableStringFieldUpdateOperationsInput | string | null
    discordUsername?: NullableStringFieldUpdateOperationsInput | string | null
    avatarKey?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    bannedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    whitelistStatus?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    lastSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    topics?: TopicUncheckedUpdateManyWithoutAuthorNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutAuthorNestedInput
    assignedTickets?: TicketUncheckedUpdateManyWithoutAssignedToNestedInput
    ticketMsgs?: TicketMessageUncheckedUpdateManyWithoutAuthorNestedInput
    ticketParticipants?: TicketParticipantUncheckedUpdateManyWithoutUserNestedInput
    ticketParticipantsAdded?: TicketParticipantUncheckedUpdateManyWithoutAddedByNestedInput
    ticketRatingsGiven?: TicketRatingUncheckedUpdateManyWithoutRaterNestedInput
    ticketRatingsReceived?: TicketRatingUncheckedUpdateManyWithoutTargetNestedInput
    closedTickets?: TicketUncheckedUpdateManyWithoutClosedByNestedInput
    purchases?: PurchaseUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    whitelistApps?: WhitelistApplicationUncheckedUpdateManyWithoutUserNestedInput
    convoParts?: ConversationParticipantUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: DirectMessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: DirectMessageUncheckedUpdateManyWithoutReceiverNestedInput
    userBadges?: UserBadgeUncheckedUpdateManyWithoutUserNestedInput
    gameAccounts?: GameAccountUncheckedUpdateManyWithoutUserNestedInput
    mtaAccessLogs?: MtaAccessLogUncheckedUpdateManyWithoutUserNestedInput
    ticketRatingReqGiven?: TicketRatingRequirementUncheckedUpdateManyWithoutRaterNestedInput
    ticketRatingReqReceived?: TicketRatingRequirementUncheckedUpdateManyWithoutTargetNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    entitlements?: EntitlementUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    staffShifts?: StaffShiftUncheckedUpdateManyWithoutUserNestedInput
    staffWeeklyRewards?: StaffWeeklyRewardUncheckedUpdateManyWithoutUserNestedInput
    adminCasesTarget?: AdminCaseUncheckedUpdateManyWithoutTargetUserNestedInput
    adminCasesStaff?: AdminCaseUncheckedUpdateManyWithoutStaffUserNestedInput
    reputation?: UserReputationUncheckedUpdateOneWithoutUserNestedInput
  }

  export type WhitelistAnswerUpsertWithWhereUniqueWithoutApplicationInput = {
    where: WhitelistAnswerWhereUniqueInput
    update: XOR<WhitelistAnswerUpdateWithoutApplicationInput, WhitelistAnswerUncheckedUpdateWithoutApplicationInput>
    create: XOR<WhitelistAnswerCreateWithoutApplicationInput, WhitelistAnswerUncheckedCreateWithoutApplicationInput>
  }

  export type WhitelistAnswerUpdateWithWhereUniqueWithoutApplicationInput = {
    where: WhitelistAnswerWhereUniqueInput
    data: XOR<WhitelistAnswerUpdateWithoutApplicationInput, WhitelistAnswerUncheckedUpdateWithoutApplicationInput>
  }

  export type WhitelistAnswerUpdateManyWithWhereWithoutApplicationInput = {
    where: WhitelistAnswerScalarWhereInput
    data: XOR<WhitelistAnswerUpdateManyMutationInput, WhitelistAnswerUncheckedUpdateManyWithoutApplicationInput>
  }

  export type WhitelistApplicationCreateWithoutAnswersInput = {
    id?: string
    status?: string
    rejectReason?: string | null
    createdAt?: Date | string
    reviewedAt?: Date | string | null
    user: UserCreateNestedOneWithoutWhitelistAppsInput
    reviewer?: UserCreateNestedOneWithoutReviewedWhitelistsInput
  }

  export type WhitelistApplicationUncheckedCreateWithoutAnswersInput = {
    id?: string
    userId: string
    status?: string
    reviewerId?: string | null
    rejectReason?: string | null
    createdAt?: Date | string
    reviewedAt?: Date | string | null
  }

  export type WhitelistApplicationCreateOrConnectWithoutAnswersInput = {
    where: WhitelistApplicationWhereUniqueInput
    create: XOR<WhitelistApplicationCreateWithoutAnswersInput, WhitelistApplicationUncheckedCreateWithoutAnswersInput>
  }

  export type WhitelistQuestionCreateWithoutAnswersInput = {
    id?: string
    prompt: string
    required?: boolean
    order?: number
    createdAt?: Date | string
  }

  export type WhitelistQuestionUncheckedCreateWithoutAnswersInput = {
    id?: string
    prompt: string
    required?: boolean
    order?: number
    createdAt?: Date | string
  }

  export type WhitelistQuestionCreateOrConnectWithoutAnswersInput = {
    where: WhitelistQuestionWhereUniqueInput
    create: XOR<WhitelistQuestionCreateWithoutAnswersInput, WhitelistQuestionUncheckedCreateWithoutAnswersInput>
  }

  export type WhitelistApplicationUpsertWithoutAnswersInput = {
    update: XOR<WhitelistApplicationUpdateWithoutAnswersInput, WhitelistApplicationUncheckedUpdateWithoutAnswersInput>
    create: XOR<WhitelistApplicationCreateWithoutAnswersInput, WhitelistApplicationUncheckedCreateWithoutAnswersInput>
    where?: WhitelistApplicationWhereInput
  }

  export type WhitelistApplicationUpdateToOneWithWhereWithoutAnswersInput = {
    where?: WhitelistApplicationWhereInput
    data: XOR<WhitelistApplicationUpdateWithoutAnswersInput, WhitelistApplicationUncheckedUpdateWithoutAnswersInput>
  }

  export type WhitelistApplicationUpdateWithoutAnswersInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    rejectReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutWhitelistAppsNestedInput
    reviewer?: UserUpdateOneWithoutReviewedWhitelistsNestedInput
  }

  export type WhitelistApplicationUncheckedUpdateWithoutAnswersInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    reviewerId?: NullableStringFieldUpdateOperationsInput | string | null
    rejectReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WhitelistQuestionUpsertWithoutAnswersInput = {
    update: XOR<WhitelistQuestionUpdateWithoutAnswersInput, WhitelistQuestionUncheckedUpdateWithoutAnswersInput>
    create: XOR<WhitelistQuestionCreateWithoutAnswersInput, WhitelistQuestionUncheckedCreateWithoutAnswersInput>
    where?: WhitelistQuestionWhereInput
  }

  export type WhitelistQuestionUpdateToOneWithWhereWithoutAnswersInput = {
    where?: WhitelistQuestionWhereInput
    data: XOR<WhitelistQuestionUpdateWithoutAnswersInput, WhitelistQuestionUncheckedUpdateWithoutAnswersInput>
  }

  export type WhitelistQuestionUpdateWithoutAnswersInput = {
    id?: StringFieldUpdateOperationsInput | string
    prompt?: StringFieldUpdateOperationsInput | string
    required?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WhitelistQuestionUncheckedUpdateWithoutAnswersInput = {
    id?: StringFieldUpdateOperationsInput | string
    prompt?: StringFieldUpdateOperationsInput | string
    required?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserBadgeCreateWithoutBadgeInput = {
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutUserBadgesInput
  }

  export type UserBadgeUncheckedCreateWithoutBadgeInput = {
    userId: string
    createdAt?: Date | string
  }

  export type UserBadgeCreateOrConnectWithoutBadgeInput = {
    where: UserBadgeWhereUniqueInput
    create: XOR<UserBadgeCreateWithoutBadgeInput, UserBadgeUncheckedCreateWithoutBadgeInput>
  }

  export type UserBadgeCreateManyBadgeInputEnvelope = {
    data: UserBadgeCreateManyBadgeInput | UserBadgeCreateManyBadgeInput[]
  }

  export type UserBadgeUpsertWithWhereUniqueWithoutBadgeInput = {
    where: UserBadgeWhereUniqueInput
    update: XOR<UserBadgeUpdateWithoutBadgeInput, UserBadgeUncheckedUpdateWithoutBadgeInput>
    create: XOR<UserBadgeCreateWithoutBadgeInput, UserBadgeUncheckedCreateWithoutBadgeInput>
  }

  export type UserBadgeUpdateWithWhereUniqueWithoutBadgeInput = {
    where: UserBadgeWhereUniqueInput
    data: XOR<UserBadgeUpdateWithoutBadgeInput, UserBadgeUncheckedUpdateWithoutBadgeInput>
  }

  export type UserBadgeUpdateManyWithWhereWithoutBadgeInput = {
    where: UserBadgeScalarWhereInput
    data: XOR<UserBadgeUpdateManyMutationInput, UserBadgeUncheckedUpdateManyWithoutBadgeInput>
  }

  export type UserCreateWithoutUserBadgesInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    emailVerifiedAt?: Date | string | null
    emailVerifyToken?: string | null
    emailVerifyExpiresAt?: Date | string | null
    phone?: string | null
    recoveryEmail?: string | null
    googleId?: string | null
    discordId?: string | null
    discordUsername?: string | null
    avatarKey?: string
    role?: string
    isDeleted?: boolean
    bannedUntil?: Date | string | null
    whitelistStatus?: string
    points?: number
    lastSeenAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    avatarUrl?: string | null
    topics?: TopicCreateNestedManyWithoutAuthorInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    tickets?: TicketCreateNestedManyWithoutAuthorInput
    assignedTickets?: TicketCreateNestedManyWithoutAssignedToInput
    ticketMsgs?: TicketMessageCreateNestedManyWithoutAuthorInput
    ticketParticipants?: TicketParticipantCreateNestedManyWithoutUserInput
    ticketParticipantsAdded?: TicketParticipantCreateNestedManyWithoutAddedByInput
    ticketRatingsGiven?: TicketRatingCreateNestedManyWithoutRaterInput
    ticketRatingsReceived?: TicketRatingCreateNestedManyWithoutTargetInput
    closedTickets?: TicketCreateNestedManyWithoutClosedByInput
    purchases?: PurchaseCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    whitelistApps?: WhitelistApplicationCreateNestedManyWithoutUserInput
    reviewedWhitelists?: WhitelistApplicationCreateNestedManyWithoutReviewerInput
    convoParts?: ConversationParticipantCreateNestedManyWithoutUserInput
    sentMessages?: DirectMessageCreateNestedManyWithoutSenderInput
    receivedMessages?: DirectMessageCreateNestedManyWithoutReceiverInput
    gameAccounts?: GameAccountCreateNestedManyWithoutUserInput
    mtaAccessLogs?: MtaAccessLogCreateNestedManyWithoutUserInput
    ticketRatingReqGiven?: TicketRatingRequirementCreateNestedManyWithoutRaterInput
    ticketRatingReqReceived?: TicketRatingRequirementCreateNestedManyWithoutTargetInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    entitlements?: EntitlementCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    staffShifts?: StaffShiftCreateNestedManyWithoutUserInput
    staffWeeklyRewards?: StaffWeeklyRewardCreateNestedManyWithoutUserInput
    adminCasesTarget?: AdminCaseCreateNestedManyWithoutTargetUserInput
    adminCasesStaff?: AdminCaseCreateNestedManyWithoutStaffUserInput
    reputation?: UserReputationCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUserBadgesInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    emailVerifiedAt?: Date | string | null
    emailVerifyToken?: string | null
    emailVerifyExpiresAt?: Date | string | null
    phone?: string | null
    recoveryEmail?: string | null
    googleId?: string | null
    discordId?: string | null
    discordUsername?: string | null
    avatarKey?: string
    role?: string
    isDeleted?: boolean
    bannedUntil?: Date | string | null
    whitelistStatus?: string
    points?: number
    lastSeenAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    avatarUrl?: string | null
    topics?: TopicUncheckedCreateNestedManyWithoutAuthorInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    tickets?: TicketUncheckedCreateNestedManyWithoutAuthorInput
    assignedTickets?: TicketUncheckedCreateNestedManyWithoutAssignedToInput
    ticketMsgs?: TicketMessageUncheckedCreateNestedManyWithoutAuthorInput
    ticketParticipants?: TicketParticipantUncheckedCreateNestedManyWithoutUserInput
    ticketParticipantsAdded?: TicketParticipantUncheckedCreateNestedManyWithoutAddedByInput
    ticketRatingsGiven?: TicketRatingUncheckedCreateNestedManyWithoutRaterInput
    ticketRatingsReceived?: TicketRatingUncheckedCreateNestedManyWithoutTargetInput
    closedTickets?: TicketUncheckedCreateNestedManyWithoutClosedByInput
    purchases?: PurchaseUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    whitelistApps?: WhitelistApplicationUncheckedCreateNestedManyWithoutUserInput
    reviewedWhitelists?: WhitelistApplicationUncheckedCreateNestedManyWithoutReviewerInput
    convoParts?: ConversationParticipantUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: DirectMessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: DirectMessageUncheckedCreateNestedManyWithoutReceiverInput
    gameAccounts?: GameAccountUncheckedCreateNestedManyWithoutUserInput
    mtaAccessLogs?: MtaAccessLogUncheckedCreateNestedManyWithoutUserInput
    ticketRatingReqGiven?: TicketRatingRequirementUncheckedCreateNestedManyWithoutRaterInput
    ticketRatingReqReceived?: TicketRatingRequirementUncheckedCreateNestedManyWithoutTargetInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    entitlements?: EntitlementUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    staffShifts?: StaffShiftUncheckedCreateNestedManyWithoutUserInput
    staffWeeklyRewards?: StaffWeeklyRewardUncheckedCreateNestedManyWithoutUserInput
    adminCasesTarget?: AdminCaseUncheckedCreateNestedManyWithoutTargetUserInput
    adminCasesStaff?: AdminCaseUncheckedCreateNestedManyWithoutStaffUserInput
    reputation?: UserReputationUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUserBadgesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserBadgesInput, UserUncheckedCreateWithoutUserBadgesInput>
  }

  export type BadgeCreateWithoutUsersInput = {
    id?: string
    name: string
    description?: string | null
    icon?: string | null
    createdAt?: Date | string
  }

  export type BadgeUncheckedCreateWithoutUsersInput = {
    id?: string
    name: string
    description?: string | null
    icon?: string | null
    createdAt?: Date | string
  }

  export type BadgeCreateOrConnectWithoutUsersInput = {
    where: BadgeWhereUniqueInput
    create: XOR<BadgeCreateWithoutUsersInput, BadgeUncheckedCreateWithoutUsersInput>
  }

  export type UserUpsertWithoutUserBadgesInput = {
    update: XOR<UserUpdateWithoutUserBadgesInput, UserUncheckedUpdateWithoutUserBadgesInput>
    create: XOR<UserCreateWithoutUserBadgesInput, UserUncheckedCreateWithoutUserBadgesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUserBadgesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUserBadgesInput, UserUncheckedUpdateWithoutUserBadgesInput>
  }

  export type UserUpdateWithoutUserBadgesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifyToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerifyExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    discordId?: NullableStringFieldUpdateOperationsInput | string | null
    discordUsername?: NullableStringFieldUpdateOperationsInput | string | null
    avatarKey?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    bannedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    whitelistStatus?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    lastSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    topics?: TopicUpdateManyWithoutAuthorNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    tickets?: TicketUpdateManyWithoutAuthorNestedInput
    assignedTickets?: TicketUpdateManyWithoutAssignedToNestedInput
    ticketMsgs?: TicketMessageUpdateManyWithoutAuthorNestedInput
    ticketParticipants?: TicketParticipantUpdateManyWithoutUserNestedInput
    ticketParticipantsAdded?: TicketParticipantUpdateManyWithoutAddedByNestedInput
    ticketRatingsGiven?: TicketRatingUpdateManyWithoutRaterNestedInput
    ticketRatingsReceived?: TicketRatingUpdateManyWithoutTargetNestedInput
    closedTickets?: TicketUpdateManyWithoutClosedByNestedInput
    purchases?: PurchaseUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    whitelistApps?: WhitelistApplicationUpdateManyWithoutUserNestedInput
    reviewedWhitelists?: WhitelistApplicationUpdateManyWithoutReviewerNestedInput
    convoParts?: ConversationParticipantUpdateManyWithoutUserNestedInput
    sentMessages?: DirectMessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: DirectMessageUpdateManyWithoutReceiverNestedInput
    gameAccounts?: GameAccountUpdateManyWithoutUserNestedInput
    mtaAccessLogs?: MtaAccessLogUpdateManyWithoutUserNestedInput
    ticketRatingReqGiven?: TicketRatingRequirementUpdateManyWithoutRaterNestedInput
    ticketRatingReqReceived?: TicketRatingRequirementUpdateManyWithoutTargetNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    entitlements?: EntitlementUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    staffShifts?: StaffShiftUpdateManyWithoutUserNestedInput
    staffWeeklyRewards?: StaffWeeklyRewardUpdateManyWithoutUserNestedInput
    adminCasesTarget?: AdminCaseUpdateManyWithoutTargetUserNestedInput
    adminCasesStaff?: AdminCaseUpdateManyWithoutStaffUserNestedInput
    reputation?: UserReputationUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUserBadgesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifyToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerifyExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    discordId?: NullableStringFieldUpdateOperationsInput | string | null
    discordUsername?: NullableStringFieldUpdateOperationsInput | string | null
    avatarKey?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    bannedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    whitelistStatus?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    lastSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    topics?: TopicUncheckedUpdateManyWithoutAuthorNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutAuthorNestedInput
    assignedTickets?: TicketUncheckedUpdateManyWithoutAssignedToNestedInput
    ticketMsgs?: TicketMessageUncheckedUpdateManyWithoutAuthorNestedInput
    ticketParticipants?: TicketParticipantUncheckedUpdateManyWithoutUserNestedInput
    ticketParticipantsAdded?: TicketParticipantUncheckedUpdateManyWithoutAddedByNestedInput
    ticketRatingsGiven?: TicketRatingUncheckedUpdateManyWithoutRaterNestedInput
    ticketRatingsReceived?: TicketRatingUncheckedUpdateManyWithoutTargetNestedInput
    closedTickets?: TicketUncheckedUpdateManyWithoutClosedByNestedInput
    purchases?: PurchaseUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    whitelistApps?: WhitelistApplicationUncheckedUpdateManyWithoutUserNestedInput
    reviewedWhitelists?: WhitelistApplicationUncheckedUpdateManyWithoutReviewerNestedInput
    convoParts?: ConversationParticipantUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: DirectMessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: DirectMessageUncheckedUpdateManyWithoutReceiverNestedInput
    gameAccounts?: GameAccountUncheckedUpdateManyWithoutUserNestedInput
    mtaAccessLogs?: MtaAccessLogUncheckedUpdateManyWithoutUserNestedInput
    ticketRatingReqGiven?: TicketRatingRequirementUncheckedUpdateManyWithoutRaterNestedInput
    ticketRatingReqReceived?: TicketRatingRequirementUncheckedUpdateManyWithoutTargetNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    entitlements?: EntitlementUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    staffShifts?: StaffShiftUncheckedUpdateManyWithoutUserNestedInput
    staffWeeklyRewards?: StaffWeeklyRewardUncheckedUpdateManyWithoutUserNestedInput
    adminCasesTarget?: AdminCaseUncheckedUpdateManyWithoutTargetUserNestedInput
    adminCasesStaff?: AdminCaseUncheckedUpdateManyWithoutStaffUserNestedInput
    reputation?: UserReputationUncheckedUpdateOneWithoutUserNestedInput
  }

  export type BadgeUpsertWithoutUsersInput = {
    update: XOR<BadgeUpdateWithoutUsersInput, BadgeUncheckedUpdateWithoutUsersInput>
    create: XOR<BadgeCreateWithoutUsersInput, BadgeUncheckedCreateWithoutUsersInput>
    where?: BadgeWhereInput
  }

  export type BadgeUpdateToOneWithWhereWithoutUsersInput = {
    where?: BadgeWhereInput
    data: XOR<BadgeUpdateWithoutUsersInput, BadgeUncheckedUpdateWithoutUsersInput>
  }

  export type BadgeUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BadgeUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationParticipantCreateWithoutConversationInput = {
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutConvoPartsInput
  }

  export type ConversationParticipantUncheckedCreateWithoutConversationInput = {
    userId: string
    createdAt?: Date | string
  }

  export type ConversationParticipantCreateOrConnectWithoutConversationInput = {
    where: ConversationParticipantWhereUniqueInput
    create: XOR<ConversationParticipantCreateWithoutConversationInput, ConversationParticipantUncheckedCreateWithoutConversationInput>
  }

  export type ConversationParticipantCreateManyConversationInputEnvelope = {
    data: ConversationParticipantCreateManyConversationInput | ConversationParticipantCreateManyConversationInput[]
  }

  export type DirectMessageCreateWithoutConversationInput = {
    id?: string
    content: string
    kind?: string
    isDeleted?: boolean
    createdAt?: Date | string
    sender: UserCreateNestedOneWithoutSentMessagesInput
    receiver: UserCreateNestedOneWithoutReceivedMessagesInput
  }

  export type DirectMessageUncheckedCreateWithoutConversationInput = {
    id?: string
    senderId: string
    receiverId: string
    content: string
    kind?: string
    isDeleted?: boolean
    createdAt?: Date | string
  }

  export type DirectMessageCreateOrConnectWithoutConversationInput = {
    where: DirectMessageWhereUniqueInput
    create: XOR<DirectMessageCreateWithoutConversationInput, DirectMessageUncheckedCreateWithoutConversationInput>
  }

  export type DirectMessageCreateManyConversationInputEnvelope = {
    data: DirectMessageCreateManyConversationInput | DirectMessageCreateManyConversationInput[]
  }

  export type ConversationParticipantUpsertWithWhereUniqueWithoutConversationInput = {
    where: ConversationParticipantWhereUniqueInput
    update: XOR<ConversationParticipantUpdateWithoutConversationInput, ConversationParticipantUncheckedUpdateWithoutConversationInput>
    create: XOR<ConversationParticipantCreateWithoutConversationInput, ConversationParticipantUncheckedCreateWithoutConversationInput>
  }

  export type ConversationParticipantUpdateWithWhereUniqueWithoutConversationInput = {
    where: ConversationParticipantWhereUniqueInput
    data: XOR<ConversationParticipantUpdateWithoutConversationInput, ConversationParticipantUncheckedUpdateWithoutConversationInput>
  }

  export type ConversationParticipantUpdateManyWithWhereWithoutConversationInput = {
    where: ConversationParticipantScalarWhereInput
    data: XOR<ConversationParticipantUpdateManyMutationInput, ConversationParticipantUncheckedUpdateManyWithoutConversationInput>
  }

  export type DirectMessageUpsertWithWhereUniqueWithoutConversationInput = {
    where: DirectMessageWhereUniqueInput
    update: XOR<DirectMessageUpdateWithoutConversationInput, DirectMessageUncheckedUpdateWithoutConversationInput>
    create: XOR<DirectMessageCreateWithoutConversationInput, DirectMessageUncheckedCreateWithoutConversationInput>
  }

  export type DirectMessageUpdateWithWhereUniqueWithoutConversationInput = {
    where: DirectMessageWhereUniqueInput
    data: XOR<DirectMessageUpdateWithoutConversationInput, DirectMessageUncheckedUpdateWithoutConversationInput>
  }

  export type DirectMessageUpdateManyWithWhereWithoutConversationInput = {
    where: DirectMessageScalarWhereInput
    data: XOR<DirectMessageUpdateManyMutationInput, DirectMessageUncheckedUpdateManyWithoutConversationInput>
  }

  export type ConversationCreateWithoutParticipantsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: DirectMessageCreateNestedManyWithoutConversationInput
  }

  export type ConversationUncheckedCreateWithoutParticipantsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: DirectMessageUncheckedCreateNestedManyWithoutConversationInput
  }

  export type ConversationCreateOrConnectWithoutParticipantsInput = {
    where: ConversationWhereUniqueInput
    create: XOR<ConversationCreateWithoutParticipantsInput, ConversationUncheckedCreateWithoutParticipantsInput>
  }

  export type UserCreateWithoutConvoPartsInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    emailVerifiedAt?: Date | string | null
    emailVerifyToken?: string | null
    emailVerifyExpiresAt?: Date | string | null
    phone?: string | null
    recoveryEmail?: string | null
    googleId?: string | null
    discordId?: string | null
    discordUsername?: string | null
    avatarKey?: string
    role?: string
    isDeleted?: boolean
    bannedUntil?: Date | string | null
    whitelistStatus?: string
    points?: number
    lastSeenAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    avatarUrl?: string | null
    topics?: TopicCreateNestedManyWithoutAuthorInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    tickets?: TicketCreateNestedManyWithoutAuthorInput
    assignedTickets?: TicketCreateNestedManyWithoutAssignedToInput
    ticketMsgs?: TicketMessageCreateNestedManyWithoutAuthorInput
    ticketParticipants?: TicketParticipantCreateNestedManyWithoutUserInput
    ticketParticipantsAdded?: TicketParticipantCreateNestedManyWithoutAddedByInput
    ticketRatingsGiven?: TicketRatingCreateNestedManyWithoutRaterInput
    ticketRatingsReceived?: TicketRatingCreateNestedManyWithoutTargetInput
    closedTickets?: TicketCreateNestedManyWithoutClosedByInput
    purchases?: PurchaseCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    whitelistApps?: WhitelistApplicationCreateNestedManyWithoutUserInput
    reviewedWhitelists?: WhitelistApplicationCreateNestedManyWithoutReviewerInput
    sentMessages?: DirectMessageCreateNestedManyWithoutSenderInput
    receivedMessages?: DirectMessageCreateNestedManyWithoutReceiverInput
    userBadges?: UserBadgeCreateNestedManyWithoutUserInput
    gameAccounts?: GameAccountCreateNestedManyWithoutUserInput
    mtaAccessLogs?: MtaAccessLogCreateNestedManyWithoutUserInput
    ticketRatingReqGiven?: TicketRatingRequirementCreateNestedManyWithoutRaterInput
    ticketRatingReqReceived?: TicketRatingRequirementCreateNestedManyWithoutTargetInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    entitlements?: EntitlementCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    staffShifts?: StaffShiftCreateNestedManyWithoutUserInput
    staffWeeklyRewards?: StaffWeeklyRewardCreateNestedManyWithoutUserInput
    adminCasesTarget?: AdminCaseCreateNestedManyWithoutTargetUserInput
    adminCasesStaff?: AdminCaseCreateNestedManyWithoutStaffUserInput
    reputation?: UserReputationCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutConvoPartsInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    emailVerifiedAt?: Date | string | null
    emailVerifyToken?: string | null
    emailVerifyExpiresAt?: Date | string | null
    phone?: string | null
    recoveryEmail?: string | null
    googleId?: string | null
    discordId?: string | null
    discordUsername?: string | null
    avatarKey?: string
    role?: string
    isDeleted?: boolean
    bannedUntil?: Date | string | null
    whitelistStatus?: string
    points?: number
    lastSeenAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    avatarUrl?: string | null
    topics?: TopicUncheckedCreateNestedManyWithoutAuthorInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    tickets?: TicketUncheckedCreateNestedManyWithoutAuthorInput
    assignedTickets?: TicketUncheckedCreateNestedManyWithoutAssignedToInput
    ticketMsgs?: TicketMessageUncheckedCreateNestedManyWithoutAuthorInput
    ticketParticipants?: TicketParticipantUncheckedCreateNestedManyWithoutUserInput
    ticketParticipantsAdded?: TicketParticipantUncheckedCreateNestedManyWithoutAddedByInput
    ticketRatingsGiven?: TicketRatingUncheckedCreateNestedManyWithoutRaterInput
    ticketRatingsReceived?: TicketRatingUncheckedCreateNestedManyWithoutTargetInput
    closedTickets?: TicketUncheckedCreateNestedManyWithoutClosedByInput
    purchases?: PurchaseUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    whitelistApps?: WhitelistApplicationUncheckedCreateNestedManyWithoutUserInput
    reviewedWhitelists?: WhitelistApplicationUncheckedCreateNestedManyWithoutReviewerInput
    sentMessages?: DirectMessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: DirectMessageUncheckedCreateNestedManyWithoutReceiverInput
    userBadges?: UserBadgeUncheckedCreateNestedManyWithoutUserInput
    gameAccounts?: GameAccountUncheckedCreateNestedManyWithoutUserInput
    mtaAccessLogs?: MtaAccessLogUncheckedCreateNestedManyWithoutUserInput
    ticketRatingReqGiven?: TicketRatingRequirementUncheckedCreateNestedManyWithoutRaterInput
    ticketRatingReqReceived?: TicketRatingRequirementUncheckedCreateNestedManyWithoutTargetInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    entitlements?: EntitlementUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    staffShifts?: StaffShiftUncheckedCreateNestedManyWithoutUserInput
    staffWeeklyRewards?: StaffWeeklyRewardUncheckedCreateNestedManyWithoutUserInput
    adminCasesTarget?: AdminCaseUncheckedCreateNestedManyWithoutTargetUserInput
    adminCasesStaff?: AdminCaseUncheckedCreateNestedManyWithoutStaffUserInput
    reputation?: UserReputationUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutConvoPartsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutConvoPartsInput, UserUncheckedCreateWithoutConvoPartsInput>
  }

  export type ConversationUpsertWithoutParticipantsInput = {
    update: XOR<ConversationUpdateWithoutParticipantsInput, ConversationUncheckedUpdateWithoutParticipantsInput>
    create: XOR<ConversationCreateWithoutParticipantsInput, ConversationUncheckedCreateWithoutParticipantsInput>
    where?: ConversationWhereInput
  }

  export type ConversationUpdateToOneWithWhereWithoutParticipantsInput = {
    where?: ConversationWhereInput
    data: XOR<ConversationUpdateWithoutParticipantsInput, ConversationUncheckedUpdateWithoutParticipantsInput>
  }

  export type ConversationUpdateWithoutParticipantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: DirectMessageUpdateManyWithoutConversationNestedInput
  }

  export type ConversationUncheckedUpdateWithoutParticipantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: DirectMessageUncheckedUpdateManyWithoutConversationNestedInput
  }

  export type UserUpsertWithoutConvoPartsInput = {
    update: XOR<UserUpdateWithoutConvoPartsInput, UserUncheckedUpdateWithoutConvoPartsInput>
    create: XOR<UserCreateWithoutConvoPartsInput, UserUncheckedCreateWithoutConvoPartsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutConvoPartsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutConvoPartsInput, UserUncheckedUpdateWithoutConvoPartsInput>
  }

  export type UserUpdateWithoutConvoPartsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifyToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerifyExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    discordId?: NullableStringFieldUpdateOperationsInput | string | null
    discordUsername?: NullableStringFieldUpdateOperationsInput | string | null
    avatarKey?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    bannedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    whitelistStatus?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    lastSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    topics?: TopicUpdateManyWithoutAuthorNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    tickets?: TicketUpdateManyWithoutAuthorNestedInput
    assignedTickets?: TicketUpdateManyWithoutAssignedToNestedInput
    ticketMsgs?: TicketMessageUpdateManyWithoutAuthorNestedInput
    ticketParticipants?: TicketParticipantUpdateManyWithoutUserNestedInput
    ticketParticipantsAdded?: TicketParticipantUpdateManyWithoutAddedByNestedInput
    ticketRatingsGiven?: TicketRatingUpdateManyWithoutRaterNestedInput
    ticketRatingsReceived?: TicketRatingUpdateManyWithoutTargetNestedInput
    closedTickets?: TicketUpdateManyWithoutClosedByNestedInput
    purchases?: PurchaseUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    whitelistApps?: WhitelistApplicationUpdateManyWithoutUserNestedInput
    reviewedWhitelists?: WhitelistApplicationUpdateManyWithoutReviewerNestedInput
    sentMessages?: DirectMessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: DirectMessageUpdateManyWithoutReceiverNestedInput
    userBadges?: UserBadgeUpdateManyWithoutUserNestedInput
    gameAccounts?: GameAccountUpdateManyWithoutUserNestedInput
    mtaAccessLogs?: MtaAccessLogUpdateManyWithoutUserNestedInput
    ticketRatingReqGiven?: TicketRatingRequirementUpdateManyWithoutRaterNestedInput
    ticketRatingReqReceived?: TicketRatingRequirementUpdateManyWithoutTargetNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    entitlements?: EntitlementUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    staffShifts?: StaffShiftUpdateManyWithoutUserNestedInput
    staffWeeklyRewards?: StaffWeeklyRewardUpdateManyWithoutUserNestedInput
    adminCasesTarget?: AdminCaseUpdateManyWithoutTargetUserNestedInput
    adminCasesStaff?: AdminCaseUpdateManyWithoutStaffUserNestedInput
    reputation?: UserReputationUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutConvoPartsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifyToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerifyExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    discordId?: NullableStringFieldUpdateOperationsInput | string | null
    discordUsername?: NullableStringFieldUpdateOperationsInput | string | null
    avatarKey?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    bannedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    whitelistStatus?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    lastSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    topics?: TopicUncheckedUpdateManyWithoutAuthorNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutAuthorNestedInput
    assignedTickets?: TicketUncheckedUpdateManyWithoutAssignedToNestedInput
    ticketMsgs?: TicketMessageUncheckedUpdateManyWithoutAuthorNestedInput
    ticketParticipants?: TicketParticipantUncheckedUpdateManyWithoutUserNestedInput
    ticketParticipantsAdded?: TicketParticipantUncheckedUpdateManyWithoutAddedByNestedInput
    ticketRatingsGiven?: TicketRatingUncheckedUpdateManyWithoutRaterNestedInput
    ticketRatingsReceived?: TicketRatingUncheckedUpdateManyWithoutTargetNestedInput
    closedTickets?: TicketUncheckedUpdateManyWithoutClosedByNestedInput
    purchases?: PurchaseUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    whitelistApps?: WhitelistApplicationUncheckedUpdateManyWithoutUserNestedInput
    reviewedWhitelists?: WhitelistApplicationUncheckedUpdateManyWithoutReviewerNestedInput
    sentMessages?: DirectMessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: DirectMessageUncheckedUpdateManyWithoutReceiverNestedInput
    userBadges?: UserBadgeUncheckedUpdateManyWithoutUserNestedInput
    gameAccounts?: GameAccountUncheckedUpdateManyWithoutUserNestedInput
    mtaAccessLogs?: MtaAccessLogUncheckedUpdateManyWithoutUserNestedInput
    ticketRatingReqGiven?: TicketRatingRequirementUncheckedUpdateManyWithoutRaterNestedInput
    ticketRatingReqReceived?: TicketRatingRequirementUncheckedUpdateManyWithoutTargetNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    entitlements?: EntitlementUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    staffShifts?: StaffShiftUncheckedUpdateManyWithoutUserNestedInput
    staffWeeklyRewards?: StaffWeeklyRewardUncheckedUpdateManyWithoutUserNestedInput
    adminCasesTarget?: AdminCaseUncheckedUpdateManyWithoutTargetUserNestedInput
    adminCasesStaff?: AdminCaseUncheckedUpdateManyWithoutStaffUserNestedInput
    reputation?: UserReputationUncheckedUpdateOneWithoutUserNestedInput
  }

  export type ConversationCreateWithoutMessagesInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    participants?: ConversationParticipantCreateNestedManyWithoutConversationInput
  }

  export type ConversationUncheckedCreateWithoutMessagesInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    participants?: ConversationParticipantUncheckedCreateNestedManyWithoutConversationInput
  }

  export type ConversationCreateOrConnectWithoutMessagesInput = {
    where: ConversationWhereUniqueInput
    create: XOR<ConversationCreateWithoutMessagesInput, ConversationUncheckedCreateWithoutMessagesInput>
  }

  export type UserCreateWithoutSentMessagesInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    emailVerifiedAt?: Date | string | null
    emailVerifyToken?: string | null
    emailVerifyExpiresAt?: Date | string | null
    phone?: string | null
    recoveryEmail?: string | null
    googleId?: string | null
    discordId?: string | null
    discordUsername?: string | null
    avatarKey?: string
    role?: string
    isDeleted?: boolean
    bannedUntil?: Date | string | null
    whitelistStatus?: string
    points?: number
    lastSeenAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    avatarUrl?: string | null
    topics?: TopicCreateNestedManyWithoutAuthorInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    tickets?: TicketCreateNestedManyWithoutAuthorInput
    assignedTickets?: TicketCreateNestedManyWithoutAssignedToInput
    ticketMsgs?: TicketMessageCreateNestedManyWithoutAuthorInput
    ticketParticipants?: TicketParticipantCreateNestedManyWithoutUserInput
    ticketParticipantsAdded?: TicketParticipantCreateNestedManyWithoutAddedByInput
    ticketRatingsGiven?: TicketRatingCreateNestedManyWithoutRaterInput
    ticketRatingsReceived?: TicketRatingCreateNestedManyWithoutTargetInput
    closedTickets?: TicketCreateNestedManyWithoutClosedByInput
    purchases?: PurchaseCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    whitelistApps?: WhitelistApplicationCreateNestedManyWithoutUserInput
    reviewedWhitelists?: WhitelistApplicationCreateNestedManyWithoutReviewerInput
    convoParts?: ConversationParticipantCreateNestedManyWithoutUserInput
    receivedMessages?: DirectMessageCreateNestedManyWithoutReceiverInput
    userBadges?: UserBadgeCreateNestedManyWithoutUserInput
    gameAccounts?: GameAccountCreateNestedManyWithoutUserInput
    mtaAccessLogs?: MtaAccessLogCreateNestedManyWithoutUserInput
    ticketRatingReqGiven?: TicketRatingRequirementCreateNestedManyWithoutRaterInput
    ticketRatingReqReceived?: TicketRatingRequirementCreateNestedManyWithoutTargetInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    entitlements?: EntitlementCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    staffShifts?: StaffShiftCreateNestedManyWithoutUserInput
    staffWeeklyRewards?: StaffWeeklyRewardCreateNestedManyWithoutUserInput
    adminCasesTarget?: AdminCaseCreateNestedManyWithoutTargetUserInput
    adminCasesStaff?: AdminCaseCreateNestedManyWithoutStaffUserInput
    reputation?: UserReputationCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSentMessagesInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    emailVerifiedAt?: Date | string | null
    emailVerifyToken?: string | null
    emailVerifyExpiresAt?: Date | string | null
    phone?: string | null
    recoveryEmail?: string | null
    googleId?: string | null
    discordId?: string | null
    discordUsername?: string | null
    avatarKey?: string
    role?: string
    isDeleted?: boolean
    bannedUntil?: Date | string | null
    whitelistStatus?: string
    points?: number
    lastSeenAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    avatarUrl?: string | null
    topics?: TopicUncheckedCreateNestedManyWithoutAuthorInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    tickets?: TicketUncheckedCreateNestedManyWithoutAuthorInput
    assignedTickets?: TicketUncheckedCreateNestedManyWithoutAssignedToInput
    ticketMsgs?: TicketMessageUncheckedCreateNestedManyWithoutAuthorInput
    ticketParticipants?: TicketParticipantUncheckedCreateNestedManyWithoutUserInput
    ticketParticipantsAdded?: TicketParticipantUncheckedCreateNestedManyWithoutAddedByInput
    ticketRatingsGiven?: TicketRatingUncheckedCreateNestedManyWithoutRaterInput
    ticketRatingsReceived?: TicketRatingUncheckedCreateNestedManyWithoutTargetInput
    closedTickets?: TicketUncheckedCreateNestedManyWithoutClosedByInput
    purchases?: PurchaseUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    whitelistApps?: WhitelistApplicationUncheckedCreateNestedManyWithoutUserInput
    reviewedWhitelists?: WhitelistApplicationUncheckedCreateNestedManyWithoutReviewerInput
    convoParts?: ConversationParticipantUncheckedCreateNestedManyWithoutUserInput
    receivedMessages?: DirectMessageUncheckedCreateNestedManyWithoutReceiverInput
    userBadges?: UserBadgeUncheckedCreateNestedManyWithoutUserInput
    gameAccounts?: GameAccountUncheckedCreateNestedManyWithoutUserInput
    mtaAccessLogs?: MtaAccessLogUncheckedCreateNestedManyWithoutUserInput
    ticketRatingReqGiven?: TicketRatingRequirementUncheckedCreateNestedManyWithoutRaterInput
    ticketRatingReqReceived?: TicketRatingRequirementUncheckedCreateNestedManyWithoutTargetInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    entitlements?: EntitlementUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    staffShifts?: StaffShiftUncheckedCreateNestedManyWithoutUserInput
    staffWeeklyRewards?: StaffWeeklyRewardUncheckedCreateNestedManyWithoutUserInput
    adminCasesTarget?: AdminCaseUncheckedCreateNestedManyWithoutTargetUserInput
    adminCasesStaff?: AdminCaseUncheckedCreateNestedManyWithoutStaffUserInput
    reputation?: UserReputationUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSentMessagesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSentMessagesInput, UserUncheckedCreateWithoutSentMessagesInput>
  }

  export type UserCreateWithoutReceivedMessagesInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    emailVerifiedAt?: Date | string | null
    emailVerifyToken?: string | null
    emailVerifyExpiresAt?: Date | string | null
    phone?: string | null
    recoveryEmail?: string | null
    googleId?: string | null
    discordId?: string | null
    discordUsername?: string | null
    avatarKey?: string
    role?: string
    isDeleted?: boolean
    bannedUntil?: Date | string | null
    whitelistStatus?: string
    points?: number
    lastSeenAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    avatarUrl?: string | null
    topics?: TopicCreateNestedManyWithoutAuthorInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    tickets?: TicketCreateNestedManyWithoutAuthorInput
    assignedTickets?: TicketCreateNestedManyWithoutAssignedToInput
    ticketMsgs?: TicketMessageCreateNestedManyWithoutAuthorInput
    ticketParticipants?: TicketParticipantCreateNestedManyWithoutUserInput
    ticketParticipantsAdded?: TicketParticipantCreateNestedManyWithoutAddedByInput
    ticketRatingsGiven?: TicketRatingCreateNestedManyWithoutRaterInput
    ticketRatingsReceived?: TicketRatingCreateNestedManyWithoutTargetInput
    closedTickets?: TicketCreateNestedManyWithoutClosedByInput
    purchases?: PurchaseCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    whitelistApps?: WhitelistApplicationCreateNestedManyWithoutUserInput
    reviewedWhitelists?: WhitelistApplicationCreateNestedManyWithoutReviewerInput
    convoParts?: ConversationParticipantCreateNestedManyWithoutUserInput
    sentMessages?: DirectMessageCreateNestedManyWithoutSenderInput
    userBadges?: UserBadgeCreateNestedManyWithoutUserInput
    gameAccounts?: GameAccountCreateNestedManyWithoutUserInput
    mtaAccessLogs?: MtaAccessLogCreateNestedManyWithoutUserInput
    ticketRatingReqGiven?: TicketRatingRequirementCreateNestedManyWithoutRaterInput
    ticketRatingReqReceived?: TicketRatingRequirementCreateNestedManyWithoutTargetInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    entitlements?: EntitlementCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    staffShifts?: StaffShiftCreateNestedManyWithoutUserInput
    staffWeeklyRewards?: StaffWeeklyRewardCreateNestedManyWithoutUserInput
    adminCasesTarget?: AdminCaseCreateNestedManyWithoutTargetUserInput
    adminCasesStaff?: AdminCaseCreateNestedManyWithoutStaffUserInput
    reputation?: UserReputationCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutReceivedMessagesInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    emailVerifiedAt?: Date | string | null
    emailVerifyToken?: string | null
    emailVerifyExpiresAt?: Date | string | null
    phone?: string | null
    recoveryEmail?: string | null
    googleId?: string | null
    discordId?: string | null
    discordUsername?: string | null
    avatarKey?: string
    role?: string
    isDeleted?: boolean
    bannedUntil?: Date | string | null
    whitelistStatus?: string
    points?: number
    lastSeenAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    avatarUrl?: string | null
    topics?: TopicUncheckedCreateNestedManyWithoutAuthorInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    tickets?: TicketUncheckedCreateNestedManyWithoutAuthorInput
    assignedTickets?: TicketUncheckedCreateNestedManyWithoutAssignedToInput
    ticketMsgs?: TicketMessageUncheckedCreateNestedManyWithoutAuthorInput
    ticketParticipants?: TicketParticipantUncheckedCreateNestedManyWithoutUserInput
    ticketParticipantsAdded?: TicketParticipantUncheckedCreateNestedManyWithoutAddedByInput
    ticketRatingsGiven?: TicketRatingUncheckedCreateNestedManyWithoutRaterInput
    ticketRatingsReceived?: TicketRatingUncheckedCreateNestedManyWithoutTargetInput
    closedTickets?: TicketUncheckedCreateNestedManyWithoutClosedByInput
    purchases?: PurchaseUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    whitelistApps?: WhitelistApplicationUncheckedCreateNestedManyWithoutUserInput
    reviewedWhitelists?: WhitelistApplicationUncheckedCreateNestedManyWithoutReviewerInput
    convoParts?: ConversationParticipantUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: DirectMessageUncheckedCreateNestedManyWithoutSenderInput
    userBadges?: UserBadgeUncheckedCreateNestedManyWithoutUserInput
    gameAccounts?: GameAccountUncheckedCreateNestedManyWithoutUserInput
    mtaAccessLogs?: MtaAccessLogUncheckedCreateNestedManyWithoutUserInput
    ticketRatingReqGiven?: TicketRatingRequirementUncheckedCreateNestedManyWithoutRaterInput
    ticketRatingReqReceived?: TicketRatingRequirementUncheckedCreateNestedManyWithoutTargetInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    entitlements?: EntitlementUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    staffShifts?: StaffShiftUncheckedCreateNestedManyWithoutUserInput
    staffWeeklyRewards?: StaffWeeklyRewardUncheckedCreateNestedManyWithoutUserInput
    adminCasesTarget?: AdminCaseUncheckedCreateNestedManyWithoutTargetUserInput
    adminCasesStaff?: AdminCaseUncheckedCreateNestedManyWithoutStaffUserInput
    reputation?: UserReputationUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutReceivedMessagesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReceivedMessagesInput, UserUncheckedCreateWithoutReceivedMessagesInput>
  }

  export type ConversationUpsertWithoutMessagesInput = {
    update: XOR<ConversationUpdateWithoutMessagesInput, ConversationUncheckedUpdateWithoutMessagesInput>
    create: XOR<ConversationCreateWithoutMessagesInput, ConversationUncheckedCreateWithoutMessagesInput>
    where?: ConversationWhereInput
  }

  export type ConversationUpdateToOneWithWhereWithoutMessagesInput = {
    where?: ConversationWhereInput
    data: XOR<ConversationUpdateWithoutMessagesInput, ConversationUncheckedUpdateWithoutMessagesInput>
  }

  export type ConversationUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participants?: ConversationParticipantUpdateManyWithoutConversationNestedInput
  }

  export type ConversationUncheckedUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participants?: ConversationParticipantUncheckedUpdateManyWithoutConversationNestedInput
  }

  export type UserUpsertWithoutSentMessagesInput = {
    update: XOR<UserUpdateWithoutSentMessagesInput, UserUncheckedUpdateWithoutSentMessagesInput>
    create: XOR<UserCreateWithoutSentMessagesInput, UserUncheckedCreateWithoutSentMessagesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSentMessagesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSentMessagesInput, UserUncheckedUpdateWithoutSentMessagesInput>
  }

  export type UserUpdateWithoutSentMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifyToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerifyExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    discordId?: NullableStringFieldUpdateOperationsInput | string | null
    discordUsername?: NullableStringFieldUpdateOperationsInput | string | null
    avatarKey?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    bannedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    whitelistStatus?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    lastSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    topics?: TopicUpdateManyWithoutAuthorNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    tickets?: TicketUpdateManyWithoutAuthorNestedInput
    assignedTickets?: TicketUpdateManyWithoutAssignedToNestedInput
    ticketMsgs?: TicketMessageUpdateManyWithoutAuthorNestedInput
    ticketParticipants?: TicketParticipantUpdateManyWithoutUserNestedInput
    ticketParticipantsAdded?: TicketParticipantUpdateManyWithoutAddedByNestedInput
    ticketRatingsGiven?: TicketRatingUpdateManyWithoutRaterNestedInput
    ticketRatingsReceived?: TicketRatingUpdateManyWithoutTargetNestedInput
    closedTickets?: TicketUpdateManyWithoutClosedByNestedInput
    purchases?: PurchaseUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    whitelistApps?: WhitelistApplicationUpdateManyWithoutUserNestedInput
    reviewedWhitelists?: WhitelistApplicationUpdateManyWithoutReviewerNestedInput
    convoParts?: ConversationParticipantUpdateManyWithoutUserNestedInput
    receivedMessages?: DirectMessageUpdateManyWithoutReceiverNestedInput
    userBadges?: UserBadgeUpdateManyWithoutUserNestedInput
    gameAccounts?: GameAccountUpdateManyWithoutUserNestedInput
    mtaAccessLogs?: MtaAccessLogUpdateManyWithoutUserNestedInput
    ticketRatingReqGiven?: TicketRatingRequirementUpdateManyWithoutRaterNestedInput
    ticketRatingReqReceived?: TicketRatingRequirementUpdateManyWithoutTargetNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    entitlements?: EntitlementUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    staffShifts?: StaffShiftUpdateManyWithoutUserNestedInput
    staffWeeklyRewards?: StaffWeeklyRewardUpdateManyWithoutUserNestedInput
    adminCasesTarget?: AdminCaseUpdateManyWithoutTargetUserNestedInput
    adminCasesStaff?: AdminCaseUpdateManyWithoutStaffUserNestedInput
    reputation?: UserReputationUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSentMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifyToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerifyExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    discordId?: NullableStringFieldUpdateOperationsInput | string | null
    discordUsername?: NullableStringFieldUpdateOperationsInput | string | null
    avatarKey?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    bannedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    whitelistStatus?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    lastSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    topics?: TopicUncheckedUpdateManyWithoutAuthorNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutAuthorNestedInput
    assignedTickets?: TicketUncheckedUpdateManyWithoutAssignedToNestedInput
    ticketMsgs?: TicketMessageUncheckedUpdateManyWithoutAuthorNestedInput
    ticketParticipants?: TicketParticipantUncheckedUpdateManyWithoutUserNestedInput
    ticketParticipantsAdded?: TicketParticipantUncheckedUpdateManyWithoutAddedByNestedInput
    ticketRatingsGiven?: TicketRatingUncheckedUpdateManyWithoutRaterNestedInput
    ticketRatingsReceived?: TicketRatingUncheckedUpdateManyWithoutTargetNestedInput
    closedTickets?: TicketUncheckedUpdateManyWithoutClosedByNestedInput
    purchases?: PurchaseUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    whitelistApps?: WhitelistApplicationUncheckedUpdateManyWithoutUserNestedInput
    reviewedWhitelists?: WhitelistApplicationUncheckedUpdateManyWithoutReviewerNestedInput
    convoParts?: ConversationParticipantUncheckedUpdateManyWithoutUserNestedInput
    receivedMessages?: DirectMessageUncheckedUpdateManyWithoutReceiverNestedInput
    userBadges?: UserBadgeUncheckedUpdateManyWithoutUserNestedInput
    gameAccounts?: GameAccountUncheckedUpdateManyWithoutUserNestedInput
    mtaAccessLogs?: MtaAccessLogUncheckedUpdateManyWithoutUserNestedInput
    ticketRatingReqGiven?: TicketRatingRequirementUncheckedUpdateManyWithoutRaterNestedInput
    ticketRatingReqReceived?: TicketRatingRequirementUncheckedUpdateManyWithoutTargetNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    entitlements?: EntitlementUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    staffShifts?: StaffShiftUncheckedUpdateManyWithoutUserNestedInput
    staffWeeklyRewards?: StaffWeeklyRewardUncheckedUpdateManyWithoutUserNestedInput
    adminCasesTarget?: AdminCaseUncheckedUpdateManyWithoutTargetUserNestedInput
    adminCasesStaff?: AdminCaseUncheckedUpdateManyWithoutStaffUserNestedInput
    reputation?: UserReputationUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserUpsertWithoutReceivedMessagesInput = {
    update: XOR<UserUpdateWithoutReceivedMessagesInput, UserUncheckedUpdateWithoutReceivedMessagesInput>
    create: XOR<UserCreateWithoutReceivedMessagesInput, UserUncheckedCreateWithoutReceivedMessagesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReceivedMessagesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReceivedMessagesInput, UserUncheckedUpdateWithoutReceivedMessagesInput>
  }

  export type UserUpdateWithoutReceivedMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifyToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerifyExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    discordId?: NullableStringFieldUpdateOperationsInput | string | null
    discordUsername?: NullableStringFieldUpdateOperationsInput | string | null
    avatarKey?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    bannedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    whitelistStatus?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    lastSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    topics?: TopicUpdateManyWithoutAuthorNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    tickets?: TicketUpdateManyWithoutAuthorNestedInput
    assignedTickets?: TicketUpdateManyWithoutAssignedToNestedInput
    ticketMsgs?: TicketMessageUpdateManyWithoutAuthorNestedInput
    ticketParticipants?: TicketParticipantUpdateManyWithoutUserNestedInput
    ticketParticipantsAdded?: TicketParticipantUpdateManyWithoutAddedByNestedInput
    ticketRatingsGiven?: TicketRatingUpdateManyWithoutRaterNestedInput
    ticketRatingsReceived?: TicketRatingUpdateManyWithoutTargetNestedInput
    closedTickets?: TicketUpdateManyWithoutClosedByNestedInput
    purchases?: PurchaseUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    whitelistApps?: WhitelistApplicationUpdateManyWithoutUserNestedInput
    reviewedWhitelists?: WhitelistApplicationUpdateManyWithoutReviewerNestedInput
    convoParts?: ConversationParticipantUpdateManyWithoutUserNestedInput
    sentMessages?: DirectMessageUpdateManyWithoutSenderNestedInput
    userBadges?: UserBadgeUpdateManyWithoutUserNestedInput
    gameAccounts?: GameAccountUpdateManyWithoutUserNestedInput
    mtaAccessLogs?: MtaAccessLogUpdateManyWithoutUserNestedInput
    ticketRatingReqGiven?: TicketRatingRequirementUpdateManyWithoutRaterNestedInput
    ticketRatingReqReceived?: TicketRatingRequirementUpdateManyWithoutTargetNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    entitlements?: EntitlementUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    staffShifts?: StaffShiftUpdateManyWithoutUserNestedInput
    staffWeeklyRewards?: StaffWeeklyRewardUpdateManyWithoutUserNestedInput
    adminCasesTarget?: AdminCaseUpdateManyWithoutTargetUserNestedInput
    adminCasesStaff?: AdminCaseUpdateManyWithoutStaffUserNestedInput
    reputation?: UserReputationUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutReceivedMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifyToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerifyExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    discordId?: NullableStringFieldUpdateOperationsInput | string | null
    discordUsername?: NullableStringFieldUpdateOperationsInput | string | null
    avatarKey?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    bannedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    whitelistStatus?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    lastSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    topics?: TopicUncheckedUpdateManyWithoutAuthorNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutAuthorNestedInput
    assignedTickets?: TicketUncheckedUpdateManyWithoutAssignedToNestedInput
    ticketMsgs?: TicketMessageUncheckedUpdateManyWithoutAuthorNestedInput
    ticketParticipants?: TicketParticipantUncheckedUpdateManyWithoutUserNestedInput
    ticketParticipantsAdded?: TicketParticipantUncheckedUpdateManyWithoutAddedByNestedInput
    ticketRatingsGiven?: TicketRatingUncheckedUpdateManyWithoutRaterNestedInput
    ticketRatingsReceived?: TicketRatingUncheckedUpdateManyWithoutTargetNestedInput
    closedTickets?: TicketUncheckedUpdateManyWithoutClosedByNestedInput
    purchases?: PurchaseUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    whitelistApps?: WhitelistApplicationUncheckedUpdateManyWithoutUserNestedInput
    reviewedWhitelists?: WhitelistApplicationUncheckedUpdateManyWithoutReviewerNestedInput
    convoParts?: ConversationParticipantUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: DirectMessageUncheckedUpdateManyWithoutSenderNestedInput
    userBadges?: UserBadgeUncheckedUpdateManyWithoutUserNestedInput
    gameAccounts?: GameAccountUncheckedUpdateManyWithoutUserNestedInput
    mtaAccessLogs?: MtaAccessLogUncheckedUpdateManyWithoutUserNestedInput
    ticketRatingReqGiven?: TicketRatingRequirementUncheckedUpdateManyWithoutRaterNestedInput
    ticketRatingReqReceived?: TicketRatingRequirementUncheckedUpdateManyWithoutTargetNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    entitlements?: EntitlementUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    staffShifts?: StaffShiftUncheckedUpdateManyWithoutUserNestedInput
    staffWeeklyRewards?: StaffWeeklyRewardUncheckedUpdateManyWithoutUserNestedInput
    adminCasesTarget?: AdminCaseUncheckedUpdateManyWithoutTargetUserNestedInput
    adminCasesStaff?: AdminCaseUncheckedUpdateManyWithoutStaffUserNestedInput
    reputation?: UserReputationUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserCreateWithoutGameAccountsInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    emailVerifiedAt?: Date | string | null
    emailVerifyToken?: string | null
    emailVerifyExpiresAt?: Date | string | null
    phone?: string | null
    recoveryEmail?: string | null
    googleId?: string | null
    discordId?: string | null
    discordUsername?: string | null
    avatarKey?: string
    role?: string
    isDeleted?: boolean
    bannedUntil?: Date | string | null
    whitelistStatus?: string
    points?: number
    lastSeenAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    avatarUrl?: string | null
    topics?: TopicCreateNestedManyWithoutAuthorInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    tickets?: TicketCreateNestedManyWithoutAuthorInput
    assignedTickets?: TicketCreateNestedManyWithoutAssignedToInput
    ticketMsgs?: TicketMessageCreateNestedManyWithoutAuthorInput
    ticketParticipants?: TicketParticipantCreateNestedManyWithoutUserInput
    ticketParticipantsAdded?: TicketParticipantCreateNestedManyWithoutAddedByInput
    ticketRatingsGiven?: TicketRatingCreateNestedManyWithoutRaterInput
    ticketRatingsReceived?: TicketRatingCreateNestedManyWithoutTargetInput
    closedTickets?: TicketCreateNestedManyWithoutClosedByInput
    purchases?: PurchaseCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    whitelistApps?: WhitelistApplicationCreateNestedManyWithoutUserInput
    reviewedWhitelists?: WhitelistApplicationCreateNestedManyWithoutReviewerInput
    convoParts?: ConversationParticipantCreateNestedManyWithoutUserInput
    sentMessages?: DirectMessageCreateNestedManyWithoutSenderInput
    receivedMessages?: DirectMessageCreateNestedManyWithoutReceiverInput
    userBadges?: UserBadgeCreateNestedManyWithoutUserInput
    mtaAccessLogs?: MtaAccessLogCreateNestedManyWithoutUserInput
    ticketRatingReqGiven?: TicketRatingRequirementCreateNestedManyWithoutRaterInput
    ticketRatingReqReceived?: TicketRatingRequirementCreateNestedManyWithoutTargetInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    entitlements?: EntitlementCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    staffShifts?: StaffShiftCreateNestedManyWithoutUserInput
    staffWeeklyRewards?: StaffWeeklyRewardCreateNestedManyWithoutUserInput
    adminCasesTarget?: AdminCaseCreateNestedManyWithoutTargetUserInput
    adminCasesStaff?: AdminCaseCreateNestedManyWithoutStaffUserInput
    reputation?: UserReputationCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutGameAccountsInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    emailVerifiedAt?: Date | string | null
    emailVerifyToken?: string | null
    emailVerifyExpiresAt?: Date | string | null
    phone?: string | null
    recoveryEmail?: string | null
    googleId?: string | null
    discordId?: string | null
    discordUsername?: string | null
    avatarKey?: string
    role?: string
    isDeleted?: boolean
    bannedUntil?: Date | string | null
    whitelistStatus?: string
    points?: number
    lastSeenAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    avatarUrl?: string | null
    topics?: TopicUncheckedCreateNestedManyWithoutAuthorInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    tickets?: TicketUncheckedCreateNestedManyWithoutAuthorInput
    assignedTickets?: TicketUncheckedCreateNestedManyWithoutAssignedToInput
    ticketMsgs?: TicketMessageUncheckedCreateNestedManyWithoutAuthorInput
    ticketParticipants?: TicketParticipantUncheckedCreateNestedManyWithoutUserInput
    ticketParticipantsAdded?: TicketParticipantUncheckedCreateNestedManyWithoutAddedByInput
    ticketRatingsGiven?: TicketRatingUncheckedCreateNestedManyWithoutRaterInput
    ticketRatingsReceived?: TicketRatingUncheckedCreateNestedManyWithoutTargetInput
    closedTickets?: TicketUncheckedCreateNestedManyWithoutClosedByInput
    purchases?: PurchaseUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    whitelistApps?: WhitelistApplicationUncheckedCreateNestedManyWithoutUserInput
    reviewedWhitelists?: WhitelistApplicationUncheckedCreateNestedManyWithoutReviewerInput
    convoParts?: ConversationParticipantUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: DirectMessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: DirectMessageUncheckedCreateNestedManyWithoutReceiverInput
    userBadges?: UserBadgeUncheckedCreateNestedManyWithoutUserInput
    mtaAccessLogs?: MtaAccessLogUncheckedCreateNestedManyWithoutUserInput
    ticketRatingReqGiven?: TicketRatingRequirementUncheckedCreateNestedManyWithoutRaterInput
    ticketRatingReqReceived?: TicketRatingRequirementUncheckedCreateNestedManyWithoutTargetInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    entitlements?: EntitlementUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    staffShifts?: StaffShiftUncheckedCreateNestedManyWithoutUserInput
    staffWeeklyRewards?: StaffWeeklyRewardUncheckedCreateNestedManyWithoutUserInput
    adminCasesTarget?: AdminCaseUncheckedCreateNestedManyWithoutTargetUserInput
    adminCasesStaff?: AdminCaseUncheckedCreateNestedManyWithoutStaffUserInput
    reputation?: UserReputationUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutGameAccountsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutGameAccountsInput, UserUncheckedCreateWithoutGameAccountsInput>
  }

  export type UserUpsertWithoutGameAccountsInput = {
    update: XOR<UserUpdateWithoutGameAccountsInput, UserUncheckedUpdateWithoutGameAccountsInput>
    create: XOR<UserCreateWithoutGameAccountsInput, UserUncheckedCreateWithoutGameAccountsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutGameAccountsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutGameAccountsInput, UserUncheckedUpdateWithoutGameAccountsInput>
  }

  export type UserUpdateWithoutGameAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifyToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerifyExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    discordId?: NullableStringFieldUpdateOperationsInput | string | null
    discordUsername?: NullableStringFieldUpdateOperationsInput | string | null
    avatarKey?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    bannedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    whitelistStatus?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    lastSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    topics?: TopicUpdateManyWithoutAuthorNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    tickets?: TicketUpdateManyWithoutAuthorNestedInput
    assignedTickets?: TicketUpdateManyWithoutAssignedToNestedInput
    ticketMsgs?: TicketMessageUpdateManyWithoutAuthorNestedInput
    ticketParticipants?: TicketParticipantUpdateManyWithoutUserNestedInput
    ticketParticipantsAdded?: TicketParticipantUpdateManyWithoutAddedByNestedInput
    ticketRatingsGiven?: TicketRatingUpdateManyWithoutRaterNestedInput
    ticketRatingsReceived?: TicketRatingUpdateManyWithoutTargetNestedInput
    closedTickets?: TicketUpdateManyWithoutClosedByNestedInput
    purchases?: PurchaseUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    whitelistApps?: WhitelistApplicationUpdateManyWithoutUserNestedInput
    reviewedWhitelists?: WhitelistApplicationUpdateManyWithoutReviewerNestedInput
    convoParts?: ConversationParticipantUpdateManyWithoutUserNestedInput
    sentMessages?: DirectMessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: DirectMessageUpdateManyWithoutReceiverNestedInput
    userBadges?: UserBadgeUpdateManyWithoutUserNestedInput
    mtaAccessLogs?: MtaAccessLogUpdateManyWithoutUserNestedInput
    ticketRatingReqGiven?: TicketRatingRequirementUpdateManyWithoutRaterNestedInput
    ticketRatingReqReceived?: TicketRatingRequirementUpdateManyWithoutTargetNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    entitlements?: EntitlementUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    staffShifts?: StaffShiftUpdateManyWithoutUserNestedInput
    staffWeeklyRewards?: StaffWeeklyRewardUpdateManyWithoutUserNestedInput
    adminCasesTarget?: AdminCaseUpdateManyWithoutTargetUserNestedInput
    adminCasesStaff?: AdminCaseUpdateManyWithoutStaffUserNestedInput
    reputation?: UserReputationUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutGameAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifyToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerifyExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    discordId?: NullableStringFieldUpdateOperationsInput | string | null
    discordUsername?: NullableStringFieldUpdateOperationsInput | string | null
    avatarKey?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    bannedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    whitelistStatus?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    lastSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    topics?: TopicUncheckedUpdateManyWithoutAuthorNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutAuthorNestedInput
    assignedTickets?: TicketUncheckedUpdateManyWithoutAssignedToNestedInput
    ticketMsgs?: TicketMessageUncheckedUpdateManyWithoutAuthorNestedInput
    ticketParticipants?: TicketParticipantUncheckedUpdateManyWithoutUserNestedInput
    ticketParticipantsAdded?: TicketParticipantUncheckedUpdateManyWithoutAddedByNestedInput
    ticketRatingsGiven?: TicketRatingUncheckedUpdateManyWithoutRaterNestedInput
    ticketRatingsReceived?: TicketRatingUncheckedUpdateManyWithoutTargetNestedInput
    closedTickets?: TicketUncheckedUpdateManyWithoutClosedByNestedInput
    purchases?: PurchaseUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    whitelistApps?: WhitelistApplicationUncheckedUpdateManyWithoutUserNestedInput
    reviewedWhitelists?: WhitelistApplicationUncheckedUpdateManyWithoutReviewerNestedInput
    convoParts?: ConversationParticipantUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: DirectMessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: DirectMessageUncheckedUpdateManyWithoutReceiverNestedInput
    userBadges?: UserBadgeUncheckedUpdateManyWithoutUserNestedInput
    mtaAccessLogs?: MtaAccessLogUncheckedUpdateManyWithoutUserNestedInput
    ticketRatingReqGiven?: TicketRatingRequirementUncheckedUpdateManyWithoutRaterNestedInput
    ticketRatingReqReceived?: TicketRatingRequirementUncheckedUpdateManyWithoutTargetNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    entitlements?: EntitlementUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    staffShifts?: StaffShiftUncheckedUpdateManyWithoutUserNestedInput
    staffWeeklyRewards?: StaffWeeklyRewardUncheckedUpdateManyWithoutUserNestedInput
    adminCasesTarget?: AdminCaseUncheckedUpdateManyWithoutTargetUserNestedInput
    adminCasesStaff?: AdminCaseUncheckedUpdateManyWithoutStaffUserNestedInput
    reputation?: UserReputationUncheckedUpdateOneWithoutUserNestedInput
  }

  export type TicketCreateWithoutParticipantsInput = {
    id?: string
    title: string
    status?: string
    priority?: string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    closedAt?: Date | string | null
    category: TicketCategoryCreateNestedOneWithoutTicketsInput
    author: UserCreateNestedOneWithoutTicketsInput
    assignedTo?: UserCreateNestedOneWithoutAssignedTicketsInput
    closedBy?: UserCreateNestedOneWithoutClosedTicketsInput
    messages?: TicketMessageCreateNestedManyWithoutTicketInput
    ratings?: TicketRatingCreateNestedManyWithoutTicketInput
    ratingRequirements?: TicketRatingRequirementCreateNestedManyWithoutTicketInput
  }

  export type TicketUncheckedCreateWithoutParticipantsInput = {
    id?: string
    categoryId: string
    authorId: string
    title: string
    status?: string
    priority?: string
    assignedToId?: string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    closedAt?: Date | string | null
    closedById?: string | null
    messages?: TicketMessageUncheckedCreateNestedManyWithoutTicketInput
    ratings?: TicketRatingUncheckedCreateNestedManyWithoutTicketInput
    ratingRequirements?: TicketRatingRequirementUncheckedCreateNestedManyWithoutTicketInput
  }

  export type TicketCreateOrConnectWithoutParticipantsInput = {
    where: TicketWhereUniqueInput
    create: XOR<TicketCreateWithoutParticipantsInput, TicketUncheckedCreateWithoutParticipantsInput>
  }

  export type UserCreateWithoutTicketParticipantsInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    emailVerifiedAt?: Date | string | null
    emailVerifyToken?: string | null
    emailVerifyExpiresAt?: Date | string | null
    phone?: string | null
    recoveryEmail?: string | null
    googleId?: string | null
    discordId?: string | null
    discordUsername?: string | null
    avatarKey?: string
    role?: string
    isDeleted?: boolean
    bannedUntil?: Date | string | null
    whitelistStatus?: string
    points?: number
    lastSeenAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    avatarUrl?: string | null
    topics?: TopicCreateNestedManyWithoutAuthorInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    tickets?: TicketCreateNestedManyWithoutAuthorInput
    assignedTickets?: TicketCreateNestedManyWithoutAssignedToInput
    ticketMsgs?: TicketMessageCreateNestedManyWithoutAuthorInput
    ticketParticipantsAdded?: TicketParticipantCreateNestedManyWithoutAddedByInput
    ticketRatingsGiven?: TicketRatingCreateNestedManyWithoutRaterInput
    ticketRatingsReceived?: TicketRatingCreateNestedManyWithoutTargetInput
    closedTickets?: TicketCreateNestedManyWithoutClosedByInput
    purchases?: PurchaseCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    whitelistApps?: WhitelistApplicationCreateNestedManyWithoutUserInput
    reviewedWhitelists?: WhitelistApplicationCreateNestedManyWithoutReviewerInput
    convoParts?: ConversationParticipantCreateNestedManyWithoutUserInput
    sentMessages?: DirectMessageCreateNestedManyWithoutSenderInput
    receivedMessages?: DirectMessageCreateNestedManyWithoutReceiverInput
    userBadges?: UserBadgeCreateNestedManyWithoutUserInput
    gameAccounts?: GameAccountCreateNestedManyWithoutUserInput
    mtaAccessLogs?: MtaAccessLogCreateNestedManyWithoutUserInput
    ticketRatingReqGiven?: TicketRatingRequirementCreateNestedManyWithoutRaterInput
    ticketRatingReqReceived?: TicketRatingRequirementCreateNestedManyWithoutTargetInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    entitlements?: EntitlementCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    staffShifts?: StaffShiftCreateNestedManyWithoutUserInput
    staffWeeklyRewards?: StaffWeeklyRewardCreateNestedManyWithoutUserInput
    adminCasesTarget?: AdminCaseCreateNestedManyWithoutTargetUserInput
    adminCasesStaff?: AdminCaseCreateNestedManyWithoutStaffUserInput
    reputation?: UserReputationCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTicketParticipantsInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    emailVerifiedAt?: Date | string | null
    emailVerifyToken?: string | null
    emailVerifyExpiresAt?: Date | string | null
    phone?: string | null
    recoveryEmail?: string | null
    googleId?: string | null
    discordId?: string | null
    discordUsername?: string | null
    avatarKey?: string
    role?: string
    isDeleted?: boolean
    bannedUntil?: Date | string | null
    whitelistStatus?: string
    points?: number
    lastSeenAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    avatarUrl?: string | null
    topics?: TopicUncheckedCreateNestedManyWithoutAuthorInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    tickets?: TicketUncheckedCreateNestedManyWithoutAuthorInput
    assignedTickets?: TicketUncheckedCreateNestedManyWithoutAssignedToInput
    ticketMsgs?: TicketMessageUncheckedCreateNestedManyWithoutAuthorInput
    ticketParticipantsAdded?: TicketParticipantUncheckedCreateNestedManyWithoutAddedByInput
    ticketRatingsGiven?: TicketRatingUncheckedCreateNestedManyWithoutRaterInput
    ticketRatingsReceived?: TicketRatingUncheckedCreateNestedManyWithoutTargetInput
    closedTickets?: TicketUncheckedCreateNestedManyWithoutClosedByInput
    purchases?: PurchaseUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    whitelistApps?: WhitelistApplicationUncheckedCreateNestedManyWithoutUserInput
    reviewedWhitelists?: WhitelistApplicationUncheckedCreateNestedManyWithoutReviewerInput
    convoParts?: ConversationParticipantUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: DirectMessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: DirectMessageUncheckedCreateNestedManyWithoutReceiverInput
    userBadges?: UserBadgeUncheckedCreateNestedManyWithoutUserInput
    gameAccounts?: GameAccountUncheckedCreateNestedManyWithoutUserInput
    mtaAccessLogs?: MtaAccessLogUncheckedCreateNestedManyWithoutUserInput
    ticketRatingReqGiven?: TicketRatingRequirementUncheckedCreateNestedManyWithoutRaterInput
    ticketRatingReqReceived?: TicketRatingRequirementUncheckedCreateNestedManyWithoutTargetInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    entitlements?: EntitlementUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    staffShifts?: StaffShiftUncheckedCreateNestedManyWithoutUserInput
    staffWeeklyRewards?: StaffWeeklyRewardUncheckedCreateNestedManyWithoutUserInput
    adminCasesTarget?: AdminCaseUncheckedCreateNestedManyWithoutTargetUserInput
    adminCasesStaff?: AdminCaseUncheckedCreateNestedManyWithoutStaffUserInput
    reputation?: UserReputationUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTicketParticipantsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTicketParticipantsInput, UserUncheckedCreateWithoutTicketParticipantsInput>
  }

  export type UserCreateWithoutTicketParticipantsAddedInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    emailVerifiedAt?: Date | string | null
    emailVerifyToken?: string | null
    emailVerifyExpiresAt?: Date | string | null
    phone?: string | null
    recoveryEmail?: string | null
    googleId?: string | null
    discordId?: string | null
    discordUsername?: string | null
    avatarKey?: string
    role?: string
    isDeleted?: boolean
    bannedUntil?: Date | string | null
    whitelistStatus?: string
    points?: number
    lastSeenAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    avatarUrl?: string | null
    topics?: TopicCreateNestedManyWithoutAuthorInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    tickets?: TicketCreateNestedManyWithoutAuthorInput
    assignedTickets?: TicketCreateNestedManyWithoutAssignedToInput
    ticketMsgs?: TicketMessageCreateNestedManyWithoutAuthorInput
    ticketParticipants?: TicketParticipantCreateNestedManyWithoutUserInput
    ticketRatingsGiven?: TicketRatingCreateNestedManyWithoutRaterInput
    ticketRatingsReceived?: TicketRatingCreateNestedManyWithoutTargetInput
    closedTickets?: TicketCreateNestedManyWithoutClosedByInput
    purchases?: PurchaseCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    whitelistApps?: WhitelistApplicationCreateNestedManyWithoutUserInput
    reviewedWhitelists?: WhitelistApplicationCreateNestedManyWithoutReviewerInput
    convoParts?: ConversationParticipantCreateNestedManyWithoutUserInput
    sentMessages?: DirectMessageCreateNestedManyWithoutSenderInput
    receivedMessages?: DirectMessageCreateNestedManyWithoutReceiverInput
    userBadges?: UserBadgeCreateNestedManyWithoutUserInput
    gameAccounts?: GameAccountCreateNestedManyWithoutUserInput
    mtaAccessLogs?: MtaAccessLogCreateNestedManyWithoutUserInput
    ticketRatingReqGiven?: TicketRatingRequirementCreateNestedManyWithoutRaterInput
    ticketRatingReqReceived?: TicketRatingRequirementCreateNestedManyWithoutTargetInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    entitlements?: EntitlementCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    staffShifts?: StaffShiftCreateNestedManyWithoutUserInput
    staffWeeklyRewards?: StaffWeeklyRewardCreateNestedManyWithoutUserInput
    adminCasesTarget?: AdminCaseCreateNestedManyWithoutTargetUserInput
    adminCasesStaff?: AdminCaseCreateNestedManyWithoutStaffUserInput
    reputation?: UserReputationCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTicketParticipantsAddedInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    emailVerifiedAt?: Date | string | null
    emailVerifyToken?: string | null
    emailVerifyExpiresAt?: Date | string | null
    phone?: string | null
    recoveryEmail?: string | null
    googleId?: string | null
    discordId?: string | null
    discordUsername?: string | null
    avatarKey?: string
    role?: string
    isDeleted?: boolean
    bannedUntil?: Date | string | null
    whitelistStatus?: string
    points?: number
    lastSeenAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    avatarUrl?: string | null
    topics?: TopicUncheckedCreateNestedManyWithoutAuthorInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    tickets?: TicketUncheckedCreateNestedManyWithoutAuthorInput
    assignedTickets?: TicketUncheckedCreateNestedManyWithoutAssignedToInput
    ticketMsgs?: TicketMessageUncheckedCreateNestedManyWithoutAuthorInput
    ticketParticipants?: TicketParticipantUncheckedCreateNestedManyWithoutUserInput
    ticketRatingsGiven?: TicketRatingUncheckedCreateNestedManyWithoutRaterInput
    ticketRatingsReceived?: TicketRatingUncheckedCreateNestedManyWithoutTargetInput
    closedTickets?: TicketUncheckedCreateNestedManyWithoutClosedByInput
    purchases?: PurchaseUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    whitelistApps?: WhitelistApplicationUncheckedCreateNestedManyWithoutUserInput
    reviewedWhitelists?: WhitelistApplicationUncheckedCreateNestedManyWithoutReviewerInput
    convoParts?: ConversationParticipantUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: DirectMessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: DirectMessageUncheckedCreateNestedManyWithoutReceiverInput
    userBadges?: UserBadgeUncheckedCreateNestedManyWithoutUserInput
    gameAccounts?: GameAccountUncheckedCreateNestedManyWithoutUserInput
    mtaAccessLogs?: MtaAccessLogUncheckedCreateNestedManyWithoutUserInput
    ticketRatingReqGiven?: TicketRatingRequirementUncheckedCreateNestedManyWithoutRaterInput
    ticketRatingReqReceived?: TicketRatingRequirementUncheckedCreateNestedManyWithoutTargetInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    entitlements?: EntitlementUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    staffShifts?: StaffShiftUncheckedCreateNestedManyWithoutUserInput
    staffWeeklyRewards?: StaffWeeklyRewardUncheckedCreateNestedManyWithoutUserInput
    adminCasesTarget?: AdminCaseUncheckedCreateNestedManyWithoutTargetUserInput
    adminCasesStaff?: AdminCaseUncheckedCreateNestedManyWithoutStaffUserInput
    reputation?: UserReputationUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTicketParticipantsAddedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTicketParticipantsAddedInput, UserUncheckedCreateWithoutTicketParticipantsAddedInput>
  }

  export type TicketUpsertWithoutParticipantsInput = {
    update: XOR<TicketUpdateWithoutParticipantsInput, TicketUncheckedUpdateWithoutParticipantsInput>
    create: XOR<TicketCreateWithoutParticipantsInput, TicketUncheckedCreateWithoutParticipantsInput>
    where?: TicketWhereInput
  }

  export type TicketUpdateToOneWithWhereWithoutParticipantsInput = {
    where?: TicketWhereInput
    data: XOR<TicketUpdateWithoutParticipantsInput, TicketUncheckedUpdateWithoutParticipantsInput>
  }

  export type TicketUpdateWithoutParticipantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: TicketCategoryUpdateOneRequiredWithoutTicketsNestedInput
    author?: UserUpdateOneRequiredWithoutTicketsNestedInput
    assignedTo?: UserUpdateOneWithoutAssignedTicketsNestedInput
    closedBy?: UserUpdateOneWithoutClosedTicketsNestedInput
    messages?: TicketMessageUpdateManyWithoutTicketNestedInput
    ratings?: TicketRatingUpdateManyWithoutTicketNestedInput
    ratingRequirements?: TicketRatingRequirementUpdateManyWithoutTicketNestedInput
  }

  export type TicketUncheckedUpdateWithoutParticipantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedById?: NullableStringFieldUpdateOperationsInput | string | null
    messages?: TicketMessageUncheckedUpdateManyWithoutTicketNestedInput
    ratings?: TicketRatingUncheckedUpdateManyWithoutTicketNestedInput
    ratingRequirements?: TicketRatingRequirementUncheckedUpdateManyWithoutTicketNestedInput
  }

  export type UserUpsertWithoutTicketParticipantsInput = {
    update: XOR<UserUpdateWithoutTicketParticipantsInput, UserUncheckedUpdateWithoutTicketParticipantsInput>
    create: XOR<UserCreateWithoutTicketParticipantsInput, UserUncheckedCreateWithoutTicketParticipantsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTicketParticipantsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTicketParticipantsInput, UserUncheckedUpdateWithoutTicketParticipantsInput>
  }

  export type UserUpdateWithoutTicketParticipantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifyToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerifyExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    discordId?: NullableStringFieldUpdateOperationsInput | string | null
    discordUsername?: NullableStringFieldUpdateOperationsInput | string | null
    avatarKey?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    bannedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    whitelistStatus?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    lastSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    topics?: TopicUpdateManyWithoutAuthorNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    tickets?: TicketUpdateManyWithoutAuthorNestedInput
    assignedTickets?: TicketUpdateManyWithoutAssignedToNestedInput
    ticketMsgs?: TicketMessageUpdateManyWithoutAuthorNestedInput
    ticketParticipantsAdded?: TicketParticipantUpdateManyWithoutAddedByNestedInput
    ticketRatingsGiven?: TicketRatingUpdateManyWithoutRaterNestedInput
    ticketRatingsReceived?: TicketRatingUpdateManyWithoutTargetNestedInput
    closedTickets?: TicketUpdateManyWithoutClosedByNestedInput
    purchases?: PurchaseUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    whitelistApps?: WhitelistApplicationUpdateManyWithoutUserNestedInput
    reviewedWhitelists?: WhitelistApplicationUpdateManyWithoutReviewerNestedInput
    convoParts?: ConversationParticipantUpdateManyWithoutUserNestedInput
    sentMessages?: DirectMessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: DirectMessageUpdateManyWithoutReceiverNestedInput
    userBadges?: UserBadgeUpdateManyWithoutUserNestedInput
    gameAccounts?: GameAccountUpdateManyWithoutUserNestedInput
    mtaAccessLogs?: MtaAccessLogUpdateManyWithoutUserNestedInput
    ticketRatingReqGiven?: TicketRatingRequirementUpdateManyWithoutRaterNestedInput
    ticketRatingReqReceived?: TicketRatingRequirementUpdateManyWithoutTargetNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    entitlements?: EntitlementUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    staffShifts?: StaffShiftUpdateManyWithoutUserNestedInput
    staffWeeklyRewards?: StaffWeeklyRewardUpdateManyWithoutUserNestedInput
    adminCasesTarget?: AdminCaseUpdateManyWithoutTargetUserNestedInput
    adminCasesStaff?: AdminCaseUpdateManyWithoutStaffUserNestedInput
    reputation?: UserReputationUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTicketParticipantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifyToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerifyExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    discordId?: NullableStringFieldUpdateOperationsInput | string | null
    discordUsername?: NullableStringFieldUpdateOperationsInput | string | null
    avatarKey?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    bannedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    whitelistStatus?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    lastSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    topics?: TopicUncheckedUpdateManyWithoutAuthorNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutAuthorNestedInput
    assignedTickets?: TicketUncheckedUpdateManyWithoutAssignedToNestedInput
    ticketMsgs?: TicketMessageUncheckedUpdateManyWithoutAuthorNestedInput
    ticketParticipantsAdded?: TicketParticipantUncheckedUpdateManyWithoutAddedByNestedInput
    ticketRatingsGiven?: TicketRatingUncheckedUpdateManyWithoutRaterNestedInput
    ticketRatingsReceived?: TicketRatingUncheckedUpdateManyWithoutTargetNestedInput
    closedTickets?: TicketUncheckedUpdateManyWithoutClosedByNestedInput
    purchases?: PurchaseUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    whitelistApps?: WhitelistApplicationUncheckedUpdateManyWithoutUserNestedInput
    reviewedWhitelists?: WhitelistApplicationUncheckedUpdateManyWithoutReviewerNestedInput
    convoParts?: ConversationParticipantUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: DirectMessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: DirectMessageUncheckedUpdateManyWithoutReceiverNestedInput
    userBadges?: UserBadgeUncheckedUpdateManyWithoutUserNestedInput
    gameAccounts?: GameAccountUncheckedUpdateManyWithoutUserNestedInput
    mtaAccessLogs?: MtaAccessLogUncheckedUpdateManyWithoutUserNestedInput
    ticketRatingReqGiven?: TicketRatingRequirementUncheckedUpdateManyWithoutRaterNestedInput
    ticketRatingReqReceived?: TicketRatingRequirementUncheckedUpdateManyWithoutTargetNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    entitlements?: EntitlementUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    staffShifts?: StaffShiftUncheckedUpdateManyWithoutUserNestedInput
    staffWeeklyRewards?: StaffWeeklyRewardUncheckedUpdateManyWithoutUserNestedInput
    adminCasesTarget?: AdminCaseUncheckedUpdateManyWithoutTargetUserNestedInput
    adminCasesStaff?: AdminCaseUncheckedUpdateManyWithoutStaffUserNestedInput
    reputation?: UserReputationUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserUpsertWithoutTicketParticipantsAddedInput = {
    update: XOR<UserUpdateWithoutTicketParticipantsAddedInput, UserUncheckedUpdateWithoutTicketParticipantsAddedInput>
    create: XOR<UserCreateWithoutTicketParticipantsAddedInput, UserUncheckedCreateWithoutTicketParticipantsAddedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTicketParticipantsAddedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTicketParticipantsAddedInput, UserUncheckedUpdateWithoutTicketParticipantsAddedInput>
  }

  export type UserUpdateWithoutTicketParticipantsAddedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifyToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerifyExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    discordId?: NullableStringFieldUpdateOperationsInput | string | null
    discordUsername?: NullableStringFieldUpdateOperationsInput | string | null
    avatarKey?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    bannedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    whitelistStatus?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    lastSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    topics?: TopicUpdateManyWithoutAuthorNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    tickets?: TicketUpdateManyWithoutAuthorNestedInput
    assignedTickets?: TicketUpdateManyWithoutAssignedToNestedInput
    ticketMsgs?: TicketMessageUpdateManyWithoutAuthorNestedInput
    ticketParticipants?: TicketParticipantUpdateManyWithoutUserNestedInput
    ticketRatingsGiven?: TicketRatingUpdateManyWithoutRaterNestedInput
    ticketRatingsReceived?: TicketRatingUpdateManyWithoutTargetNestedInput
    closedTickets?: TicketUpdateManyWithoutClosedByNestedInput
    purchases?: PurchaseUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    whitelistApps?: WhitelistApplicationUpdateManyWithoutUserNestedInput
    reviewedWhitelists?: WhitelistApplicationUpdateManyWithoutReviewerNestedInput
    convoParts?: ConversationParticipantUpdateManyWithoutUserNestedInput
    sentMessages?: DirectMessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: DirectMessageUpdateManyWithoutReceiverNestedInput
    userBadges?: UserBadgeUpdateManyWithoutUserNestedInput
    gameAccounts?: GameAccountUpdateManyWithoutUserNestedInput
    mtaAccessLogs?: MtaAccessLogUpdateManyWithoutUserNestedInput
    ticketRatingReqGiven?: TicketRatingRequirementUpdateManyWithoutRaterNestedInput
    ticketRatingReqReceived?: TicketRatingRequirementUpdateManyWithoutTargetNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    entitlements?: EntitlementUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    staffShifts?: StaffShiftUpdateManyWithoutUserNestedInput
    staffWeeklyRewards?: StaffWeeklyRewardUpdateManyWithoutUserNestedInput
    adminCasesTarget?: AdminCaseUpdateManyWithoutTargetUserNestedInput
    adminCasesStaff?: AdminCaseUpdateManyWithoutStaffUserNestedInput
    reputation?: UserReputationUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTicketParticipantsAddedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifyToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerifyExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    discordId?: NullableStringFieldUpdateOperationsInput | string | null
    discordUsername?: NullableStringFieldUpdateOperationsInput | string | null
    avatarKey?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    bannedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    whitelistStatus?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    lastSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    topics?: TopicUncheckedUpdateManyWithoutAuthorNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutAuthorNestedInput
    assignedTickets?: TicketUncheckedUpdateManyWithoutAssignedToNestedInput
    ticketMsgs?: TicketMessageUncheckedUpdateManyWithoutAuthorNestedInput
    ticketParticipants?: TicketParticipantUncheckedUpdateManyWithoutUserNestedInput
    ticketRatingsGiven?: TicketRatingUncheckedUpdateManyWithoutRaterNestedInput
    ticketRatingsReceived?: TicketRatingUncheckedUpdateManyWithoutTargetNestedInput
    closedTickets?: TicketUncheckedUpdateManyWithoutClosedByNestedInput
    purchases?: PurchaseUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    whitelistApps?: WhitelistApplicationUncheckedUpdateManyWithoutUserNestedInput
    reviewedWhitelists?: WhitelistApplicationUncheckedUpdateManyWithoutReviewerNestedInput
    convoParts?: ConversationParticipantUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: DirectMessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: DirectMessageUncheckedUpdateManyWithoutReceiverNestedInput
    userBadges?: UserBadgeUncheckedUpdateManyWithoutUserNestedInput
    gameAccounts?: GameAccountUncheckedUpdateManyWithoutUserNestedInput
    mtaAccessLogs?: MtaAccessLogUncheckedUpdateManyWithoutUserNestedInput
    ticketRatingReqGiven?: TicketRatingRequirementUncheckedUpdateManyWithoutRaterNestedInput
    ticketRatingReqReceived?: TicketRatingRequirementUncheckedUpdateManyWithoutTargetNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    entitlements?: EntitlementUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    staffShifts?: StaffShiftUncheckedUpdateManyWithoutUserNestedInput
    staffWeeklyRewards?: StaffWeeklyRewardUncheckedUpdateManyWithoutUserNestedInput
    adminCasesTarget?: AdminCaseUncheckedUpdateManyWithoutTargetUserNestedInput
    adminCasesStaff?: AdminCaseUncheckedUpdateManyWithoutStaffUserNestedInput
    reputation?: UserReputationUncheckedUpdateOneWithoutUserNestedInput
  }

  export type TicketCreateWithoutRatingsInput = {
    id?: string
    title: string
    status?: string
    priority?: string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    closedAt?: Date | string | null
    category: TicketCategoryCreateNestedOneWithoutTicketsInput
    author: UserCreateNestedOneWithoutTicketsInput
    assignedTo?: UserCreateNestedOneWithoutAssignedTicketsInput
    closedBy?: UserCreateNestedOneWithoutClosedTicketsInput
    messages?: TicketMessageCreateNestedManyWithoutTicketInput
    participants?: TicketParticipantCreateNestedManyWithoutTicketInput
    ratingRequirements?: TicketRatingRequirementCreateNestedManyWithoutTicketInput
  }

  export type TicketUncheckedCreateWithoutRatingsInput = {
    id?: string
    categoryId: string
    authorId: string
    title: string
    status?: string
    priority?: string
    assignedToId?: string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    closedAt?: Date | string | null
    closedById?: string | null
    messages?: TicketMessageUncheckedCreateNestedManyWithoutTicketInput
    participants?: TicketParticipantUncheckedCreateNestedManyWithoutTicketInput
    ratingRequirements?: TicketRatingRequirementUncheckedCreateNestedManyWithoutTicketInput
  }

  export type TicketCreateOrConnectWithoutRatingsInput = {
    where: TicketWhereUniqueInput
    create: XOR<TicketCreateWithoutRatingsInput, TicketUncheckedCreateWithoutRatingsInput>
  }

  export type UserCreateWithoutTicketRatingsGivenInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    emailVerifiedAt?: Date | string | null
    emailVerifyToken?: string | null
    emailVerifyExpiresAt?: Date | string | null
    phone?: string | null
    recoveryEmail?: string | null
    googleId?: string | null
    discordId?: string | null
    discordUsername?: string | null
    avatarKey?: string
    role?: string
    isDeleted?: boolean
    bannedUntil?: Date | string | null
    whitelistStatus?: string
    points?: number
    lastSeenAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    avatarUrl?: string | null
    topics?: TopicCreateNestedManyWithoutAuthorInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    tickets?: TicketCreateNestedManyWithoutAuthorInput
    assignedTickets?: TicketCreateNestedManyWithoutAssignedToInput
    ticketMsgs?: TicketMessageCreateNestedManyWithoutAuthorInput
    ticketParticipants?: TicketParticipantCreateNestedManyWithoutUserInput
    ticketParticipantsAdded?: TicketParticipantCreateNestedManyWithoutAddedByInput
    ticketRatingsReceived?: TicketRatingCreateNestedManyWithoutTargetInput
    closedTickets?: TicketCreateNestedManyWithoutClosedByInput
    purchases?: PurchaseCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    whitelistApps?: WhitelistApplicationCreateNestedManyWithoutUserInput
    reviewedWhitelists?: WhitelistApplicationCreateNestedManyWithoutReviewerInput
    convoParts?: ConversationParticipantCreateNestedManyWithoutUserInput
    sentMessages?: DirectMessageCreateNestedManyWithoutSenderInput
    receivedMessages?: DirectMessageCreateNestedManyWithoutReceiverInput
    userBadges?: UserBadgeCreateNestedManyWithoutUserInput
    gameAccounts?: GameAccountCreateNestedManyWithoutUserInput
    mtaAccessLogs?: MtaAccessLogCreateNestedManyWithoutUserInput
    ticketRatingReqGiven?: TicketRatingRequirementCreateNestedManyWithoutRaterInput
    ticketRatingReqReceived?: TicketRatingRequirementCreateNestedManyWithoutTargetInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    entitlements?: EntitlementCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    staffShifts?: StaffShiftCreateNestedManyWithoutUserInput
    staffWeeklyRewards?: StaffWeeklyRewardCreateNestedManyWithoutUserInput
    adminCasesTarget?: AdminCaseCreateNestedManyWithoutTargetUserInput
    adminCasesStaff?: AdminCaseCreateNestedManyWithoutStaffUserInput
    reputation?: UserReputationCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTicketRatingsGivenInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    emailVerifiedAt?: Date | string | null
    emailVerifyToken?: string | null
    emailVerifyExpiresAt?: Date | string | null
    phone?: string | null
    recoveryEmail?: string | null
    googleId?: string | null
    discordId?: string | null
    discordUsername?: string | null
    avatarKey?: string
    role?: string
    isDeleted?: boolean
    bannedUntil?: Date | string | null
    whitelistStatus?: string
    points?: number
    lastSeenAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    avatarUrl?: string | null
    topics?: TopicUncheckedCreateNestedManyWithoutAuthorInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    tickets?: TicketUncheckedCreateNestedManyWithoutAuthorInput
    assignedTickets?: TicketUncheckedCreateNestedManyWithoutAssignedToInput
    ticketMsgs?: TicketMessageUncheckedCreateNestedManyWithoutAuthorInput
    ticketParticipants?: TicketParticipantUncheckedCreateNestedManyWithoutUserInput
    ticketParticipantsAdded?: TicketParticipantUncheckedCreateNestedManyWithoutAddedByInput
    ticketRatingsReceived?: TicketRatingUncheckedCreateNestedManyWithoutTargetInput
    closedTickets?: TicketUncheckedCreateNestedManyWithoutClosedByInput
    purchases?: PurchaseUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    whitelistApps?: WhitelistApplicationUncheckedCreateNestedManyWithoutUserInput
    reviewedWhitelists?: WhitelistApplicationUncheckedCreateNestedManyWithoutReviewerInput
    convoParts?: ConversationParticipantUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: DirectMessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: DirectMessageUncheckedCreateNestedManyWithoutReceiverInput
    userBadges?: UserBadgeUncheckedCreateNestedManyWithoutUserInput
    gameAccounts?: GameAccountUncheckedCreateNestedManyWithoutUserInput
    mtaAccessLogs?: MtaAccessLogUncheckedCreateNestedManyWithoutUserInput
    ticketRatingReqGiven?: TicketRatingRequirementUncheckedCreateNestedManyWithoutRaterInput
    ticketRatingReqReceived?: TicketRatingRequirementUncheckedCreateNestedManyWithoutTargetInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    entitlements?: EntitlementUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    staffShifts?: StaffShiftUncheckedCreateNestedManyWithoutUserInput
    staffWeeklyRewards?: StaffWeeklyRewardUncheckedCreateNestedManyWithoutUserInput
    adminCasesTarget?: AdminCaseUncheckedCreateNestedManyWithoutTargetUserInput
    adminCasesStaff?: AdminCaseUncheckedCreateNestedManyWithoutStaffUserInput
    reputation?: UserReputationUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTicketRatingsGivenInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTicketRatingsGivenInput, UserUncheckedCreateWithoutTicketRatingsGivenInput>
  }

  export type UserCreateWithoutTicketRatingsReceivedInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    emailVerifiedAt?: Date | string | null
    emailVerifyToken?: string | null
    emailVerifyExpiresAt?: Date | string | null
    phone?: string | null
    recoveryEmail?: string | null
    googleId?: string | null
    discordId?: string | null
    discordUsername?: string | null
    avatarKey?: string
    role?: string
    isDeleted?: boolean
    bannedUntil?: Date | string | null
    whitelistStatus?: string
    points?: number
    lastSeenAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    avatarUrl?: string | null
    topics?: TopicCreateNestedManyWithoutAuthorInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    tickets?: TicketCreateNestedManyWithoutAuthorInput
    assignedTickets?: TicketCreateNestedManyWithoutAssignedToInput
    ticketMsgs?: TicketMessageCreateNestedManyWithoutAuthorInput
    ticketParticipants?: TicketParticipantCreateNestedManyWithoutUserInput
    ticketParticipantsAdded?: TicketParticipantCreateNestedManyWithoutAddedByInput
    ticketRatingsGiven?: TicketRatingCreateNestedManyWithoutRaterInput
    closedTickets?: TicketCreateNestedManyWithoutClosedByInput
    purchases?: PurchaseCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    whitelistApps?: WhitelistApplicationCreateNestedManyWithoutUserInput
    reviewedWhitelists?: WhitelistApplicationCreateNestedManyWithoutReviewerInput
    convoParts?: ConversationParticipantCreateNestedManyWithoutUserInput
    sentMessages?: DirectMessageCreateNestedManyWithoutSenderInput
    receivedMessages?: DirectMessageCreateNestedManyWithoutReceiverInput
    userBadges?: UserBadgeCreateNestedManyWithoutUserInput
    gameAccounts?: GameAccountCreateNestedManyWithoutUserInput
    mtaAccessLogs?: MtaAccessLogCreateNestedManyWithoutUserInput
    ticketRatingReqGiven?: TicketRatingRequirementCreateNestedManyWithoutRaterInput
    ticketRatingReqReceived?: TicketRatingRequirementCreateNestedManyWithoutTargetInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    entitlements?: EntitlementCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    staffShifts?: StaffShiftCreateNestedManyWithoutUserInput
    staffWeeklyRewards?: StaffWeeklyRewardCreateNestedManyWithoutUserInput
    adminCasesTarget?: AdminCaseCreateNestedManyWithoutTargetUserInput
    adminCasesStaff?: AdminCaseCreateNestedManyWithoutStaffUserInput
    reputation?: UserReputationCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTicketRatingsReceivedInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    emailVerifiedAt?: Date | string | null
    emailVerifyToken?: string | null
    emailVerifyExpiresAt?: Date | string | null
    phone?: string | null
    recoveryEmail?: string | null
    googleId?: string | null
    discordId?: string | null
    discordUsername?: string | null
    avatarKey?: string
    role?: string
    isDeleted?: boolean
    bannedUntil?: Date | string | null
    whitelistStatus?: string
    points?: number
    lastSeenAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    avatarUrl?: string | null
    topics?: TopicUncheckedCreateNestedManyWithoutAuthorInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    tickets?: TicketUncheckedCreateNestedManyWithoutAuthorInput
    assignedTickets?: TicketUncheckedCreateNestedManyWithoutAssignedToInput
    ticketMsgs?: TicketMessageUncheckedCreateNestedManyWithoutAuthorInput
    ticketParticipants?: TicketParticipantUncheckedCreateNestedManyWithoutUserInput
    ticketParticipantsAdded?: TicketParticipantUncheckedCreateNestedManyWithoutAddedByInput
    ticketRatingsGiven?: TicketRatingUncheckedCreateNestedManyWithoutRaterInput
    closedTickets?: TicketUncheckedCreateNestedManyWithoutClosedByInput
    purchases?: PurchaseUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    whitelistApps?: WhitelistApplicationUncheckedCreateNestedManyWithoutUserInput
    reviewedWhitelists?: WhitelistApplicationUncheckedCreateNestedManyWithoutReviewerInput
    convoParts?: ConversationParticipantUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: DirectMessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: DirectMessageUncheckedCreateNestedManyWithoutReceiverInput
    userBadges?: UserBadgeUncheckedCreateNestedManyWithoutUserInput
    gameAccounts?: GameAccountUncheckedCreateNestedManyWithoutUserInput
    mtaAccessLogs?: MtaAccessLogUncheckedCreateNestedManyWithoutUserInput
    ticketRatingReqGiven?: TicketRatingRequirementUncheckedCreateNestedManyWithoutRaterInput
    ticketRatingReqReceived?: TicketRatingRequirementUncheckedCreateNestedManyWithoutTargetInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    entitlements?: EntitlementUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    staffShifts?: StaffShiftUncheckedCreateNestedManyWithoutUserInput
    staffWeeklyRewards?: StaffWeeklyRewardUncheckedCreateNestedManyWithoutUserInput
    adminCasesTarget?: AdminCaseUncheckedCreateNestedManyWithoutTargetUserInput
    adminCasesStaff?: AdminCaseUncheckedCreateNestedManyWithoutStaffUserInput
    reputation?: UserReputationUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTicketRatingsReceivedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTicketRatingsReceivedInput, UserUncheckedCreateWithoutTicketRatingsReceivedInput>
  }

  export type TicketUpsertWithoutRatingsInput = {
    update: XOR<TicketUpdateWithoutRatingsInput, TicketUncheckedUpdateWithoutRatingsInput>
    create: XOR<TicketCreateWithoutRatingsInput, TicketUncheckedCreateWithoutRatingsInput>
    where?: TicketWhereInput
  }

  export type TicketUpdateToOneWithWhereWithoutRatingsInput = {
    where?: TicketWhereInput
    data: XOR<TicketUpdateWithoutRatingsInput, TicketUncheckedUpdateWithoutRatingsInput>
  }

  export type TicketUpdateWithoutRatingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: TicketCategoryUpdateOneRequiredWithoutTicketsNestedInput
    author?: UserUpdateOneRequiredWithoutTicketsNestedInput
    assignedTo?: UserUpdateOneWithoutAssignedTicketsNestedInput
    closedBy?: UserUpdateOneWithoutClosedTicketsNestedInput
    messages?: TicketMessageUpdateManyWithoutTicketNestedInput
    participants?: TicketParticipantUpdateManyWithoutTicketNestedInput
    ratingRequirements?: TicketRatingRequirementUpdateManyWithoutTicketNestedInput
  }

  export type TicketUncheckedUpdateWithoutRatingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedById?: NullableStringFieldUpdateOperationsInput | string | null
    messages?: TicketMessageUncheckedUpdateManyWithoutTicketNestedInput
    participants?: TicketParticipantUncheckedUpdateManyWithoutTicketNestedInput
    ratingRequirements?: TicketRatingRequirementUncheckedUpdateManyWithoutTicketNestedInput
  }

  export type UserUpsertWithoutTicketRatingsGivenInput = {
    update: XOR<UserUpdateWithoutTicketRatingsGivenInput, UserUncheckedUpdateWithoutTicketRatingsGivenInput>
    create: XOR<UserCreateWithoutTicketRatingsGivenInput, UserUncheckedCreateWithoutTicketRatingsGivenInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTicketRatingsGivenInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTicketRatingsGivenInput, UserUncheckedUpdateWithoutTicketRatingsGivenInput>
  }

  export type UserUpdateWithoutTicketRatingsGivenInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifyToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerifyExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    discordId?: NullableStringFieldUpdateOperationsInput | string | null
    discordUsername?: NullableStringFieldUpdateOperationsInput | string | null
    avatarKey?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    bannedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    whitelistStatus?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    lastSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    topics?: TopicUpdateManyWithoutAuthorNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    tickets?: TicketUpdateManyWithoutAuthorNestedInput
    assignedTickets?: TicketUpdateManyWithoutAssignedToNestedInput
    ticketMsgs?: TicketMessageUpdateManyWithoutAuthorNestedInput
    ticketParticipants?: TicketParticipantUpdateManyWithoutUserNestedInput
    ticketParticipantsAdded?: TicketParticipantUpdateManyWithoutAddedByNestedInput
    ticketRatingsReceived?: TicketRatingUpdateManyWithoutTargetNestedInput
    closedTickets?: TicketUpdateManyWithoutClosedByNestedInput
    purchases?: PurchaseUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    whitelistApps?: WhitelistApplicationUpdateManyWithoutUserNestedInput
    reviewedWhitelists?: WhitelistApplicationUpdateManyWithoutReviewerNestedInput
    convoParts?: ConversationParticipantUpdateManyWithoutUserNestedInput
    sentMessages?: DirectMessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: DirectMessageUpdateManyWithoutReceiverNestedInput
    userBadges?: UserBadgeUpdateManyWithoutUserNestedInput
    gameAccounts?: GameAccountUpdateManyWithoutUserNestedInput
    mtaAccessLogs?: MtaAccessLogUpdateManyWithoutUserNestedInput
    ticketRatingReqGiven?: TicketRatingRequirementUpdateManyWithoutRaterNestedInput
    ticketRatingReqReceived?: TicketRatingRequirementUpdateManyWithoutTargetNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    entitlements?: EntitlementUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    staffShifts?: StaffShiftUpdateManyWithoutUserNestedInput
    staffWeeklyRewards?: StaffWeeklyRewardUpdateManyWithoutUserNestedInput
    adminCasesTarget?: AdminCaseUpdateManyWithoutTargetUserNestedInput
    adminCasesStaff?: AdminCaseUpdateManyWithoutStaffUserNestedInput
    reputation?: UserReputationUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTicketRatingsGivenInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifyToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerifyExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    discordId?: NullableStringFieldUpdateOperationsInput | string | null
    discordUsername?: NullableStringFieldUpdateOperationsInput | string | null
    avatarKey?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    bannedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    whitelistStatus?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    lastSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    topics?: TopicUncheckedUpdateManyWithoutAuthorNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutAuthorNestedInput
    assignedTickets?: TicketUncheckedUpdateManyWithoutAssignedToNestedInput
    ticketMsgs?: TicketMessageUncheckedUpdateManyWithoutAuthorNestedInput
    ticketParticipants?: TicketParticipantUncheckedUpdateManyWithoutUserNestedInput
    ticketParticipantsAdded?: TicketParticipantUncheckedUpdateManyWithoutAddedByNestedInput
    ticketRatingsReceived?: TicketRatingUncheckedUpdateManyWithoutTargetNestedInput
    closedTickets?: TicketUncheckedUpdateManyWithoutClosedByNestedInput
    purchases?: PurchaseUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    whitelistApps?: WhitelistApplicationUncheckedUpdateManyWithoutUserNestedInput
    reviewedWhitelists?: WhitelistApplicationUncheckedUpdateManyWithoutReviewerNestedInput
    convoParts?: ConversationParticipantUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: DirectMessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: DirectMessageUncheckedUpdateManyWithoutReceiverNestedInput
    userBadges?: UserBadgeUncheckedUpdateManyWithoutUserNestedInput
    gameAccounts?: GameAccountUncheckedUpdateManyWithoutUserNestedInput
    mtaAccessLogs?: MtaAccessLogUncheckedUpdateManyWithoutUserNestedInput
    ticketRatingReqGiven?: TicketRatingRequirementUncheckedUpdateManyWithoutRaterNestedInput
    ticketRatingReqReceived?: TicketRatingRequirementUncheckedUpdateManyWithoutTargetNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    entitlements?: EntitlementUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    staffShifts?: StaffShiftUncheckedUpdateManyWithoutUserNestedInput
    staffWeeklyRewards?: StaffWeeklyRewardUncheckedUpdateManyWithoutUserNestedInput
    adminCasesTarget?: AdminCaseUncheckedUpdateManyWithoutTargetUserNestedInput
    adminCasesStaff?: AdminCaseUncheckedUpdateManyWithoutStaffUserNestedInput
    reputation?: UserReputationUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserUpsertWithoutTicketRatingsReceivedInput = {
    update: XOR<UserUpdateWithoutTicketRatingsReceivedInput, UserUncheckedUpdateWithoutTicketRatingsReceivedInput>
    create: XOR<UserCreateWithoutTicketRatingsReceivedInput, UserUncheckedCreateWithoutTicketRatingsReceivedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTicketRatingsReceivedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTicketRatingsReceivedInput, UserUncheckedUpdateWithoutTicketRatingsReceivedInput>
  }

  export type UserUpdateWithoutTicketRatingsReceivedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifyToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerifyExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    discordId?: NullableStringFieldUpdateOperationsInput | string | null
    discordUsername?: NullableStringFieldUpdateOperationsInput | string | null
    avatarKey?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    bannedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    whitelistStatus?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    lastSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    topics?: TopicUpdateManyWithoutAuthorNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    tickets?: TicketUpdateManyWithoutAuthorNestedInput
    assignedTickets?: TicketUpdateManyWithoutAssignedToNestedInput
    ticketMsgs?: TicketMessageUpdateManyWithoutAuthorNestedInput
    ticketParticipants?: TicketParticipantUpdateManyWithoutUserNestedInput
    ticketParticipantsAdded?: TicketParticipantUpdateManyWithoutAddedByNestedInput
    ticketRatingsGiven?: TicketRatingUpdateManyWithoutRaterNestedInput
    closedTickets?: TicketUpdateManyWithoutClosedByNestedInput
    purchases?: PurchaseUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    whitelistApps?: WhitelistApplicationUpdateManyWithoutUserNestedInput
    reviewedWhitelists?: WhitelistApplicationUpdateManyWithoutReviewerNestedInput
    convoParts?: ConversationParticipantUpdateManyWithoutUserNestedInput
    sentMessages?: DirectMessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: DirectMessageUpdateManyWithoutReceiverNestedInput
    userBadges?: UserBadgeUpdateManyWithoutUserNestedInput
    gameAccounts?: GameAccountUpdateManyWithoutUserNestedInput
    mtaAccessLogs?: MtaAccessLogUpdateManyWithoutUserNestedInput
    ticketRatingReqGiven?: TicketRatingRequirementUpdateManyWithoutRaterNestedInput
    ticketRatingReqReceived?: TicketRatingRequirementUpdateManyWithoutTargetNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    entitlements?: EntitlementUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    staffShifts?: StaffShiftUpdateManyWithoutUserNestedInput
    staffWeeklyRewards?: StaffWeeklyRewardUpdateManyWithoutUserNestedInput
    adminCasesTarget?: AdminCaseUpdateManyWithoutTargetUserNestedInput
    adminCasesStaff?: AdminCaseUpdateManyWithoutStaffUserNestedInput
    reputation?: UserReputationUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTicketRatingsReceivedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifyToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerifyExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    discordId?: NullableStringFieldUpdateOperationsInput | string | null
    discordUsername?: NullableStringFieldUpdateOperationsInput | string | null
    avatarKey?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    bannedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    whitelistStatus?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    lastSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    topics?: TopicUncheckedUpdateManyWithoutAuthorNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutAuthorNestedInput
    assignedTickets?: TicketUncheckedUpdateManyWithoutAssignedToNestedInput
    ticketMsgs?: TicketMessageUncheckedUpdateManyWithoutAuthorNestedInput
    ticketParticipants?: TicketParticipantUncheckedUpdateManyWithoutUserNestedInput
    ticketParticipantsAdded?: TicketParticipantUncheckedUpdateManyWithoutAddedByNestedInput
    ticketRatingsGiven?: TicketRatingUncheckedUpdateManyWithoutRaterNestedInput
    closedTickets?: TicketUncheckedUpdateManyWithoutClosedByNestedInput
    purchases?: PurchaseUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    whitelistApps?: WhitelistApplicationUncheckedUpdateManyWithoutUserNestedInput
    reviewedWhitelists?: WhitelistApplicationUncheckedUpdateManyWithoutReviewerNestedInput
    convoParts?: ConversationParticipantUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: DirectMessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: DirectMessageUncheckedUpdateManyWithoutReceiverNestedInput
    userBadges?: UserBadgeUncheckedUpdateManyWithoutUserNestedInput
    gameAccounts?: GameAccountUncheckedUpdateManyWithoutUserNestedInput
    mtaAccessLogs?: MtaAccessLogUncheckedUpdateManyWithoutUserNestedInput
    ticketRatingReqGiven?: TicketRatingRequirementUncheckedUpdateManyWithoutRaterNestedInput
    ticketRatingReqReceived?: TicketRatingRequirementUncheckedUpdateManyWithoutTargetNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    entitlements?: EntitlementUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    staffShifts?: StaffShiftUncheckedUpdateManyWithoutUserNestedInput
    staffWeeklyRewards?: StaffWeeklyRewardUncheckedUpdateManyWithoutUserNestedInput
    adminCasesTarget?: AdminCaseUncheckedUpdateManyWithoutTargetUserNestedInput
    adminCasesStaff?: AdminCaseUncheckedUpdateManyWithoutStaffUserNestedInput
    reputation?: UserReputationUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserCreateWithoutMtaAccessLogsInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    emailVerifiedAt?: Date | string | null
    emailVerifyToken?: string | null
    emailVerifyExpiresAt?: Date | string | null
    phone?: string | null
    recoveryEmail?: string | null
    googleId?: string | null
    discordId?: string | null
    discordUsername?: string | null
    avatarKey?: string
    role?: string
    isDeleted?: boolean
    bannedUntil?: Date | string | null
    whitelistStatus?: string
    points?: number
    lastSeenAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    avatarUrl?: string | null
    topics?: TopicCreateNestedManyWithoutAuthorInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    tickets?: TicketCreateNestedManyWithoutAuthorInput
    assignedTickets?: TicketCreateNestedManyWithoutAssignedToInput
    ticketMsgs?: TicketMessageCreateNestedManyWithoutAuthorInput
    ticketParticipants?: TicketParticipantCreateNestedManyWithoutUserInput
    ticketParticipantsAdded?: TicketParticipantCreateNestedManyWithoutAddedByInput
    ticketRatingsGiven?: TicketRatingCreateNestedManyWithoutRaterInput
    ticketRatingsReceived?: TicketRatingCreateNestedManyWithoutTargetInput
    closedTickets?: TicketCreateNestedManyWithoutClosedByInput
    purchases?: PurchaseCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    whitelistApps?: WhitelistApplicationCreateNestedManyWithoutUserInput
    reviewedWhitelists?: WhitelistApplicationCreateNestedManyWithoutReviewerInput
    convoParts?: ConversationParticipantCreateNestedManyWithoutUserInput
    sentMessages?: DirectMessageCreateNestedManyWithoutSenderInput
    receivedMessages?: DirectMessageCreateNestedManyWithoutReceiverInput
    userBadges?: UserBadgeCreateNestedManyWithoutUserInput
    gameAccounts?: GameAccountCreateNestedManyWithoutUserInput
    ticketRatingReqGiven?: TicketRatingRequirementCreateNestedManyWithoutRaterInput
    ticketRatingReqReceived?: TicketRatingRequirementCreateNestedManyWithoutTargetInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    entitlements?: EntitlementCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    staffShifts?: StaffShiftCreateNestedManyWithoutUserInput
    staffWeeklyRewards?: StaffWeeklyRewardCreateNestedManyWithoutUserInput
    adminCasesTarget?: AdminCaseCreateNestedManyWithoutTargetUserInput
    adminCasesStaff?: AdminCaseCreateNestedManyWithoutStaffUserInput
    reputation?: UserReputationCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutMtaAccessLogsInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    emailVerifiedAt?: Date | string | null
    emailVerifyToken?: string | null
    emailVerifyExpiresAt?: Date | string | null
    phone?: string | null
    recoveryEmail?: string | null
    googleId?: string | null
    discordId?: string | null
    discordUsername?: string | null
    avatarKey?: string
    role?: string
    isDeleted?: boolean
    bannedUntil?: Date | string | null
    whitelistStatus?: string
    points?: number
    lastSeenAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    avatarUrl?: string | null
    topics?: TopicUncheckedCreateNestedManyWithoutAuthorInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    tickets?: TicketUncheckedCreateNestedManyWithoutAuthorInput
    assignedTickets?: TicketUncheckedCreateNestedManyWithoutAssignedToInput
    ticketMsgs?: TicketMessageUncheckedCreateNestedManyWithoutAuthorInput
    ticketParticipants?: TicketParticipantUncheckedCreateNestedManyWithoutUserInput
    ticketParticipantsAdded?: TicketParticipantUncheckedCreateNestedManyWithoutAddedByInput
    ticketRatingsGiven?: TicketRatingUncheckedCreateNestedManyWithoutRaterInput
    ticketRatingsReceived?: TicketRatingUncheckedCreateNestedManyWithoutTargetInput
    closedTickets?: TicketUncheckedCreateNestedManyWithoutClosedByInput
    purchases?: PurchaseUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    whitelistApps?: WhitelistApplicationUncheckedCreateNestedManyWithoutUserInput
    reviewedWhitelists?: WhitelistApplicationUncheckedCreateNestedManyWithoutReviewerInput
    convoParts?: ConversationParticipantUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: DirectMessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: DirectMessageUncheckedCreateNestedManyWithoutReceiverInput
    userBadges?: UserBadgeUncheckedCreateNestedManyWithoutUserInput
    gameAccounts?: GameAccountUncheckedCreateNestedManyWithoutUserInput
    ticketRatingReqGiven?: TicketRatingRequirementUncheckedCreateNestedManyWithoutRaterInput
    ticketRatingReqReceived?: TicketRatingRequirementUncheckedCreateNestedManyWithoutTargetInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    entitlements?: EntitlementUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    staffShifts?: StaffShiftUncheckedCreateNestedManyWithoutUserInput
    staffWeeklyRewards?: StaffWeeklyRewardUncheckedCreateNestedManyWithoutUserInput
    adminCasesTarget?: AdminCaseUncheckedCreateNestedManyWithoutTargetUserInput
    adminCasesStaff?: AdminCaseUncheckedCreateNestedManyWithoutStaffUserInput
    reputation?: UserReputationUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutMtaAccessLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMtaAccessLogsInput, UserUncheckedCreateWithoutMtaAccessLogsInput>
  }

  export type UserUpsertWithoutMtaAccessLogsInput = {
    update: XOR<UserUpdateWithoutMtaAccessLogsInput, UserUncheckedUpdateWithoutMtaAccessLogsInput>
    create: XOR<UserCreateWithoutMtaAccessLogsInput, UserUncheckedCreateWithoutMtaAccessLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMtaAccessLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMtaAccessLogsInput, UserUncheckedUpdateWithoutMtaAccessLogsInput>
  }

  export type UserUpdateWithoutMtaAccessLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifyToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerifyExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    discordId?: NullableStringFieldUpdateOperationsInput | string | null
    discordUsername?: NullableStringFieldUpdateOperationsInput | string | null
    avatarKey?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    bannedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    whitelistStatus?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    lastSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    topics?: TopicUpdateManyWithoutAuthorNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    tickets?: TicketUpdateManyWithoutAuthorNestedInput
    assignedTickets?: TicketUpdateManyWithoutAssignedToNestedInput
    ticketMsgs?: TicketMessageUpdateManyWithoutAuthorNestedInput
    ticketParticipants?: TicketParticipantUpdateManyWithoutUserNestedInput
    ticketParticipantsAdded?: TicketParticipantUpdateManyWithoutAddedByNestedInput
    ticketRatingsGiven?: TicketRatingUpdateManyWithoutRaterNestedInput
    ticketRatingsReceived?: TicketRatingUpdateManyWithoutTargetNestedInput
    closedTickets?: TicketUpdateManyWithoutClosedByNestedInput
    purchases?: PurchaseUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    whitelistApps?: WhitelistApplicationUpdateManyWithoutUserNestedInput
    reviewedWhitelists?: WhitelistApplicationUpdateManyWithoutReviewerNestedInput
    convoParts?: ConversationParticipantUpdateManyWithoutUserNestedInput
    sentMessages?: DirectMessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: DirectMessageUpdateManyWithoutReceiverNestedInput
    userBadges?: UserBadgeUpdateManyWithoutUserNestedInput
    gameAccounts?: GameAccountUpdateManyWithoutUserNestedInput
    ticketRatingReqGiven?: TicketRatingRequirementUpdateManyWithoutRaterNestedInput
    ticketRatingReqReceived?: TicketRatingRequirementUpdateManyWithoutTargetNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    entitlements?: EntitlementUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    staffShifts?: StaffShiftUpdateManyWithoutUserNestedInput
    staffWeeklyRewards?: StaffWeeklyRewardUpdateManyWithoutUserNestedInput
    adminCasesTarget?: AdminCaseUpdateManyWithoutTargetUserNestedInput
    adminCasesStaff?: AdminCaseUpdateManyWithoutStaffUserNestedInput
    reputation?: UserReputationUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutMtaAccessLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifyToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerifyExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    discordId?: NullableStringFieldUpdateOperationsInput | string | null
    discordUsername?: NullableStringFieldUpdateOperationsInput | string | null
    avatarKey?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    bannedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    whitelistStatus?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    lastSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    topics?: TopicUncheckedUpdateManyWithoutAuthorNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutAuthorNestedInput
    assignedTickets?: TicketUncheckedUpdateManyWithoutAssignedToNestedInput
    ticketMsgs?: TicketMessageUncheckedUpdateManyWithoutAuthorNestedInput
    ticketParticipants?: TicketParticipantUncheckedUpdateManyWithoutUserNestedInput
    ticketParticipantsAdded?: TicketParticipantUncheckedUpdateManyWithoutAddedByNestedInput
    ticketRatingsGiven?: TicketRatingUncheckedUpdateManyWithoutRaterNestedInput
    ticketRatingsReceived?: TicketRatingUncheckedUpdateManyWithoutTargetNestedInput
    closedTickets?: TicketUncheckedUpdateManyWithoutClosedByNestedInput
    purchases?: PurchaseUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    whitelistApps?: WhitelistApplicationUncheckedUpdateManyWithoutUserNestedInput
    reviewedWhitelists?: WhitelistApplicationUncheckedUpdateManyWithoutReviewerNestedInput
    convoParts?: ConversationParticipantUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: DirectMessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: DirectMessageUncheckedUpdateManyWithoutReceiverNestedInput
    userBadges?: UserBadgeUncheckedUpdateManyWithoutUserNestedInput
    gameAccounts?: GameAccountUncheckedUpdateManyWithoutUserNestedInput
    ticketRatingReqGiven?: TicketRatingRequirementUncheckedUpdateManyWithoutRaterNestedInput
    ticketRatingReqReceived?: TicketRatingRequirementUncheckedUpdateManyWithoutTargetNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    entitlements?: EntitlementUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    staffShifts?: StaffShiftUncheckedUpdateManyWithoutUserNestedInput
    staffWeeklyRewards?: StaffWeeklyRewardUncheckedUpdateManyWithoutUserNestedInput
    adminCasesTarget?: AdminCaseUncheckedUpdateManyWithoutTargetUserNestedInput
    adminCasesStaff?: AdminCaseUncheckedUpdateManyWithoutStaffUserNestedInput
    reputation?: UserReputationUncheckedUpdateOneWithoutUserNestedInput
  }

  export type TicketCreateWithoutRatingRequirementsInput = {
    id?: string
    title: string
    status?: string
    priority?: string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    closedAt?: Date | string | null
    category: TicketCategoryCreateNestedOneWithoutTicketsInput
    author: UserCreateNestedOneWithoutTicketsInput
    assignedTo?: UserCreateNestedOneWithoutAssignedTicketsInput
    closedBy?: UserCreateNestedOneWithoutClosedTicketsInput
    messages?: TicketMessageCreateNestedManyWithoutTicketInput
    participants?: TicketParticipantCreateNestedManyWithoutTicketInput
    ratings?: TicketRatingCreateNestedManyWithoutTicketInput
  }

  export type TicketUncheckedCreateWithoutRatingRequirementsInput = {
    id?: string
    categoryId: string
    authorId: string
    title: string
    status?: string
    priority?: string
    assignedToId?: string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    closedAt?: Date | string | null
    closedById?: string | null
    messages?: TicketMessageUncheckedCreateNestedManyWithoutTicketInput
    participants?: TicketParticipantUncheckedCreateNestedManyWithoutTicketInput
    ratings?: TicketRatingUncheckedCreateNestedManyWithoutTicketInput
  }

  export type TicketCreateOrConnectWithoutRatingRequirementsInput = {
    where: TicketWhereUniqueInput
    create: XOR<TicketCreateWithoutRatingRequirementsInput, TicketUncheckedCreateWithoutRatingRequirementsInput>
  }

  export type UserCreateWithoutTicketRatingReqGivenInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    emailVerifiedAt?: Date | string | null
    emailVerifyToken?: string | null
    emailVerifyExpiresAt?: Date | string | null
    phone?: string | null
    recoveryEmail?: string | null
    googleId?: string | null
    discordId?: string | null
    discordUsername?: string | null
    avatarKey?: string
    role?: string
    isDeleted?: boolean
    bannedUntil?: Date | string | null
    whitelistStatus?: string
    points?: number
    lastSeenAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    avatarUrl?: string | null
    topics?: TopicCreateNestedManyWithoutAuthorInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    tickets?: TicketCreateNestedManyWithoutAuthorInput
    assignedTickets?: TicketCreateNestedManyWithoutAssignedToInput
    ticketMsgs?: TicketMessageCreateNestedManyWithoutAuthorInput
    ticketParticipants?: TicketParticipantCreateNestedManyWithoutUserInput
    ticketParticipantsAdded?: TicketParticipantCreateNestedManyWithoutAddedByInput
    ticketRatingsGiven?: TicketRatingCreateNestedManyWithoutRaterInput
    ticketRatingsReceived?: TicketRatingCreateNestedManyWithoutTargetInput
    closedTickets?: TicketCreateNestedManyWithoutClosedByInput
    purchases?: PurchaseCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    whitelistApps?: WhitelistApplicationCreateNestedManyWithoutUserInput
    reviewedWhitelists?: WhitelistApplicationCreateNestedManyWithoutReviewerInput
    convoParts?: ConversationParticipantCreateNestedManyWithoutUserInput
    sentMessages?: DirectMessageCreateNestedManyWithoutSenderInput
    receivedMessages?: DirectMessageCreateNestedManyWithoutReceiverInput
    userBadges?: UserBadgeCreateNestedManyWithoutUserInput
    gameAccounts?: GameAccountCreateNestedManyWithoutUserInput
    mtaAccessLogs?: MtaAccessLogCreateNestedManyWithoutUserInput
    ticketRatingReqReceived?: TicketRatingRequirementCreateNestedManyWithoutTargetInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    entitlements?: EntitlementCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    staffShifts?: StaffShiftCreateNestedManyWithoutUserInput
    staffWeeklyRewards?: StaffWeeklyRewardCreateNestedManyWithoutUserInput
    adminCasesTarget?: AdminCaseCreateNestedManyWithoutTargetUserInput
    adminCasesStaff?: AdminCaseCreateNestedManyWithoutStaffUserInput
    reputation?: UserReputationCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTicketRatingReqGivenInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    emailVerifiedAt?: Date | string | null
    emailVerifyToken?: string | null
    emailVerifyExpiresAt?: Date | string | null
    phone?: string | null
    recoveryEmail?: string | null
    googleId?: string | null
    discordId?: string | null
    discordUsername?: string | null
    avatarKey?: string
    role?: string
    isDeleted?: boolean
    bannedUntil?: Date | string | null
    whitelistStatus?: string
    points?: number
    lastSeenAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    avatarUrl?: string | null
    topics?: TopicUncheckedCreateNestedManyWithoutAuthorInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    tickets?: TicketUncheckedCreateNestedManyWithoutAuthorInput
    assignedTickets?: TicketUncheckedCreateNestedManyWithoutAssignedToInput
    ticketMsgs?: TicketMessageUncheckedCreateNestedManyWithoutAuthorInput
    ticketParticipants?: TicketParticipantUncheckedCreateNestedManyWithoutUserInput
    ticketParticipantsAdded?: TicketParticipantUncheckedCreateNestedManyWithoutAddedByInput
    ticketRatingsGiven?: TicketRatingUncheckedCreateNestedManyWithoutRaterInput
    ticketRatingsReceived?: TicketRatingUncheckedCreateNestedManyWithoutTargetInput
    closedTickets?: TicketUncheckedCreateNestedManyWithoutClosedByInput
    purchases?: PurchaseUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    whitelistApps?: WhitelistApplicationUncheckedCreateNestedManyWithoutUserInput
    reviewedWhitelists?: WhitelistApplicationUncheckedCreateNestedManyWithoutReviewerInput
    convoParts?: ConversationParticipantUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: DirectMessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: DirectMessageUncheckedCreateNestedManyWithoutReceiverInput
    userBadges?: UserBadgeUncheckedCreateNestedManyWithoutUserInput
    gameAccounts?: GameAccountUncheckedCreateNestedManyWithoutUserInput
    mtaAccessLogs?: MtaAccessLogUncheckedCreateNestedManyWithoutUserInput
    ticketRatingReqReceived?: TicketRatingRequirementUncheckedCreateNestedManyWithoutTargetInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    entitlements?: EntitlementUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    staffShifts?: StaffShiftUncheckedCreateNestedManyWithoutUserInput
    staffWeeklyRewards?: StaffWeeklyRewardUncheckedCreateNestedManyWithoutUserInput
    adminCasesTarget?: AdminCaseUncheckedCreateNestedManyWithoutTargetUserInput
    adminCasesStaff?: AdminCaseUncheckedCreateNestedManyWithoutStaffUserInput
    reputation?: UserReputationUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTicketRatingReqGivenInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTicketRatingReqGivenInput, UserUncheckedCreateWithoutTicketRatingReqGivenInput>
  }

  export type UserCreateWithoutTicketRatingReqReceivedInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    emailVerifiedAt?: Date | string | null
    emailVerifyToken?: string | null
    emailVerifyExpiresAt?: Date | string | null
    phone?: string | null
    recoveryEmail?: string | null
    googleId?: string | null
    discordId?: string | null
    discordUsername?: string | null
    avatarKey?: string
    role?: string
    isDeleted?: boolean
    bannedUntil?: Date | string | null
    whitelistStatus?: string
    points?: number
    lastSeenAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    avatarUrl?: string | null
    topics?: TopicCreateNestedManyWithoutAuthorInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    tickets?: TicketCreateNestedManyWithoutAuthorInput
    assignedTickets?: TicketCreateNestedManyWithoutAssignedToInput
    ticketMsgs?: TicketMessageCreateNestedManyWithoutAuthorInput
    ticketParticipants?: TicketParticipantCreateNestedManyWithoutUserInput
    ticketParticipantsAdded?: TicketParticipantCreateNestedManyWithoutAddedByInput
    ticketRatingsGiven?: TicketRatingCreateNestedManyWithoutRaterInput
    ticketRatingsReceived?: TicketRatingCreateNestedManyWithoutTargetInput
    closedTickets?: TicketCreateNestedManyWithoutClosedByInput
    purchases?: PurchaseCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    whitelistApps?: WhitelistApplicationCreateNestedManyWithoutUserInput
    reviewedWhitelists?: WhitelistApplicationCreateNestedManyWithoutReviewerInput
    convoParts?: ConversationParticipantCreateNestedManyWithoutUserInput
    sentMessages?: DirectMessageCreateNestedManyWithoutSenderInput
    receivedMessages?: DirectMessageCreateNestedManyWithoutReceiverInput
    userBadges?: UserBadgeCreateNestedManyWithoutUserInput
    gameAccounts?: GameAccountCreateNestedManyWithoutUserInput
    mtaAccessLogs?: MtaAccessLogCreateNestedManyWithoutUserInput
    ticketRatingReqGiven?: TicketRatingRequirementCreateNestedManyWithoutRaterInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    entitlements?: EntitlementCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    staffShifts?: StaffShiftCreateNestedManyWithoutUserInput
    staffWeeklyRewards?: StaffWeeklyRewardCreateNestedManyWithoutUserInput
    adminCasesTarget?: AdminCaseCreateNestedManyWithoutTargetUserInput
    adminCasesStaff?: AdminCaseCreateNestedManyWithoutStaffUserInput
    reputation?: UserReputationCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTicketRatingReqReceivedInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    emailVerifiedAt?: Date | string | null
    emailVerifyToken?: string | null
    emailVerifyExpiresAt?: Date | string | null
    phone?: string | null
    recoveryEmail?: string | null
    googleId?: string | null
    discordId?: string | null
    discordUsername?: string | null
    avatarKey?: string
    role?: string
    isDeleted?: boolean
    bannedUntil?: Date | string | null
    whitelistStatus?: string
    points?: number
    lastSeenAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    avatarUrl?: string | null
    topics?: TopicUncheckedCreateNestedManyWithoutAuthorInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    tickets?: TicketUncheckedCreateNestedManyWithoutAuthorInput
    assignedTickets?: TicketUncheckedCreateNestedManyWithoutAssignedToInput
    ticketMsgs?: TicketMessageUncheckedCreateNestedManyWithoutAuthorInput
    ticketParticipants?: TicketParticipantUncheckedCreateNestedManyWithoutUserInput
    ticketParticipantsAdded?: TicketParticipantUncheckedCreateNestedManyWithoutAddedByInput
    ticketRatingsGiven?: TicketRatingUncheckedCreateNestedManyWithoutRaterInput
    ticketRatingsReceived?: TicketRatingUncheckedCreateNestedManyWithoutTargetInput
    closedTickets?: TicketUncheckedCreateNestedManyWithoutClosedByInput
    purchases?: PurchaseUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    whitelistApps?: WhitelistApplicationUncheckedCreateNestedManyWithoutUserInput
    reviewedWhitelists?: WhitelistApplicationUncheckedCreateNestedManyWithoutReviewerInput
    convoParts?: ConversationParticipantUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: DirectMessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: DirectMessageUncheckedCreateNestedManyWithoutReceiverInput
    userBadges?: UserBadgeUncheckedCreateNestedManyWithoutUserInput
    gameAccounts?: GameAccountUncheckedCreateNestedManyWithoutUserInput
    mtaAccessLogs?: MtaAccessLogUncheckedCreateNestedManyWithoutUserInput
    ticketRatingReqGiven?: TicketRatingRequirementUncheckedCreateNestedManyWithoutRaterInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    entitlements?: EntitlementUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    staffShifts?: StaffShiftUncheckedCreateNestedManyWithoutUserInput
    staffWeeklyRewards?: StaffWeeklyRewardUncheckedCreateNestedManyWithoutUserInput
    adminCasesTarget?: AdminCaseUncheckedCreateNestedManyWithoutTargetUserInput
    adminCasesStaff?: AdminCaseUncheckedCreateNestedManyWithoutStaffUserInput
    reputation?: UserReputationUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTicketRatingReqReceivedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTicketRatingReqReceivedInput, UserUncheckedCreateWithoutTicketRatingReqReceivedInput>
  }

  export type TicketUpsertWithoutRatingRequirementsInput = {
    update: XOR<TicketUpdateWithoutRatingRequirementsInput, TicketUncheckedUpdateWithoutRatingRequirementsInput>
    create: XOR<TicketCreateWithoutRatingRequirementsInput, TicketUncheckedCreateWithoutRatingRequirementsInput>
    where?: TicketWhereInput
  }

  export type TicketUpdateToOneWithWhereWithoutRatingRequirementsInput = {
    where?: TicketWhereInput
    data: XOR<TicketUpdateWithoutRatingRequirementsInput, TicketUncheckedUpdateWithoutRatingRequirementsInput>
  }

  export type TicketUpdateWithoutRatingRequirementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: TicketCategoryUpdateOneRequiredWithoutTicketsNestedInput
    author?: UserUpdateOneRequiredWithoutTicketsNestedInput
    assignedTo?: UserUpdateOneWithoutAssignedTicketsNestedInput
    closedBy?: UserUpdateOneWithoutClosedTicketsNestedInput
    messages?: TicketMessageUpdateManyWithoutTicketNestedInput
    participants?: TicketParticipantUpdateManyWithoutTicketNestedInput
    ratings?: TicketRatingUpdateManyWithoutTicketNestedInput
  }

  export type TicketUncheckedUpdateWithoutRatingRequirementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedById?: NullableStringFieldUpdateOperationsInput | string | null
    messages?: TicketMessageUncheckedUpdateManyWithoutTicketNestedInput
    participants?: TicketParticipantUncheckedUpdateManyWithoutTicketNestedInput
    ratings?: TicketRatingUncheckedUpdateManyWithoutTicketNestedInput
  }

  export type UserUpsertWithoutTicketRatingReqGivenInput = {
    update: XOR<UserUpdateWithoutTicketRatingReqGivenInput, UserUncheckedUpdateWithoutTicketRatingReqGivenInput>
    create: XOR<UserCreateWithoutTicketRatingReqGivenInput, UserUncheckedCreateWithoutTicketRatingReqGivenInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTicketRatingReqGivenInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTicketRatingReqGivenInput, UserUncheckedUpdateWithoutTicketRatingReqGivenInput>
  }

  export type UserUpdateWithoutTicketRatingReqGivenInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifyToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerifyExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    discordId?: NullableStringFieldUpdateOperationsInput | string | null
    discordUsername?: NullableStringFieldUpdateOperationsInput | string | null
    avatarKey?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    bannedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    whitelistStatus?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    lastSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    topics?: TopicUpdateManyWithoutAuthorNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    tickets?: TicketUpdateManyWithoutAuthorNestedInput
    assignedTickets?: TicketUpdateManyWithoutAssignedToNestedInput
    ticketMsgs?: TicketMessageUpdateManyWithoutAuthorNestedInput
    ticketParticipants?: TicketParticipantUpdateManyWithoutUserNestedInput
    ticketParticipantsAdded?: TicketParticipantUpdateManyWithoutAddedByNestedInput
    ticketRatingsGiven?: TicketRatingUpdateManyWithoutRaterNestedInput
    ticketRatingsReceived?: TicketRatingUpdateManyWithoutTargetNestedInput
    closedTickets?: TicketUpdateManyWithoutClosedByNestedInput
    purchases?: PurchaseUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    whitelistApps?: WhitelistApplicationUpdateManyWithoutUserNestedInput
    reviewedWhitelists?: WhitelistApplicationUpdateManyWithoutReviewerNestedInput
    convoParts?: ConversationParticipantUpdateManyWithoutUserNestedInput
    sentMessages?: DirectMessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: DirectMessageUpdateManyWithoutReceiverNestedInput
    userBadges?: UserBadgeUpdateManyWithoutUserNestedInput
    gameAccounts?: GameAccountUpdateManyWithoutUserNestedInput
    mtaAccessLogs?: MtaAccessLogUpdateManyWithoutUserNestedInput
    ticketRatingReqReceived?: TicketRatingRequirementUpdateManyWithoutTargetNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    entitlements?: EntitlementUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    staffShifts?: StaffShiftUpdateManyWithoutUserNestedInput
    staffWeeklyRewards?: StaffWeeklyRewardUpdateManyWithoutUserNestedInput
    adminCasesTarget?: AdminCaseUpdateManyWithoutTargetUserNestedInput
    adminCasesStaff?: AdminCaseUpdateManyWithoutStaffUserNestedInput
    reputation?: UserReputationUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTicketRatingReqGivenInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifyToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerifyExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    discordId?: NullableStringFieldUpdateOperationsInput | string | null
    discordUsername?: NullableStringFieldUpdateOperationsInput | string | null
    avatarKey?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    bannedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    whitelistStatus?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    lastSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    topics?: TopicUncheckedUpdateManyWithoutAuthorNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutAuthorNestedInput
    assignedTickets?: TicketUncheckedUpdateManyWithoutAssignedToNestedInput
    ticketMsgs?: TicketMessageUncheckedUpdateManyWithoutAuthorNestedInput
    ticketParticipants?: TicketParticipantUncheckedUpdateManyWithoutUserNestedInput
    ticketParticipantsAdded?: TicketParticipantUncheckedUpdateManyWithoutAddedByNestedInput
    ticketRatingsGiven?: TicketRatingUncheckedUpdateManyWithoutRaterNestedInput
    ticketRatingsReceived?: TicketRatingUncheckedUpdateManyWithoutTargetNestedInput
    closedTickets?: TicketUncheckedUpdateManyWithoutClosedByNestedInput
    purchases?: PurchaseUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    whitelistApps?: WhitelistApplicationUncheckedUpdateManyWithoutUserNestedInput
    reviewedWhitelists?: WhitelistApplicationUncheckedUpdateManyWithoutReviewerNestedInput
    convoParts?: ConversationParticipantUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: DirectMessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: DirectMessageUncheckedUpdateManyWithoutReceiverNestedInput
    userBadges?: UserBadgeUncheckedUpdateManyWithoutUserNestedInput
    gameAccounts?: GameAccountUncheckedUpdateManyWithoutUserNestedInput
    mtaAccessLogs?: MtaAccessLogUncheckedUpdateManyWithoutUserNestedInput
    ticketRatingReqReceived?: TicketRatingRequirementUncheckedUpdateManyWithoutTargetNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    entitlements?: EntitlementUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    staffShifts?: StaffShiftUncheckedUpdateManyWithoutUserNestedInput
    staffWeeklyRewards?: StaffWeeklyRewardUncheckedUpdateManyWithoutUserNestedInput
    adminCasesTarget?: AdminCaseUncheckedUpdateManyWithoutTargetUserNestedInput
    adminCasesStaff?: AdminCaseUncheckedUpdateManyWithoutStaffUserNestedInput
    reputation?: UserReputationUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserUpsertWithoutTicketRatingReqReceivedInput = {
    update: XOR<UserUpdateWithoutTicketRatingReqReceivedInput, UserUncheckedUpdateWithoutTicketRatingReqReceivedInput>
    create: XOR<UserCreateWithoutTicketRatingReqReceivedInput, UserUncheckedCreateWithoutTicketRatingReqReceivedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTicketRatingReqReceivedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTicketRatingReqReceivedInput, UserUncheckedUpdateWithoutTicketRatingReqReceivedInput>
  }

  export type UserUpdateWithoutTicketRatingReqReceivedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifyToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerifyExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    discordId?: NullableStringFieldUpdateOperationsInput | string | null
    discordUsername?: NullableStringFieldUpdateOperationsInput | string | null
    avatarKey?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    bannedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    whitelistStatus?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    lastSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    topics?: TopicUpdateManyWithoutAuthorNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    tickets?: TicketUpdateManyWithoutAuthorNestedInput
    assignedTickets?: TicketUpdateManyWithoutAssignedToNestedInput
    ticketMsgs?: TicketMessageUpdateManyWithoutAuthorNestedInput
    ticketParticipants?: TicketParticipantUpdateManyWithoutUserNestedInput
    ticketParticipantsAdded?: TicketParticipantUpdateManyWithoutAddedByNestedInput
    ticketRatingsGiven?: TicketRatingUpdateManyWithoutRaterNestedInput
    ticketRatingsReceived?: TicketRatingUpdateManyWithoutTargetNestedInput
    closedTickets?: TicketUpdateManyWithoutClosedByNestedInput
    purchases?: PurchaseUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    whitelistApps?: WhitelistApplicationUpdateManyWithoutUserNestedInput
    reviewedWhitelists?: WhitelistApplicationUpdateManyWithoutReviewerNestedInput
    convoParts?: ConversationParticipantUpdateManyWithoutUserNestedInput
    sentMessages?: DirectMessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: DirectMessageUpdateManyWithoutReceiverNestedInput
    userBadges?: UserBadgeUpdateManyWithoutUserNestedInput
    gameAccounts?: GameAccountUpdateManyWithoutUserNestedInput
    mtaAccessLogs?: MtaAccessLogUpdateManyWithoutUserNestedInput
    ticketRatingReqGiven?: TicketRatingRequirementUpdateManyWithoutRaterNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    entitlements?: EntitlementUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    staffShifts?: StaffShiftUpdateManyWithoutUserNestedInput
    staffWeeklyRewards?: StaffWeeklyRewardUpdateManyWithoutUserNestedInput
    adminCasesTarget?: AdminCaseUpdateManyWithoutTargetUserNestedInput
    adminCasesStaff?: AdminCaseUpdateManyWithoutStaffUserNestedInput
    reputation?: UserReputationUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTicketRatingReqReceivedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifyToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerifyExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    discordId?: NullableStringFieldUpdateOperationsInput | string | null
    discordUsername?: NullableStringFieldUpdateOperationsInput | string | null
    avatarKey?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    bannedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    whitelistStatus?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    lastSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    topics?: TopicUncheckedUpdateManyWithoutAuthorNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutAuthorNestedInput
    assignedTickets?: TicketUncheckedUpdateManyWithoutAssignedToNestedInput
    ticketMsgs?: TicketMessageUncheckedUpdateManyWithoutAuthorNestedInput
    ticketParticipants?: TicketParticipantUncheckedUpdateManyWithoutUserNestedInput
    ticketParticipantsAdded?: TicketParticipantUncheckedUpdateManyWithoutAddedByNestedInput
    ticketRatingsGiven?: TicketRatingUncheckedUpdateManyWithoutRaterNestedInput
    ticketRatingsReceived?: TicketRatingUncheckedUpdateManyWithoutTargetNestedInput
    closedTickets?: TicketUncheckedUpdateManyWithoutClosedByNestedInput
    purchases?: PurchaseUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    whitelistApps?: WhitelistApplicationUncheckedUpdateManyWithoutUserNestedInput
    reviewedWhitelists?: WhitelistApplicationUncheckedUpdateManyWithoutReviewerNestedInput
    convoParts?: ConversationParticipantUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: DirectMessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: DirectMessageUncheckedUpdateManyWithoutReceiverNestedInput
    userBadges?: UserBadgeUncheckedUpdateManyWithoutUserNestedInput
    gameAccounts?: GameAccountUncheckedUpdateManyWithoutUserNestedInput
    mtaAccessLogs?: MtaAccessLogUncheckedUpdateManyWithoutUserNestedInput
    ticketRatingReqGiven?: TicketRatingRequirementUncheckedUpdateManyWithoutRaterNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    entitlements?: EntitlementUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    staffShifts?: StaffShiftUncheckedUpdateManyWithoutUserNestedInput
    staffWeeklyRewards?: StaffWeeklyRewardUncheckedUpdateManyWithoutUserNestedInput
    adminCasesTarget?: AdminCaseUncheckedUpdateManyWithoutTargetUserNestedInput
    adminCasesStaff?: AdminCaseUncheckedUpdateManyWithoutStaffUserNestedInput
    reputation?: UserReputationUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserCreateWithoutPasswordResetTokensInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    emailVerifiedAt?: Date | string | null
    emailVerifyToken?: string | null
    emailVerifyExpiresAt?: Date | string | null
    phone?: string | null
    recoveryEmail?: string | null
    googleId?: string | null
    discordId?: string | null
    discordUsername?: string | null
    avatarKey?: string
    role?: string
    isDeleted?: boolean
    bannedUntil?: Date | string | null
    whitelistStatus?: string
    points?: number
    lastSeenAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    avatarUrl?: string | null
    topics?: TopicCreateNestedManyWithoutAuthorInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    tickets?: TicketCreateNestedManyWithoutAuthorInput
    assignedTickets?: TicketCreateNestedManyWithoutAssignedToInput
    ticketMsgs?: TicketMessageCreateNestedManyWithoutAuthorInput
    ticketParticipants?: TicketParticipantCreateNestedManyWithoutUserInput
    ticketParticipantsAdded?: TicketParticipantCreateNestedManyWithoutAddedByInput
    ticketRatingsGiven?: TicketRatingCreateNestedManyWithoutRaterInput
    ticketRatingsReceived?: TicketRatingCreateNestedManyWithoutTargetInput
    closedTickets?: TicketCreateNestedManyWithoutClosedByInput
    purchases?: PurchaseCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    whitelistApps?: WhitelistApplicationCreateNestedManyWithoutUserInput
    reviewedWhitelists?: WhitelistApplicationCreateNestedManyWithoutReviewerInput
    convoParts?: ConversationParticipantCreateNestedManyWithoutUserInput
    sentMessages?: DirectMessageCreateNestedManyWithoutSenderInput
    receivedMessages?: DirectMessageCreateNestedManyWithoutReceiverInput
    userBadges?: UserBadgeCreateNestedManyWithoutUserInput
    gameAccounts?: GameAccountCreateNestedManyWithoutUserInput
    mtaAccessLogs?: MtaAccessLogCreateNestedManyWithoutUserInput
    ticketRatingReqGiven?: TicketRatingRequirementCreateNestedManyWithoutRaterInput
    ticketRatingReqReceived?: TicketRatingRequirementCreateNestedManyWithoutTargetInput
    entitlements?: EntitlementCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    staffShifts?: StaffShiftCreateNestedManyWithoutUserInput
    staffWeeklyRewards?: StaffWeeklyRewardCreateNestedManyWithoutUserInput
    adminCasesTarget?: AdminCaseCreateNestedManyWithoutTargetUserInput
    adminCasesStaff?: AdminCaseCreateNestedManyWithoutStaffUserInput
    reputation?: UserReputationCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPasswordResetTokensInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    emailVerifiedAt?: Date | string | null
    emailVerifyToken?: string | null
    emailVerifyExpiresAt?: Date | string | null
    phone?: string | null
    recoveryEmail?: string | null
    googleId?: string | null
    discordId?: string | null
    discordUsername?: string | null
    avatarKey?: string
    role?: string
    isDeleted?: boolean
    bannedUntil?: Date | string | null
    whitelistStatus?: string
    points?: number
    lastSeenAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    avatarUrl?: string | null
    topics?: TopicUncheckedCreateNestedManyWithoutAuthorInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    tickets?: TicketUncheckedCreateNestedManyWithoutAuthorInput
    assignedTickets?: TicketUncheckedCreateNestedManyWithoutAssignedToInput
    ticketMsgs?: TicketMessageUncheckedCreateNestedManyWithoutAuthorInput
    ticketParticipants?: TicketParticipantUncheckedCreateNestedManyWithoutUserInput
    ticketParticipantsAdded?: TicketParticipantUncheckedCreateNestedManyWithoutAddedByInput
    ticketRatingsGiven?: TicketRatingUncheckedCreateNestedManyWithoutRaterInput
    ticketRatingsReceived?: TicketRatingUncheckedCreateNestedManyWithoutTargetInput
    closedTickets?: TicketUncheckedCreateNestedManyWithoutClosedByInput
    purchases?: PurchaseUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    whitelistApps?: WhitelistApplicationUncheckedCreateNestedManyWithoutUserInput
    reviewedWhitelists?: WhitelistApplicationUncheckedCreateNestedManyWithoutReviewerInput
    convoParts?: ConversationParticipantUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: DirectMessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: DirectMessageUncheckedCreateNestedManyWithoutReceiverInput
    userBadges?: UserBadgeUncheckedCreateNestedManyWithoutUserInput
    gameAccounts?: GameAccountUncheckedCreateNestedManyWithoutUserInput
    mtaAccessLogs?: MtaAccessLogUncheckedCreateNestedManyWithoutUserInput
    ticketRatingReqGiven?: TicketRatingRequirementUncheckedCreateNestedManyWithoutRaterInput
    ticketRatingReqReceived?: TicketRatingRequirementUncheckedCreateNestedManyWithoutTargetInput
    entitlements?: EntitlementUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    staffShifts?: StaffShiftUncheckedCreateNestedManyWithoutUserInput
    staffWeeklyRewards?: StaffWeeklyRewardUncheckedCreateNestedManyWithoutUserInput
    adminCasesTarget?: AdminCaseUncheckedCreateNestedManyWithoutTargetUserInput
    adminCasesStaff?: AdminCaseUncheckedCreateNestedManyWithoutStaffUserInput
    reputation?: UserReputationUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPasswordResetTokensInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPasswordResetTokensInput, UserUncheckedCreateWithoutPasswordResetTokensInput>
  }

  export type UserUpsertWithoutPasswordResetTokensInput = {
    update: XOR<UserUpdateWithoutPasswordResetTokensInput, UserUncheckedUpdateWithoutPasswordResetTokensInput>
    create: XOR<UserCreateWithoutPasswordResetTokensInput, UserUncheckedCreateWithoutPasswordResetTokensInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPasswordResetTokensInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPasswordResetTokensInput, UserUncheckedUpdateWithoutPasswordResetTokensInput>
  }

  export type UserUpdateWithoutPasswordResetTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifyToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerifyExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    discordId?: NullableStringFieldUpdateOperationsInput | string | null
    discordUsername?: NullableStringFieldUpdateOperationsInput | string | null
    avatarKey?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    bannedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    whitelistStatus?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    lastSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    topics?: TopicUpdateManyWithoutAuthorNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    tickets?: TicketUpdateManyWithoutAuthorNestedInput
    assignedTickets?: TicketUpdateManyWithoutAssignedToNestedInput
    ticketMsgs?: TicketMessageUpdateManyWithoutAuthorNestedInput
    ticketParticipants?: TicketParticipantUpdateManyWithoutUserNestedInput
    ticketParticipantsAdded?: TicketParticipantUpdateManyWithoutAddedByNestedInput
    ticketRatingsGiven?: TicketRatingUpdateManyWithoutRaterNestedInput
    ticketRatingsReceived?: TicketRatingUpdateManyWithoutTargetNestedInput
    closedTickets?: TicketUpdateManyWithoutClosedByNestedInput
    purchases?: PurchaseUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    whitelistApps?: WhitelistApplicationUpdateManyWithoutUserNestedInput
    reviewedWhitelists?: WhitelistApplicationUpdateManyWithoutReviewerNestedInput
    convoParts?: ConversationParticipantUpdateManyWithoutUserNestedInput
    sentMessages?: DirectMessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: DirectMessageUpdateManyWithoutReceiverNestedInput
    userBadges?: UserBadgeUpdateManyWithoutUserNestedInput
    gameAccounts?: GameAccountUpdateManyWithoutUserNestedInput
    mtaAccessLogs?: MtaAccessLogUpdateManyWithoutUserNestedInput
    ticketRatingReqGiven?: TicketRatingRequirementUpdateManyWithoutRaterNestedInput
    ticketRatingReqReceived?: TicketRatingRequirementUpdateManyWithoutTargetNestedInput
    entitlements?: EntitlementUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    staffShifts?: StaffShiftUpdateManyWithoutUserNestedInput
    staffWeeklyRewards?: StaffWeeklyRewardUpdateManyWithoutUserNestedInput
    adminCasesTarget?: AdminCaseUpdateManyWithoutTargetUserNestedInput
    adminCasesStaff?: AdminCaseUpdateManyWithoutStaffUserNestedInput
    reputation?: UserReputationUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPasswordResetTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifyToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerifyExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    discordId?: NullableStringFieldUpdateOperationsInput | string | null
    discordUsername?: NullableStringFieldUpdateOperationsInput | string | null
    avatarKey?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    bannedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    whitelistStatus?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    lastSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    topics?: TopicUncheckedUpdateManyWithoutAuthorNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutAuthorNestedInput
    assignedTickets?: TicketUncheckedUpdateManyWithoutAssignedToNestedInput
    ticketMsgs?: TicketMessageUncheckedUpdateManyWithoutAuthorNestedInput
    ticketParticipants?: TicketParticipantUncheckedUpdateManyWithoutUserNestedInput
    ticketParticipantsAdded?: TicketParticipantUncheckedUpdateManyWithoutAddedByNestedInput
    ticketRatingsGiven?: TicketRatingUncheckedUpdateManyWithoutRaterNestedInput
    ticketRatingsReceived?: TicketRatingUncheckedUpdateManyWithoutTargetNestedInput
    closedTickets?: TicketUncheckedUpdateManyWithoutClosedByNestedInput
    purchases?: PurchaseUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    whitelistApps?: WhitelistApplicationUncheckedUpdateManyWithoutUserNestedInput
    reviewedWhitelists?: WhitelistApplicationUncheckedUpdateManyWithoutReviewerNestedInput
    convoParts?: ConversationParticipantUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: DirectMessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: DirectMessageUncheckedUpdateManyWithoutReceiverNestedInput
    userBadges?: UserBadgeUncheckedUpdateManyWithoutUserNestedInput
    gameAccounts?: GameAccountUncheckedUpdateManyWithoutUserNestedInput
    mtaAccessLogs?: MtaAccessLogUncheckedUpdateManyWithoutUserNestedInput
    ticketRatingReqGiven?: TicketRatingRequirementUncheckedUpdateManyWithoutRaterNestedInput
    ticketRatingReqReceived?: TicketRatingRequirementUncheckedUpdateManyWithoutTargetNestedInput
    entitlements?: EntitlementUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    staffShifts?: StaffShiftUncheckedUpdateManyWithoutUserNestedInput
    staffWeeklyRewards?: StaffWeeklyRewardUncheckedUpdateManyWithoutUserNestedInput
    adminCasesTarget?: AdminCaseUncheckedUpdateManyWithoutTargetUserNestedInput
    adminCasesStaff?: AdminCaseUncheckedUpdateManyWithoutStaffUserNestedInput
    reputation?: UserReputationUncheckedUpdateOneWithoutUserNestedInput
  }

  export type PurchaseItemCreateManyProductInput = {
    id?: string
    purchaseId: string
    sku: string
    name: string
    priceCents: number
    durationDays?: number | null
    grantPoints?: number
    grantVipRole?: string | null
    mtaActions?: string | null
  }

  export type PurchaseItemUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    priceCents?: IntFieldUpdateOperationsInput | number
    durationDays?: NullableIntFieldUpdateOperationsInput | number | null
    grantPoints?: IntFieldUpdateOperationsInput | number
    grantVipRole?: NullableStringFieldUpdateOperationsInput | string | null
    mtaActions?: NullableStringFieldUpdateOperationsInput | string | null
    purchase?: PurchaseUpdateOneRequiredWithoutItemsNestedInput
  }

  export type PurchaseItemUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    purchaseId?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    priceCents?: IntFieldUpdateOperationsInput | number
    durationDays?: NullableIntFieldUpdateOperationsInput | number | null
    grantPoints?: IntFieldUpdateOperationsInput | number
    grantVipRole?: NullableStringFieldUpdateOperationsInput | string | null
    mtaActions?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PurchaseItemUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    purchaseId?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    priceCents?: IntFieldUpdateOperationsInput | number
    durationDays?: NullableIntFieldUpdateOperationsInput | number | null
    grantPoints?: IntFieldUpdateOperationsInput | number
    grantVipRole?: NullableStringFieldUpdateOperationsInput | string | null
    mtaActions?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TopicCreateManyAuthorInput = {
    id?: string
    boardId: string
    title: string
    status?: string
    pinned?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastPostAt?: Date | string
  }

  export type PostCreateManyAuthorInput = {
    id?: string
    topicId: string
    content: string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TicketCreateManyAuthorInput = {
    id?: string
    categoryId: string
    title: string
    status?: string
    priority?: string
    assignedToId?: string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    closedAt?: Date | string | null
    closedById?: string | null
  }

  export type TicketCreateManyAssignedToInput = {
    id?: string
    categoryId: string
    authorId: string
    title: string
    status?: string
    priority?: string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    closedAt?: Date | string | null
    closedById?: string | null
  }

  export type TicketMessageCreateManyAuthorInput = {
    id?: string
    ticketId: string
    content: string
    isDeleted?: boolean
    createdAt?: Date | string
  }

  export type TicketParticipantCreateManyUserInput = {
    ticketId: string
    addedById?: string | null
    createdAt?: Date | string
  }

  export type TicketParticipantCreateManyAddedByInput = {
    ticketId: string
    userId: string
    createdAt?: Date | string
  }

  export type TicketRatingCreateManyRaterInput = {
    id?: string
    ticketId: string
    targetUserId: string
    stars: number
    feedback: string
    createdAt?: Date | string
  }

  export type TicketRatingCreateManyTargetInput = {
    id?: string
    ticketId: string
    raterUserId: string
    stars: number
    feedback: string
    createdAt?: Date | string
  }

  export type TicketCreateManyClosedByInput = {
    id?: string
    categoryId: string
    authorId: string
    title: string
    status?: string
    priority?: string
    assignedToId?: string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    closedAt?: Date | string | null
  }

  export type PurchaseCreateManyUserInput = {
    id?: string
    provider: string
    externalId?: string | null
    status?: string
    amountCents: number
    currency?: string
    meta?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuditLogCreateManyActorInput = {
    id?: string
    action: string
    entityType: string
    entityId?: string | null
    ip?: string | null
    userAgent?: string | null
    meta?: string | null
    createdAt?: Date | string
  }

  export type UserRoleCreateManyUserInput = {
    roleId: string
  }

  export type WhitelistApplicationCreateManyUserInput = {
    id?: string
    status?: string
    reviewerId?: string | null
    rejectReason?: string | null
    createdAt?: Date | string
    reviewedAt?: Date | string | null
  }

  export type WhitelistApplicationCreateManyReviewerInput = {
    id?: string
    userId: string
    status?: string
    rejectReason?: string | null
    createdAt?: Date | string
    reviewedAt?: Date | string | null
  }

  export type ConversationParticipantCreateManyUserInput = {
    conversationId: string
    createdAt?: Date | string
  }

  export type DirectMessageCreateManySenderInput = {
    id?: string
    conversationId: string
    receiverId: string
    content: string
    kind?: string
    isDeleted?: boolean
    createdAt?: Date | string
  }

  export type DirectMessageCreateManyReceiverInput = {
    id?: string
    conversationId: string
    senderId: string
    content: string
    kind?: string
    isDeleted?: boolean
    createdAt?: Date | string
  }

  export type UserBadgeCreateManyUserInput = {
    badgeId: string
    createdAt?: Date | string
  }

  export type GameAccountCreateManyUserInput = {
    id?: string
    mtaSerial: string
    mtaAccount?: string | null
    locked?: boolean
    changedAfterApproved?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MtaAccessLogCreateManyUserInput = {
    id?: string
    serial: string
    allowed: boolean
    reason?: string | null
    ip?: string | null
    createdAt?: Date | string
  }

  export type TicketRatingRequirementCreateManyRaterInput = {
    id?: string
    ticketId: string
    targetId: string
    completed?: boolean
    createdAt?: Date | string
  }

  export type TicketRatingRequirementCreateManyTargetInput = {
    id?: string
    ticketId: string
    raterId: string
    completed?: boolean
    createdAt?: Date | string
  }

  export type PasswordResetTokenCreateManyUserInput = {
    id?: string
    code: string
    expiresAt: Date | string
    usedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type EntitlementCreateManyUserInput = {
    id?: string
    roleName: string
    expiresAt: Date | string
    source?: string | null
    createdAt?: Date | string
  }

  export type NotificationCreateManyUserInput = {
    id?: string
    message: string
    href?: string | null
    read?: boolean
    createdAt?: Date | string
  }

  export type StaffShiftCreateManyUserInput = {
    id?: string
    openedAt: Date | string
    closedAt?: Date | string | null
    seconds?: number
    createdAt?: Date | string
  }

  export type StaffWeeklyRewardCreateManyUserInput = {
    id?: string
    position: number
    weekKey: string
    createdAt?: Date | string
  }

  export type AdminCaseCreateManyTargetUserInput = {
    id?: string
    staffUserId: string
    type: string
    reason: string
    expiresAt?: Date | string | null
    active?: boolean
    createdAt?: Date | string
  }

  export type AdminCaseCreateManyStaffUserInput = {
    id?: string
    targetUserId: string
    type: string
    reason: string
    expiresAt?: Date | string | null
    active?: boolean
    createdAt?: Date | string
  }

  export type TopicUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    pinned?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastPostAt?: DateTimeFieldUpdateOperationsInput | Date | string
    board?: ForumBoardUpdateOneRequiredWithoutTopicsNestedInput
    posts?: PostUpdateManyWithoutTopicNestedInput
  }

  export type TopicUncheckedUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    boardId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    pinned?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastPostAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posts?: PostUncheckedUpdateManyWithoutTopicNestedInput
  }

  export type TopicUncheckedUpdateManyWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    boardId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    pinned?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastPostAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    topic?: TopicUpdateOneRequiredWithoutPostsNestedInput
    attachments?: PostAttachmentUpdateManyWithoutPostNestedInput
  }

  export type PostUncheckedUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    topicId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attachments?: PostAttachmentUncheckedUpdateManyWithoutPostNestedInput
  }

  export type PostUncheckedUpdateManyWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    topicId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: TicketCategoryUpdateOneRequiredWithoutTicketsNestedInput
    assignedTo?: UserUpdateOneWithoutAssignedTicketsNestedInput
    closedBy?: UserUpdateOneWithoutClosedTicketsNestedInput
    messages?: TicketMessageUpdateManyWithoutTicketNestedInput
    participants?: TicketParticipantUpdateManyWithoutTicketNestedInput
    ratings?: TicketRatingUpdateManyWithoutTicketNestedInput
    ratingRequirements?: TicketRatingRequirementUpdateManyWithoutTicketNestedInput
  }

  export type TicketUncheckedUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedById?: NullableStringFieldUpdateOperationsInput | string | null
    messages?: TicketMessageUncheckedUpdateManyWithoutTicketNestedInput
    participants?: TicketParticipantUncheckedUpdateManyWithoutTicketNestedInput
    ratings?: TicketRatingUncheckedUpdateManyWithoutTicketNestedInput
    ratingRequirements?: TicketRatingRequirementUncheckedUpdateManyWithoutTicketNestedInput
  }

  export type TicketUncheckedUpdateManyWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TicketUpdateWithoutAssignedToInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: TicketCategoryUpdateOneRequiredWithoutTicketsNestedInput
    author?: UserUpdateOneRequiredWithoutTicketsNestedInput
    closedBy?: UserUpdateOneWithoutClosedTicketsNestedInput
    messages?: TicketMessageUpdateManyWithoutTicketNestedInput
    participants?: TicketParticipantUpdateManyWithoutTicketNestedInput
    ratings?: TicketRatingUpdateManyWithoutTicketNestedInput
    ratingRequirements?: TicketRatingRequirementUpdateManyWithoutTicketNestedInput
  }

  export type TicketUncheckedUpdateWithoutAssignedToInput = {
    id?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedById?: NullableStringFieldUpdateOperationsInput | string | null
    messages?: TicketMessageUncheckedUpdateManyWithoutTicketNestedInput
    participants?: TicketParticipantUncheckedUpdateManyWithoutTicketNestedInput
    ratings?: TicketRatingUncheckedUpdateManyWithoutTicketNestedInput
    ratingRequirements?: TicketRatingRequirementUncheckedUpdateManyWithoutTicketNestedInput
  }

  export type TicketUncheckedUpdateManyWithoutAssignedToInput = {
    id?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TicketMessageUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ticket?: TicketUpdateOneRequiredWithoutMessagesNestedInput
  }

  export type TicketMessageUncheckedUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticketId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketMessageUncheckedUpdateManyWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticketId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketParticipantUpdateWithoutUserInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ticket?: TicketUpdateOneRequiredWithoutParticipantsNestedInput
    addedBy?: UserUpdateOneWithoutTicketParticipantsAddedNestedInput
  }

  export type TicketParticipantUncheckedUpdateWithoutUserInput = {
    ticketId?: StringFieldUpdateOperationsInput | string
    addedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketParticipantUncheckedUpdateManyWithoutUserInput = {
    ticketId?: StringFieldUpdateOperationsInput | string
    addedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketParticipantUpdateWithoutAddedByInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ticket?: TicketUpdateOneRequiredWithoutParticipantsNestedInput
    user?: UserUpdateOneRequiredWithoutTicketParticipantsNestedInput
  }

  export type TicketParticipantUncheckedUpdateWithoutAddedByInput = {
    ticketId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketParticipantUncheckedUpdateManyWithoutAddedByInput = {
    ticketId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketRatingUpdateWithoutRaterInput = {
    id?: StringFieldUpdateOperationsInput | string
    stars?: IntFieldUpdateOperationsInput | number
    feedback?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ticket?: TicketUpdateOneRequiredWithoutRatingsNestedInput
    target?: UserUpdateOneRequiredWithoutTicketRatingsReceivedNestedInput
  }

  export type TicketRatingUncheckedUpdateWithoutRaterInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticketId?: StringFieldUpdateOperationsInput | string
    targetUserId?: StringFieldUpdateOperationsInput | string
    stars?: IntFieldUpdateOperationsInput | number
    feedback?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketRatingUncheckedUpdateManyWithoutRaterInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticketId?: StringFieldUpdateOperationsInput | string
    targetUserId?: StringFieldUpdateOperationsInput | string
    stars?: IntFieldUpdateOperationsInput | number
    feedback?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketRatingUpdateWithoutTargetInput = {
    id?: StringFieldUpdateOperationsInput | string
    stars?: IntFieldUpdateOperationsInput | number
    feedback?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ticket?: TicketUpdateOneRequiredWithoutRatingsNestedInput
    rater?: UserUpdateOneRequiredWithoutTicketRatingsGivenNestedInput
  }

  export type TicketRatingUncheckedUpdateWithoutTargetInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticketId?: StringFieldUpdateOperationsInput | string
    raterUserId?: StringFieldUpdateOperationsInput | string
    stars?: IntFieldUpdateOperationsInput | number
    feedback?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketRatingUncheckedUpdateManyWithoutTargetInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticketId?: StringFieldUpdateOperationsInput | string
    raterUserId?: StringFieldUpdateOperationsInput | string
    stars?: IntFieldUpdateOperationsInput | number
    feedback?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketUpdateWithoutClosedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: TicketCategoryUpdateOneRequiredWithoutTicketsNestedInput
    author?: UserUpdateOneRequiredWithoutTicketsNestedInput
    assignedTo?: UserUpdateOneWithoutAssignedTicketsNestedInput
    messages?: TicketMessageUpdateManyWithoutTicketNestedInput
    participants?: TicketParticipantUpdateManyWithoutTicketNestedInput
    ratings?: TicketRatingUpdateManyWithoutTicketNestedInput
    ratingRequirements?: TicketRatingRequirementUpdateManyWithoutTicketNestedInput
  }

  export type TicketUncheckedUpdateWithoutClosedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    messages?: TicketMessageUncheckedUpdateManyWithoutTicketNestedInput
    participants?: TicketParticipantUncheckedUpdateManyWithoutTicketNestedInput
    ratings?: TicketRatingUncheckedUpdateManyWithoutTicketNestedInput
    ratingRequirements?: TicketRatingRequirementUncheckedUpdateManyWithoutTicketNestedInput
  }

  export type TicketUncheckedUpdateManyWithoutClosedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PurchaseUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    amountCents?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    meta?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: PurchaseItemUpdateManyWithoutPurchaseNestedInput
  }

  export type PurchaseUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    amountCents?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    meta?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: PurchaseItemUncheckedUpdateManyWithoutPurchaseNestedInput
  }

  export type PurchaseUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    amountCents?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    meta?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUpdateWithoutActorInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    meta?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateWithoutActorInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    meta?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyWithoutActorInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    meta?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserRoleUpdateWithoutUserInput = {
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserRoleUncheckedUpdateWithoutUserInput = {
    roleId?: StringFieldUpdateOperationsInput | string
  }

  export type UserRoleUncheckedUpdateManyWithoutUserInput = {
    roleId?: StringFieldUpdateOperationsInput | string
  }

  export type WhitelistApplicationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    rejectReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewer?: UserUpdateOneWithoutReviewedWhitelistsNestedInput
    answers?: WhitelistAnswerUpdateManyWithoutApplicationNestedInput
  }

  export type WhitelistApplicationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    reviewerId?: NullableStringFieldUpdateOperationsInput | string | null
    rejectReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    answers?: WhitelistAnswerUncheckedUpdateManyWithoutApplicationNestedInput
  }

  export type WhitelistApplicationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    reviewerId?: NullableStringFieldUpdateOperationsInput | string | null
    rejectReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WhitelistApplicationUpdateWithoutReviewerInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    rejectReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutWhitelistAppsNestedInput
    answers?: WhitelistAnswerUpdateManyWithoutApplicationNestedInput
  }

  export type WhitelistApplicationUncheckedUpdateWithoutReviewerInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    rejectReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    answers?: WhitelistAnswerUncheckedUpdateManyWithoutApplicationNestedInput
  }

  export type WhitelistApplicationUncheckedUpdateManyWithoutReviewerInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    rejectReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ConversationParticipantUpdateWithoutUserInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conversation?: ConversationUpdateOneRequiredWithoutParticipantsNestedInput
  }

  export type ConversationParticipantUncheckedUpdateWithoutUserInput = {
    conversationId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationParticipantUncheckedUpdateManyWithoutUserInput = {
    conversationId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DirectMessageUpdateWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    kind?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conversation?: ConversationUpdateOneRequiredWithoutMessagesNestedInput
    receiver?: UserUpdateOneRequiredWithoutReceivedMessagesNestedInput
  }

  export type DirectMessageUncheckedUpdateWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    receiverId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    kind?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DirectMessageUncheckedUpdateManyWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    receiverId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    kind?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DirectMessageUpdateWithoutReceiverInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    kind?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conversation?: ConversationUpdateOneRequiredWithoutMessagesNestedInput
    sender?: UserUpdateOneRequiredWithoutSentMessagesNestedInput
  }

  export type DirectMessageUncheckedUpdateWithoutReceiverInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    kind?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DirectMessageUncheckedUpdateManyWithoutReceiverInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    kind?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserBadgeUpdateWithoutUserInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    badge?: BadgeUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserBadgeUncheckedUpdateWithoutUserInput = {
    badgeId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserBadgeUncheckedUpdateManyWithoutUserInput = {
    badgeId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GameAccountUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    mtaSerial?: StringFieldUpdateOperationsInput | string
    mtaAccount?: NullableStringFieldUpdateOperationsInput | string | null
    locked?: BoolFieldUpdateOperationsInput | boolean
    changedAfterApproved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GameAccountUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    mtaSerial?: StringFieldUpdateOperationsInput | string
    mtaAccount?: NullableStringFieldUpdateOperationsInput | string | null
    locked?: BoolFieldUpdateOperationsInput | boolean
    changedAfterApproved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GameAccountUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    mtaSerial?: StringFieldUpdateOperationsInput | string
    mtaAccount?: NullableStringFieldUpdateOperationsInput | string | null
    locked?: BoolFieldUpdateOperationsInput | boolean
    changedAfterApproved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MtaAccessLogUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    serial?: StringFieldUpdateOperationsInput | string
    allowed?: BoolFieldUpdateOperationsInput | boolean
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MtaAccessLogUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    serial?: StringFieldUpdateOperationsInput | string
    allowed?: BoolFieldUpdateOperationsInput | boolean
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MtaAccessLogUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    serial?: StringFieldUpdateOperationsInput | string
    allowed?: BoolFieldUpdateOperationsInput | boolean
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketRatingRequirementUpdateWithoutRaterInput = {
    id?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ticket?: TicketUpdateOneRequiredWithoutRatingRequirementsNestedInput
    target?: UserUpdateOneRequiredWithoutTicketRatingReqReceivedNestedInput
  }

  export type TicketRatingRequirementUncheckedUpdateWithoutRaterInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticketId?: StringFieldUpdateOperationsInput | string
    targetId?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketRatingRequirementUncheckedUpdateManyWithoutRaterInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticketId?: StringFieldUpdateOperationsInput | string
    targetId?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketRatingRequirementUpdateWithoutTargetInput = {
    id?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ticket?: TicketUpdateOneRequiredWithoutRatingRequirementsNestedInput
    rater?: UserUpdateOneRequiredWithoutTicketRatingReqGivenNestedInput
  }

  export type TicketRatingRequirementUncheckedUpdateWithoutTargetInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticketId?: StringFieldUpdateOperationsInput | string
    raterId?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketRatingRequirementUncheckedUpdateManyWithoutTargetInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticketId?: StringFieldUpdateOperationsInput | string
    raterId?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetTokenUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetTokenUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetTokenUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EntitlementUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    roleName?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EntitlementUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    roleName?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EntitlementUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    roleName?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    href?: NullableStringFieldUpdateOperationsInput | string | null
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    href?: NullableStringFieldUpdateOperationsInput | string | null
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    href?: NullableStringFieldUpdateOperationsInput | string | null
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StaffShiftUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    openedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    seconds?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StaffShiftUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    openedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    seconds?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StaffShiftUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    openedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    seconds?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StaffWeeklyRewardUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    weekKey?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StaffWeeklyRewardUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    weekKey?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StaffWeeklyRewardUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    weekKey?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminCaseUpdateWithoutTargetUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    staffUser?: UserUpdateOneRequiredWithoutAdminCasesStaffNestedInput
  }

  export type AdminCaseUncheckedUpdateWithoutTargetUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    staffUserId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminCaseUncheckedUpdateManyWithoutTargetUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    staffUserId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminCaseUpdateWithoutStaffUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    targetUser?: UserUpdateOneRequiredWithoutAdminCasesTargetNestedInput
  }

  export type AdminCaseUncheckedUpdateWithoutStaffUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    targetUserId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminCaseUncheckedUpdateManyWithoutStaffUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    targetUserId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ForumBoardCreateManyCategoryInput = {
    id?: string
    name: string
    description?: string | null
    order?: number
    requireWhitelist?: boolean
    pointsOnTopic?: number
    pointsOnReply?: number
    allowReplies?: boolean
    createdAt?: Date | string
  }

  export type ForumBoardUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    requireWhitelist?: BoolFieldUpdateOperationsInput | boolean
    pointsOnTopic?: IntFieldUpdateOperationsInput | number
    pointsOnReply?: IntFieldUpdateOperationsInput | number
    allowReplies?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    topics?: TopicUpdateManyWithoutBoardNestedInput
  }

  export type ForumBoardUncheckedUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    requireWhitelist?: BoolFieldUpdateOperationsInput | boolean
    pointsOnTopic?: IntFieldUpdateOperationsInput | number
    pointsOnReply?: IntFieldUpdateOperationsInput | number
    allowReplies?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    topics?: TopicUncheckedUpdateManyWithoutBoardNestedInput
  }

  export type ForumBoardUncheckedUpdateManyWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    requireWhitelist?: BoolFieldUpdateOperationsInput | boolean
    pointsOnTopic?: IntFieldUpdateOperationsInput | number
    pointsOnReply?: IntFieldUpdateOperationsInput | number
    allowReplies?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TopicCreateManyBoardInput = {
    id?: string
    authorId: string
    title: string
    status?: string
    pinned?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastPostAt?: Date | string
  }

  export type TopicUpdateWithoutBoardInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    pinned?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastPostAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutTopicsNestedInput
    posts?: PostUpdateManyWithoutTopicNestedInput
  }

  export type TopicUncheckedUpdateWithoutBoardInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    pinned?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastPostAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posts?: PostUncheckedUpdateManyWithoutTopicNestedInput
  }

  export type TopicUncheckedUpdateManyWithoutBoardInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    pinned?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastPostAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostCreateManyTopicInput = {
    id?: string
    authorId: string
    content: string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PostUpdateWithoutTopicInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutPostsNestedInput
    attachments?: PostAttachmentUpdateManyWithoutPostNestedInput
  }

  export type PostUncheckedUpdateWithoutTopicInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attachments?: PostAttachmentUncheckedUpdateManyWithoutPostNestedInput
  }

  export type PostUncheckedUpdateManyWithoutTopicInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostAttachmentCreateManyPostInput = {
    id?: string
    url: string
    mime?: string | null
    size?: number | null
    createdAt?: Date | string
  }

  export type PostAttachmentUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    mime?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostAttachmentUncheckedUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    mime?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostAttachmentUncheckedUpdateManyWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    mime?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketCreateManyCategoryInput = {
    id?: string
    authorId: string
    title: string
    status?: string
    priority?: string
    assignedToId?: string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    closedAt?: Date | string | null
    closedById?: string | null
  }

  export type TicketUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    author?: UserUpdateOneRequiredWithoutTicketsNestedInput
    assignedTo?: UserUpdateOneWithoutAssignedTicketsNestedInput
    closedBy?: UserUpdateOneWithoutClosedTicketsNestedInput
    messages?: TicketMessageUpdateManyWithoutTicketNestedInput
    participants?: TicketParticipantUpdateManyWithoutTicketNestedInput
    ratings?: TicketRatingUpdateManyWithoutTicketNestedInput
    ratingRequirements?: TicketRatingRequirementUpdateManyWithoutTicketNestedInput
  }

  export type TicketUncheckedUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedById?: NullableStringFieldUpdateOperationsInput | string | null
    messages?: TicketMessageUncheckedUpdateManyWithoutTicketNestedInput
    participants?: TicketParticipantUncheckedUpdateManyWithoutTicketNestedInput
    ratings?: TicketRatingUncheckedUpdateManyWithoutTicketNestedInput
    ratingRequirements?: TicketRatingRequirementUncheckedUpdateManyWithoutTicketNestedInput
  }

  export type TicketUncheckedUpdateManyWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TicketMessageCreateManyTicketInput = {
    id?: string
    authorId: string
    content: string
    isDeleted?: boolean
    createdAt?: Date | string
  }

  export type TicketParticipantCreateManyTicketInput = {
    userId: string
    addedById?: string | null
    createdAt?: Date | string
  }

  export type TicketRatingCreateManyTicketInput = {
    id?: string
    raterUserId: string
    targetUserId: string
    stars: number
    feedback: string
    createdAt?: Date | string
  }

  export type TicketRatingRequirementCreateManyTicketInput = {
    id?: string
    raterId: string
    targetId: string
    completed?: boolean
    createdAt?: Date | string
  }

  export type TicketMessageUpdateWithoutTicketInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutTicketMsgsNestedInput
  }

  export type TicketMessageUncheckedUpdateWithoutTicketInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketMessageUncheckedUpdateManyWithoutTicketInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketParticipantUpdateWithoutTicketInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTicketParticipantsNestedInput
    addedBy?: UserUpdateOneWithoutTicketParticipantsAddedNestedInput
  }

  export type TicketParticipantUncheckedUpdateWithoutTicketInput = {
    userId?: StringFieldUpdateOperationsInput | string
    addedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketParticipantUncheckedUpdateManyWithoutTicketInput = {
    userId?: StringFieldUpdateOperationsInput | string
    addedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketRatingUpdateWithoutTicketInput = {
    id?: StringFieldUpdateOperationsInput | string
    stars?: IntFieldUpdateOperationsInput | number
    feedback?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rater?: UserUpdateOneRequiredWithoutTicketRatingsGivenNestedInput
    target?: UserUpdateOneRequiredWithoutTicketRatingsReceivedNestedInput
  }

  export type TicketRatingUncheckedUpdateWithoutTicketInput = {
    id?: StringFieldUpdateOperationsInput | string
    raterUserId?: StringFieldUpdateOperationsInput | string
    targetUserId?: StringFieldUpdateOperationsInput | string
    stars?: IntFieldUpdateOperationsInput | number
    feedback?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketRatingUncheckedUpdateManyWithoutTicketInput = {
    id?: StringFieldUpdateOperationsInput | string
    raterUserId?: StringFieldUpdateOperationsInput | string
    targetUserId?: StringFieldUpdateOperationsInput | string
    stars?: IntFieldUpdateOperationsInput | number
    feedback?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketRatingRequirementUpdateWithoutTicketInput = {
    id?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rater?: UserUpdateOneRequiredWithoutTicketRatingReqGivenNestedInput
    target?: UserUpdateOneRequiredWithoutTicketRatingReqReceivedNestedInput
  }

  export type TicketRatingRequirementUncheckedUpdateWithoutTicketInput = {
    id?: StringFieldUpdateOperationsInput | string
    raterId?: StringFieldUpdateOperationsInput | string
    targetId?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketRatingRequirementUncheckedUpdateManyWithoutTicketInput = {
    id?: StringFieldUpdateOperationsInput | string
    raterId?: StringFieldUpdateOperationsInput | string
    targetId?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseItemCreateManyPurchaseInput = {
    id?: string
    productId: string
    sku: string
    name: string
    priceCents: number
    durationDays?: number | null
    grantPoints?: number
    grantVipRole?: string | null
    mtaActions?: string | null
  }

  export type PurchaseItemUpdateWithoutPurchaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    priceCents?: IntFieldUpdateOperationsInput | number
    durationDays?: NullableIntFieldUpdateOperationsInput | number | null
    grantPoints?: IntFieldUpdateOperationsInput | number
    grantVipRole?: NullableStringFieldUpdateOperationsInput | string | null
    mtaActions?: NullableStringFieldUpdateOperationsInput | string | null
    product?: ProductUpdateOneRequiredWithoutPurchaseItemsNestedInput
  }

  export type PurchaseItemUncheckedUpdateWithoutPurchaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    priceCents?: IntFieldUpdateOperationsInput | number
    durationDays?: NullableIntFieldUpdateOperationsInput | number | null
    grantPoints?: IntFieldUpdateOperationsInput | number
    grantVipRole?: NullableStringFieldUpdateOperationsInput | string | null
    mtaActions?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PurchaseItemUncheckedUpdateManyWithoutPurchaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    priceCents?: IntFieldUpdateOperationsInput | number
    durationDays?: NullableIntFieldUpdateOperationsInput | number | null
    grantPoints?: IntFieldUpdateOperationsInput | number
    grantVipRole?: NullableStringFieldUpdateOperationsInput | string | null
    mtaActions?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RolePermissionCreateManyRoleInput = {
    permissionId: string
  }

  export type UserRoleCreateManyRoleInput = {
    userId: string
  }

  export type RolePermissionUpdateWithoutRoleInput = {
    permission?: PermissionUpdateOneRequiredWithoutRolesNestedInput
  }

  export type RolePermissionUncheckedUpdateWithoutRoleInput = {
    permissionId?: StringFieldUpdateOperationsInput | string
  }

  export type RolePermissionUncheckedUpdateManyWithoutRoleInput = {
    permissionId?: StringFieldUpdateOperationsInput | string
  }

  export type UserRoleUpdateWithoutRoleInput = {
    user?: UserUpdateOneRequiredWithoutUserRolesNestedInput
  }

  export type UserRoleUncheckedUpdateWithoutRoleInput = {
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type UserRoleUncheckedUpdateManyWithoutRoleInput = {
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type RolePermissionCreateManyPermissionInput = {
    roleId: string
  }

  export type RolePermissionUpdateWithoutPermissionInput = {
    role?: RoleUpdateOneRequiredWithoutPermissionsNestedInput
  }

  export type RolePermissionUncheckedUpdateWithoutPermissionInput = {
    roleId?: StringFieldUpdateOperationsInput | string
  }

  export type RolePermissionUncheckedUpdateManyWithoutPermissionInput = {
    roleId?: StringFieldUpdateOperationsInput | string
  }

  export type WhitelistAnswerCreateManyQuestionInput = {
    id?: string
    applicationId: string
    value: string
    createdAt?: Date | string
  }

  export type WhitelistAnswerUpdateWithoutQuestionInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    application?: WhitelistApplicationUpdateOneRequiredWithoutAnswersNestedInput
  }

  export type WhitelistAnswerUncheckedUpdateWithoutQuestionInput = {
    id?: StringFieldUpdateOperationsInput | string
    applicationId?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WhitelistAnswerUncheckedUpdateManyWithoutQuestionInput = {
    id?: StringFieldUpdateOperationsInput | string
    applicationId?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WhitelistAnswerCreateManyApplicationInput = {
    id?: string
    questionId: string
    value: string
    createdAt?: Date | string
  }

  export type WhitelistAnswerUpdateWithoutApplicationInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    question?: WhitelistQuestionUpdateOneRequiredWithoutAnswersNestedInput
  }

  export type WhitelistAnswerUncheckedUpdateWithoutApplicationInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WhitelistAnswerUncheckedUpdateManyWithoutApplicationInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserBadgeCreateManyBadgeInput = {
    userId: string
    createdAt?: Date | string
  }

  export type UserBadgeUpdateWithoutBadgeInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutUserBadgesNestedInput
  }

  export type UserBadgeUncheckedUpdateWithoutBadgeInput = {
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserBadgeUncheckedUpdateManyWithoutBadgeInput = {
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationParticipantCreateManyConversationInput = {
    userId: string
    createdAt?: Date | string
  }

  export type DirectMessageCreateManyConversationInput = {
    id?: string
    senderId: string
    receiverId: string
    content: string
    kind?: string
    isDeleted?: boolean
    createdAt?: Date | string
  }

  export type ConversationParticipantUpdateWithoutConversationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutConvoPartsNestedInput
  }

  export type ConversationParticipantUncheckedUpdateWithoutConversationInput = {
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationParticipantUncheckedUpdateManyWithoutConversationInput = {
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DirectMessageUpdateWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    kind?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sender?: UserUpdateOneRequiredWithoutSentMessagesNestedInput
    receiver?: UserUpdateOneRequiredWithoutReceivedMessagesNestedInput
  }

  export type DirectMessageUncheckedUpdateWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    receiverId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    kind?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DirectMessageUncheckedUpdateManyWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    receiverId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    kind?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use ProductCountOutputTypeDefaultArgs instead
     */
    export type ProductCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProductCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ForumCategoryCountOutputTypeDefaultArgs instead
     */
    export type ForumCategoryCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ForumCategoryCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ForumBoardCountOutputTypeDefaultArgs instead
     */
    export type ForumBoardCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ForumBoardCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TopicCountOutputTypeDefaultArgs instead
     */
    export type TopicCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TopicCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PostCountOutputTypeDefaultArgs instead
     */
    export type PostCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PostCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TicketCategoryCountOutputTypeDefaultArgs instead
     */
    export type TicketCategoryCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TicketCategoryCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TicketCountOutputTypeDefaultArgs instead
     */
    export type TicketCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TicketCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PurchaseCountOutputTypeDefaultArgs instead
     */
    export type PurchaseCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PurchaseCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RoleCountOutputTypeDefaultArgs instead
     */
    export type RoleCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RoleCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PermissionCountOutputTypeDefaultArgs instead
     */
    export type PermissionCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PermissionCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WhitelistQuestionCountOutputTypeDefaultArgs instead
     */
    export type WhitelistQuestionCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WhitelistQuestionCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WhitelistApplicationCountOutputTypeDefaultArgs instead
     */
    export type WhitelistApplicationCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WhitelistApplicationCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BadgeCountOutputTypeDefaultArgs instead
     */
    export type BadgeCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BadgeCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ConversationCountOutputTypeDefaultArgs instead
     */
    export type ConversationCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ConversationCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProductDefaultArgs instead
     */
    export type ProductArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProductDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CouponDefaultArgs instead
     */
    export type CouponArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CouponDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PurchaseItemDefaultArgs instead
     */
    export type PurchaseItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PurchaseItemDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EntitlementDefaultArgs instead
     */
    export type EntitlementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EntitlementDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NotificationDefaultArgs instead
     */
    export type NotificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NotificationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StaffShiftDefaultArgs instead
     */
    export type StaffShiftArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StaffShiftDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StaffWeeklyRewardDefaultArgs instead
     */
    export type StaffWeeklyRewardArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StaffWeeklyRewardDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AdminCaseDefaultArgs instead
     */
    export type AdminCaseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AdminCaseDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserReputationDefaultArgs instead
     */
    export type UserReputationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserReputationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ForumCategoryDefaultArgs instead
     */
    export type ForumCategoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ForumCategoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ForumBoardDefaultArgs instead
     */
    export type ForumBoardArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ForumBoardDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TopicDefaultArgs instead
     */
    export type TopicArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TopicDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PostDefaultArgs instead
     */
    export type PostArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PostDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PostAttachmentDefaultArgs instead
     */
    export type PostAttachmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PostAttachmentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TicketCategoryDefaultArgs instead
     */
    export type TicketCategoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TicketCategoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TicketDefaultArgs instead
     */
    export type TicketArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TicketDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TicketMessageDefaultArgs instead
     */
    export type TicketMessageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TicketMessageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PurchaseDefaultArgs instead
     */
    export type PurchaseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PurchaseDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AuditLogDefaultArgs instead
     */
    export type AuditLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AuditLogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MpWebhookEventDefaultArgs instead
     */
    export type MpWebhookEventArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MpWebhookEventDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RoleDefaultArgs instead
     */
    export type RoleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RoleDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PermissionDefaultArgs instead
     */
    export type PermissionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PermissionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RolePermissionDefaultArgs instead
     */
    export type RolePermissionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RolePermissionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserRoleDefaultArgs instead
     */
    export type UserRoleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserRoleDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WhitelistConfigDefaultArgs instead
     */
    export type WhitelistConfigArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WhitelistConfigDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WhitelistQuestionDefaultArgs instead
     */
    export type WhitelistQuestionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WhitelistQuestionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WhitelistApplicationDefaultArgs instead
     */
    export type WhitelistApplicationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WhitelistApplicationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WhitelistAnswerDefaultArgs instead
     */
    export type WhitelistAnswerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WhitelistAnswerDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BadgeDefaultArgs instead
     */
    export type BadgeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BadgeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserBadgeDefaultArgs instead
     */
    export type UserBadgeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserBadgeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ConversationDefaultArgs instead
     */
    export type ConversationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ConversationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ConversationParticipantDefaultArgs instead
     */
    export type ConversationParticipantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ConversationParticipantDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DirectMessageDefaultArgs instead
     */
    export type DirectMessageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DirectMessageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BankInfoDefaultArgs instead
     */
    export type BankInfoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BankInfoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SiteSettingDefaultArgs instead
     */
    export type SiteSettingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SiteSettingDefaultArgs<ExtArgs>
    /**
     * @deprecated Use GameAccountDefaultArgs instead
     */
    export type GameAccountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = GameAccountDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TicketParticipantDefaultArgs instead
     */
    export type TicketParticipantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TicketParticipantDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TicketRatingDefaultArgs instead
     */
    export type TicketRatingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TicketRatingDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MtaAccessLogDefaultArgs instead
     */
    export type MtaAccessLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MtaAccessLogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TicketRatingRequirementDefaultArgs instead
     */
    export type TicketRatingRequirementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TicketRatingRequirementDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PasswordResetTokenDefaultArgs instead
     */
    export type PasswordResetTokenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PasswordResetTokenDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}